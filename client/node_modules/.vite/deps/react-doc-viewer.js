import {
  require_fs,
  require_http,
  require_https
} from "./chunk-WWQUWZAR.js";
import {
  init_emotion_is_prop_valid_esm,
  isPropValid
} from "./chunk-6NKM4W3E.js";
import {
  require_hoist_non_react_statics_cjs,
  require_react_is
} from "./chunk-OGX7YE4Z.js";
import {
  require_jsx_runtime
} from "./chunk-EVYFT2IE.js";
import {
  require_react
} from "./chunk-KTLD2JDZ.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-BYPFWIQ6.js";

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports2, module2) {
    module2.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/@emotion/stylis/dist/stylis.browser.esm.js
function stylis_min(W3) {
  function M3(d3, c3, e3, h2, a3) {
    for (var m3 = 0, b3 = 0, v3 = 0, n3 = 0, q3, g3, x3 = 0, K3 = 0, k3, u3 = k3 = q3 = 0, l3 = 0, r3 = 0, I3 = 0, t3 = 0, B4 = e3.length, J3 = B4 - 1, y3, f2 = "", p2 = "", F4 = "", G4 = "", C3; l3 < B4; ) {
      g3 = e3.charCodeAt(l3);
      l3 === J3 && 0 !== b3 + n3 + v3 + m3 && (0 !== b3 && (g3 = 47 === b3 ? 10 : 47), n3 = v3 = m3 = 0, B4++, J3++);
      if (0 === b3 + n3 + v3 + m3) {
        if (l3 === J3 && (0 < r3 && (f2 = f2.replace(N3, "")), 0 < f2.trim().length)) {
          switch (g3) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f2 += e3.charAt(l3);
          }
          g3 = 59;
        }
        switch (g3) {
          case 123:
            f2 = f2.trim();
            q3 = f2.charCodeAt(0);
            k3 = 1;
            for (t3 = ++l3; l3 < B4; ) {
              switch (g3 = e3.charCodeAt(l3)) {
                case 123:
                  k3++;
                  break;
                case 125:
                  k3--;
                  break;
                case 47:
                  switch (g3 = e3.charCodeAt(l3 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u3 = l3 + 1; u3 < J3; ++u3) {
                          switch (e3.charCodeAt(u3)) {
                            case 47:
                              if (42 === g3 && 42 === e3.charCodeAt(u3 - 1) && l3 + 2 !== u3) {
                                l3 = u3 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (47 === g3) {
                                l3 = u3 + 1;
                                break a;
                              }
                          }
                        }
                        l3 = u3;
                      }
                  }
                  break;
                case 91:
                  g3++;
                case 40:
                  g3++;
                case 34:
                case 39:
                  for (; l3++ < J3 && e3.charCodeAt(l3) !== g3; ) {
                  }
              }
              if (0 === k3)
                break;
              l3++;
            }
            k3 = e3.substring(t3, l3);
            0 === q3 && (q3 = (f2 = f2.replace(ca2, "").trim()).charCodeAt(0));
            switch (q3) {
              case 64:
                0 < r3 && (f2 = f2.replace(N3, ""));
                g3 = f2.charCodeAt(1);
                switch (g3) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r3 = c3;
                    break;
                  default:
                    r3 = O3;
                }
                k3 = M3(c3, r3, k3, g3, a3 + 1);
                t3 = k3.length;
                0 < A3 && (r3 = X3(O3, f2, I3), C3 = H3(3, k3, r3, c3, D3, z3, t3, g3, a3, h2), f2 = r3.join(""), void 0 !== C3 && 0 === (t3 = (k3 = C3.trim()).length) && (g3 = 0, k3 = ""));
                if (0 < t3)
                  switch (g3) {
                    case 115:
                      f2 = f2.replace(da2, ea2);
                    case 100:
                    case 109:
                    case 45:
                      k3 = f2 + "{" + k3 + "}";
                      break;
                    case 107:
                      f2 = f2.replace(fa2, "$1 $2");
                      k3 = f2 + "{" + k3 + "}";
                      k3 = 1 === w3 || 2 === w3 && L3("@" + k3, 3) ? "@-webkit-" + k3 + "@" + k3 : "@" + k3;
                      break;
                    default:
                      k3 = f2 + k3, 112 === h2 && (k3 = (p2 += k3, ""));
                  }
                else
                  k3 = "";
                break;
              default:
                k3 = M3(c3, X3(c3, f2, I3), k3, h2, a3 + 1);
            }
            F4 += k3;
            k3 = I3 = r3 = u3 = q3 = 0;
            f2 = "";
            g3 = e3.charCodeAt(++l3);
            break;
          case 125:
          case 59:
            f2 = (0 < r3 ? f2.replace(N3, "") : f2).trim();
            if (1 < (t3 = f2.length))
              switch (0 === u3 && (q3 = f2.charCodeAt(0), 45 === q3 || 96 < q3 && 123 > q3) && (t3 = (f2 = f2.replace(" ", ":")).length), 0 < A3 && void 0 !== (C3 = H3(1, f2, c3, d3, D3, z3, p2.length, h2, a3, h2)) && 0 === (t3 = (f2 = C3.trim()).length) && (f2 = "\0\0"), q3 = f2.charCodeAt(0), g3 = f2.charCodeAt(1), q3) {
                case 0:
                  break;
                case 64:
                  if (105 === g3 || 99 === g3) {
                    G4 += f2 + e3.charAt(l3);
                    break;
                  }
                default:
                  58 !== f2.charCodeAt(t3 - 1) && (p2 += P3(f2, q3, g3, f2.charCodeAt(2)));
              }
            I3 = r3 = u3 = q3 = 0;
            f2 = "";
            g3 = e3.charCodeAt(++l3);
        }
      }
      switch (g3) {
        case 13:
        case 10:
          47 === b3 ? b3 = 0 : 0 === 1 + q3 && 107 !== h2 && 0 < f2.length && (r3 = 1, f2 += "\0");
          0 < A3 * Y3 && H3(0, f2, c3, d3, D3, z3, p2.length, h2, a3, h2);
          z3 = 1;
          D3++;
          break;
        case 59:
        case 125:
          if (0 === b3 + n3 + v3 + m3) {
            z3++;
            break;
          }
        default:
          z3++;
          y3 = e3.charAt(l3);
          switch (g3) {
            case 9:
            case 32:
              if (0 === n3 + m3 + b3)
                switch (x3) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y3 = "";
                    break;
                  default:
                    32 !== g3 && (y3 = " ");
                }
              break;
            case 0:
              y3 = "\\0";
              break;
            case 12:
              y3 = "\\f";
              break;
            case 11:
              y3 = "\\v";
              break;
            case 38:
              0 === n3 + b3 + m3 && (r3 = I3 = 1, y3 = "\f" + y3);
              break;
            case 108:
              if (0 === n3 + b3 + m3 + E3 && 0 < u3)
                switch (l3 - u3) {
                  case 2:
                    112 === x3 && 58 === e3.charCodeAt(l3 - 3) && (E3 = x3);
                  case 8:
                    111 === K3 && (E3 = K3);
                }
              break;
            case 58:
              0 === n3 + b3 + m3 && (u3 = l3);
              break;
            case 44:
              0 === b3 + v3 + n3 + m3 && (r3 = 1, y3 += "\r");
              break;
            case 34:
            case 39:
              0 === b3 && (n3 = n3 === g3 ? 0 : 0 === n3 ? g3 : n3);
              break;
            case 91:
              0 === n3 + b3 + v3 && m3++;
              break;
            case 93:
              0 === n3 + b3 + v3 && m3--;
              break;
            case 41:
              0 === n3 + b3 + m3 && v3--;
              break;
            case 40:
              if (0 === n3 + b3 + m3) {
                if (0 === q3)
                  switch (2 * x3 + 3 * K3) {
                    case 533:
                      break;
                    default:
                      q3 = 1;
                  }
                v3++;
              }
              break;
            case 64:
              0 === b3 + v3 + n3 + m3 + u3 + k3 && (k3 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n3 + m3 + v3))
                switch (b3) {
                  case 0:
                    switch (2 * g3 + 3 * e3.charCodeAt(l3 + 1)) {
                      case 235:
                        b3 = 47;
                        break;
                      case 220:
                        t3 = l3, b3 = 42;
                    }
                    break;
                  case 42:
                    47 === g3 && 42 === x3 && t3 + 2 !== l3 && (33 === e3.charCodeAt(t3 + 2) && (p2 += e3.substring(t3, l3 + 1)), y3 = "", b3 = 0);
                }
          }
          0 === b3 && (f2 += y3);
      }
      K3 = x3;
      x3 = g3;
      l3++;
    }
    t3 = p2.length;
    if (0 < t3) {
      r3 = c3;
      if (0 < A3 && (C3 = H3(2, p2, r3, d3, D3, z3, t3, h2, a3, h2), void 0 !== C3 && 0 === (p2 = C3).length))
        return G4 + p2 + F4;
      p2 = r3.join(",") + "{" + p2 + "}";
      if (0 !== w3 * E3) {
        2 !== w3 || L3(p2, 2) || (E3 = 0);
        switch (E3) {
          case 111:
            p2 = p2.replace(ha2, ":-moz-$1") + p2;
            break;
          case 112:
            p2 = p2.replace(Q3, "::-webkit-input-$1") + p2.replace(Q3, "::-moz-$1") + p2.replace(Q3, ":-ms-input-$1") + p2;
        }
        E3 = 0;
      }
    }
    return G4 + p2 + F4;
  }
  function X3(d3, c3, e3) {
    var h2 = c3.trim().split(ia2);
    c3 = h2;
    var a3 = h2.length, m3 = d3.length;
    switch (m3) {
      case 0:
      case 1:
        var b3 = 0;
        for (d3 = 0 === m3 ? "" : d3[0] + " "; b3 < a3; ++b3) {
          c3[b3] = Z3(d3, c3[b3], e3).trim();
        }
        break;
      default:
        var v3 = b3 = 0;
        for (c3 = []; b3 < a3; ++b3) {
          for (var n3 = 0; n3 < m3; ++n3) {
            c3[v3++] = Z3(d3[n3] + " ", h2[b3], e3).trim();
          }
        }
    }
    return c3;
  }
  function Z3(d3, c3, e3) {
    var h2 = c3.charCodeAt(0);
    33 > h2 && (h2 = (c3 = c3.trim()).charCodeAt(0));
    switch (h2) {
      case 38:
        return c3.replace(F3, "$1" + d3.trim());
      case 58:
        return d3.trim() + c3.replace(F3, "$1" + d3.trim());
      default:
        if (0 < 1 * e3 && 0 < c3.indexOf("\f"))
          return c3.replace(F3, (58 === d3.charCodeAt(0) ? "" : "$1") + d3.trim());
    }
    return d3 + c3;
  }
  function P3(d3, c3, e3, h2) {
    var a3 = d3 + ";", m3 = 2 * c3 + 3 * e3 + 4 * h2;
    if (944 === m3) {
      d3 = a3.indexOf(":", 9) + 1;
      var b3 = a3.substring(d3, a3.length - 1).trim();
      b3 = a3.substring(0, d3).trim() + b3 + ";";
      return 1 === w3 || 2 === w3 && L3(b3, 1) ? "-webkit-" + b3 + b3 : b3;
    }
    if (0 === w3 || 2 === w3 && !L3(a3, 1))
      return a3;
    switch (m3) {
      case 1015:
        return 97 === a3.charCodeAt(10) ? "-webkit-" + a3 + a3 : a3;
      case 951:
        return 116 === a3.charCodeAt(3) ? "-webkit-" + a3 + a3 : a3;
      case 963:
        return 110 === a3.charCodeAt(5) ? "-webkit-" + a3 + a3 : a3;
      case 1009:
        if (100 !== a3.charCodeAt(4))
          break;
      case 969:
      case 942:
        return "-webkit-" + a3 + a3;
      case 978:
        return "-webkit-" + a3 + "-moz-" + a3 + a3;
      case 1019:
      case 983:
        return "-webkit-" + a3 + "-moz-" + a3 + "-ms-" + a3 + a3;
      case 883:
        if (45 === a3.charCodeAt(8))
          return "-webkit-" + a3 + a3;
        if (0 < a3.indexOf("image-set(", 11))
          return a3.replace(ja2, "$1-webkit-$2") + a3;
        break;
      case 932:
        if (45 === a3.charCodeAt(4))
          switch (a3.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + a3.replace("-grow", "") + "-webkit-" + a3 + "-ms-" + a3.replace("grow", "positive") + a3;
            case 115:
              return "-webkit-" + a3 + "-ms-" + a3.replace("shrink", "negative") + a3;
            case 98:
              return "-webkit-" + a3 + "-ms-" + a3.replace("basis", "preferred-size") + a3;
          }
        return "-webkit-" + a3 + "-ms-" + a3 + a3;
      case 964:
        return "-webkit-" + a3 + "-ms-flex-" + a3 + a3;
      case 1023:
        if (99 !== a3.charCodeAt(8))
          break;
        b3 = a3.substring(a3.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
        return "-webkit-box-pack" + b3 + "-webkit-" + a3 + "-ms-flex-pack" + b3 + a3;
      case 1005:
        return ka2.test(a3) ? a3.replace(aa2, ":-webkit-") + a3.replace(aa2, ":-moz-") + a3 : a3;
      case 1e3:
        b3 = a3.substring(13).trim();
        c3 = b3.indexOf("-") + 1;
        switch (b3.charCodeAt(0) + b3.charCodeAt(c3)) {
          case 226:
            b3 = a3.replace(G3, "tb");
            break;
          case 232:
            b3 = a3.replace(G3, "tb-rl");
            break;
          case 220:
            b3 = a3.replace(G3, "lr");
            break;
          default:
            return a3;
        }
        return "-webkit-" + a3 + "-ms-" + b3 + a3;
      case 1017:
        if (-1 === a3.indexOf("sticky", 9))
          break;
      case 975:
        c3 = (a3 = d3).length - 10;
        b3 = (33 === a3.charCodeAt(c3) ? a3.substring(0, c3) : a3).substring(d3.indexOf(":", 7) + 1).trim();
        switch (m3 = b3.charCodeAt(0) + (b3.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b3.charCodeAt(8))
              break;
          case 115:
            a3 = a3.replace(b3, "-webkit-" + b3) + ";" + a3;
            break;
          case 207:
          case 102:
            a3 = a3.replace(b3, "-webkit-" + (102 < m3 ? "inline-" : "") + "box") + ";" + a3.replace(b3, "-webkit-" + b3) + ";" + a3.replace(b3, "-ms-" + b3 + "box") + ";" + a3;
        }
        return a3 + ";";
      case 938:
        if (45 === a3.charCodeAt(5))
          switch (a3.charCodeAt(6)) {
            case 105:
              return b3 = a3.replace("-items", ""), "-webkit-" + a3 + "-webkit-box-" + b3 + "-ms-flex-" + b3 + a3;
            case 115:
              return "-webkit-" + a3 + "-ms-flex-item-" + a3.replace(ba2, "") + a3;
            default:
              return "-webkit-" + a3 + "-ms-flex-line-pack" + a3.replace("align-content", "").replace(ba2, "") + a3;
          }
        break;
      case 973:
      case 989:
        if (45 !== a3.charCodeAt(3) || 122 === a3.charCodeAt(4))
          break;
      case 931:
      case 953:
        if (true === la2.test(d3))
          return 115 === (b3 = d3.substring(d3.indexOf(":") + 1)).charCodeAt(0) ? P3(d3.replace("stretch", "fill-available"), c3, e3, h2).replace(":fill-available", ":stretch") : a3.replace(b3, "-webkit-" + b3) + a3.replace(b3, "-moz-" + b3.replace("fill-", "")) + a3;
        break;
      case 962:
        if (a3 = "-webkit-" + a3 + (102 === a3.charCodeAt(5) ? "-ms-" + a3 : "") + a3, 211 === e3 + h2 && 105 === a3.charCodeAt(13) && 0 < a3.indexOf("transform", 10))
          return a3.substring(0, a3.indexOf(";", 27) + 1).replace(ma2, "$1-webkit-$2") + a3;
    }
    return a3;
  }
  function L3(d3, c3) {
    var e3 = d3.indexOf(1 === c3 ? ":" : "{"), h2 = d3.substring(0, 3 !== c3 ? e3 : 10);
    e3 = d3.substring(e3 + 1, d3.length - 1);
    return R3(2 !== c3 ? h2 : h2.replace(na2, "$1"), e3, c3);
  }
  function ea2(d3, c3) {
    var e3 = P3(c3, c3.charCodeAt(0), c3.charCodeAt(1), c3.charCodeAt(2));
    return e3 !== c3 + ";" ? e3.replace(oa2, " or ($1)").substring(4) : "(" + c3 + ")";
  }
  function H3(d3, c3, e3, h2, a3, m3, b3, v3, n3, q3) {
    for (var g3 = 0, x3 = c3, w4; g3 < A3; ++g3) {
      switch (w4 = S3[g3].call(B3, d3, x3, e3, h2, a3, m3, b3, v3, n3, q3)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          x3 = w4;
      }
    }
    if (x3 !== c3)
      return x3;
  }
  function T3(d3) {
    switch (d3) {
      case void 0:
      case null:
        A3 = S3.length = 0;
        break;
      default:
        if ("function" === typeof d3)
          S3[A3++] = d3;
        else if ("object" === typeof d3)
          for (var c3 = 0, e3 = d3.length; c3 < e3; ++c3) {
            T3(d3[c3]);
          }
        else
          Y3 = !!d3 | 0;
    }
    return T3;
  }
  function U3(d3) {
    d3 = d3.prefix;
    void 0 !== d3 && (R3 = null, d3 ? "function" !== typeof d3 ? w3 = 1 : (w3 = 2, R3 = d3) : w3 = 0);
    return U3;
  }
  function B3(d3, c3) {
    var e3 = d3;
    33 > e3.charCodeAt(0) && (e3 = e3.trim());
    V3 = e3;
    e3 = [V3];
    if (0 < A3) {
      var h2 = H3(-1, c3, e3, e3, D3, z3, 0, 0, 0, 0);
      void 0 !== h2 && "string" === typeof h2 && (c3 = h2);
    }
    var a3 = M3(O3, e3, c3, 0, 0);
    0 < A3 && (h2 = H3(-2, a3, e3, e3, D3, z3, a3.length, 0, 0, 0), void 0 !== h2 && (a3 = h2));
    V3 = "";
    E3 = 0;
    z3 = D3 = 1;
    return a3;
  }
  var ca2 = /^\0+/g, N3 = /[\0\r\f]/g, aa2 = /: */g, ka2 = /zoo|gra/, ma2 = /([,: ])(transform)/g, ia2 = /,\r+?/g, F3 = /([\t\r\n ])*\f?&/g, fa2 = /@(k\w+)\s*(\S*)\s*/, Q3 = /::(place)/g, ha2 = /:(read-only)/g, G3 = /[svh]\w+-[tblr]{2}/, da2 = /\(\s*(.*)\s*\)/g, oa2 = /([\s\S]*?);/g, ba2 = /-self|flex-/g, na2 = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la2 = /stretch|:\s*\w+\-(?:conte|avail)/, ja2 = /([^-])(image-set\()/, z3 = 1, D3 = 1, E3 = 0, w3 = 1, O3 = [], S3 = [], A3 = 0, R3 = null, Y3 = 0, V3 = "";
  B3.use = T3;
  B3.set = U3;
  void 0 !== W3 && U3(W3);
  return B3;
}
var stylis_browser_esm_default;
var init_stylis_browser_esm = __esm({
  "node_modules/@emotion/stylis/dist/stylis.browser.esm.js"() {
    stylis_browser_esm_default = stylis_min;
  }
});

// node_modules/styled-components/node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys, unitless_browser_esm_default;
var init_unitless_browser_esm = __esm({
  "node_modules/styled-components/node_modules/@emotion/unitless/dist/unitless.browser.esm.js"() {
    unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    unitless_browser_esm_default = unitlessKeys;
  }
});

// node_modules/styled-components/dist/styled-components.browser.esm.js
var styled_components_browser_esm_exports = {};
__export(styled_components_browser_esm_exports, {
  ServerStyleSheet: () => Ue,
  StyleSheetConsumer: () => ue,
  StyleSheetContext: () => ce,
  StyleSheetManager: () => me,
  ThemeConsumer: () => Ge,
  ThemeContext: () => Me,
  ThemeProvider: () => Le,
  __PRIVATE__: () => Ze,
  createGlobalStyle: () => $e,
  css: () => Ae,
  default: () => styled_components_browser_esm_default,
  isStyledComponent: () => _,
  keyframes: () => We,
  useTheme: () => Xe,
  version: () => A,
  withTheme: () => Je
});
function y() {
  return (y = Object.assign || function(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var n3 = arguments[t3];
      for (var r3 in n3)
        Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
    }
    return e3;
  }).apply(this, arguments);
}
function E(e3) {
  return "function" == typeof e3;
}
function b(e3) {
  return "string" == typeof e3 && e3 || e3.displayName || e3.name || "Component";
}
function _(e3) {
  return e3 && "string" == typeof e3.styledComponentId;
}
function R() {
  for (var e3 = arguments.length <= 0 ? void 0 : arguments[0], t3 = [], n3 = 1, r3 = arguments.length; n3 < r3; n3 += 1)
    t3.push(n3 < 0 || arguments.length <= n3 ? void 0 : arguments[n3]);
  return t3.forEach(function(t4) {
    e3 = e3.replace(/%[a-z]/, t4);
  }), e3;
}
function D(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  throw false ? new Error("An error occurred. See https://git.io/JUIaE#" + e3 + " for more information." + (n3.length > 0 ? " Args: " + n3.join(", ") : "")) : new Error(R.apply(void 0, [O[e3]].concat(n3)).trim());
}
function Q(e3) {
  var t3, n3 = "";
  for (t3 = Math.abs(e3); t3 > 52; t3 = t3 / 52 | 0)
    n3 = K(t3 % 52) + n3;
  return (K(t3 % 52) + n3).replace(Z, "$1-$2");
}
function ne(e3) {
  for (var t3 = 0; t3 < e3.length; t3 += 1) {
    var n3 = e3[t3];
    if (E(n3) && !_(n3))
      return false;
  }
  return true;
}
function ae(e3) {
  var t3, n3, r3, o3, s3 = void 0 === e3 ? w : e3, i3 = s3.options, a3 = void 0 === i3 ? w : i3, c3 = s3.plugins, u3 = void 0 === c3 ? S : c3, l3 = new stylis_browser_esm_default(a3), d3 = [], p2 = /* @__PURE__ */ function(e4) {
    function t4(t5) {
      if (t5)
        try {
          e4(t5 + "}");
        } catch (e5) {
        }
    }
    return function(n4, r4, o4, s4, i4, a4, c4, u4, l4, d4) {
      switch (n4) {
        case 1:
          if (0 === l4 && 64 === r4.charCodeAt(0))
            return e4(r4 + ";"), "";
          break;
        case 2:
          if (0 === u4)
            return r4 + "/*|*/";
          break;
        case 3:
          switch (u4) {
            case 102:
            case 112:
              return e4(o4[0] + r4), "";
            default:
              return r4 + (0 === d4 ? "/*|*/" : "");
          }
        case -2:
          r4.split("/*|*/}").forEach(t4);
      }
    };
  }(function(e4) {
    d3.push(e4);
  }), f2 = function(e4, r4, s4) {
    return 0 === r4 && -1 !== ie.indexOf(s4[n3.length]) || s4.match(o3) ? e4 : "." + t3;
  };
  function m3(e4, s4, i4, a4) {
    void 0 === a4 && (a4 = "&");
    var c4 = e4.replace(se, ""), u4 = s4 && i4 ? i4 + " " + s4 + " { " + c4 + " }" : c4;
    return t3 = a4, n3 = s4, r3 = new RegExp("\\" + n3 + "\\b", "g"), o3 = new RegExp("(\\" + n3 + "\\b){2,}"), l3(i4 || !s4 ? "" : s4, u4);
  }
  return l3.use([].concat(u3, [function(e4, t4, o4) {
    2 === e4 && o4.length && o4[0].lastIndexOf(n3) > 0 && (o4[0] = o4[0].replace(r3, f2));
  }, p2, function(e4) {
    if (-2 === e4) {
      var t4 = d3;
      return d3 = [], t4;
    }
  }])), m3.hash = u3.length ? u3.reduce(function(e4, t4) {
    return t4.name || D(15), ee(e4, t4.name);
  }, 5381).toString() : "", m3;
}
function pe() {
  return (0, import_react.useContext)(ce) || de;
}
function fe() {
  return (0, import_react.useContext)(le) || he;
}
function me(e3) {
  var t3 = (0, import_react.useState)(e3.stylisPlugins), n3 = t3[0], s3 = t3[1], c3 = pe(), u3 = (0, import_react.useMemo)(function() {
    var t4 = c3;
    return e3.sheet ? t4 = e3.sheet : e3.target && (t4 = t4.reconstructWithOptions({ target: e3.target }, false)), e3.disableCSSOMInjection && (t4 = t4.reconstructWithOptions({ useCSSOMInjection: false })), t4;
  }, [e3.disableCSSOMInjection, e3.sheet, e3.target]), l3 = (0, import_react.useMemo)(function() {
    return ae({ options: { prefix: !e3.disableVendorPrefixes }, plugins: n3 });
  }, [e3.disableVendorPrefixes, n3]);
  return (0, import_react.useEffect)(function() {
    (0, import_shallowequal.default)(n3, e3.stylisPlugins) || s3(e3.stylisPlugins);
  }, [e3.stylisPlugins]), import_react.default.createElement(ce.Provider, { value: u3 }, import_react.default.createElement(le.Provider, { value: l3 }, true ? import_react.default.Children.only(e3.children) : e3.children));
}
function Ee(e3) {
  return ve.test(e3) ? e3.replace(ge, we).replace(Se, "-ms-") : e3;
}
function _e(e3, n3, r3, o3) {
  if (Array.isArray(e3)) {
    for (var s3, i3 = [], a3 = 0, c3 = e3.length; a3 < c3; a3 += 1)
      "" !== (s3 = _e(e3[a3], n3, r3, o3)) && (Array.isArray(s3) ? i3.push.apply(i3, s3) : i3.push(s3));
    return i3;
  }
  if (be(e3))
    return "";
  if (_(e3))
    return "." + e3.styledComponentId;
  if (E(e3)) {
    if ("function" != typeof (l3 = e3) || l3.prototype && l3.prototype.isReactComponent || !n3)
      return e3;
    var u3 = e3(n3);
    return (0, import_react_is.isElement)(u3) && console.warn(b(e3) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), _e(u3, n3, r3, o3);
  }
  var l3;
  return e3 instanceof ye ? r3 ? (e3.inject(r3, o3), e3.getName(o3)) : e3 : g(e3) ? function e4(t3, n4) {
    var r4, o4, s4 = [];
    for (var i4 in t3)
      t3.hasOwnProperty(i4) && !be(t3[i4]) && (Array.isArray(t3[i4]) && t3[i4].isCss || E(t3[i4]) ? s4.push(Ee(i4) + ":", t3[i4], ";") : g(t3[i4]) ? s4.push.apply(s4, e4(t3[i4], i4)) : s4.push(Ee(i4) + ": " + (r4 = i4, null == (o4 = t3[i4]) || "boolean" == typeof o4 || "" === o4 ? "" : "number" != typeof o4 || 0 === o4 || r4 in unitless_browser_esm_default || r4.startsWith("--") ? String(o4).trim() : o4 + "px") + ";"));
    return n4 ? [n4 + " {"].concat(s4, ["}"]) : s4;
  }(e3) : e3.toString();
}
function Ae(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  return E(e3) || g(e3) ? Ne(_e(v(S, [e3].concat(n3)))) : 0 === n3.length && 1 === e3.length && "string" == typeof e3[0] ? e3 : Ne(_e(v(e3, n3)));
}
function je(e3) {
  return e3.replace(Re, "-").replace(De, "");
}
function xe(e3) {
  return "string" == typeof e3 && e3.charAt(0) === e3.charAt(0).toLowerCase();
}
function Be(e3, t3, n3) {
  var r3 = e3[n3];
  ke(t3) && ke(r3) ? ze(r3, t3) : e3[n3] = t3;
}
function ze(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  for (var o3 = 0, s3 = n3; o3 < s3.length; o3++) {
    var i3 = s3[o3];
    if (ke(i3))
      for (var a3 in i3)
        Ve(a3) && Be(e3, i3[a3], a3);
  }
  return e3;
}
function Le(e3) {
  var t3 = (0, import_react.useContext)(Me), n3 = (0, import_react.useMemo)(function() {
    return function(e4, t4) {
      if (!e4)
        return D(14);
      if (E(e4)) {
        var n4 = e4(t4);
        return null !== n4 && !Array.isArray(n4) && "object" == typeof n4 ? n4 : D(7);
      }
      return Array.isArray(e4) || "object" != typeof e4 ? D(8) : t4 ? y({}, t4, {}, e4) : e4;
    }(e3.theme, t3);
  }, [e3.theme, t3]);
  return e3.children ? import_react.default.createElement(Me.Provider, { value: n3 }, e3.children) : null;
}
function Ye(e3, t3, n3) {
  var o3 = _(e3), i3 = !xe(e3), a3 = t3.attrs, c3 = void 0 === a3 ? S : a3, l3 = t3.componentId, d3 = void 0 === l3 ? function(e4, t4) {
    var n4 = "string" != typeof e4 ? "sc" : je(e4);
    Fe[n4] = (Fe[n4] || 0) + 1;
    var r3 = n4 + "-" + Te("5.3.11" + n4 + Fe[n4]);
    return t4 ? t4 + "-" + r3 : r3;
  }(t3.displayName, t3.parentComponentId) : l3, h2 = t3.displayName, p2 = void 0 === h2 ? function(e4) {
    return xe(e4) ? "styled." + e4 : "Styled(" + b(e4) + ")";
  }(e3) : h2, v3 = t3.displayName && t3.componentId ? je(t3.displayName) + "-" + t3.componentId : t3.componentId || d3, g3 = o3 && e3.attrs ? Array.prototype.concat(e3.attrs, c3).filter(Boolean) : c3, N3 = t3.shouldForwardProp;
  o3 && e3.shouldForwardProp && (N3 = t3.shouldForwardProp ? function(n4, r3, o4) {
    return e3.shouldForwardProp(n4, r3, o4) && t3.shouldForwardProp(n4, r3, o4);
  } : e3.shouldForwardProp);
  var A3, C3 = new oe(n3, v3, o3 ? e3.componentStyle : void 0), I3 = C3.isStatic && 0 === c3.length, P3 = function(e4, t4) {
    return function(e5, t5, n4, r3) {
      var o4 = e5.attrs, i4 = e5.componentStyle, a4 = e5.defaultProps, c4 = e5.foldedComponentIds, l4 = e5.shouldForwardProp, d4 = e5.styledComponentId, h3 = e5.target, p3 = function(e6, t6, n5) {
        void 0 === e6 && (e6 = w);
        var r4 = y({}, t6, { theme: e6 }), o5 = {};
        return n5.forEach(function(e7) {
          var t7, n6, s3, i5 = e7;
          for (t7 in E(i5) && (i5 = i5(r4)), i5)
            r4[t7] = o5[t7] = "className" === t7 ? (n6 = o5[t7], s3 = i5[t7], n6 && s3 ? n6 + " " + s3 : n6 || s3) : i5[t7];
        }), [r4, o5];
      }(Oe(t5, (0, import_react.useContext)(Me), a4) || w, t5, o4), m3 = p3[0], v4 = p3[1], g4 = function(e6, t6, n5, r4) {
        var o5 = pe(), s3 = fe(), i5 = t6 ? e6.generateAndInjectStyles(w, o5, s3) : e6.generateAndInjectStyles(n5, o5, s3);
        return !t6 && r4 && r4(i5), i5;
      }(i4, r3, m3, true ? e5.warnTooManyClasses : void 0), S3 = n4, b3 = v4.$as || t5.$as || v4.as || t5.as || h3, _3 = xe(b3), N4 = v4 !== t5 ? y({}, t5, {}, v4) : t5, A4 = {};
      for (var C4 in N4)
        "$" !== C4[0] && "as" !== C4 && ("forwardedAs" === C4 ? A4.as = N4[C4] : (l4 ? l4(C4, isPropValid, b3) : !_3 || isPropValid(C4)) && (A4[C4] = N4[C4]));
      return t5.style && v4.style !== t5.style && (A4.style = y({}, t5.style, {}, v4.style)), A4.className = Array.prototype.concat(c4, d4, g4 !== d4 ? g4 : null, t5.className, v4.className).filter(Boolean).join(" "), A4.ref = S3, (0, import_react.createElement)(b3, A4);
    }(A3, e4, t4, I3);
  };
  return P3.displayName = p2, (A3 = import_react.default.forwardRef(P3)).attrs = g3, A3.componentStyle = C3, A3.displayName = p2, A3.shouldForwardProp = N3, A3.foldedComponentIds = o3 ? Array.prototype.concat(e3.foldedComponentIds, e3.styledComponentId) : S, A3.styledComponentId = v3, A3.target = o3 ? e3.target : e3, A3.withComponent = function(e4) {
    var r3 = t3.componentId, o4 = function(e5, t4) {
      if (null == e5)
        return {};
      var n4, r4, o5 = {}, s4 = Object.keys(e5);
      for (r4 = 0; r4 < s4.length; r4++)
        n4 = s4[r4], t4.indexOf(n4) >= 0 || (o5[n4] = e5[n4]);
      return o5;
    }(t3, ["componentId"]), s3 = r3 && r3 + "-" + (xe(e4) ? e4 : je(b(e4)));
    return Ye(e4, y({}, o4, { attrs: g3, componentId: s3 }), n3);
  }, Object.defineProperty(A3, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t4) {
    this._foldedDefaultProps = o3 ? ze({}, e3.defaultProps, t4) : t4;
  } }), Pe(p2, v3), A3.warnTooManyClasses = /* @__PURE__ */ function(e4, t4) {
    var n4 = {}, r3 = false;
    return function(o4) {
      if (!r3 && (n4[o4] = true, Object.keys(n4).length >= 200)) {
        var s3 = t4 ? ' with the id of "' + t4 + '"' : "";
        console.warn("Over 200 classes were generated for component " + e4 + s3 + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r3 = true, n4 = {};
      }
    };
  }(p2, v3), Object.defineProperty(A3, "toString", { value: function() {
    return "." + A3.styledComponentId;
  } }), i3 && (0, import_hoist_non_react_statics.default)(A3, e3, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), A3;
}
function $e(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
    n3[o3 - 1] = arguments[o3];
  var i3 = Ae.apply(void 0, [e3].concat(n3)), a3 = "sc-global-" + Te(JSON.stringify(i3)), u3 = new He(i3, a3);
  function d3(e4) {
    var t4 = pe(), n4 = fe(), o4 = (0, import_react.useContext)(Me), d4 = (0, import_react.useRef)(t4.allocateGSInstance(a3)).current;
    return import_react.default.Children.count(e4.children) && console.warn("The global style component " + a3 + " was given child JSX. createGlobalStyle does not render children."), i3.some(function(e5) {
      return "string" == typeof e5 && -1 !== e5.indexOf("@import");
    }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t4.server && h2(d4, e4, t4, o4, n4), (0, import_react.useLayoutEffect)(function() {
      if (!t4.server)
        return h2(d4, e4, t4, o4, n4), function() {
          return u3.removeStyles(d4, t4);
        };
    }, [d4, e4, t4, o4, n4]), null;
  }
  function h2(e4, t4, n4, r3, o4) {
    if (u3.isStatic)
      u3.renderStyles(e4, P, n4, o4);
    else {
      var s3 = y({}, t4, { theme: Oe(t4, r3, d3.defaultProps) });
      u3.renderStyles(e4, s3, n4, o4);
    }
  }
  return Pe(a3), import_react.default.memo(d3);
}
function We(e3) {
  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  var o3 = Ae.apply(void 0, [e3].concat(n3)).join(""), s3 = Te(o3);
  return new ye(s3, o3);
}
var import_react_is, import_react, import_shallowequal, import_hoist_non_react_statics, v, g, S, w, N, A, C, I, P, O, j, T, x, k, V, B, z, M, G, L, F, Y, q, H, $, W, U, J, X, Z, K, ee, te, re, oe, se, ie, ce, ue, le, de, he, ye, ve, ge, Se, we, be, Ne, Ce, Ie, Pe, Oe, Re, De, Te, ke, Ve, Me, Ge, Fe, qe, He, Ue, Je, Xe, Ze, styled_components_browser_esm_default;
var init_styled_components_browser_esm = __esm({
  "node_modules/styled-components/dist/styled-components.browser.esm.js"() {
    import_react_is = __toESM(require_react_is());
    import_react = __toESM(require_react());
    import_shallowequal = __toESM(require_shallowequal());
    init_stylis_browser_esm();
    init_unitless_browser_esm();
    init_emotion_is_prop_valid_esm();
    import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
    v = function(e3, t3) {
      for (var n3 = [e3[0]], r3 = 0, o3 = t3.length; r3 < o3; r3 += 1)
        n3.push(t3[r3], e3[r3 + 1]);
      return n3;
    };
    g = function(t3) {
      return null !== t3 && "object" == typeof t3 && "[object Object]" === (t3.toString ? t3.toString() : Object.prototype.toString.call(t3)) && !(0, import_react_is.typeOf)(t3);
    };
    S = Object.freeze([]);
    w = Object.freeze({});
    N = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
    A = "5.3.11";
    C = "undefined" != typeof window && "HTMLElement" in window;
    I = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && (void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true));
    P = {};
    O = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n" } : {};
    j = function() {
      function e3(e4) {
        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e4;
      }
      var t3 = e3.prototype;
      return t3.indexOfGroup = function(e4) {
        for (var t4 = 0, n3 = 0; n3 < e4; n3++)
          t4 += this.groupSizes[n3];
        return t4;
      }, t3.insertRules = function(e4, t4) {
        if (e4 >= this.groupSizes.length) {
          for (var n3 = this.groupSizes, r3 = n3.length, o3 = r3; e4 >= o3; )
            (o3 <<= 1) < 0 && D(16, "" + e4);
          this.groupSizes = new Uint32Array(o3), this.groupSizes.set(n3), this.length = o3;
          for (var s3 = r3; s3 < o3; s3++)
            this.groupSizes[s3] = 0;
        }
        for (var i3 = this.indexOfGroup(e4 + 1), a3 = 0, c3 = t4.length; a3 < c3; a3++)
          this.tag.insertRule(i3, t4[a3]) && (this.groupSizes[e4]++, i3++);
      }, t3.clearGroup = function(e4) {
        if (e4 < this.length) {
          var t4 = this.groupSizes[e4], n3 = this.indexOfGroup(e4), r3 = n3 + t4;
          this.groupSizes[e4] = 0;
          for (var o3 = n3; o3 < r3; o3++)
            this.tag.deleteRule(n3);
        }
      }, t3.getGroup = function(e4) {
        var t4 = "";
        if (e4 >= this.length || 0 === this.groupSizes[e4])
          return t4;
        for (var n3 = this.groupSizes[e4], r3 = this.indexOfGroup(e4), o3 = r3 + n3, s3 = r3; s3 < o3; s3++)
          t4 += this.tag.getRule(s3) + "/*!sc*/\n";
        return t4;
      }, e3;
    }();
    T = /* @__PURE__ */ new Map();
    x = /* @__PURE__ */ new Map();
    k = 1;
    V = function(e3) {
      if (T.has(e3))
        return T.get(e3);
      for (; x.has(k); )
        k++;
      var t3 = k++;
      return ((0 | t3) < 0 || t3 > 1 << 30) && D(16, "" + t3), T.set(e3, t3), x.set(t3, e3), t3;
    };
    B = function(e3) {
      return x.get(e3);
    };
    z = function(e3, t3) {
      t3 >= k && (k = t3 + 1), T.set(e3, t3), x.set(t3, e3);
    };
    M = "style[" + N + '][data-styled-version="5.3.11"]';
    G = new RegExp("^" + N + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
    L = function(e3, t3, n3) {
      for (var r3, o3 = n3.split(","), s3 = 0, i3 = o3.length; s3 < i3; s3++)
        (r3 = o3[s3]) && e3.registerName(t3, r3);
    };
    F = function(e3, t3) {
      for (var n3 = (t3.textContent || "").split("/*!sc*/\n"), r3 = [], o3 = 0, s3 = n3.length; o3 < s3; o3++) {
        var i3 = n3[o3].trim();
        if (i3) {
          var a3 = i3.match(G);
          if (a3) {
            var c3 = 0 | parseInt(a3[1], 10), u3 = a3[2];
            0 !== c3 && (z(u3, c3), L(e3, u3, a3[3]), e3.getTag().insertRules(c3, r3)), r3.length = 0;
          } else
            r3.push(i3);
        }
      }
    };
    Y = function() {
      return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
    };
    q = function(e3) {
      var t3 = document.head, n3 = e3 || t3, r3 = document.createElement("style"), o3 = function(e4) {
        for (var t4 = e4.childNodes, n4 = t4.length; n4 >= 0; n4--) {
          var r4 = t4[n4];
          if (r4 && 1 === r4.nodeType && r4.hasAttribute(N))
            return r4;
        }
      }(n3), s3 = void 0 !== o3 ? o3.nextSibling : null;
      r3.setAttribute(N, "active"), r3.setAttribute("data-styled-version", "5.3.11");
      var i3 = Y();
      return i3 && r3.setAttribute("nonce", i3), n3.insertBefore(r3, s3), r3;
    };
    H = function() {
      function e3(e4) {
        var t4 = this.element = q(e4);
        t4.appendChild(document.createTextNode("")), this.sheet = function(e5) {
          if (e5.sheet)
            return e5.sheet;
          for (var t5 = document.styleSheets, n3 = 0, r3 = t5.length; n3 < r3; n3++) {
            var o3 = t5[n3];
            if (o3.ownerNode === e5)
              return o3;
          }
          D(17);
        }(t4), this.length = 0;
      }
      var t3 = e3.prototype;
      return t3.insertRule = function(e4, t4) {
        try {
          return this.sheet.insertRule(t4, e4), this.length++, true;
        } catch (e5) {
          return false;
        }
      }, t3.deleteRule = function(e4) {
        this.sheet.deleteRule(e4), this.length--;
      }, t3.getRule = function(e4) {
        var t4 = this.sheet.cssRules[e4];
        return void 0 !== t4 && "string" == typeof t4.cssText ? t4.cssText : "";
      }, e3;
    }();
    $ = function() {
      function e3(e4) {
        var t4 = this.element = q(e4);
        this.nodes = t4.childNodes, this.length = 0;
      }
      var t3 = e3.prototype;
      return t3.insertRule = function(e4, t4) {
        if (e4 <= this.length && e4 >= 0) {
          var n3 = document.createTextNode(t4), r3 = this.nodes[e4];
          return this.element.insertBefore(n3, r3 || null), this.length++, true;
        }
        return false;
      }, t3.deleteRule = function(e4) {
        this.element.removeChild(this.nodes[e4]), this.length--;
      }, t3.getRule = function(e4) {
        return e4 < this.length ? this.nodes[e4].textContent : "";
      }, e3;
    }();
    W = function() {
      function e3(e4) {
        this.rules = [], this.length = 0;
      }
      var t3 = e3.prototype;
      return t3.insertRule = function(e4, t4) {
        return e4 <= this.length && (this.rules.splice(e4, 0, t4), this.length++, true);
      }, t3.deleteRule = function(e4) {
        this.rules.splice(e4, 1), this.length--;
      }, t3.getRule = function(e4) {
        return e4 < this.length ? this.rules[e4] : "";
      }, e3;
    }();
    U = C;
    J = { isServer: !C, useCSSOMInjection: !I };
    X = function() {
      function e3(e4, t4, n3) {
        void 0 === e4 && (e4 = w), void 0 === t4 && (t4 = {}), this.options = y({}, J, {}, e4), this.gs = t4, this.names = new Map(n3), this.server = !!e4.isServer, !this.server && C && U && (U = false, function(e5) {
          for (var t5 = document.querySelectorAll(M), n4 = 0, r3 = t5.length; n4 < r3; n4++) {
            var o3 = t5[n4];
            o3 && "active" !== o3.getAttribute(N) && (F(e5, o3), o3.parentNode && o3.parentNode.removeChild(o3));
          }
        }(this));
      }
      e3.registerId = function(e4) {
        return V(e4);
      };
      var t3 = e3.prototype;
      return t3.reconstructWithOptions = function(t4, n3) {
        return void 0 === n3 && (n3 = true), new e3(y({}, this.options, {}, t4), this.gs, n3 && this.names || void 0);
      }, t3.allocateGSInstance = function(e4) {
        return this.gs[e4] = (this.gs[e4] || 0) + 1;
      }, t3.getTag = function() {
        return this.tag || (this.tag = (n3 = (t4 = this.options).isServer, r3 = t4.useCSSOMInjection, o3 = t4.target, e4 = n3 ? new W(o3) : r3 ? new H(o3) : new $(o3), new j(e4)));
        var e4, t4, n3, r3, o3;
      }, t3.hasNameForId = function(e4, t4) {
        return this.names.has(e4) && this.names.get(e4).has(t4);
      }, t3.registerName = function(e4, t4) {
        if (V(e4), this.names.has(e4))
          this.names.get(e4).add(t4);
        else {
          var n3 = /* @__PURE__ */ new Set();
          n3.add(t4), this.names.set(e4, n3);
        }
      }, t3.insertRules = function(e4, t4, n3) {
        this.registerName(e4, t4), this.getTag().insertRules(V(e4), n3);
      }, t3.clearNames = function(e4) {
        this.names.has(e4) && this.names.get(e4).clear();
      }, t3.clearRules = function(e4) {
        this.getTag().clearGroup(V(e4)), this.clearNames(e4);
      }, t3.clearTag = function() {
        this.tag = void 0;
      }, t3.toString = function() {
        return function(e4) {
          for (var t4 = e4.getTag(), n3 = t4.length, r3 = "", o3 = 0; o3 < n3; o3++) {
            var s3 = B(o3);
            if (void 0 !== s3) {
              var i3 = e4.names.get(s3), a3 = t4.getGroup(o3);
              if (i3 && a3 && i3.size) {
                var c3 = N + ".g" + o3 + '[id="' + s3 + '"]', u3 = "";
                void 0 !== i3 && i3.forEach(function(e5) {
                  e5.length > 0 && (u3 += e5 + ",");
                }), r3 += "" + a3 + c3 + '{content:"' + u3 + '"}/*!sc*/\n';
              }
            }
          }
          return r3;
        }(this);
      }, e3;
    }();
    Z = /(a)(d)/gi;
    K = function(e3) {
      return String.fromCharCode(e3 + (e3 > 25 ? 39 : 97));
    };
    ee = function(e3, t3) {
      for (var n3 = t3.length; n3; )
        e3 = 33 * e3 ^ t3.charCodeAt(--n3);
      return e3;
    };
    te = function(e3) {
      return ee(5381, e3);
    };
    re = te("5.3.11");
    oe = function() {
      function e3(e4, t3, n3) {
        this.rules = e4, this.staticRulesId = "", this.isStatic = false, this.componentId = t3, this.baseHash = ee(re, t3), this.baseStyle = n3, X.registerId(t3);
      }
      return e3.prototype.generateAndInjectStyles = function(e4, t3, n3) {
        var r3 = this.componentId, o3 = [];
        if (this.baseStyle && o3.push(this.baseStyle.generateAndInjectStyles(e4, t3, n3)), this.isStatic && !n3.hash)
          if (this.staticRulesId && t3.hasNameForId(r3, this.staticRulesId))
            o3.push(this.staticRulesId);
          else {
            var s3 = _e(this.rules, e4, t3, n3).join(""), i3 = Q(ee(this.baseHash, s3) >>> 0);
            if (!t3.hasNameForId(r3, i3)) {
              var a3 = n3(s3, "." + i3, void 0, r3);
              t3.insertRules(r3, i3, a3);
            }
            o3.push(i3), this.staticRulesId = i3;
          }
        else {
          for (var c3 = this.rules.length, u3 = ee(this.baseHash, n3.hash), l3 = "", d3 = 0; d3 < c3; d3++) {
            var h2 = this.rules[d3];
            if ("string" == typeof h2)
              l3 += h2, u3 = ee(u3, h2 + d3);
            else if (h2) {
              var p2 = _e(h2, e4, t3, n3), f2 = Array.isArray(p2) ? p2.join("") : p2;
              u3 = ee(u3, f2 + d3), l3 += f2;
            }
          }
          if (l3) {
            var m3 = Q(u3 >>> 0);
            if (!t3.hasNameForId(r3, m3)) {
              var y3 = n3(l3, "." + m3, void 0, r3);
              t3.insertRules(r3, m3, y3);
            }
            o3.push(m3);
          }
        }
        return o3.join(" ");
      }, e3;
    }();
    se = /^\s*\/\/.*$/gm;
    ie = [":", "[", ".", "#"];
    ce = import_react.default.createContext();
    ue = ce.Consumer;
    le = import_react.default.createContext();
    de = (le.Consumer, new X());
    he = ae();
    ye = function() {
      function e3(e4, t3) {
        var n3 = this;
        this.inject = function(e5, t4) {
          void 0 === t4 && (t4 = he);
          var r3 = n3.name + t4.hash;
          e5.hasNameForId(n3.id, r3) || e5.insertRules(n3.id, r3, t4(n3.rules, r3, "@keyframes"));
        }, this.toString = function() {
          return D(12, String(n3.name));
        }, this.name = e4, this.id = "sc-keyframes-" + e4, this.rules = t3;
      }
      return e3.prototype.getName = function(e4) {
        return void 0 === e4 && (e4 = he), this.name + e4.hash;
      }, e3;
    }();
    ve = /([A-Z])/;
    ge = /([A-Z])/g;
    Se = /^ms-/;
    we = function(e3) {
      return "-" + e3.toLowerCase();
    };
    be = function(e3) {
      return null == e3 || false === e3 || "" === e3;
    };
    Ne = function(e3) {
      return Array.isArray(e3) && (e3.isCss = true), e3;
    };
    Ce = /invalid hook call/i;
    Ie = /* @__PURE__ */ new Set();
    Pe = function(e3, t3) {
      if (true) {
        var n3 = "The component " + e3 + (t3 ? ' with the id of "' + t3 + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", r3 = console.error;
        try {
          var o3 = true;
          console.error = function(e4) {
            if (Ce.test(e4))
              o3 = false, Ie.delete(n3);
            else {
              for (var t4 = arguments.length, s3 = new Array(t4 > 1 ? t4 - 1 : 0), i3 = 1; i3 < t4; i3++)
                s3[i3 - 1] = arguments[i3];
              r3.apply(void 0, [e4].concat(s3));
            }
          }, (0, import_react.useRef)(), o3 && !Ie.has(n3) && (console.warn(n3), Ie.add(n3));
        } catch (e4) {
          Ce.test(e4.message) && Ie.delete(n3);
        } finally {
          console.error = r3;
        }
      }
    };
    Oe = function(e3, t3, n3) {
      return void 0 === n3 && (n3 = w), e3.theme !== n3.theme && e3.theme || t3 || n3.theme;
    };
    Re = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
    De = /(^-|-$)/g;
    Te = function(e3) {
      return Q(te(e3) >>> 0);
    };
    ke = function(e3) {
      return "function" == typeof e3 || "object" == typeof e3 && null !== e3 && !Array.isArray(e3);
    };
    Ve = function(e3) {
      return "__proto__" !== e3 && "constructor" !== e3 && "prototype" !== e3;
    };
    Me = import_react.default.createContext();
    Ge = Me.Consumer;
    Fe = {};
    qe = function(e3) {
      return function e4(t3, r3, o3) {
        if (void 0 === o3 && (o3 = w), !(0, import_react_is.isValidElementType)(r3))
          return D(1, String(r3));
        var s3 = function() {
          return t3(r3, o3, Ae.apply(void 0, arguments));
        };
        return s3.withConfig = function(n3) {
          return e4(t3, r3, y({}, o3, {}, n3));
        }, s3.attrs = function(n3) {
          return e4(t3, r3, y({}, o3, { attrs: Array.prototype.concat(o3.attrs, n3).filter(Boolean) }));
        }, s3;
      }(Ye, e3);
    };
    ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e3) {
      qe[e3] = qe(e3);
    });
    He = function() {
      function e3(e4, t4) {
        this.rules = e4, this.componentId = t4, this.isStatic = ne(e4), X.registerId(this.componentId + 1);
      }
      var t3 = e3.prototype;
      return t3.createStyles = function(e4, t4, n3, r3) {
        var o3 = r3(_e(this.rules, t4, n3, r3).join(""), ""), s3 = this.componentId + e4;
        n3.insertRules(s3, s3, o3);
      }, t3.removeStyles = function(e4, t4) {
        t4.clearRules(this.componentId + e4);
      }, t3.renderStyles = function(e4, t4, n3, r3) {
        e4 > 2 && X.registerId(this.componentId + e4), this.removeStyles(e4, n3), this.createStyles(e4, t4, n3, r3);
      }, e3;
    }();
    Ue = function() {
      function e3() {
        var e4 = this;
        this._emitSheetCSS = function() {
          var t4 = e4.instance.toString();
          if (!t4)
            return "";
          var n3 = Y();
          return "<style " + [n3 && 'nonce="' + n3 + '"', N + '="true"', 'data-styled-version="5.3.11"'].filter(Boolean).join(" ") + ">" + t4 + "</style>";
        }, this.getStyleTags = function() {
          return e4.sealed ? D(2) : e4._emitSheetCSS();
        }, this.getStyleElement = function() {
          var t4;
          if (e4.sealed)
            return D(2);
          var n3 = ((t4 = {})[N] = "", t4["data-styled-version"] = "5.3.11", t4.dangerouslySetInnerHTML = { __html: e4.instance.toString() }, t4), o3 = Y();
          return o3 && (n3.nonce = o3), [import_react.default.createElement("style", y({}, n3, { key: "sc-0-0" }))];
        }, this.seal = function() {
          e4.sealed = true;
        }, this.instance = new X({ isServer: true }), this.sealed = false;
      }
      var t3 = e3.prototype;
      return t3.collectStyles = function(e4) {
        return this.sealed ? D(2) : import_react.default.createElement(me, { sheet: this.instance }, e4);
      }, t3.interleaveWithNodeStream = function(e4) {
        return D(3);
      }, e3;
    }();
    Je = function(e3) {
      var t3 = import_react.default.forwardRef(function(t4, n3) {
        var o3 = (0, import_react.useContext)(Me), i3 = e3.defaultProps, a3 = Oe(t4, o3, i3);
        return void 0 === a3 && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "' + b(e3) + '"'), import_react.default.createElement(e3, y({}, t4, { theme: a3, ref: n3 }));
      });
      return (0, import_hoist_non_react_statics.default)(t3, e3), t3.displayName = "WithTheme(" + b(e3) + ")", t3;
    };
    Xe = function() {
      return (0, import_react.useContext)(Me);
    };
    Ze = { StyleSheet: X, masterSheet: de };
    "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), "undefined" != typeof window && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 1 === window["__styled-components-init__"] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1);
    styled_components_browser_esm_default = qe;
  }
});

// node_modules/react-doc-viewer/build/state/actions.js
var require_actions = __commonJS({
  "node_modules/react-doc-viewer/build/state/actions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setMainConfig = exports2.SET_MAIN_CONFIG = exports2.setRendererRect = exports2.SET_RENDERER_RECT = exports2.updateCurrentDocument = exports2.UPDATE_CURRENT_DOCUMENT = exports2.previousDocument = exports2.PREVIOUS_DOCUMENT = exports2.nextDocument = exports2.NEXT_DOCUMENT = exports2.setDocumentLoading = exports2.SET_DOCUMENT_LOADING = exports2.setAllDocuments = exports2.SET_ALL_DOCUMENTS = void 0;
    exports2.SET_ALL_DOCUMENTS = "SET_ALL_DOCUMENTS";
    exports2.setAllDocuments = function(documents) {
      return {
        type: exports2.SET_ALL_DOCUMENTS,
        documents
      };
    };
    exports2.SET_DOCUMENT_LOADING = "SET_DOCUMENT_LOADING";
    exports2.setDocumentLoading = function(value) {
      return {
        type: exports2.SET_DOCUMENT_LOADING,
        value
      };
    };
    exports2.NEXT_DOCUMENT = "NEXT_DOCUMENT";
    exports2.nextDocument = function() {
      return { type: exports2.NEXT_DOCUMENT };
    };
    exports2.PREVIOUS_DOCUMENT = "PREVIOUS_DOCUMENT";
    exports2.previousDocument = function() {
      return {
        type: exports2.PREVIOUS_DOCUMENT
      };
    };
    exports2.UPDATE_CURRENT_DOCUMENT = "UPDATE_CURRENT_DOCUMENT";
    exports2.updateCurrentDocument = function(document2) {
      return { type: exports2.UPDATE_CURRENT_DOCUMENT, document: document2 };
    };
    exports2.SET_RENDERER_RECT = "SET_RENDERER_RECT";
    exports2.setRendererRect = function(rect) {
      return {
        type: exports2.SET_RENDERER_RECT,
        rect
      };
    };
    exports2.SET_MAIN_CONFIG = "SET_MAIN_CONFIG";
    exports2.setMainConfig = function(config) {
      return {
        type: exports2.SET_MAIN_CONFIG,
        config
      };
    };
  }
});

// node_modules/react-doc-viewer/build/state/reducer.js
var require_reducer = __commonJS({
  "node_modules/react-doc-viewer/build/state/reducer.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mainStateReducer = exports2.initialState = void 0;
    var actions_1 = require_actions();
    exports2.initialState = {
      currentFileNo: 0,
      documents: [],
      documentLoading: true,
      currentDocument: void 0,
      rendererRect: void 0,
      config: {},
      pluginRenderers: []
    };
    exports2.mainStateReducer = function(state, action) {
      if (state === void 0) {
        state = exports2.initialState;
      }
      switch (action.type) {
        case actions_1.SET_ALL_DOCUMENTS: {
          var documents = action.documents;
          return __assign(__assign({}, state), { documents, currentDocument: documents[0] || null });
        }
        case actions_1.SET_DOCUMENT_LOADING: {
          var value = action.value;
          return __assign(__assign({}, state), { documentLoading: value });
        }
        case actions_1.NEXT_DOCUMENT: {
          if (state.currentFileNo >= state.documents.length - 1)
            return state;
          var nextDocumentNo = state.currentFileNo + 1;
          return __assign(__assign({}, state), { currentFileNo: nextDocumentNo, currentDocument: state.documents[nextDocumentNo], documentLoading: true });
        }
        case actions_1.PREVIOUS_DOCUMENT: {
          if (state.currentFileNo <= 0)
            return state;
          var prevDocumentNo = state.currentFileNo - 1;
          return __assign(__assign({}, state), { currentFileNo: state.currentFileNo - 1, currentDocument: state.documents[prevDocumentNo], documentLoading: true });
        }
        case actions_1.UPDATE_CURRENT_DOCUMENT: {
          var document_1 = action.document;
          return __assign(__assign({}, state), { currentDocument: document_1 });
        }
        case actions_1.SET_RENDERER_RECT: {
          var rect = action.rect;
          return __assign(__assign({}, state), { rendererRect: rect });
        }
        case actions_1.SET_MAIN_CONFIG: {
          var config = action.config;
          return __assign(__assign({}, state), { config });
        }
        default:
          return state;
      }
    };
  }
});

// node_modules/react-doc-viewer/build/state/index.js
var require_state = __commonJS({
  "node_modules/react-doc-viewer/build/state/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AppProvider = exports2.DocViewerContext = void 0;
    var react_1 = __importStar(require_react());
    var actions_1 = require_actions();
    var reducer_1 = require_reducer();
    var DocViewerContext = react_1.createContext({ state: reducer_1.initialState, dispatch: function() {
      return null;
    } });
    exports2.DocViewerContext = DocViewerContext;
    var AppProvider = function(props) {
      var children = props.children, documents = props.documents, config = props.config, pluginRenderers = props.pluginRenderers;
      var _a3 = react_1.useReducer(reducer_1.mainStateReducer, __assign(__assign({}, reducer_1.initialState), {
        documents: documents || [],
        currentDocument: documents && documents.length ? documents[0] : void 0,
        config,
        pluginRenderers
      })), state = _a3[0], dispatch = _a3[1];
      react_1.useEffect(function() {
        dispatch(actions_1.setAllDocuments(documents));
        config && dispatch(actions_1.setMainConfig(config));
      }, [documents]);
      return react_1.default.createElement(DocViewerContext.Provider, { value: { state, dispatch } }, children);
    };
    exports2.AppProvider = AppProvider;
  }
});

// node_modules/react-doc-viewer/build/components/common/Button.js
var require_Button = __commonJS({
  "node_modules/react-doc-viewer/build/components/common/Button.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ButtonSecondary = exports2.ButtonPrimary = exports2.LinkButton = exports2.Button = exports2.ButtonSecondaryStyle = exports2.ButtonPrimaryStyle = void 0;
    var styled_components_1 = __importStar((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    exports2.ButtonPrimaryStyle = styled_components_1.css(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  background-color: ", ";\n  color: ", ";\n"], ["\n  background-color: ", ";\n  color: ", ";\n"])), function(props) {
      return props.theme.primary;
    }, function(props) {
      return props.theme.text_primary;
    });
    exports2.ButtonSecondaryStyle = styled_components_1.css(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  background-color: ", ";\n  color: ", ";\n"], ["\n  background-color: ", ";\n  color: ", ";\n"])), function(props) {
      return props.theme.secondary;
    }, function(props) {
      return props.theme.text_secondary;
    });
    exports2.Button = styled_components_1.default.button(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  ", "\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 35px;\n  height: 35px;\n  padding: 0;\n  margin: 0 0 0 5px;\n  text-align: center;\n  font-size: 18px;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n  text-decoration: none;\n  border-radius: 35px;\n  opacity: ", ";\n  pointer-events: ", ";\n  box-shadow: 2px 2px 3px #00000033;\n\n  @media (max-width: 768px) {\n    width: 30px;\n    height: 30px;\n    font-size: 15px;\n  }\n"], ["\n  ", "\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 35px;\n  height: 35px;\n  padding: 0;\n  margin: 0 0 0 5px;\n  text-align: center;\n  font-size: 18px;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n  text-decoration: none;\n  border-radius: 35px;\n  opacity: ", ";\n  pointer-events: ", ";\n  box-shadow: 2px 2px 3px #00000033;\n\n  @media (max-width: 768px) {\n    width: 30px;\n    height: 30px;\n    font-size: 15px;\n  }\n"])), exports2.ButtonPrimaryStyle, function(props) {
      return props.disabled ? 0.4 : 1;
    }, function(props) {
      return props.disabled ? "none" : "all";
    });
    exports2.LinkButton = styled_components_1.default.a(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n  text-decoration: none;\n  border-radius: 35px;\n  background-color: ", ";\n  color: ", ";\n  box-shadow: 2px 2px 3px #00000033;\n\n  width: 35px;\n  height: 35px;\n  font-size: 18px;\n  @media (max-width: 768px) {\n    width: 30px;\n    height: 30px;\n    font-size: 15px;\n  }\n"], ["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n  text-decoration: none;\n  border-radius: 35px;\n  background-color: ", ";\n  color: ", ";\n  box-shadow: 2px 2px 3px #00000033;\n\n  width: 35px;\n  height: 35px;\n  font-size: 18px;\n  @media (max-width: 768px) {\n    width: 30px;\n    height: 30px;\n    font-size: 15px;\n  }\n"])), function(props) {
      return props.theme.primary;
    }, function(props) {
      return props.theme.text_primary;
    });
    exports2.ButtonPrimary = styled_components_1.default(exports2.Button)(templateObject_5 || (templateObject_5 = __makeTemplateObject([""], [""])));
    exports2.ButtonSecondary = styled_components_1.default(exports2.Button)(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), exports2.ButtonSecondaryStyle);
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
    var templateObject_5;
    var templateObject_6;
  }
});

// node_modules/react-doc-viewer/build/components/icons/index.js
var require_icons = __commonJS({
  "node_modules/react-doc-viewer/build/components/icons/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LoadingIcon = exports2.NextDocIcon = exports2.PrevDocIcon = void 0;
    var react_1 = __importDefault(require_react());
    exports2.PrevDocIcon = function(props) {
      return react_1.default.createElement(DocNavIcon, __assign({}, props));
    };
    exports2.NextDocIcon = function(props) {
      return react_1.default.createElement(DocNavIcon, __assign({}, props, { reverse: true }));
    };
    var DocNavIcon = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", style: { transform: reverse ? "rotate(180deg)" : "" }, id: "arrow_left", version: "1.1", viewBox: "0 0 32 32", xmlSpace: "preserve" },
        react_1.default.createElement("path", { clipRule: "evenodd", d: "M31.106,15H3.278l8.325-8.293  c0.391-0.391,0.391-1.024,0-1.414c-0.391-0.391-1.024-0.391-1.414,0l-9.9,9.899c-0.385,0.385-0.385,1.029,0,1.414l9.9,9.9  c0.391,0.391,1.024,0.391,1.414,0c0.391-0.391,0.391-1.024,0-1.414L3.278,17h27.828c0.552,0,1-0.448,1-1  C32.106,15.448,31.658,15,31.106,15z", fill: color || "#aaa", fillRule: "evenodd", id: "Arrow_Back" })
      );
    };
    exports2.LoadingIcon = function(props) {
      var color = props.color, size = props.size;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", version: "1.1", id: "Icons", viewBox: "0 0 32 32", xmlSpace: "preserve", style: { alignSelf: "center", justifySelf: "center" } },
        react_1.default.createElement(
          "g",
          null,
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M16,2c-0.6,0-1,0.4-1,1v5c0,0.6,0.4,1,1,1s1-0.4,1-1V3C17,2.4,16.6,2,16,2z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M7.5,6.1c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l3.5,3.5c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.5,6.1\n		z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M9,16c0-0.6-0.4-1-1-1H3c-0.6,0-1,0.4-1,1s0.4,1,1,1h5C8.6,17,9,16.6,9,16z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M9.6,20.9l-3.5,3.5c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l3.5-3.5c0.4-0.4,0.4-1,0-1.4\n		S10,20.6,9.6,20.9z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M16,23c-0.6,0-1,0.4-1,1v5c0,0.6,0.4,1,1,1s1-0.4,1-1v-5C17,23.4,16.6,23,16,23z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M22.4,20.9c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l3.5,3.5c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4\n		L22.4,20.9z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M29,15h-5c-0.6,0-1,0.4-1,1s0.4,1,1,1h5c0.6,0,1-0.4,1-1S29.6,15,29,15z" }),
          react_1.default.createElement("path", { fill: color || "#aaa", d: "M21.7,11.3c0.3,0,0.5-0.1,0.7-0.3l3.5-3.5c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-3.5,3.5c-0.4,0.4-0.4,1,0,1.4\n		C21.1,11.2,21.4,11.3,21.7,11.3z" })
        )
      );
    };
  }
});

// node_modules/react-doc-viewer/build/components/DocumentNav.js
var require_DocumentNav = __commonJS({
  "node_modules/react-doc-viewer/build/components/DocumentNav.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentNav = void 0;
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state();
    var actions_1 = require_actions();
    var Button_1 = require_Button();
    var icons_1 = require_icons();
    exports2.DocumentNav = function() {
      var _a3 = react_1.useContext(state_1.DocViewerContext), _b2 = _a3.state, currentDocument = _b2.currentDocument, currentFileNo = _b2.currentFileNo, documents = _b2.documents, dispatch = _a3.dispatch;
      if (documents.length <= 1 || !currentDocument)
        return null;
      var fileName = currentDocument.uri;
      var splitURL = fileName.split("/");
      if (splitURL.length) {
        fileName = splitURL[splitURL.length - 1];
      }
      return react_1.default.createElement(
        Container,
        { id: "doc-nav" },
        react_1.default.createElement(
          "p",
          { id: "doc-nav-info" },
          "Doc ",
          currentFileNo + 1,
          " of ",
          documents.length
        ),
        react_1.default.createElement(
          ButtonPrev,
          { id: "doc-nav-prev", onClick: function() {
            return dispatch(actions_1.previousDocument());
          }, disabled: currentFileNo === 0 },
          react_1.default.createElement(icons_1.PrevDocIcon, { color: "#fff", size: "60%" })
        ),
        react_1.default.createElement(
          ButtonNext,
          { id: "doc-nav-next", onClick: function() {
            return dispatch(actions_1.nextDocument());
          }, disabled: currentFileNo >= documents.length - 1 },
          react_1.default.createElement(icons_1.NextDocIcon, { color: "#fff", size: "60%" })
        )
      );
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  min-width: 150px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  margin: 0 10px;\n  color: ", ";\n"], ["\n  min-width: 150px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  margin: 0 10px;\n  color: ", ";\n"])), function(props) {
      return props.theme.text_primary;
    });
    var ButtonPrev = styled_components_1.default(Button_1.ButtonSecondary)(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  margin: 0 5px 0 10px;\n\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"], ["\n  width: 30px;\n  height: 30px;\n  margin: 0 5px 0 10px;\n\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"])));
    var ButtonNext = styled_components_1.default(ButtonPrev)(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  margin: 0 5px;\n"], ["\n  margin: 0 5px;\n"])));
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
  }
});

// node_modules/react-doc-viewer/build/components/FileName.js
var require_FileName = __commonJS({
  "node_modules/react-doc-viewer/build/components/FileName.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileName = void 0;
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state();
    exports2.FileName = function() {
      var _a3, _b2;
      var _c2 = react_1.useContext(state_1.DocViewerContext).state, config = _c2.config, currentDocument = _c2.currentDocument;
      if (!currentDocument || ((_a3 = config === null || config === void 0 ? void 0 : config.header) === null || _a3 === void 0 ? void 0 : _a3.disableFileName))
        return null;
      var fileName = currentDocument.uri || "";
      fileName = decodeURI(fileName);
      if (!((_b2 = config === null || config === void 0 ? void 0 : config.header) === null || _b2 === void 0 ? void 0 : _b2.retainURLParams)) {
        fileName = fileName.split("?")[0];
      }
      var splitURL = fileName.split("/");
      if (splitURL.length) {
        fileName = splitURL[splitURL.length - 1];
      }
      return react_1.default.createElement(Container, { id: "file-name", "data-testid": "file-name" }, fileName);
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  flex: 1;\n  text-align: left;\n  color: ", ";\n  font-weight: bold;\n  margin: 0 10px;\n  overflow: hidden;\n"], ["\n  flex: 1;\n  text-align: left;\n  color: ", ";\n  font-weight: bold;\n  margin: 0 10px;\n  overflow: hidden;\n"])), function(props) {
      return props.theme.text_primary;
    });
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/components/HeaderBar.js
var require_HeaderBar = __commonJS({
  "node_modules/react-doc-viewer/build/components/HeaderBar.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HeaderBar = void 0;
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state();
    var actions_1 = require_actions();
    var DocumentNav_1 = require_DocumentNav();
    var FileName_1 = require_FileName();
    exports2.HeaderBar = function() {
      var _a3, _b2, _c2;
      var _d2 = react_1.useContext(state_1.DocViewerContext), state = _d2.state, dispatch = _d2.dispatch;
      var config = state.config;
      if ((_a3 = config === null || config === void 0 ? void 0 : config.header) === null || _a3 === void 0 ? void 0 : _a3.disableHeader)
        return null;
      var override = (_c2 = (_b2 = config === null || config === void 0 ? void 0 : config.header) === null || _b2 === void 0 ? void 0 : _b2.overrideComponent) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, state, function() {
        return dispatch(actions_1.previousDocument());
      }, function() {
        return dispatch(actions_1.nextDocument());
      });
      if (override) {
        return override;
      } else {
        return react_1.default.createElement(
          Container,
          { id: "header-bar", "data-testid": "header-bar" },
          react_1.default.createElement(FileName_1.FileName, null),
          react_1.default.createElement(DocumentNav_1.DocumentNav, null)
        );
      }
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n  z-index: 1;\n  padding: 0 10px;\n  background-color: ", ";\n  font-size: 16px;\n  min-height: 50px;\n\n  @media (max-width: 768px) {\n    min-height: 30px;\n    padding: 5px;\n    font-size: 10px;\n  }\n"], ["\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n  z-index: 1;\n  padding: 0 10px;\n  background-color: ", ";\n  font-size: 16px;\n  min-height: 50px;\n\n  @media (max-width: 768px) {\n    min-height: 30px;\n    padding: 5px;\n    font-size: 10px;\n  }\n"])), function(props) {
      return props.theme.primary;
    });
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/utils/fileLoaders.js
var require_fileLoaders = __commonJS({
  "node_modules/react-doc-viewer/build/utils/fileLoaders.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _3 = { label: 0, sent: function() {
        if (t3[0] & 1)
          throw t3[1];
        return t3[1];
      }, trys: [], ops: [] }, f2, y3, t3, g3;
      return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n3) {
        return function(v3) {
          return step([n3, v3]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_3)
          try {
            if (f2 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
              return t3;
            if (y3 = 0, t3)
              op = [op[0] & 2, t3.value];
            switch (op[0]) {
              case 0:
              case 1:
                t3 = op;
                break;
              case 4:
                _3.label++;
                return { value: op[1], done: false };
              case 5:
                _3.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _3.ops.pop();
                _3.trys.pop();
                continue;
              default:
                if (!(t3 = _3.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _3 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                  _3.label = op[1];
                  break;
                }
                if (op[0] === 6 && _3.label < t3[1]) {
                  _3.label = t3[1];
                  t3 = op;
                  break;
                }
                if (t3 && _3.label < t3[2]) {
                  _3.label = t3[2];
                  _3.ops.push(op);
                  break;
                }
                if (t3[2])
                  _3.ops.pop();
                _3.trys.pop();
                continue;
            }
            op = body.call(thisArg, _3);
          } catch (e3) {
            op = [6, e3];
            y3 = 0;
          } finally {
            f2 = t3 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultFileLoader = exports2.binaryStringFileLoader = exports2.textFileLoader = exports2.dataURLFileLoader = exports2.arrayBufferFileLoader = void 0;
    var _fileLoader = function(_a3) {
      var documentURI = _a3.documentURI, signal = _a3.signal, fileLoaderComplete = _a3.fileLoaderComplete, readerTypeFunction = _a3.readerTypeFunction;
      return fetch(documentURI, { signal }).then(function(res) {
        return __awaiter(void 0, void 0, void 0, function() {
          var blob, fileReader;
          return __generator(this, function(_a4) {
            switch (_a4.label) {
              case 0:
                return [4, res.blob()];
              case 1:
                blob = _a4.sent();
                fileReader = new FileReader();
                fileReader.addEventListener("loadend", function() {
                  return fileLoaderComplete(fileReader);
                });
                switch (readerTypeFunction) {
                  case "arrayBuffer":
                    fileReader.readAsArrayBuffer(blob);
                    break;
                  case "binaryString":
                    fileReader.readAsBinaryString(blob);
                    break;
                  case "dataURL":
                    fileReader.readAsDataURL(blob);
                    break;
                  case "text":
                    fileReader.readAsText(blob);
                    break;
                  default:
                    break;
                }
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }).catch(function(e3) {
        return e3;
      });
    };
    exports2.arrayBufferFileLoader = function(props) {
      return _fileLoader(__assign(__assign({}, props), { readerTypeFunction: "arrayBuffer" }));
    };
    exports2.dataURLFileLoader = function(props) {
      return _fileLoader(__assign(__assign({}, props), { readerTypeFunction: "dataURL" }));
    };
    exports2.textFileLoader = function(props) {
      return _fileLoader(__assign(__assign({}, props), { readerTypeFunction: "text" }));
    };
    exports2.binaryStringFileLoader = function(props) {
      return _fileLoader(__assign(__assign({}, props), { readerTypeFunction: "binaryString" }));
    };
    exports2.defaultFileLoader = exports2.dataURLFileLoader;
  }
});

// node_modules/react-doc-viewer/build/utils/useRendererSelector.js
var require_useRendererSelector = __commonJS({
  "node_modules/react-doc-viewer/build/utils/useRendererSelector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useRendererSelector = void 0;
    var react_1 = require_react();
    var state_1 = require_state();
    exports2.useRendererSelector = function() {
      var _a3 = react_1.useContext(state_1.DocViewerContext).state, currentDocument = _a3.currentDocument, pluginRenderers = _a3.pluginRenderers;
      var _b2 = react_1.useState(), CurrentRenderer = _b2[0], setCurrentRenderer = _b2[1];
      react_1.useEffect(function() {
        if (!currentDocument)
          return;
        if (!currentDocument.fileType) {
          setCurrentRenderer(void 0);
          return;
        }
        var matchingRenderers = [];
        pluginRenderers === null || pluginRenderers === void 0 ? void 0 : pluginRenderers.map(function(r3) {
          if (currentDocument.fileType === void 0)
            return;
          if (r3.fileTypes.indexOf(currentDocument.fileType) >= 0) {
            matchingRenderers.push(r3);
          }
        });
        var SelectedRenderer = matchingRenderers.sort(function(a3, b3) {
          return b3.weight - a3.weight;
        })[0];
        if (SelectedRenderer && SelectedRenderer !== void 0) {
          setCurrentRenderer(function() {
            return SelectedRenderer;
          });
        } else {
          setCurrentRenderer(null);
        }
      }, [currentDocument]);
      return { CurrentRenderer };
    };
  }
});

// node_modules/react-doc-viewer/build/utils/useDocumentLoader.js
var require_useDocumentLoader = __commonJS({
  "node_modules/react-doc-viewer/build/utils/useDocumentLoader.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useDocumentLoader = void 0;
    var react_1 = require_react();
    var state_1 = require_state();
    var actions_1 = require_actions();
    var fileLoaders_1 = require_fileLoaders();
    var useRendererSelector_1 = require_useRendererSelector();
    exports2.useDocumentLoader = function() {
      var _a3 = react_1.useContext(state_1.DocViewerContext), state = _a3.state, dispatch = _a3.dispatch;
      var currentFileNo = state.currentFileNo, currentDocument = state.currentDocument;
      var CurrentRenderer = useRendererSelector_1.useRendererSelector().CurrentRenderer;
      var documentURI = (currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.uri) || "";
      react_1.useEffect(
        function() {
          if (!currentDocument)
            return;
          if (currentDocument.fileType !== void 0)
            return;
          var controller = new AbortController();
          var signal = controller.signal;
          fetch(documentURI, { method: "HEAD", signal }).then(function(response) {
            var contentTypeRaw = response.headers.get("content-type");
            var contentTypes = (contentTypeRaw === null || contentTypeRaw === void 0 ? void 0 : contentTypeRaw.split(";")) || [];
            var contentType = contentTypes.length ? contentTypes[0] : void 0;
            dispatch(actions_1.updateCurrentDocument(__assign(__assign({}, currentDocument), { fileType: contentType || void 0 })));
          });
          return function() {
            controller.abort();
          };
        },
        // eslint ignore added, because a warning appears for dispatch to
        // be a dependancy of the useEffect
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [currentFileNo, documentURI]
      );
      react_1.useEffect(function() {
        var _a4;
        if (!currentDocument || CurrentRenderer === void 0)
          return;
        var controller = new AbortController();
        var signal = controller.signal;
        var fileLoaderComplete = function(fileReader) {
          if (!currentDocument || !fileReader) {
            dispatch(actions_1.setDocumentLoading(false));
            return;
          }
          var updatedDocument = __assign({}, currentDocument);
          if (fileReader.result !== null) {
            updatedDocument.fileData = fileReader.result;
          }
          dispatch(actions_1.updateCurrentDocument(updatedDocument));
          dispatch(actions_1.setDocumentLoading(false));
        };
        if (CurrentRenderer === null) {
          dispatch(actions_1.setDocumentLoading(false));
        } else if (CurrentRenderer.fileLoader !== void 0) {
          (_a4 = CurrentRenderer.fileLoader) === null || _a4 === void 0 ? void 0 : _a4.call(CurrentRenderer, { documentURI, signal, fileLoaderComplete });
        } else {
          fileLoaders_1.defaultFileLoader({ documentURI, signal, fileLoaderComplete });
        }
        return function() {
          controller.abort();
        };
      }, [CurrentRenderer]);
      return { state, dispatch, CurrentRenderer };
    };
  }
});

// node_modules/react-doc-viewer/build/utils/useWindowSize.js
var require_useWindowSize = __commonJS({
  "node_modules/react-doc-viewer/build/utils/useWindowSize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useWindowSize = void 0;
    var react_1 = require_react();
    exports2.useWindowSize = function() {
      var _a3 = react_1.useState({
        width: void 0,
        height: void 0
      }), windowSize = _a3[0], setWindowSize = _a3[1];
      react_1.useEffect(function() {
        function handleResize() {
          setWindowSize({
            width: window.innerWidth,
            height: window.innerHeight
          });
        }
        window.addEventListener("resize", handleResize);
        handleResize();
        return function() {
          return window.removeEventListener("resize", handleResize);
        };
      }, []);
      return windowSize;
    };
  }
});

// node_modules/react-doc-viewer/build/components/common/index.js
var require_common = __commonJS({
  "node_modules/react-doc-viewer/build/components/common/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3)
        if (p2 !== "default" && !exports3.hasOwnProperty(p2))
          __createBinding(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Button(), exports2);
  }
});

// node_modules/react-doc-viewer/build/components/ProxyRenderer.js
var require_ProxyRenderer = __commonJS({
  "node_modules/react-doc-viewer/build/components/ProxyRenderer.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyRenderer = void 0;
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importStar((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var actions_1 = require_actions();
    var useDocumentLoader_1 = require_useDocumentLoader();
    var useWindowSize_1 = require_useWindowSize();
    var common_1 = require_common();
    var icons_1 = require_icons();
    exports2.ProxyRenderer = function() {
      var _a3 = useDocumentLoader_1.useDocumentLoader(), state = _a3.state, dispatch = _a3.dispatch, CurrentRenderer = _a3.CurrentRenderer;
      var documents = state.documents, documentLoading = state.documentLoading, currentDocument = state.currentDocument;
      var size = useWindowSize_1.useWindowSize();
      var containerRef = react_1.useCallback(
        function(node) {
          node && dispatch(actions_1.setRendererRect(node === null || node === void 0 ? void 0 : node.getBoundingClientRect()));
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [size]
      );
      var Contents = function() {
        if (!documents.length) {
          return react_1.default.createElement("div", { id: "no-documents" });
        } else if (documentLoading) {
          return react_1.default.createElement(
            LoadingContainer,
            { id: "loading-renderer", "data-testid": "loading-renderer" },
            react_1.default.createElement(
              LoadingIconContainer,
              null,
              react_1.default.createElement(icons_1.LoadingIcon, { color: "#444", size: 40 })
            )
          );
        } else {
          if (CurrentRenderer) {
            return react_1.default.createElement(CurrentRenderer, { mainState: state });
          } else if (CurrentRenderer === void 0) {
            return null;
          } else {
            return react_1.default.createElement(
              "div",
              { id: "no-renderer", "data-testid": "no-renderer" },
              "No Renderer for file type ",
              currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileType,
              react_1.default.createElement(DownloadButton, { id: "no-renderer-download", href: currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.uri, download: currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.uri }, "Download File")
            );
          }
        }
      };
      return react_1.default.createElement(
        Container,
        { id: "proxy-renderer", ref: containerRef },
        react_1.default.createElement(Contents, null)
      );
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex: 1;\n  overflow-y: auto;\n"], ["\n  display: flex;\n  flex: 1;\n  overflow-y: auto;\n"])));
    var LoadingContainer = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  display: flex;\n  flex: 1;\n  height: 75px;\n  align-items: center;\n  justify-content: center;\n"], ["\n  display: flex;\n  flex: 1;\n  height: 75px;\n  align-items: center;\n  justify-content: center;\n"])));
    var spinAnim = styled_components_1.keyframes(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"], ["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"])));
    var LoadingIconContainer = styled_components_1.default.div(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  animation-name: ", ";\n  animation-duration: 4s;\n  animation-timing-function: linear;\n  animation-iteration-count: infinite;\n"], ["\n  animation-name: ", ";\n  animation-duration: 4s;\n  animation-timing-function: linear;\n  animation-iteration-count: infinite;\n"])), spinAnim);
    var DownloadButton = styled_components_1.default(common_1.LinkButton)(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\n  width: 130px;\n  height: 30px;\n  background-color: ", ";\n  @media (max-width: 768px) {\n    width: 125px;\n    height: 25px;\n  }\n"], ["\n  width: 130px;\n  height: 30px;\n  background-color: ", ";\n  @media (max-width: 768px) {\n    width: 125px;\n    height: 25px;\n  }\n"])), function(props) {
      return props.theme.primary;
    });
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
    var templateObject_5;
  }
});

// node_modules/react-doc-viewer/build/plugins/image/index.js
var require_image = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/image/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var ImageProxyRenderer = function(props) {
      var currentDocument = props.mainState.currentDocument, children = props.children;
      if (!currentDocument)
        return null;
      return react_1.default.createElement(Container, __assign({ id: "image-renderer" }, props), children || react_1.default.createElement(Img, { id: "image-img", src: currentDocument.fileData }));
    };
    exports2.default = ImageProxyRenderer;
    ImageProxyRenderer.fileTypes = [];
    ImageProxyRenderer.weight = 0;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  background-color: #fff;\n"], ["\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  background-color: #fff;\n"])));
    var Img = styled_components_1.default.img(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  max-width: 95%;\n  max-height: 95%;\n"], ["\n  max-width: 95%;\n  max-height: 95%;\n"])));
    var templateObject_1;
    var templateObject_2;
  }
});

// node_modules/react-doc-viewer/build/plugins/bmp/index.js
var require_bmp = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/bmp/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var image_1 = __importDefault(require_image());
    var BMPRenderer = function(props) {
      return react_1.default.createElement(image_1.default, __assign({}, props));
    };
    BMPRenderer.fileTypes = ["bmp", "image/bmp"];
    BMPRenderer.weight = 0;
    exports2.default = BMPRenderer;
  }
});

// node_modules/react-doc-viewer/build/plugins/html/index.js
var require_html = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/html/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var fileLoaders_1 = require_fileLoaders();
    var HTMLRenderer = function(_a3) {
      var currentDocument = _a3.mainState.currentDocument;
      react_1.useEffect(function() {
        var b64String = currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData;
        var bodyBase64 = (b64String === null || b64String === void 0 ? void 0 : b64String.replace("data:text/html;base64,", "")) || "";
        var body = window.atob(bodyBase64);
        var iframeCont = document.getElementById("html-body");
        var iframe = (iframeCont === null || iframeCont === void 0 ? void 0 : iframeCont.contentWindow) && iframeCont.contentWindow;
        if (!iframe)
          return;
        var iframeDoc = iframe.document;
        iframeDoc.open();
        iframeDoc.write("" + body);
        iframeDoc.close();
      }, []);
      return react_1.default.createElement(
        Container,
        { id: "html-renderer" },
        react_1.default.createElement(BodyIFrame, { id: "html-body", sandbox: "allow-same-origin" })
      );
    };
    exports2.default = HTMLRenderer;
    HTMLRenderer.fileTypes = ["htm", "html", "text/htm", "text/html"];
    HTMLRenderer.weight = 0;
    HTMLRenderer.fileLoader = fileLoaders_1.dataURLFileLoader;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 0 30px;\n"], ["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 0 30px;\n"])));
    var BodyIFrame = styled_components_1.default.iframe(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  height: 100%;\n  padding: 15px;\n  margin: 20px 0 20px 0;\n  border: 1px solid ", ";\n"], ["\n  height: 100%;\n  padding: 15px;\n  margin: 20px 0 20px 0;\n  border: 1px solid ", ";\n"])), function(props) {
      return props.theme.secondary;
    });
    var templateObject_1;
    var templateObject_2;
  }
});

// node_modules/react-doc-viewer/build/plugins/jpg/index.js
var require_jpg = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/jpg/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var image_1 = __importDefault(require_image());
    var JPGRenderer = function(props) {
      return react_1.default.createElement(image_1.default, __assign({}, props));
    };
    JPGRenderer.fileTypes = ["jpg", "jpeg", "image/jpg", "image/jpeg"];
    JPGRenderer.weight = 0;
    exports2.default = JPGRenderer;
  }
});

// node_modules/react-doc-viewer/build/plugins/msdoc/index.js
var require_msdoc = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/msdoc/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {
      for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
        s3 += arguments[i3].length;
      for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
        for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
          r3[k3] = a3[j3];
      return r3;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var MSDocRenderer = function(_a3) {
      var currentDocument = _a3.mainState.currentDocument;
      if (!currentDocument)
        return null;
      return react_1.default.createElement(
        Container,
        { id: "msdoc-renderer" },
        react_1.default.createElement(IFrame, { id: "msdoc-iframe", title: "msdoc-iframe", src: "https://view.officeapps.live.com/op/embed.aspx?src=" + encodeURIComponent(currentDocument.uri), frameBorder: "0" })
      );
    };
    exports2.default = MSDocRenderer;
    var MSDocFTMaps = {
      doc: ["doc", "application/msword"],
      docx: [
        "docx",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
      ],
      xls: ["xls", "application/vnd.ms-excel"],
      xlsx: [
        "xlsx",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
      ],
      ppt: ["ppt", "application/vnd.ms-powerpoint"],
      pptx: [
        "pptx",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation"
      ]
    };
    MSDocRenderer.fileTypes = __spreadArrays(MSDocFTMaps.doc, MSDocFTMaps.docx, MSDocFTMaps.xls, MSDocFTMaps.xlsx, MSDocFTMaps.ppt, MSDocFTMaps.pptx);
    MSDocRenderer.weight = 0;
    MSDocRenderer.fileLoader = function(_a3) {
      var fileLoaderComplete = _a3.fileLoaderComplete;
      return fileLoaderComplete();
    };
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  width: 100%;\n"], ["\n  width: 100%;\n"])));
    var IFrame = styled_components_1.default.iframe(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: 100%;\n  height: 100%;\n  border: 0;\n"], ["\n  width: 100%;\n  height: 100%;\n  border: 0;\n"])));
    var templateObject_1;
    var templateObject_2;
  }
});

// node_modules/wl-msg-reader/lib/DataStream.js
var require_DataStream = __commonJS({
  "node_modules/wl-msg-reader/lib/DataStream.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports2 === "object") {
        module2.exports = factory();
      } else {
        root.DataStream = factory();
      }
    })(exports2, function() {
      var DataStream = function(arrayBuffer, byteOffset, endianness) {
        this._byteOffset = byteOffset || 0;
        if (arrayBuffer instanceof ArrayBuffer) {
          this.buffer = arrayBuffer;
        } else if (typeof arrayBuffer == "object") {
          this.dataView = arrayBuffer;
          if (byteOffset) {
            this._byteOffset += byteOffset;
          }
        } else {
          this.buffer = new ArrayBuffer(arrayBuffer || 1);
        }
        this.position = 0;
        this.endianness = endianness == null ? DataStream.LITTLE_ENDIAN : endianness;
      };
      DataStream.prototype = {};
      if (Uint8Array.prototype.BYTES_PER_ELEMENT === void 0) {
        Uint8Array.prototype.BYTES_PER_ELEMENT = Uint8Array.BYTES_PER_ELEMENT;
        Int8Array.prototype.BYTES_PER_ELEMENT = Int8Array.BYTES_PER_ELEMENT;
        Uint8ClampedArray.prototype.BYTES_PER_ELEMENT = Uint8ClampedArray.BYTES_PER_ELEMENT;
        Uint16Array.prototype.BYTES_PER_ELEMENT = Uint16Array.BYTES_PER_ELEMENT;
        Int16Array.prototype.BYTES_PER_ELEMENT = Int16Array.BYTES_PER_ELEMENT;
        Uint32Array.prototype.BYTES_PER_ELEMENT = Uint32Array.BYTES_PER_ELEMENT;
        Int32Array.prototype.BYTES_PER_ELEMENT = Int32Array.BYTES_PER_ELEMENT;
        Float64Array.prototype.BYTES_PER_ELEMENT = Float64Array.BYTES_PER_ELEMENT;
      }
      DataStream.prototype.save = function(filename) {
        var blob = new Blob(this.buffer);
        var URL2 = window.webkitURL || window.URL;
        if (URL2 && URL2.createObjectURL) {
          var url = URL2.createObjectURL(blob);
          var a3 = document.createElement("a");
          a3.setAttribute("href", url);
          a3.setAttribute("download", filename);
          a3.click();
          URL2.revokeObjectURL(url);
        } else {
          throw "DataStream.save: Can't create object URL.";
        }
      };
      DataStream.BIG_ENDIAN = false;
      DataStream.LITTLE_ENDIAN = true;
      DataStream.prototype._dynamicSize = true;
      Object.defineProperty(
        DataStream.prototype,
        "dynamicSize",
        {
          get: function() {
            return this._dynamicSize;
          },
          set: function(v3) {
            if (!v3) {
              this._trimAlloc();
            }
            this._dynamicSize = v3;
          }
        }
      );
      DataStream.prototype._byteLength = 0;
      Object.defineProperty(
        DataStream.prototype,
        "byteLength",
        {
          get: function() {
            return this._byteLength - this._byteOffset;
          }
        }
      );
      Object.defineProperty(
        DataStream.prototype,
        "buffer",
        {
          get: function() {
            this._trimAlloc();
            return this._buffer;
          },
          set: function(v3) {
            this._buffer = v3;
            this._dataView = new DataView(this._buffer, this._byteOffset);
            this._byteLength = this._buffer.byteLength;
          }
        }
      );
      Object.defineProperty(
        DataStream.prototype,
        "byteOffset",
        {
          get: function() {
            return this._byteOffset;
          },
          set: function(v3) {
            this._byteOffset = v3;
            this._dataView = new DataView(this._buffer, this._byteOffset);
            this._byteLength = this._buffer.byteLength;
          }
        }
      );
      Object.defineProperty(
        DataStream.prototype,
        "dataView",
        {
          get: function() {
            return this._dataView;
          },
          set: function(v3) {
            this._byteOffset = v3.byteOffset;
            this._buffer = v3.buffer;
            this._dataView = new DataView(this._buffer, this._byteOffset);
            this._byteLength = this._byteOffset + v3.byteLength;
          }
        }
      );
      DataStream.prototype._realloc = function(extra) {
        if (!this._dynamicSize) {
          return;
        }
        var req = this._byteOffset + this.position + extra;
        var blen = this._buffer.byteLength;
        if (req <= blen) {
          if (req > this._byteLength) {
            this._byteLength = req;
          }
          return;
        }
        if (blen < 1) {
          blen = 1;
        }
        while (req > blen) {
          blen *= 2;
        }
        var buf = new ArrayBuffer(blen);
        var src = new Uint8Array(this._buffer);
        var dst = new Uint8Array(buf, 0, src.length);
        dst.set(src);
        this.buffer = buf;
        this._byteLength = req;
      };
      DataStream.prototype._trimAlloc = function() {
        if (this._byteLength == this._buffer.byteLength) {
          return;
        }
        var buf = new ArrayBuffer(this._byteLength);
        var dst = new Uint8Array(buf);
        var src = new Uint8Array(this._buffer, 0, dst.length);
        dst.set(src);
        this.buffer = buf;
      };
      DataStream.prototype.seek = function(pos) {
        var npos = Math.max(0, Math.min(this.byteLength, pos));
        this.position = isNaN(npos) || !isFinite(npos) ? 0 : npos;
      };
      DataStream.prototype.isEof = function() {
        return this.position >= this.byteLength;
      };
      DataStream.prototype.mapInt32Array = function(length, e3) {
        this._realloc(length * 4);
        var arr = new Int32Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += length * 4;
        return arr;
      };
      DataStream.prototype.mapInt16Array = function(length, e3) {
        this._realloc(length * 2);
        var arr = new Int16Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += length * 2;
        return arr;
      };
      DataStream.prototype.mapInt8Array = function(length) {
        this._realloc(length * 1);
        var arr = new Int8Array(this._buffer, this.byteOffset + this.position, length);
        this.position += length * 1;
        return arr;
      };
      DataStream.prototype.mapUint32Array = function(length, e3) {
        this._realloc(length * 4);
        var arr = new Uint32Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += length * 4;
        return arr;
      };
      DataStream.prototype.mapUint16Array = function(length, e3) {
        this._realloc(length * 2);
        var arr = new Uint16Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += length * 2;
        return arr;
      };
      DataStream.prototype.mapUint8Array = function(length) {
        this._realloc(length * 1);
        var arr = new Uint8Array(this._buffer, this.byteOffset + this.position, length);
        this.position += length * 1;
        return arr;
      };
      DataStream.prototype.mapFloat64Array = function(length, e3) {
        this._realloc(length * 8);
        var arr = new Float64Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += length * 8;
        return arr;
      };
      DataStream.prototype.mapFloat32Array = function(length, e3) {
        this._realloc(length * 4);
        var arr = new Float32Array(this._buffer, this.byteOffset + this.position, length);
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += length * 4;
        return arr;
      };
      DataStream.prototype.readInt32Array = function(length, e3) {
        length = length == null ? this.byteLength - this.position / 4 : length;
        var arr = new Int32Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readInt16Array = function(length, e3) {
        length = length == null ? this.byteLength - this.position / 2 : length;
        var arr = new Int16Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readInt8Array = function(length) {
        length = length == null ? this.byteLength - this.position : length;
        var arr = new Int8Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readUint32Array = function(length, e3) {
        length = length == null ? this.byteLength - this.position / 4 : length;
        var arr = new Uint32Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readUint16Array = function(length, e3) {
        length = length == null ? this.byteLength - this.position / 2 : length;
        var arr = new Uint16Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readUint8Array = function(length) {
        length = length == null ? this.byteLength - this.position : length;
        var arr = new Uint8Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readFloat64Array = function(length, e3) {
        length = length == null ? this.byteLength - this.position / 8 : length;
        var arr = new Float64Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.readFloat32Array = function(length, e3) {
        length = length == null ? this.byteLength - this.position / 4 : length;
        var arr = new Float32Array(length);
        DataStream.memcpy(
          arr.buffer,
          0,
          this.buffer,
          this.byteOffset + this.position,
          length * arr.BYTES_PER_ELEMENT
        );
        DataStream.arrayToNative(arr, e3 == null ? this.endianness : e3);
        this.position += arr.byteLength;
        return arr;
      };
      DataStream.prototype.writeInt32Array = function(arr, e3) {
        this._realloc(arr.length * 4);
        if (arr instanceof Int32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapInt32Array(arr.length, e3);
        } else {
          for (var i3 = 0; i3 < arr.length; i3++) {
            this.writeInt32(arr[i3], e3);
          }
        }
      };
      DataStream.prototype.writeInt16Array = function(arr, e3) {
        this._realloc(arr.length * 2);
        if (arr instanceof Int16Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapInt16Array(arr.length, e3);
        } else {
          for (var i3 = 0; i3 < arr.length; i3++) {
            this.writeInt16(arr[i3], e3);
          }
        }
      };
      DataStream.prototype.writeInt8Array = function(arr) {
        this._realloc(arr.length * 1);
        if (arr instanceof Int8Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapInt8Array(arr.length);
        } else {
          for (var i3 = 0; i3 < arr.length; i3++) {
            this.writeInt8(arr[i3]);
          }
        }
      };
      DataStream.prototype.writeUint32Array = function(arr, e3) {
        this._realloc(arr.length * 4);
        if (arr instanceof Uint32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapUint32Array(arr.length, e3);
        } else {
          for (var i3 = 0; i3 < arr.length; i3++) {
            this.writeUint32(arr[i3], e3);
          }
        }
      };
      DataStream.prototype.writeUint16Array = function(arr, e3) {
        this._realloc(arr.length * 2);
        if (arr instanceof Uint16Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapUint16Array(arr.length, e3);
        } else {
          for (var i3 = 0; i3 < arr.length; i3++) {
            this.writeUint16(arr[i3], e3);
          }
        }
      };
      DataStream.prototype.writeUint8Array = function(arr) {
        this._realloc(arr.length * 1);
        if (arr instanceof Uint8Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapUint8Array(arr.length);
        } else {
          for (var i3 = 0; i3 < arr.length; i3++) {
            this.writeUint8(arr[i3]);
          }
        }
      };
      DataStream.prototype.writeFloat64Array = function(arr, e3) {
        this._realloc(arr.length * 8);
        if (arr instanceof Float64Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapFloat64Array(arr.length, e3);
        } else {
          for (var i3 = 0; i3 < arr.length; i3++) {
            this.writeFloat64(arr[i3], e3);
          }
        }
      };
      DataStream.prototype.writeFloat32Array = function(arr, e3) {
        this._realloc(arr.length * 4);
        if (arr instanceof Float32Array && this.byteOffset + this.position % arr.BYTES_PER_ELEMENT == 0) {
          DataStream.memcpy(
            this._buffer,
            this.byteOffset + this.position,
            arr.buffer,
            0,
            arr.byteLength
          );
          this.mapFloat32Array(arr.length, e3);
        } else {
          for (var i3 = 0; i3 < arr.length; i3++) {
            this.writeFloat32(arr[i3], e3);
          }
        }
      };
      DataStream.prototype.readInt32 = function(e3) {
        var v3 = this._dataView.getInt32(this.position, e3 == null ? this.endianness : e3);
        this.position += 4;
        return v3;
      };
      DataStream.prototype.readInt = function(offset) {
        this.seek(offset);
        return this.readInt32();
      };
      DataStream.prototype.readInt16 = function(e3) {
        var v3 = this._dataView.getInt16(this.position, e3 == null ? this.endianness : e3);
        this.position += 2;
        return v3;
      };
      DataStream.prototype.readShort = function(offset) {
        this.seek(offset);
        return this.readInt16();
      };
      DataStream.prototype.readInt8 = function() {
        var v3 = this._dataView.getInt8(this.position);
        this.position += 1;
        return v3;
      };
      DataStream.prototype.readByte = function(offset) {
        this.seek(offset);
        return this.readInt8();
      };
      DataStream.prototype.readUint32 = function(e3) {
        var v3 = this._dataView.getUint32(this.position, e3 == null ? this.endianness : e3);
        this.position += 4;
        return v3;
      };
      DataStream.prototype.readUint16 = function(e3) {
        var v3 = this._dataView.getUint16(this.position, e3 == null ? this.endianness : e3);
        this.position += 2;
        return v3;
      };
      DataStream.prototype.readUint8 = function() {
        var v3 = this._dataView.getUint8(this.position);
        this.position += 1;
        return v3;
      };
      DataStream.prototype.readFloat32 = function(e3) {
        var v3 = this._dataView.getFloat32(this.position, e3 == null ? this.endianness : e3);
        this.position += 4;
        return v3;
      };
      DataStream.prototype.readFloat64 = function(e3) {
        var v3 = this._dataView.getFloat64(this.position, e3 == null ? this.endianness : e3);
        this.position += 8;
        return v3;
      };
      DataStream.prototype.writeInt32 = function(v3, e3) {
        this._realloc(4);
        this._dataView.setInt32(this.position, v3, e3 == null ? this.endianness : e3);
        this.position += 4;
      };
      DataStream.prototype.writeInt16 = function(v3, e3) {
        this._realloc(2);
        this._dataView.setInt16(this.position, v3, e3 == null ? this.endianness : e3);
        this.position += 2;
      };
      DataStream.prototype.writeInt8 = function(v3) {
        this._realloc(1);
        this._dataView.setInt8(this.position, v3);
        this.position += 1;
      };
      DataStream.prototype.writeUint32 = function(v3, e3) {
        this._realloc(4);
        this._dataView.setUint32(this.position, v3, e3 == null ? this.endianness : e3);
        this.position += 4;
      };
      DataStream.prototype.writeUint16 = function(v3, e3) {
        this._realloc(2);
        this._dataView.setUint16(this.position, v3, e3 == null ? this.endianness : e3);
        this.position += 2;
      };
      DataStream.prototype.writeUint8 = function(v3) {
        this._realloc(1);
        this._dataView.setUint8(this.position, v3);
        this.position += 1;
      };
      DataStream.prototype.writeFloat32 = function(v3, e3) {
        this._realloc(4);
        this._dataView.setFloat32(this.position, v3, e3 == null ? this.endianness : e3);
        this.position += 4;
      };
      DataStream.prototype.writeFloat64 = function(v3, e3) {
        this._realloc(8);
        this._dataView.setFloat64(this.position, v3, e3 == null ? this.endianness : e3);
        this.position += 8;
      };
      DataStream.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0;
      DataStream.memcpy = function(dst, dstOffset, src, srcOffset, byteLength) {
        var dstU8 = new Uint8Array(dst, dstOffset, byteLength);
        var srcU8 = new Uint8Array(src, srcOffset, byteLength);
        dstU8.set(srcU8);
      };
      DataStream.arrayToNative = function(array, arrayIsLittleEndian) {
        if (arrayIsLittleEndian == this.endianness) {
          return array;
        } else {
          return this.flipArrayEndianness(array);
        }
      };
      DataStream.nativeToEndian = function(array, littleEndian) {
        if (this.endianness == littleEndian) {
          return array;
        } else {
          return this.flipArrayEndianness(array);
        }
      };
      DataStream.flipArrayEndianness = function(array) {
        var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        for (var i3 = 0; i3 < array.byteLength; i3 += array.BYTES_PER_ELEMENT) {
          for (var j3 = i3 + array.BYTES_PER_ELEMENT - 1, k3 = i3; j3 > k3; j3--, k3++) {
            var tmp = u8[k3];
            u8[k3] = u8[j3];
            u8[j3] = tmp;
          }
        }
        return array;
      };
      DataStream.createStringFromArray = function(array) {
        var str = "";
        for (var i3 = 0; i3 < array.length; i3++) {
          str += String.fromCharCode(array[i3]);
        }
        return str;
      };
      DataStream.prototype.failurePosition = 0;
      DataStream.prototype.readStruct = function(structDefinition) {
        var struct = {}, t3, v3, n3;
        var p2 = this.position;
        for (var i3 = 0; i3 < structDefinition.length; i3 += 2) {
          t3 = structDefinition[i3 + 1];
          v3 = this.readType(t3, struct);
          if (v3 == null) {
            if (this.failurePosition == 0) {
              this.failurePosition = this.position;
            }
            this.position = p2;
            return null;
          }
          struct[structDefinition[i3]] = v3;
        }
        return struct;
      };
      DataStream.prototype.readUCS2String = function(length, endianness) {
        return DataStream.createStringFromArray(this.readUint16Array(length, endianness));
      };
      DataStream.prototype.readStringAt = function(offset, length) {
        this.seek(offset);
        return this.readUCS2String(length);
      };
      DataStream.prototype.writeUCS2String = function(str, endianness, lengthOverride) {
        if (lengthOverride == null) {
          lengthOverride = str.length;
        }
        for (var i3 = 0; i3 < str.length && i3 < lengthOverride; i3++) {
          this.writeUint16(str.charCodeAt(i3), endianness);
        }
        for (; i3 < lengthOverride; i3++) {
          this.writeUint16(0);
        }
      };
      DataStream.prototype.readString = function(length, encoding) {
        if (encoding == null || encoding == "ASCII") {
          return DataStream.createStringFromArray(this.mapUint8Array(length == null ? this.byteLength - this.position : length));
        } else {
          return new TextDecoder(encoding).decode(this.mapUint8Array(length));
        }
      };
      DataStream.prototype.writeString = function(s3, encoding, length) {
        if (encoding == null || encoding == "ASCII") {
          if (length != null) {
            var i3 = 0;
            var len = Math.min(s3.length, length);
            for (i3 = 0; i3 < len; i3++) {
              this.writeUint8(s3.charCodeAt(i3));
            }
            for (; i3 < length; i3++) {
              this.writeUint8(0);
            }
          } else {
            for (var i3 = 0; i3 < s3.length; i3++) {
              this.writeUint8(s3.charCodeAt(i3));
            }
          }
        } else {
          this.writeUint8Array(new TextEncoder(encoding).encode(s3.substring(0, length)));
        }
      };
      DataStream.prototype.readCString = function(length) {
        var blen = this.byteLength - this.position;
        var u8 = new Uint8Array(this._buffer, this._byteOffset + this.position);
        var len = blen;
        if (length != null) {
          len = Math.min(length, blen);
        }
        for (var i3 = 0; i3 < len && u8[i3] != 0; i3++)
          ;
        var s3 = DataStream.createStringFromArray(this.mapUint8Array(i3));
        if (length != null) {
          this.position += len - i3;
        } else if (i3 != blen) {
          this.position += 1;
        }
        return s3;
      };
      DataStream.prototype.writeCString = function(s3, length) {
        if (length != null) {
          var i3 = 0;
          var len = Math.min(s3.length, length);
          for (i3 = 0; i3 < len; i3++) {
            this.writeUint8(s3.charCodeAt(i3));
          }
          for (; i3 < length; i3++) {
            this.writeUint8(0);
          }
        } else {
          for (var i3 = 0; i3 < s3.length; i3++) {
            this.writeUint8(s3.charCodeAt(i3));
          }
          this.writeUint8(0);
        }
      };
      DataStream.prototype.readType = function(t3, struct) {
        if (typeof t3 == "function") {
          return t3(this, struct);
        } else if (typeof t3 == "object" && !(t3 instanceof Array)) {
          return t3.get(this, struct);
        } else if (t3 instanceof Array && t3.length != 3) {
          return this.readStruct(t3, struct);
        }
        var v3 = null;
        var lengthOverride = null;
        var charset = "ASCII";
        var pos = this.position;
        var len;
        if (typeof t3 == "string" && /:/.test(t3)) {
          var tp = t3.split(":");
          t3 = tp[0];
          len = tp[1];
          if (struct[len] != null) {
            lengthOverride = parseInt(struct[len]);
          } else {
            lengthOverride = parseInt(tp[1]);
          }
        }
        if (typeof t3 == "string" && /,/.test(t3)) {
          var tp = t3.split(",");
          t3 = tp[0];
          charset = parseInt(tp[1]);
        }
        switch (t3) {
          case "uint8":
            v3 = this.readUint8();
            break;
          case "int8":
            v3 = this.readInt8();
            break;
          case "uint16":
            v3 = this.readUint16(this.endianness);
            break;
          case "int16":
            v3 = this.readInt16(this.endianness);
            break;
          case "uint32":
            v3 = this.readUint32(this.endianness);
            break;
          case "int32":
            v3 = this.readInt32(this.endianness);
            break;
          case "float32":
            v3 = this.readFloat32(this.endianness);
            break;
          case "float64":
            v3 = this.readFloat64(this.endianness);
            break;
          case "uint16be":
            v3 = this.readUint16(DataStream.BIG_ENDIAN);
            break;
          case "int16be":
            v3 = this.readInt16(DataStream.BIG_ENDIAN);
            break;
          case "uint32be":
            v3 = this.readUint32(DataStream.BIG_ENDIAN);
            break;
          case "int32be":
            v3 = this.readInt32(DataStream.BIG_ENDIAN);
            break;
          case "float32be":
            v3 = this.readFloat32(DataStream.BIG_ENDIAN);
            break;
          case "float64be":
            v3 = this.readFloat64(DataStream.BIG_ENDIAN);
            break;
          case "uint16le":
            v3 = this.readUint16(DataStream.LITTLE_ENDIAN);
            break;
          case "int16le":
            v3 = this.readInt16(DataStream.LITTLE_ENDIAN);
            break;
          case "uint32le":
            v3 = this.readUint32(DataStream.LITTLE_ENDIAN);
            break;
          case "int32le":
            v3 = this.readInt32(DataStream.LITTLE_ENDIAN);
            break;
          case "float32le":
            v3 = this.readFloat32(DataStream.LITTLE_ENDIAN);
            break;
          case "float64le":
            v3 = this.readFloat64(DataStream.LITTLE_ENDIAN);
            break;
          case "cstring":
            v3 = this.readCString(lengthOverride);
            break;
          case "string":
            v3 = this.readString(lengthOverride, charset);
            break;
          case "u16string":
            v3 = this.readUCS2String(lengthOverride, this.endianness);
            break;
          case "u16stringle":
            v3 = this.readUCS2String(lengthOverride, DataStream.LITTLE_ENDIAN);
            break;
          case "u16stringbe":
            v3 = this.readUCS2String(lengthOverride, DataStream.BIG_ENDIAN);
            break;
          default:
            if (t3.length == 3) {
              var ta2 = t3[1];
              var len = t3[2];
              var length = 0;
              if (typeof len == "function") {
                length = len(struct, this, t3);
              } else if (typeof len == "string" && struct[len] != null) {
                length = parseInt(struct[len]);
              } else {
                length = parseInt(len);
              }
              if (typeof ta2 == "string") {
                var tap = ta2.replace(/(le|be)$/, "");
                var endianness = null;
                if (/le$/.test(ta2)) {
                  endianness = DataStream.LITTLE_ENDIAN;
                } else if (/be$/.test(ta2)) {
                  endianness = DataStream.BIG_ENDIAN;
                }
                if (len == "*") {
                  length = null;
                }
                switch (tap) {
                  case "uint8":
                    v3 = this.readUint8Array(length);
                    break;
                  case "uint16":
                    v3 = this.readUint16Array(length, endianness);
                    break;
                  case "uint32":
                    v3 = this.readUint32Array(length, endianness);
                    break;
                  case "int8":
                    v3 = this.readInt8Array(length);
                    break;
                  case "int16":
                    v3 = this.readInt16Array(length, endianness);
                    break;
                  case "int32":
                    v3 = this.readInt32Array(length, endianness);
                    break;
                  case "float32":
                    v3 = this.readFloat32Array(length, endianness);
                    break;
                  case "float64":
                    v3 = this.readFloat64Array(length, endianness);
                    break;
                  case "cstring":
                  case "utf16string":
                  case "string":
                    if (length == null) {
                      v3 = [];
                      while (!this.isEof()) {
                        var u3 = this.readType(ta2, struct);
                        if (u3 == null)
                          break;
                        v3.push(u3);
                      }
                    } else {
                      v3 = new Array(length);
                      for (var i3 = 0; i3 < length; i3++) {
                        v3[i3] = this.readType(ta2, struct);
                      }
                    }
                    break;
                }
              } else {
                if (len == "*") {
                  v3 = [];
                  this.buffer;
                  while (true) {
                    var p2 = this.position;
                    try {
                      var o3 = this.readType(ta2, struct);
                      if (o3 == null) {
                        this.position = p2;
                        break;
                      }
                      v3.push(o3);
                    } catch (e3) {
                      this.position = p2;
                      break;
                    }
                  }
                } else {
                  v3 = new Array(length);
                  for (var i3 = 0; i3 < length; i3++) {
                    var u3 = this.readType(ta2, struct);
                    if (u3 == null)
                      return null;
                    v3[i3] = u3;
                  }
                }
              }
              break;
            }
        }
        if (lengthOverride != null) {
          this.position = pos + lengthOverride;
        }
        return v3;
      };
      DataStream.prototype.writeStruct = function(structDefinition, struct) {
        for (var i3 = 0; i3 < structDefinition.length; i3 += 2) {
          var t3 = structDefinition[i3 + 1];
          this.writeType(t3, struct[structDefinition[i3]], struct);
        }
      };
      DataStream.prototype.writeType = function(t3, v3, struct) {
        if (typeof t3 == "function") {
          return t3(this, v3);
        } else if (typeof t3 == "object" && !(t3 instanceof Array)) {
          return t3.set(this, v3, struct);
        }
        var lengthOverride = null;
        var charset = "ASCII";
        var pos = this.position;
        if (typeof t3 == "string" && /:/.test(t3)) {
          var tp = t3.split(":");
          t3 = tp[0];
          lengthOverride = parseInt(tp[1]);
        }
        if (typeof t3 == "string" && /,/.test(t3)) {
          var tp = t3.split(",");
          t3 = tp[0];
          charset = parseInt(tp[1]);
        }
        switch (t3) {
          case "uint8":
            this.writeUint8(v3);
            break;
          case "int8":
            this.writeInt8(v3);
            break;
          case "uint16":
            this.writeUint16(v3, this.endianness);
            break;
          case "int16":
            this.writeInt16(v3, this.endianness);
            break;
          case "uint32":
            this.writeUint32(v3, this.endianness);
            break;
          case "int32":
            this.writeInt32(v3, this.endianness);
            break;
          case "float32":
            this.writeFloat32(v3, this.endianness);
            break;
          case "float64":
            this.writeFloat64(v3, this.endianness);
            break;
          case "uint16be":
            this.writeUint16(v3, DataStream.BIG_ENDIAN);
            break;
          case "int16be":
            this.writeInt16(v3, DataStream.BIG_ENDIAN);
            break;
          case "uint32be":
            this.writeUint32(v3, DataStream.BIG_ENDIAN);
            break;
          case "int32be":
            this.writeInt32(v3, DataStream.BIG_ENDIAN);
            break;
          case "float32be":
            this.writeFloat32(v3, DataStream.BIG_ENDIAN);
            break;
          case "float64be":
            this.writeFloat64(v3, DataStream.BIG_ENDIAN);
            break;
          case "uint16le":
            this.writeUint16(v3, DataStream.LITTLE_ENDIAN);
            break;
          case "int16le":
            this.writeInt16(v3, DataStream.LITTLE_ENDIAN);
            break;
          case "uint32le":
            this.writeUint32(v3, DataStream.LITTLE_ENDIAN);
            break;
          case "int32le":
            this.writeInt32(v3, DataStream.LITTLE_ENDIAN);
            break;
          case "float32le":
            this.writeFloat32(v3, DataStream.LITTLE_ENDIAN);
            break;
          case "float64le":
            this.writeFloat64(v3, DataStream.LITTLE_ENDIAN);
            break;
          case "cstring":
            this.writeCString(v3, lengthOverride);
            break;
          case "string":
            this.writeString(v3, charset, lengthOverride);
            break;
          case "u16string":
            this.writeUCS2String(v3, this.endianness, lengthOverride);
            break;
          case "u16stringle":
            this.writeUCS2String(v3, DataStream.LITTLE_ENDIAN, lengthOverride);
            break;
          case "u16stringbe":
            this.writeUCS2String(v3, DataStream.BIG_ENDIAN, lengthOverride);
            break;
          default:
            if (t3.length == 3) {
              var ta2 = t3[1];
              for (var i3 = 0; i3 < v3.length; i3++) {
                this.writeType(ta2, v3[i3]);
              }
              break;
            } else {
              this.writeStruct(t3, v3);
              break;
            }
        }
        if (lengthOverride != null) {
          this.position = pos;
          this._realloc(lengthOverride);
          this.position = pos + lengthOverride;
        }
      };
      return DataStream;
    });
  }
});

// node_modules/wl-msg-reader/lib/msg.reader.js
var require_msg_reader = __commonJS({
  "node_modules/wl-msg-reader/lib/msg.reader.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(["./DataStream"], factory);
      } else if (typeof exports2 === "object") {
        module2.exports = factory(require_DataStream());
      } else {
        root.MSGReader = factory(root.DataStream);
      }
    })(exports2, function(DataStream) {
      var CONST = {
        FILE_HEADER: uInt2int([208, 207, 17, 224, 161, 177, 26, 225]),
        MSG: {
          UNUSED_BLOCK: -1,
          END_OF_CHAIN: -2,
          S_BIG_BLOCK_SIZE: 512,
          S_BIG_BLOCK_MARK: 9,
          L_BIG_BLOCK_SIZE: 4096,
          L_BIG_BLOCK_MARK: 12,
          SMALL_BLOCK_SIZE: 64,
          BIG_BLOCK_MIN_DOC_SIZE: 4096,
          HEADER: {
            PROPERTY_START_OFFSET: 48,
            BAT_START_OFFSET: 76,
            BAT_COUNT_OFFSET: 44,
            SBAT_START_OFFSET: 60,
            SBAT_COUNT_OFFSET: 64,
            XBAT_START_OFFSET: 68,
            XBAT_COUNT_OFFSET: 72
          },
          PROP: {
            NO_INDEX: -1,
            PROPERTY_SIZE: 128,
            NAME_SIZE_OFFSET: 64,
            MAX_NAME_LENGTH: (
              /*NAME_SIZE_OFFSET*/
              64 / 2 - 1
            ),
            TYPE_OFFSET: 66,
            PREVIOUS_PROPERTY_OFFSET: 68,
            NEXT_PROPERTY_OFFSET: 72,
            CHILD_PROPERTY_OFFSET: 76,
            START_BLOCK_OFFSET: 116,
            SIZE_OFFSET: 120,
            TYPE_ENUM: {
              DIRECTORY: 1,
              DOCUMENT: 2,
              ROOT: 5
            }
          },
          FIELD: {
            PREFIX: {
              ATTACHMENT: "__attach_version1.0",
              RECIPIENT: "__recip_version1.0",
              DOCUMENT: "__substg1."
            },
            // example (use fields as needed)
            NAME_MAPPING: {
              // email specific
              "0037": "subject",
              "0c1a": "senderName",
              "5d02": "senderEmail",
              "1000": "body",
              "007d": "headers",
              // attachment specific
              "3703": "extension",
              "3704": "fileNameShort",
              "3707": "fileName",
              "3712": "pidContentId",
              // recipient specific
              "3001": "name",
              "39fe": "email"
            },
            CLASS_MAPPING: {
              ATTACHMENT_DATA: "3701"
            },
            TYPE_MAPPING: {
              "001e": "string",
              "001f": "unicode",
              "0102": "binary"
            },
            DIR_TYPE: {
              INNER_MSG: "000d"
            }
          }
        }
      };
      function arraysEqual(a3, b3) {
        if (a3 === b3)
          return true;
        if (a3 == null || b3 == null)
          return false;
        if (a3.length != b3.length)
          return false;
        for (var i3 = 0; i3 < a3.length; i3++) {
          if (a3[i3] !== b3[i3])
            return false;
        }
        return true;
      }
      function uInt2int(data) {
        var result = new Array(data.length);
        for (var i3 = 0; i3 < data.length; i3++) {
          result[i3] = data[i3] << 24 >> 24;
        }
        return result;
      }
      function isMSGFile(ds2) {
        ds2.seek(0);
        return arraysEqual(CONST.FILE_HEADER, ds2.readInt8Array(CONST.FILE_HEADER.length));
      }
      function getBlockOffsetAt(msgData, offset) {
        return (offset + 1) * msgData.bigBlockSize;
      }
      function getBlockAt(ds2, msgData, offset) {
        var startOffset = getBlockOffsetAt(msgData, offset);
        ds2.seek(startOffset);
        return ds2.readInt32Array(msgData.bigBlockLength);
      }
      function getNextBlockInner(ds2, msgData, offset, blockOffsetData) {
        var currentBlock = Math.floor(offset / msgData.bigBlockLength);
        var currentBlockIndex = offset % msgData.bigBlockLength;
        var startBlockOffset = blockOffsetData[currentBlock];
        return getBlockAt(ds2, msgData, startBlockOffset)[currentBlockIndex];
      }
      function getNextBlock(ds2, msgData, offset) {
        return getNextBlockInner(ds2, msgData, offset, msgData.batData);
      }
      function getNextBlockSmall(ds2, msgData, offset) {
        return getNextBlockInner(ds2, msgData, offset, msgData.sbatData);
      }
      function parseMsgData(ds2) {
        var msgData = headerData(ds2);
        msgData.batData = batData(ds2, msgData);
        msgData.sbatData = sbatData(ds2, msgData);
        if (msgData.xbatCount > 0) {
          xbatData(ds2, msgData);
        }
        msgData.propertyData = propertyData(ds2, msgData);
        msgData.fieldsData = fieldsData(ds2, msgData);
        return msgData;
      }
      function headerData(ds2) {
        var headerData2 = {};
        headerData2.bigBlockSize = ds2.readByte(
          /*const position*/
          30
        ) == CONST.MSG.L_BIG_BLOCK_MARK ? CONST.MSG.L_BIG_BLOCK_SIZE : CONST.MSG.S_BIG_BLOCK_SIZE;
        headerData2.bigBlockLength = headerData2.bigBlockSize / 4;
        headerData2.xBlockLength = headerData2.bigBlockLength - 1;
        headerData2.batCount = ds2.readInt(CONST.MSG.HEADER.BAT_COUNT_OFFSET);
        headerData2.propertyStart = ds2.readInt(CONST.MSG.HEADER.PROPERTY_START_OFFSET);
        headerData2.sbatStart = ds2.readInt(CONST.MSG.HEADER.SBAT_START_OFFSET);
        headerData2.sbatCount = ds2.readInt(CONST.MSG.HEADER.SBAT_COUNT_OFFSET);
        headerData2.xbatStart = ds2.readInt(CONST.MSG.HEADER.XBAT_START_OFFSET);
        headerData2.xbatCount = ds2.readInt(CONST.MSG.HEADER.XBAT_COUNT_OFFSET);
        return headerData2;
      }
      function batCountInHeader(msgData) {
        var maxBatsInHeader = (CONST.MSG.S_BIG_BLOCK_SIZE - CONST.MSG.HEADER.BAT_START_OFFSET) / 4;
        return Math.min(msgData.batCount, maxBatsInHeader);
      }
      function batData(ds2, msgData) {
        var result = new Array(batCountInHeader(msgData));
        ds2.seek(CONST.MSG.HEADER.BAT_START_OFFSET);
        for (var i3 = 0; i3 < result.length; i3++) {
          result[i3] = ds2.readInt32();
        }
        return result;
      }
      function sbatData(ds2, msgData) {
        var result = [];
        var startIndex = msgData.sbatStart;
        for (var i3 = 0; i3 < msgData.sbatCount && startIndex != CONST.MSG.END_OF_CHAIN; i3++) {
          result.push(startIndex);
          startIndex = getNextBlock(ds2, msgData, startIndex);
        }
        return result;
      }
      function xbatData(ds2, msgData) {
        var batCount = batCountInHeader(msgData);
        var batCountTotal = msgData.batCount;
        var remainingBlocks = batCountTotal - batCount;
        var nextBlockAt = msgData.xbatStart;
        for (var i3 = 0; i3 < msgData.xbatCount; i3++) {
          var xBatBlock = getBlockAt(ds2, msgData, nextBlockAt);
          nextBlockAt = xBatBlock[msgData.xBlockLength];
          var blocksToProcess = Math.min(remainingBlocks, msgData.xBlockLength);
          for (var j3 = 0; j3 < blocksToProcess; j3++) {
            var blockStartAt = xBatBlock[j3];
            if (blockStartAt == CONST.MSG.UNUSED_BLOCK || blockStartAt == CONST.MSG.END_OF_CHAIN) {
              break;
            }
            msgData.batData.push(blockStartAt);
          }
          remainingBlocks -= blocksToProcess;
        }
      }
      function propertyData(ds2, msgData) {
        var props = [];
        var currentOffset = msgData.propertyStart;
        while (currentOffset != CONST.MSG.END_OF_CHAIN) {
          convertBlockToProperties(ds2, msgData, currentOffset, props);
          currentOffset = getNextBlock(ds2, msgData, currentOffset);
        }
        createPropertyHierarchy(
          props,
          /*property with index 0 (zero) always as root*/
          props[0]
        );
        return props;
      }
      function convertName(ds2, offset) {
        var nameLength = ds2.readShort(offset + CONST.MSG.PROP.NAME_SIZE_OFFSET);
        if (nameLength < 1) {
          return "";
        } else {
          return ds2.readStringAt(offset, nameLength / 2);
        }
      }
      function convertProperty(ds2, index, offset) {
        return {
          index,
          type: ds2.readByte(offset + CONST.MSG.PROP.TYPE_OFFSET),
          name: convertName(ds2, offset),
          // hierarchy
          previousProperty: ds2.readInt(offset + CONST.MSG.PROP.PREVIOUS_PROPERTY_OFFSET),
          nextProperty: ds2.readInt(offset + CONST.MSG.PROP.NEXT_PROPERTY_OFFSET),
          childProperty: ds2.readInt(offset + CONST.MSG.PROP.CHILD_PROPERTY_OFFSET),
          // data offset
          startBlock: ds2.readInt(offset + CONST.MSG.PROP.START_BLOCK_OFFSET),
          sizeBlock: ds2.readInt(offset + CONST.MSG.PROP.SIZE_OFFSET)
        };
      }
      function convertBlockToProperties(ds2, msgData, propertyBlockOffset, props) {
        var propertyCount = msgData.bigBlockSize / CONST.MSG.PROP.PROPERTY_SIZE;
        var propertyOffset = getBlockOffsetAt(msgData, propertyBlockOffset);
        for (var i3 = 0; i3 < propertyCount; i3++) {
          var propertyType = ds2.readByte(propertyOffset + CONST.MSG.PROP.TYPE_OFFSET);
          switch (propertyType) {
            case CONST.MSG.PROP.TYPE_ENUM.ROOT:
            case CONST.MSG.PROP.TYPE_ENUM.DIRECTORY:
            case CONST.MSG.PROP.TYPE_ENUM.DOCUMENT:
              props.push(convertProperty(ds2, props.length, propertyOffset));
              break;
            default:
              props.push(null);
          }
          propertyOffset += CONST.MSG.PROP.PROPERTY_SIZE;
        }
      }
      function createPropertyHierarchy(props, nodeProperty) {
        if (nodeProperty.childProperty == CONST.MSG.PROP.NO_INDEX) {
          return;
        }
        nodeProperty.children = [];
        var children = [nodeProperty.childProperty];
        while (children.length != 0) {
          var currentIndex = children.shift();
          var current = props[currentIndex];
          if (current == null) {
            continue;
          }
          nodeProperty.children.push(currentIndex);
          if (current.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {
            createPropertyHierarchy(props, current);
          }
          if (current.previousProperty != CONST.MSG.PROP.NO_INDEX) {
            children.push(current.previousProperty);
          }
          if (current.nextProperty != CONST.MSG.PROP.NO_INDEX) {
            children.push(current.nextProperty);
          }
        }
      }
      function fieldsData(ds2, msgData) {
        var fields = {
          attachments: [],
          recipients: []
        };
        fieldsDataDir(ds2, msgData, msgData.propertyData[0], fields);
        return fields;
      }
      function fieldsDataDir(ds2, msgData, dirProperty, fields) {
        if (dirProperty.children && dirProperty.children.length > 0) {
          for (var i3 = 0; i3 < dirProperty.children.length; i3++) {
            var childProperty = msgData.propertyData[dirProperty.children[i3]];
            if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {
              fieldsDataDirInner(ds2, msgData, childProperty, fields);
            } else if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DOCUMENT && childProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.DOCUMENT) == 0) {
              fieldsDataDocument(ds2, msgData, childProperty, fields);
            }
          }
        }
      }
      function fieldsDataDirInner(ds2, msgData, dirProperty, fields) {
        if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.ATTACHMENT) == 0) {
          var attachmentField = {};
          fields.attachments.push(attachmentField);
          fieldsDataDir(ds2, msgData, dirProperty, attachmentField);
        } else if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.RECIPIENT) == 0) {
          var recipientField = {};
          fields.recipients.push(recipientField);
          fieldsDataDir(ds2, msgData, dirProperty, recipientField);
        } else {
          var childFieldType = getFieldType(dirProperty);
          if (childFieldType != CONST.MSG.FIELD.DIR_TYPE.INNER_MSG) {
            fieldsDataDir(ds2, msgData, dirProperty, fields);
          } else {
            fields.innerMsgContent = true;
          }
        }
      }
      function fieldsDataDocument(ds2, msgData, documentProperty, fields) {
        var value = documentProperty.name.substring(12).toLowerCase();
        var fieldClass = value.substring(0, 4);
        var fieldType = value.substring(4, 8);
        var fieldName = CONST.MSG.FIELD.NAME_MAPPING[fieldClass];
        if (fieldName) {
          fields[fieldName] = getFieldValue(ds2, msgData, documentProperty, fieldType);
        }
        if (fieldClass == CONST.MSG.FIELD.CLASS_MAPPING.ATTACHMENT_DATA) {
          fields["dataId"] = documentProperty.index;
          fields["contentLength"] = documentProperty.sizeBlock;
        }
      }
      function getFieldType(fieldProperty) {
        var value = fieldProperty.name.substring(12).toLowerCase();
        return value.substring(4, 8);
      }
      var extractorFieldValue = {
        sbat: {
          "extractor": function extractDataViaSbat(ds2, msgData, fieldProperty, dataTypeExtractor) {
            var chain = getChainByBlockSmall(ds2, msgData, fieldProperty);
            if (chain.length == 1) {
              return readDataByBlockSmall(ds2, msgData, fieldProperty.startBlock, fieldProperty.sizeBlock, dataTypeExtractor);
            } else if (chain.length > 1) {
              return readChainDataByBlockSmall(ds2, msgData, fieldProperty, chain, dataTypeExtractor);
            }
            return null;
          },
          dataType: {
            "string": function extractBatString(ds2, msgData, blockStartOffset, bigBlockOffset, blockSize) {
              ds2.seek(blockStartOffset + bigBlockOffset);
              return ds2.readString(blockSize);
            },
            "unicode": function extractBatUnicode(ds2, msgData, blockStartOffset, bigBlockOffset, blockSize) {
              ds2.seek(blockStartOffset + bigBlockOffset);
              return ds2.readUCS2String(blockSize / 2);
            },
            "binary": function extractBatBinary(ds2, msgData, blockStartOffset, bigBlockOffset, blockSize) {
              ds2.seek(blockStartOffset + bigBlockOffset);
              var toReadLength = Math.min(Math.min(msgData.bigBlockSize - bigBlockOffset, blockSize), CONST.MSG.SMALL_BLOCK_SIZE);
              return ds2.readUint8Array(toReadLength);
            }
          }
        },
        bat: {
          "extractor": function extractDataViaBat(ds2, msgData, fieldProperty, dataTypeExtractor) {
            var offset = getBlockOffsetAt(msgData, fieldProperty.startBlock);
            ds2.seek(offset);
            return dataTypeExtractor(ds2, fieldProperty);
          },
          dataType: {
            "string": function extractSbatString(ds2, fieldProperty) {
              return ds2.readString(fieldProperty.sizeBlock);
            },
            "unicode": function extractSbatUnicode(ds2, fieldProperty) {
              return ds2.readUCS2String(fieldProperty.sizeBlock / 2);
            },
            "binary": function extractSbatBinary(ds2, fieldProperty) {
              return ds2.readUint8Array(fieldProperty.sizeBlock);
            }
          }
        }
      };
      function readDataByBlockSmall(ds2, msgData, startBlock, blockSize, dataTypeExtractor) {
        var byteOffset = startBlock * CONST.MSG.SMALL_BLOCK_SIZE;
        var bigBlockNumber = Math.floor(byteOffset / msgData.bigBlockSize);
        var bigBlockOffset = byteOffset % msgData.bigBlockSize;
        var rootProp = msgData.propertyData[0];
        var nextBlock = rootProp.startBlock;
        for (var i3 = 0; i3 < bigBlockNumber; i3++) {
          nextBlock = getNextBlock(ds2, msgData, nextBlock);
        }
        var blockStartOffset = getBlockOffsetAt(msgData, nextBlock);
        return dataTypeExtractor(ds2, msgData, blockStartOffset, bigBlockOffset, blockSize);
      }
      function readChainDataByBlockSmall(ds2, msgData, fieldProperty, chain, dataTypeExtractor) {
        var resultData = new Int8Array(fieldProperty.sizeBlock);
        for (var i3 = 0, idx = 0; i3 < chain.length; i3++) {
          var data = readDataByBlockSmall(ds2, msgData, chain[i3], CONST.MSG.SMALL_BLOCK_SIZE, extractorFieldValue.sbat.dataType.binary);
          for (var j3 = 0; j3 < data.length; j3++) {
            resultData[idx++] = data[j3];
          }
        }
        var localDs = new DataStream(resultData, 0, DataStream.LITTLE_ENDIAN);
        return dataTypeExtractor(localDs, msgData, 0, 0, fieldProperty.sizeBlock);
      }
      function getChainByBlockSmall(ds2, msgData, fieldProperty) {
        var blockChain = [];
        var nextBlockSmall = fieldProperty.startBlock;
        while (nextBlockSmall != CONST.MSG.END_OF_CHAIN) {
          blockChain.push(nextBlockSmall);
          nextBlockSmall = getNextBlockSmall(ds2, msgData, nextBlockSmall);
        }
        return blockChain;
      }
      function getFieldValue(ds2, msgData, fieldProperty, type) {
        var value = null;
        var valueExtractor = fieldProperty.sizeBlock < CONST.MSG.BIG_BLOCK_MIN_DOC_SIZE ? extractorFieldValue.sbat : extractorFieldValue.bat;
        var dataTypeExtractor = valueExtractor.dataType[CONST.MSG.FIELD.TYPE_MAPPING[type]];
        if (dataTypeExtractor) {
          value = valueExtractor.extractor(ds2, msgData, fieldProperty, dataTypeExtractor);
        }
        return value;
      }
      var MSGReader = function(arrayBuffer) {
        this.ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);
      };
      MSGReader.prototype = {
        /**
             Converts bytes to fields information
        
             @return {Object} The fields data for MSG file
             */
        getFileData: function() {
          if (!isMSGFile(this.ds)) {
            return { error: "Unsupported file type!" };
          }
          if (this.fileData == null) {
            this.fileData = parseMsgData(this.ds);
          }
          return this.fileData.fieldsData;
        },
        /**
             Reads an attachment content by key/ID
        
             @return {Object} The attachment for specific attachment key
             */
        getAttachment: function(attach) {
          var attachData = typeof attach === "number" ? this.fileData.fieldsData.attachments[attach] : attach;
          var fieldProperty = this.fileData.propertyData[attachData.dataId];
          var fieldData = getFieldValue(this.ds, this.fileData, fieldProperty, getFieldType(fieldProperty));
          return { fileName: attachData.fileName, content: fieldData };
        }
      };
      return MSGReader;
    });
  }
});

// node_modules/wl-msg-reader/index.js
var require_wl_msg_reader = __commonJS({
  "node_modules/wl-msg-reader/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataStream = require_DataStream();
    exports2.MSGReader = require_msg_reader();
  }
});

// node_modules/react-doc-viewer/build/plugins/msg/index.js
var require_msg = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/msg/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var wl_msg_reader_1 = require_wl_msg_reader();
    var fileLoaders_1 = require_fileLoaders();
    var MSGRenderer = function(_a3) {
      var _b2;
      var currentDocument = _a3.mainState.currentDocument;
      var _c2 = react_1.useState(), fileData = _c2[0], setFileData = _c2[1];
      react_1.useEffect(function() {
        if (!currentDocument || !currentDocument.fileData)
          return;
        var _fd = new wl_msg_reader_1.MSGReader(currentDocument.fileData).getFileData();
        setFileData(_fd);
      }, [currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData]);
      react_1.useEffect(function() {
        if (!fileData || fileData.hasOwnProperty("error"))
          return;
        var iframeCont = document.getElementById("msg-body");
        var iframe = (iframeCont === null || iframeCont === void 0 ? void 0 : iframeCont.contentWindow) && iframeCont.contentWindow;
        if (!iframe)
          return;
        var iframeDoc = iframe.document;
        var body = fileData.body.replace(/(\r\n|\n|\r)/gm, "<br />");
        iframeDoc.open();
        iframeDoc.write("" + body);
        iframeDoc.close();
      }, [fileData]);
      if (!fileData || fileData.hasOwnProperty("error")) {
        return react_1.default.createElement("span", null, (_b2 = fileData) === null || _b2 === void 0 ? void 0 : _b2.error);
      }
      var _d2 = fileData, recipients = _d2.recipients, subject = _d2.subject, senderEmail = _d2.senderEmail, senderName = _d2.senderName;
      return react_1.default.createElement(
        Container,
        { id: "msg-renderer" },
        react_1.default.createElement("h2", { id: "msg-subject-title", style: { marginBottom: 0 } }, subject),
        react_1.default.createElement(Sender, { name: senderName, email: senderEmail }),
        react_1.default.createElement(
          RecipientContainer,
          { id: "msg-recipient" },
          react_1.default.createElement("h3", { id: "msg-recipient-title" }, "Recipients"),
          react_1.default.createElement("ul", { id: "msg-recipient-ul" }, recipients.map(function(r3, i3) {
            return react_1.default.createElement(
              "li",
              { key: i3, id: "msg-recipient-li" },
              react_1.default.createElement("span", { id: "msg-recipient-name" }, r3.name),
              r3.hasOwnProperty("email") && react_1.default.createElement(
                "span",
                { id: "msg-recipient-email" },
                " - ",
                r3.email
              )
            );
          }))
        ),
        react_1.default.createElement(BodyIFrame, { id: "msg-body", sandbox: "allow-same-origin" })
      );
    };
    var Sender = function(_a3) {
      var name = _a3.name, email = _a3.email;
      if (!name && !email)
        return null;
      return react_1.default.createElement(
        SenderContainer,
        { id: "msg-sender" },
        react_1.default.createElement("h3", { id: "msg-sender-title" }, "Sender"),
        name !== void 0 && react_1.default.createElement("div", { id: "msg-sender-name" }, name),
        email !== void 0 && react_1.default.createElement("div", { id: "msg-sender-email" }, email)
      );
    };
    exports2.default = MSGRenderer;
    MSGRenderer.fileTypes = ["msg", "application/vnd.ms-outlook"];
    MSGRenderer.weight = 0;
    MSGRenderer.fileLoader = fileLoaders_1.arrayBufferFileLoader;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 0 30px;\n"], ["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 0 30px;\n"])));
    var SenderContainer = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  padding: 0 15px 15px 15px;\n  margin-top: 20px;\n  border: 1px solid ", ";\n"], ["\n  padding: 0 15px 15px 15px;\n  margin-top: 20px;\n  border: 1px solid ", ";\n"])), function(props) {
      return props.theme.secondary;
    });
    var RecipientContainer = styled_components_1.default.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  padding: 0 15px;\n  margin-top: 20px;\n  border: 1px solid ", ";\n"], ["\n  padding: 0 15px;\n  margin-top: 20px;\n  border: 1px solid ", ";\n"])), function(props) {
      return props.theme.secondary;
    });
    var BodyIFrame = styled_components_1.default.iframe(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  height: 100%;\n  padding: 15px;\n  margin: 20px 0 20px 0;\n  border: 1px solid ", ";\n"], ["\n  height: 100%;\n  padding: 15px;\n  margin: 20px 0 20px 0;\n  border: 1px solid ", ";\n"])), function(props) {
      return props.theme.secondary;
    });
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
  }
});

// node_modules/pdfjs-dist/build/pdf.worker.min.mjs
var pdf_worker_min_exports = {};
__export(pdf_worker_min_exports, {
  WorkerMessageHandler: () => fo
});
function getVerbosityLevel() {
  return st;
}
function info(e3) {
  st >= pA.INFOS && console.log(`Info: ${e3}`);
}
function warn(e3) {
  st >= pA.WARNINGS && console.log(`Warning: ${e3}`);
}
function unreachable(e3) {
  throw new Error(e3);
}
function assert(e3, t3) {
  e3 || unreachable(t3);
}
function createValidAbsoluteUrl(e3, t3 = null, i3 = null) {
  if (!e3)
    return null;
  try {
    if (i3 && "string" == typeof e3) {
      if (i3.addDefaultProtocol && e3.startsWith("www.")) {
        const t4 = e3.match(/\./g);
        (t4 == null ? void 0 : t4.length) >= 2 && (e3 = `http://${e3}`);
      }
      if (i3.tryConvertEncoding)
        try {
          e3 = stringToUTF8String(e3);
        } catch {
        }
    }
    const a3 = t3 ? new URL(e3, t3) : new URL(e3);
    if (function _isValidProtocol(e4) {
      switch (e4 == null ? void 0 : e4.protocol) {
        case "http:":
        case "https:":
        case "ftp:":
        case "mailto:":
        case "tel:":
          return true;
        default:
          return false;
      }
    }(a3))
      return a3;
  } catch {
  }
  return null;
}
function shadow(e3, t3, i3, a3 = false) {
  Object.defineProperty(e3, t3, { value: i3, enumerable: !a3, configurable: true, writable: false });
  return i3;
}
function bytesToString(e3) {
  "object" == typeof e3 && void 0 !== (e3 == null ? void 0 : e3.length) || unreachable("Invalid argument for bytesToString");
  const t3 = e3.length, i3 = 8192;
  if (t3 < i3)
    return String.fromCharCode.apply(null, e3);
  const a3 = [];
  for (let s3 = 0; s3 < t3; s3 += i3) {
    const r3 = Math.min(s3 + i3, t3), n3 = e3.subarray(s3, r3);
    a3.push(String.fromCharCode.apply(null, n3));
  }
  return a3.join("");
}
function stringToBytes(e3) {
  "string" != typeof e3 && unreachable("Invalid argument for stringToBytes");
  const t3 = e3.length, i3 = new Uint8Array(t3);
  for (let a3 = 0; a3 < t3; ++a3)
    i3[a3] = 255 & e3.charCodeAt(a3);
  return i3;
}
function string32(e3) {
  return String.fromCharCode(e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3);
}
function objectSize(e3) {
  return Object.keys(e3).length;
}
function stringToPDFString(e3) {
  if (e3[0] >= "ï") {
    let t4;
    if ("þ" === e3[0] && "ÿ" === e3[1]) {
      t4 = "utf-16be";
      e3.length % 2 == 1 && (e3 = e3.slice(0, -1));
    } else if ("ÿ" === e3[0] && "þ" === e3[1]) {
      t4 = "utf-16le";
      e3.length % 2 == 1 && (e3 = e3.slice(0, -1));
    } else
      "ï" === e3[0] && "»" === e3[1] && "¿" === e3[2] && (t4 = "utf-8");
    if (t4)
      try {
        const i3 = new TextDecoder(t4, { fatal: true }), a3 = stringToBytes(e3), s3 = i3.decode(a3);
        return s3.includes("\x1B") ? s3.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "") : s3;
      } catch (e4) {
        warn(`stringToPDFString: "${e4}".`);
      }
  }
  const t3 = [];
  for (let i3 = 0, a3 = e3.length; i3 < a3; i3++) {
    const s3 = e3.charCodeAt(i3);
    if (27 === s3) {
      for (; ++i3 < a3 && 27 !== e3.charCodeAt(i3); )
        ;
      continue;
    }
    const r3 = ot[s3];
    t3.push(r3 ? String.fromCharCode(r3) : e3.charAt(i3));
  }
  return t3.join("");
}
function stringToUTF8String(e3) {
  return decodeURIComponent(escape(e3));
}
function utf8StringToString(e3) {
  return unescape(encodeURIComponent(e3));
}
function isArrayEqual(e3, t3) {
  if (e3.length !== t3.length)
    return false;
  for (let i3 = 0, a3 = e3.length; i3 < a3; i3++)
    if (e3[i3] !== t3[i3])
      return false;
  return true;
}
function getModificationDate(e3 = /* @__PURE__ */ new Date()) {
  return [e3.getUTCFullYear().toString(), (e3.getUTCMonth() + 1).toString().padStart(2, "0"), e3.getUTCDate().toString().padStart(2, "0"), e3.getUTCHours().toString().padStart(2, "0"), e3.getUTCMinutes().toString().padStart(2, "0"), e3.getUTCSeconds().toString().padStart(2, "0")].join("");
}
function isName(e3, t3) {
  return e3 instanceof Name && (void 0 === t3 || e3.name === t3);
}
function isCmd(e3, t3) {
  return e3 instanceof Cmd && (void 0 === t3 || e3.cmd === t3);
}
function isDict(e3, t3) {
  return e3 instanceof Dict && (void 0 === t3 || isName(e3.get("Type"), t3));
}
function isRefsEqual(e3, t3) {
  return e3.num === t3.num && e3.gen === t3.gen;
}
function getLookupTableFactory(e3) {
  let t3;
  return function() {
    if (e3) {
      t3 = /* @__PURE__ */ Object.create(null);
      e3(t3);
      e3 = null;
    }
    return t3;
  };
}
function arrayBuffersToBytes(e3) {
  const t3 = e3.length;
  if (0 === t3)
    return new Uint8Array(0);
  if (1 === t3)
    return new Uint8Array(e3[0]);
  let i3 = 0;
  for (let a4 = 0; a4 < t3; a4++)
    i3 += e3[a4].byteLength;
  const a3 = new Uint8Array(i3);
  let s3 = 0;
  for (let i4 = 0; i4 < t3; i4++) {
    const t4 = new Uint8Array(e3[i4]);
    a3.set(t4, s3);
    s3 += t4.byteLength;
  }
  return a3;
}
function getInheritableProperty({ dict: e3, key: t3, getArray: i3 = false, stopWhenFound: a3 = true }) {
  let s3;
  const r3 = new RefSet();
  for (; e3 instanceof Dict && (!e3.objId || !r3.has(e3.objId)); ) {
    e3.objId && r3.put(e3.objId);
    const n3 = i3 ? e3.getArray(t3) : e3.get(t3);
    if (void 0 !== n3) {
      if (a3)
        return n3;
      (s3 || (s3 = [])).push(n3);
    }
    e3 = e3.get("Parent");
  }
  return s3;
}
function toRomanNumerals(e3, t3 = false) {
  assert(Number.isInteger(e3) && e3 > 0, "The number should be a positive integer.");
  const i3 = [];
  let a3;
  for (; e3 >= 1e3; ) {
    e3 -= 1e3;
    i3.push("M");
  }
  a3 = e3 / 100 | 0;
  e3 %= 100;
  i3.push(Ft[a3]);
  a3 = e3 / 10 | 0;
  e3 %= 10;
  i3.push(Ft[10 + a3]);
  i3.push(Ft[20 + e3]);
  const s3 = i3.join("");
  return t3 ? s3.toLowerCase() : s3;
}
function log2(e3) {
  return e3 <= 0 ? 0 : Math.ceil(Math.log2(e3));
}
function readInt8(e3, t3) {
  return e3[t3] << 24 >> 24;
}
function readUint16(e3, t3) {
  return e3[t3] << 8 | e3[t3 + 1];
}
function readUint32(e3, t3) {
  return (e3[t3] << 24 | e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | e3[t3 + 3]) >>> 0;
}
function isWhiteSpace(e3) {
  return 32 === e3 || 9 === e3 || 13 === e3 || 10 === e3;
}
function isNumberArray(e3, t3) {
  return Array.isArray(e3) && (null === t3 || e3.length === t3) && e3.every((e4) => "number" == typeof e4);
}
function parseXFAPath(e3) {
  const t3 = /(.+)\[(\d+)\]$/;
  return e3.split(".").map((e4) => {
    const i3 = e4.match(t3);
    return i3 ? { name: i3[1], pos: parseInt(i3[2], 10) } : { name: e4, pos: 0 };
  });
}
function escapePDFName(e3) {
  const t3 = [];
  let i3 = 0;
  for (let a3 = 0, s3 = e3.length; a3 < s3; a3++) {
    const s4 = e3.charCodeAt(a3);
    if (s4 < 33 || s4 > 126 || 35 === s4 || 40 === s4 || 41 === s4 || 60 === s4 || 62 === s4 || 91 === s4 || 93 === s4 || 123 === s4 || 125 === s4 || 47 === s4 || 37 === s4) {
      i3 < a3 && t3.push(e3.substring(i3, a3));
      t3.push(`#${s4.toString(16)}`);
      i3 = a3 + 1;
    }
  }
  if (0 === t3.length)
    return e3;
  i3 < e3.length && t3.push(e3.substring(i3, e3.length));
  return t3.join("");
}
function escapeString(e3) {
  return e3.replaceAll(/([()\\\n\r])/g, (e4) => "\n" === e4 ? "\\n" : "\r" === e4 ? "\\r" : `\\${e4}`);
}
function _collectJS(e3, t3, i3, a3) {
  if (!e3)
    return;
  let s3 = null;
  if (e3 instanceof Ref) {
    if (a3.has(e3))
      return;
    s3 = e3;
    a3.put(s3);
    e3 = t3.fetch(e3);
  }
  if (Array.isArray(e3))
    for (const s4 of e3)
      _collectJS(s4, t3, i3, a3);
  else if (e3 instanceof Dict) {
    if (isName(e3.get("S"), "JavaScript")) {
      const t4 = e3.get("JS");
      let a4;
      t4 instanceof BaseStream ? a4 = t4.getString() : "string" == typeof t4 && (a4 = t4);
      a4 && (a4 = stringToPDFString(a4).replaceAll("\0", ""));
      a4 && i3.push(a4);
    }
    _collectJS(e3.getRaw("Next"), t3, i3, a3);
  }
  s3 && a3.remove(s3);
}
function collectActions(e3, t3, i3) {
  const a3 = /* @__PURE__ */ Object.create(null), s3 = getInheritableProperty({ dict: t3, key: "AA", stopWhenFound: false });
  if (s3)
    for (let t4 = s3.length - 1; t4 >= 0; t4--) {
      const r3 = s3[t4];
      if (r3 instanceof Dict)
        for (const t5 of r3.getKeys()) {
          const s4 = i3[t5];
          if (!s4)
            continue;
          const n3 = [];
          _collectJS(r3.getRaw(t5), e3, n3, new RefSet());
          n3.length > 0 && (a3[s4] = n3);
        }
    }
  if (t3.has("A")) {
    const i4 = [];
    _collectJS(t3.get("A"), e3, i4, new RefSet());
    i4.length > 0 && (a3.Action = i4);
  }
  return objectSize(a3) > 0 ? a3 : null;
}
function* codePointIter(e3) {
  for (let t3 = 0, i3 = e3.length; t3 < i3; t3++) {
    const i4 = e3.codePointAt(t3);
    i4 > 55295 && (i4 < 57344 || i4 > 65533) && t3++;
    yield i4;
  }
}
function encodeToXmlString(e3) {
  const t3 = [];
  let i3 = 0;
  for (let a3 = 0, s3 = e3.length; a3 < s3; a3++) {
    const s4 = e3.codePointAt(a3);
    if (32 <= s4 && s4 <= 126) {
      const r3 = St[s4];
      if (r3) {
        i3 < a3 && t3.push(e3.substring(i3, a3));
        t3.push(r3);
        i3 = a3 + 1;
      }
    } else {
      i3 < a3 && t3.push(e3.substring(i3, a3));
      t3.push(`&#x${s4.toString(16).toUpperCase()};`);
      s4 > 55295 && (s4 < 57344 || s4 > 65533) && a3++;
      i3 = a3 + 1;
    }
  }
  if (0 === t3.length)
    return e3;
  i3 < e3.length && t3.push(e3.substring(i3, e3.length));
  return t3.join("");
}
function validateFontName(e3, t3 = false) {
  const i3 = /^("|').*("|')$/.exec(e3);
  if (i3 && i3[1] === i3[2]) {
    if (new RegExp(`[^\\\\]${i3[1]}`).test(e3.slice(1, -1))) {
      t3 && warn(`FontFamily contains unescaped ${i3[1]}: ${e3}.`);
      return false;
    }
  } else
    for (const i4 of e3.split(/[ \t]+/))
      if (/^(\d|(-(\d|-)))/.test(i4) || !/^[\w-\\]+$/.test(i4)) {
        t3 && warn(`FontFamily contains invalid <custom-ident>: ${e3}.`);
        return false;
      }
  return true;
}
function validateCSSFont(e3) {
  const t3 = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: i3, fontWeight: a3, italicAngle: s3 } = e3;
  if (!validateFontName(i3, true))
    return false;
  const r3 = a3 ? a3.toString() : "";
  e3.fontWeight = t3.has(r3) ? r3 : "400";
  const n3 = parseFloat(s3);
  e3.italicAngle = isNaN(n3) || n3 < -90 || n3 > 90 ? "14" : s3.toString();
  return true;
}
function recoverJsURL(e3) {
  const t3 = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e3);
  if (t3 == null ? void 0 : t3[2]) {
    const e4 = t3[2];
    let i3 = false;
    "true" === t3[3] && "app.launchURL" === t3[1] && (i3 = true);
    return { url: e4, newWindow: i3 };
  }
  return null;
}
function numberToString(e3) {
  if (Number.isInteger(e3))
    return e3.toString();
  const t3 = Math.round(100 * e3);
  return t3 % 100 == 0 ? (t3 / 100).toString() : t3 % 10 == 0 ? e3.toFixed(1) : e3.toFixed(2);
}
function getNewAnnotationsMap(e3) {
  if (!e3)
    return null;
  const t3 = /* @__PURE__ */ new Map();
  for (const [i3, a3] of e3) {
    if (!i3.startsWith(E2))
      continue;
    let e4 = t3.get(a3.pageIndex);
    if (!e4) {
      e4 = [];
      t3.set(a3.pageIndex, e4);
    }
    e4.push(a3);
  }
  return t3.size > 0 ? t3 : null;
}
function isAscii(e3) {
  return /^[\x00-\x7F]*$/.test(e3);
}
function stringToUTF16HexString(e3) {
  const t3 = [];
  for (let i3 = 0, a3 = e3.length; i3 < a3; i3++) {
    const a4 = e3.charCodeAt(i3);
    t3.push((a4 >> 8 & 255).toString(16).padStart(2, "0"), (255 & a4).toString(16).padStart(2, "0"));
  }
  return t3.join("");
}
function stringToUTF16String(e3, t3 = false) {
  const i3 = [];
  t3 && i3.push("þÿ");
  for (let t4 = 0, a3 = e3.length; t4 < a3; t4++) {
    const a4 = e3.charCodeAt(t4);
    i3.push(String.fromCharCode(a4 >> 8 & 255), String.fromCharCode(255 & a4));
  }
  return i3.join("");
}
function getRotationMatrix(e3, t3, i3) {
  switch (e3) {
    case 90:
      return [0, 1, -1, 0, t3, 0];
    case 180:
      return [-1, 0, 0, -1, t3, i3];
    case 270:
      return [0, -1, 1, 0, 0, i3];
    default:
      throw new Error("Invalid rotation");
  }
}
function getSizeInBytes(e3) {
  return Math.ceil(Math.ceil(Math.log2(1 + e3)) / 8);
}
function hexToInt(e3, t3) {
  let i3 = 0;
  for (let a3 = 0; a3 <= t3; a3++)
    i3 = i3 << 8 | e3[a3];
  return i3 >>> 0;
}
function hexToStr(e3, t3) {
  return 1 === t3 ? String.fromCharCode(e3[0], e3[1]) : 3 === t3 ? String.fromCharCode(e3[0], e3[1], e3[2], e3[3]) : String.fromCharCode(...e3.subarray(0, t3 + 1));
}
function addHex(e3, t3, i3) {
  let a3 = 0;
  for (let s3 = i3; s3 >= 0; s3--) {
    a3 += e3[s3] + t3[s3];
    e3[s3] = 255 & a3;
    a3 >>= 8;
  }
}
function incHex(e3, t3) {
  let i3 = 1;
  for (let a3 = t3; a3 >= 0 && i3 > 0; a3--) {
    i3 += e3[a3];
    e3[a3] = 255 & i3;
    i3 >>= 8;
  }
}
function decodeInteger(e3, t3, i3) {
  const a3 = e3.getContexts(t3);
  let s3 = 1;
  function readBits(e4) {
    let t4 = 0;
    for (let r4 = 0; r4 < e4; r4++) {
      const e5 = i3.readBit(a3, s3);
      s3 = s3 < 256 ? s3 << 1 | e5 : 511 & (s3 << 1 | e5) | 256;
      t4 = t4 << 1 | e5;
    }
    return t4 >>> 0;
  }
  const r3 = readBits(1), n3 = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  let o3;
  0 === r3 ? o3 = n3 : n3 > 0 && (o3 = -n3);
  return o3 >= Pt && o3 <= Ot ? o3 : null;
}
function decodeIAID(e3, t3, i3) {
  const a3 = e3.getContexts("IAID");
  let s3 = 1;
  for (let e4 = 0; e4 < i3; e4++) {
    s3 = s3 << 1 | t3.readBit(a3, s3);
  }
  return i3 < 31 ? s3 & (1 << i3) - 1 : 2147483647 & s3;
}
function decodeBitmap(e3, t3, i3, a3, s3, r3, n3, o3) {
  if (e3) {
    return decodeMMRBitmap(new Reader(o3.data, o3.start, o3.end), t3, i3, false);
  }
  if (0 === a3 && !r3 && !s3 && 4 === n3.length && 3 === n3[0].x && -1 === n3[0].y && -3 === n3[1].x && -1 === n3[1].y && 2 === n3[2].x && -2 === n3[2].y && -2 === n3[3].x && -2 === n3[3].y)
    return function decodeBitmapTemplate0(e4, t4, i4) {
      const a4 = i4.decoder, s4 = i4.contextCache.getContexts("GB"), r4 = [];
      let n4, o4, g4, c4, C4, h3, l4;
      for (o4 = 0; o4 < t4; o4++) {
        C4 = r4[o4] = new Uint8Array(e4);
        h3 = o4 < 1 ? C4 : r4[o4 - 1];
        l4 = o4 < 2 ? C4 : r4[o4 - 2];
        n4 = l4[0] << 13 | l4[1] << 12 | l4[2] << 11 | h3[0] << 7 | h3[1] << 6 | h3[2] << 5 | h3[3] << 4;
        for (g4 = 0; g4 < e4; g4++) {
          C4[g4] = c4 = a4.readBit(s4, n4);
          n4 = (31735 & n4) << 1 | (g4 + 3 < e4 ? l4[g4 + 3] << 11 : 0) | (g4 + 4 < e4 ? h3[g4 + 4] << 4 : 0) | c4;
        }
      }
      return r4;
    }(t3, i3, o3);
  const g3 = !!r3, c3 = jt[a3].concat(n3);
  c3.sort(function(e4, t4) {
    return e4.y - t4.y || e4.x - t4.x;
  });
  const C3 = c3.length, h2 = new Int8Array(C3), l3 = new Int8Array(C3), Q3 = [];
  let E3, u3, d3 = 0, f2 = 0, p2 = 0, m3 = 0;
  for (u3 = 0; u3 < C3; u3++) {
    h2[u3] = c3[u3].x;
    l3[u3] = c3[u3].y;
    f2 = Math.min(f2, c3[u3].x);
    p2 = Math.max(p2, c3[u3].x);
    m3 = Math.min(m3, c3[u3].y);
    u3 < C3 - 1 && c3[u3].y === c3[u3 + 1].y && c3[u3].x === c3[u3 + 1].x - 1 ? d3 |= 1 << C3 - 1 - u3 : Q3.push(u3);
  }
  const y3 = Q3.length, w3 = new Int8Array(y3), b3 = new Int8Array(y3), D3 = new Uint16Array(y3);
  for (E3 = 0; E3 < y3; E3++) {
    u3 = Q3[E3];
    w3[E3] = c3[u3].x;
    b3[E3] = c3[u3].y;
    D3[E3] = 1 << C3 - 1 - u3;
  }
  const F3 = -f2, S3 = -m3, k3 = t3 - p2, N3 = Zt[a3];
  let R3 = new Uint8Array(t3);
  const G3 = [], x3 = o3.decoder, U3 = o3.contextCache.getContexts("GB");
  let M3, L3, H3, J3, Y3, v3 = 0, K3 = 0;
  for (let e4 = 0; e4 < i3; e4++) {
    if (s3) {
      v3 ^= x3.readBit(U3, N3);
      if (v3) {
        G3.push(R3);
        continue;
      }
    }
    R3 = new Uint8Array(R3);
    G3.push(R3);
    for (M3 = 0; M3 < t3; M3++) {
      if (g3 && r3[e4][M3]) {
        R3[M3] = 0;
        continue;
      }
      if (M3 >= F3 && M3 < k3 && e4 >= S3) {
        K3 = K3 << 1 & d3;
        for (u3 = 0; u3 < y3; u3++) {
          L3 = e4 + b3[u3];
          H3 = M3 + w3[u3];
          J3 = G3[L3][H3];
          if (J3) {
            J3 = D3[u3];
            K3 |= J3;
          }
        }
      } else {
        K3 = 0;
        Y3 = C3 - 1;
        for (u3 = 0; u3 < C3; u3++, Y3--) {
          H3 = M3 + h2[u3];
          if (H3 >= 0 && H3 < t3) {
            L3 = e4 + l3[u3];
            if (L3 >= 0) {
              J3 = G3[L3][H3];
              J3 && (K3 |= J3 << Y3);
            }
          }
        }
      }
      const i4 = x3.readBit(U3, K3);
      R3[M3] = i4;
    }
  }
  return G3;
}
function decodeRefinement(e3, t3, i3, a3, s3, r3, n3, o3, g3) {
  let c3 = Xt[i3].coding;
  0 === i3 && (c3 = c3.concat([o3[0]]));
  const C3 = c3.length, h2 = new Int32Array(C3), l3 = new Int32Array(C3);
  let Q3;
  for (Q3 = 0; Q3 < C3; Q3++) {
    h2[Q3] = c3[Q3].x;
    l3[Q3] = c3[Q3].y;
  }
  let E3 = Xt[i3].reference;
  0 === i3 && (E3 = E3.concat([o3[1]]));
  const u3 = E3.length, d3 = new Int32Array(u3), f2 = new Int32Array(u3);
  for (Q3 = 0; Q3 < u3; Q3++) {
    d3[Q3] = E3[Q3].x;
    f2[Q3] = E3[Q3].y;
  }
  const p2 = a3[0].length, m3 = a3.length, y3 = Vt[i3], w3 = [], b3 = g3.decoder, D3 = g3.contextCache.getContexts("GR");
  let F3 = 0;
  for (let i4 = 0; i4 < t3; i4++) {
    if (n3) {
      F3 ^= b3.readBit(D3, y3);
      if (F3)
        throw new Jbig2Error("prediction is not supported");
    }
    const t4 = new Uint8Array(e3);
    w3.push(t4);
    for (let n4 = 0; n4 < e3; n4++) {
      let o4, g4, c4 = 0;
      for (Q3 = 0; Q3 < C3; Q3++) {
        o4 = i4 + l3[Q3];
        g4 = n4 + h2[Q3];
        o4 < 0 || g4 < 0 || g4 >= e3 ? c4 <<= 1 : c4 = c4 << 1 | w3[o4][g4];
      }
      for (Q3 = 0; Q3 < u3; Q3++) {
        o4 = i4 + f2[Q3] - r3;
        g4 = n4 + d3[Q3] - s3;
        o4 < 0 || o4 >= m3 || g4 < 0 || g4 >= p2 ? c4 <<= 1 : c4 = c4 << 1 | a3[o4][g4];
      }
      const E4 = b3.readBit(D3, c4);
      t4[n4] = E4;
    }
  }
  return w3;
}
function decodeTextRegion(e3, t3, i3, a3, s3, r3, n3, o3, g3, c3, C3, h2, l3, Q3, E3, u3, d3, f2, p2) {
  if (e3 && t3)
    throw new Jbig2Error("refinement with Huffman is not supported");
  const m3 = [];
  let y3, w3;
  for (y3 = 0; y3 < a3; y3++) {
    w3 = new Uint8Array(i3);
    if (s3)
      for (let e4 = 0; e4 < i3; e4++)
        w3[e4] = s3;
    m3.push(w3);
  }
  const b3 = d3.decoder, D3 = d3.contextCache;
  let F3 = e3 ? -Q3.tableDeltaT.decode(p2) : -decodeInteger(D3, "IADT", b3), S3 = 0;
  y3 = 0;
  for (; y3 < r3; ) {
    F3 += e3 ? Q3.tableDeltaT.decode(p2) : decodeInteger(D3, "IADT", b3);
    S3 += e3 ? Q3.tableFirstS.decode(p2) : decodeInteger(D3, "IAFS", b3);
    let a4 = S3;
    for (; ; ) {
      let s4 = 0;
      n3 > 1 && (s4 = e3 ? p2.readBits(f2) : decodeInteger(D3, "IAIT", b3));
      const r4 = n3 * F3 + s4, S4 = e3 ? Q3.symbolIDTable.decode(p2) : decodeIAID(D3, b3, g3), k3 = t3 && (e3 ? p2.readBit() : decodeInteger(D3, "IARI", b3));
      let N3 = o3[S4], R3 = N3[0].length, G3 = N3.length;
      if (k3) {
        const e4 = decodeInteger(D3, "IARDW", b3), t4 = decodeInteger(D3, "IARDH", b3);
        R3 += e4;
        G3 += t4;
        N3 = decodeRefinement(R3, G3, E3, N3, (e4 >> 1) + decodeInteger(D3, "IARDX", b3), (t4 >> 1) + decodeInteger(D3, "IARDY", b3), false, u3, d3);
      }
      let x3 = 0;
      c3 ? 1 & h2 ? x3 = G3 - 1 : a4 += G3 - 1 : h2 > 1 ? a4 += R3 - 1 : x3 = R3 - 1;
      const U3 = r4 - (1 & h2 ? 0 : G3 - 1), M3 = a4 - (2 & h2 ? R3 - 1 : 0);
      let L3, H3, J3;
      if (c3)
        for (L3 = 0; L3 < G3; L3++) {
          w3 = m3[M3 + L3];
          if (!w3)
            continue;
          J3 = N3[L3];
          const e4 = Math.min(i3 - U3, R3);
          switch (l3) {
            case 0:
              for (H3 = 0; H3 < e4; H3++)
                w3[U3 + H3] |= J3[H3];
              break;
            case 2:
              for (H3 = 0; H3 < e4; H3++)
                w3[U3 + H3] ^= J3[H3];
              break;
            default:
              throw new Jbig2Error(`operator ${l3} is not supported`);
          }
        }
      else
        for (H3 = 0; H3 < G3; H3++) {
          w3 = m3[U3 + H3];
          if (w3) {
            J3 = N3[H3];
            switch (l3) {
              case 0:
                for (L3 = 0; L3 < R3; L3++)
                  w3[M3 + L3] |= J3[L3];
                break;
              case 2:
                for (L3 = 0; L3 < R3; L3++)
                  w3[M3 + L3] ^= J3[L3];
                break;
              default:
                throw new Jbig2Error(`operator ${l3} is not supported`);
            }
          }
        }
      y3++;
      const Y3 = e3 ? Q3.tableDeltaS.decode(p2) : decodeInteger(D3, "IADS", b3);
      if (null === Y3)
        break;
      a4 += x3 + Y3 + C3;
    }
  }
  return m3;
}
function readSegmentHeader(e3, t3) {
  const i3 = {};
  i3.number = readUint32(e3, t3);
  const a3 = e3[t3 + 4], s3 = 63 & a3;
  if (!Wt[s3])
    throw new Jbig2Error("invalid segment type: " + s3);
  i3.type = s3;
  i3.typeName = Wt[s3];
  i3.deferredNonRetain = !!(128 & a3);
  const r3 = !!(64 & a3), n3 = e3[t3 + 5];
  let o3 = n3 >> 5 & 7;
  const g3 = [31 & n3];
  let c3 = t3 + 6;
  if (7 === n3) {
    o3 = 536870911 & readUint32(e3, c3 - 1);
    c3 += 3;
    let t4 = o3 + 7 >> 3;
    g3[0] = e3[c3++];
    for (; --t4 > 0; )
      g3.push(e3[c3++]);
  } else if (5 === n3 || 6 === n3)
    throw new Jbig2Error("invalid referred-to flags");
  i3.retainBits = g3;
  let C3 = 4;
  i3.number <= 256 ? C3 = 1 : i3.number <= 65536 && (C3 = 2);
  const h2 = [];
  let l3, Q3;
  for (l3 = 0; l3 < o3; l3++) {
    let t4;
    t4 = 1 === C3 ? e3[c3] : 2 === C3 ? readUint16(e3, c3) : readUint32(e3, c3);
    h2.push(t4);
    c3 += C3;
  }
  i3.referredTo = h2;
  if (r3) {
    i3.pageAssociation = readUint32(e3, c3);
    c3 += 4;
  } else
    i3.pageAssociation = e3[c3++];
  i3.length = readUint32(e3, c3);
  c3 += 4;
  if (4294967295 === i3.length) {
    if (38 !== s3)
      throw new Jbig2Error("invalid unknown segment length");
    {
      const t4 = readRegionSegmentInformation(e3, c3), a4 = !!(1 & e3[c3 + zt]), s4 = 6, r4 = new Uint8Array(s4);
      if (!a4) {
        r4[0] = 255;
        r4[1] = 172;
      }
      r4[2] = t4.height >>> 24 & 255;
      r4[3] = t4.height >> 16 & 255;
      r4[4] = t4.height >> 8 & 255;
      r4[5] = 255 & t4.height;
      for (l3 = c3, Q3 = e3.length; l3 < Q3; l3++) {
        let t5 = 0;
        for (; t5 < s4 && r4[t5] === e3[l3 + t5]; )
          t5++;
        if (t5 === s4) {
          i3.length = l3 + s4;
          break;
        }
      }
      if (4294967295 === i3.length)
        throw new Jbig2Error("segment end was not found");
    }
  }
  i3.headerEnd = c3;
  return i3;
}
function readSegments(e3, t3, i3, a3) {
  const s3 = [];
  let r3 = i3;
  for (; r3 < a3; ) {
    const i4 = readSegmentHeader(t3, r3);
    r3 = i4.headerEnd;
    const a4 = { header: i4, data: t3 };
    if (!e3.randomAccess) {
      a4.start = r3;
      r3 += i4.length;
      a4.end = r3;
    }
    s3.push(a4);
    if (51 === i4.type)
      break;
  }
  if (e3.randomAccess)
    for (let e4 = 0, t4 = s3.length; e4 < t4; e4++) {
      s3[e4].start = r3;
      r3 += s3[e4].header.length;
      s3[e4].end = r3;
    }
  return s3;
}
function readRegionSegmentInformation(e3, t3) {
  return { width: readUint32(e3, t3), height: readUint32(e3, t3 + 4), x: readUint32(e3, t3 + 8), y: readUint32(e3, t3 + 12), combinationOperator: 7 & e3[t3 + 16] };
}
function processSegment(e3, t3) {
  const i3 = e3.header, a3 = e3.data, s3 = e3.end;
  let r3, n3, o3, g3, c3 = e3.start;
  switch (i3.type) {
    case 0:
      const e4 = {}, t4 = readUint16(a3, c3);
      e4.huffman = !!(1 & t4);
      e4.refinement = !!(2 & t4);
      e4.huffmanDHSelector = t4 >> 2 & 3;
      e4.huffmanDWSelector = t4 >> 4 & 3;
      e4.bitmapSizeSelector = t4 >> 6 & 1;
      e4.aggregationInstancesSelector = t4 >> 7 & 1;
      e4.bitmapCodingContextUsed = !!(256 & t4);
      e4.bitmapCodingContextRetained = !!(512 & t4);
      e4.template = t4 >> 10 & 3;
      e4.refinementTemplate = t4 >> 12 & 1;
      c3 += 2;
      if (!e4.huffman) {
        g3 = 0 === e4.template ? 4 : 1;
        n3 = [];
        for (o3 = 0; o3 < g3; o3++) {
          n3.push({ x: readInt8(a3, c3), y: readInt8(a3, c3 + 1) });
          c3 += 2;
        }
        e4.at = n3;
      }
      if (e4.refinement && !e4.refinementTemplate) {
        n3 = [];
        for (o3 = 0; o3 < 2; o3++) {
          n3.push({ x: readInt8(a3, c3), y: readInt8(a3, c3 + 1) });
          c3 += 2;
        }
        e4.refinementAt = n3;
      }
      e4.numberOfExportedSymbols = readUint32(a3, c3);
      c3 += 4;
      e4.numberOfNewSymbols = readUint32(a3, c3);
      c3 += 4;
      r3 = [e4, i3.number, i3.referredTo, a3, c3, s3];
      break;
    case 6:
    case 7:
      const C4 = {};
      C4.info = readRegionSegmentInformation(a3, c3);
      c3 += zt;
      const h2 = readUint16(a3, c3);
      c3 += 2;
      C4.huffman = !!(1 & h2);
      C4.refinement = !!(2 & h2);
      C4.logStripSize = h2 >> 2 & 3;
      C4.stripSize = 1 << C4.logStripSize;
      C4.referenceCorner = h2 >> 4 & 3;
      C4.transposed = !!(64 & h2);
      C4.combinationOperator = h2 >> 7 & 3;
      C4.defaultPixelValue = h2 >> 9 & 1;
      C4.dsOffset = h2 << 17 >> 27;
      C4.refinementTemplate = h2 >> 15 & 1;
      if (C4.huffman) {
        const e5 = readUint16(a3, c3);
        c3 += 2;
        C4.huffmanFS = 3 & e5;
        C4.huffmanDS = e5 >> 2 & 3;
        C4.huffmanDT = e5 >> 4 & 3;
        C4.huffmanRefinementDW = e5 >> 6 & 3;
        C4.huffmanRefinementDH = e5 >> 8 & 3;
        C4.huffmanRefinementDX = e5 >> 10 & 3;
        C4.huffmanRefinementDY = e5 >> 12 & 3;
        C4.huffmanRefinementSizeSelector = !!(16384 & e5);
      }
      if (C4.refinement && !C4.refinementTemplate) {
        n3 = [];
        for (o3 = 0; o3 < 2; o3++) {
          n3.push({ x: readInt8(a3, c3), y: readInt8(a3, c3 + 1) });
          c3 += 2;
        }
        C4.refinementAt = n3;
      }
      C4.numberOfSymbolInstances = readUint32(a3, c3);
      c3 += 4;
      r3 = [C4, i3.referredTo, a3, c3, s3];
      break;
    case 16:
      const l3 = {}, Q3 = a3[c3++];
      l3.mmr = !!(1 & Q3);
      l3.template = Q3 >> 1 & 3;
      l3.patternWidth = a3[c3++];
      l3.patternHeight = a3[c3++];
      l3.maxPatternIndex = readUint32(a3, c3);
      c3 += 4;
      r3 = [l3, i3.number, a3, c3, s3];
      break;
    case 22:
    case 23:
      const E3 = {};
      E3.info = readRegionSegmentInformation(a3, c3);
      c3 += zt;
      const u3 = a3[c3++];
      E3.mmr = !!(1 & u3);
      E3.template = u3 >> 1 & 3;
      E3.enableSkip = !!(8 & u3);
      E3.combinationOperator = u3 >> 4 & 7;
      E3.defaultPixelValue = u3 >> 7 & 1;
      E3.gridWidth = readUint32(a3, c3);
      c3 += 4;
      E3.gridHeight = readUint32(a3, c3);
      c3 += 4;
      E3.gridOffsetX = 4294967295 & readUint32(a3, c3);
      c3 += 4;
      E3.gridOffsetY = 4294967295 & readUint32(a3, c3);
      c3 += 4;
      E3.gridVectorX = readUint16(a3, c3);
      c3 += 2;
      E3.gridVectorY = readUint16(a3, c3);
      c3 += 2;
      r3 = [E3, i3.referredTo, a3, c3, s3];
      break;
    case 38:
    case 39:
      const d3 = {};
      d3.info = readRegionSegmentInformation(a3, c3);
      c3 += zt;
      const f2 = a3[c3++];
      d3.mmr = !!(1 & f2);
      d3.template = f2 >> 1 & 3;
      d3.prediction = !!(8 & f2);
      if (!d3.mmr) {
        g3 = 0 === d3.template ? 4 : 1;
        n3 = [];
        for (o3 = 0; o3 < g3; o3++) {
          n3.push({ x: readInt8(a3, c3), y: readInt8(a3, c3 + 1) });
          c3 += 2;
        }
        d3.at = n3;
      }
      r3 = [d3, a3, c3, s3];
      break;
    case 48:
      const p2 = { width: readUint32(a3, c3), height: readUint32(a3, c3 + 4), resolutionX: readUint32(a3, c3 + 8), resolutionY: readUint32(a3, c3 + 12) };
      4294967295 === p2.height && delete p2.height;
      const m3 = a3[c3 + 16];
      readUint16(a3, c3 + 17);
      p2.lossless = !!(1 & m3);
      p2.refinement = !!(2 & m3);
      p2.defaultPixelValue = m3 >> 2 & 1;
      p2.combinationOperator = m3 >> 3 & 3;
      p2.requiresBuffer = !!(32 & m3);
      p2.combinationOperatorOverride = !!(64 & m3);
      r3 = [p2];
      break;
    case 49:
    case 50:
    case 51:
    case 62:
      break;
    case 53:
      r3 = [i3.number, a3, c3, s3];
      break;
    default:
      throw new Jbig2Error(`segment type ${i3.typeName}(${i3.type}) is not implemented`);
  }
  const C3 = "on" + i3.typeName;
  C3 in t3 && t3[C3].apply(t3, r3);
}
function processSegments(e3, t3) {
  for (let i3 = 0, a3 = e3.length; i3 < a3; i3++)
    processSegment(e3[i3], t3);
}
function getStandardTable(e3) {
  let t3, i3 = _t5[e3];
  if (i3)
    return i3;
  switch (e3) {
    case 1:
      t3 = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      t3 = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      t3 = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      t3 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      t3 = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      t3 = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      t3 = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      t3 = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      t3 = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      t3 = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      t3 = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      t3 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      t3 = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      t3 = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      t3 = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new Jbig2Error(`standard table B.${e3} does not exist`);
  }
  for (let e4 = 0, i4 = t3.length; e4 < i4; e4++)
    t3[e4] = new HuffmanLine(t3[e4]);
  i3 = new HuffmanTable(t3, true);
  _t5[e3] = i3;
  return i3;
}
function getCustomHuffmanTable(e3, t3, i3) {
  let a3 = 0;
  for (let s3 = 0, r3 = t3.length; s3 < r3; s3++) {
    const r4 = i3[t3[s3]];
    if (r4) {
      if (e3 === a3)
        return r4;
      a3++;
    }
  }
  throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e3, t3, i3) {
  const a3 = [];
  for (let s3 = 0; s3 < i3; s3++) {
    const i4 = new Uint8Array(t3);
    a3.push(i4);
    for (let a4 = 0; a4 < t3; a4++)
      i4[a4] = e3.readBit();
    e3.byteAlign();
  }
  return a3;
}
function decodeMMRBitmap(e3, t3, i3, a3) {
  const s3 = new CCITTFaxDecoder(e3, { K: -1, Columns: t3, Rows: i3, BlackIs1: true, EndOfBlock: a3 }), r3 = [];
  let n3, o3 = false;
  for (let e4 = 0; e4 < i3; e4++) {
    const e5 = new Uint8Array(t3);
    r3.push(e5);
    let i4 = -1;
    for (let a4 = 0; a4 < t3; a4++) {
      if (i4 < 0) {
        n3 = s3.readNextChar();
        if (-1 === n3) {
          n3 = 0;
          o3 = true;
        }
        i4 = 7;
      }
      e5[a4] = n3 >> i4 & 1;
      i4--;
    }
  }
  if (a3 && !o3) {
    const e4 = 5;
    for (let t4 = 0; t4 < e4 && -1 !== s3.readNextChar(); t4++)
      ;
  }
  return r3;
}
function convertToRGBA(e3) {
  switch (e3.kind) {
    case b2:
      return convertBlackAndWhiteToRGBA(e3);
    case D2:
      return function convertRGBToRGBA({ src: e4, srcPos: t3 = 0, dest: i3, destPos: a3 = 0, width: s3, height: r3 }) {
        let n3 = 0;
        const o3 = e4.length >> 2, g3 = new Uint32Array(e4.buffer, t3, o3);
        if (FeatureTest.isLittleEndian) {
          for (; n3 < o3 - 2; n3 += 3, a3 += 4) {
            const e5 = g3[n3], t4 = g3[n3 + 1], s4 = g3[n3 + 2];
            i3[a3] = 4278190080 | e5;
            i3[a3 + 1] = e5 >>> 24 | t4 << 8 | 4278190080;
            i3[a3 + 2] = t4 >>> 16 | s4 << 16 | 4278190080;
            i3[a3 + 3] = s4 >>> 8 | 4278190080;
          }
          for (let t4 = 4 * n3, s4 = e4.length; t4 < s4; t4 += 3)
            i3[a3++] = e4[t4] | e4[t4 + 1] << 8 | e4[t4 + 2] << 16 | 4278190080;
        } else {
          for (; n3 < o3 - 2; n3 += 3, a3 += 4) {
            const e5 = g3[n3], t4 = g3[n3 + 1], s4 = g3[n3 + 2];
            i3[a3] = 255 | e5;
            i3[a3 + 1] = e5 << 24 | t4 >>> 8 | 255;
            i3[a3 + 2] = t4 << 16 | s4 >>> 16 | 255;
            i3[a3 + 3] = s4 << 8 | 255;
          }
          for (let t4 = 4 * n3, s4 = e4.length; t4 < s4; t4 += 3)
            i3[a3++] = e4[t4] << 24 | e4[t4 + 1] << 16 | e4[t4 + 2] << 8 | 255;
        }
        return { srcPos: t3, destPos: a3 };
      }(e3);
  }
  return null;
}
function convertBlackAndWhiteToRGBA({ src: e3, srcPos: t3 = 0, dest: i3, width: a3, height: s3, nonBlackColor: r3 = 4294967295, inverseDecode: n3 = false }) {
  const o3 = FeatureTest.isLittleEndian ? 4278190080 : 255, [g3, c3] = n3 ? [r3, o3] : [o3, r3], C3 = a3 >> 3, h2 = 7 & a3, l3 = e3.length;
  i3 = new Uint32Array(i3.buffer);
  let Q3 = 0;
  for (let a4 = 0; a4 < s3; a4++) {
    for (const a6 = t3 + C3; t3 < a6; t3++) {
      const a7 = t3 < l3 ? e3[t3] : 255;
      i3[Q3++] = 128 & a7 ? c3 : g3;
      i3[Q3++] = 64 & a7 ? c3 : g3;
      i3[Q3++] = 32 & a7 ? c3 : g3;
      i3[Q3++] = 16 & a7 ? c3 : g3;
      i3[Q3++] = 8 & a7 ? c3 : g3;
      i3[Q3++] = 4 & a7 ? c3 : g3;
      i3[Q3++] = 2 & a7 ? c3 : g3;
      i3[Q3++] = 1 & a7 ? c3 : g3;
    }
    if (0 === h2)
      continue;
    const a5 = t3 < l3 ? e3[t3++] : 255;
    for (let e4 = 0; e4 < h2; e4++)
      i3[Q3++] = a5 & 1 << 7 - e4 ? c3 : g3;
  }
  return { srcPos: t3, destPos: Q3 };
}
function buildHuffmanTable(e3, t3) {
  let i3, a3, s3 = 0, r3 = 16;
  for (; r3 > 0 && !e3[r3 - 1]; )
    r3--;
  const n3 = [{ children: [], index: 0 }];
  let o3, g3 = n3[0];
  for (i3 = 0; i3 < r3; i3++) {
    for (a3 = 0; a3 < e3[i3]; a3++) {
      g3 = n3.pop();
      g3.children[g3.index] = t3[s3];
      for (; g3.index > 0; )
        g3 = n3.pop();
      g3.index++;
      n3.push(g3);
      for (; n3.length <= i3; ) {
        n3.push(o3 = { children: [], index: 0 });
        g3.children[g3.index] = o3.children;
        g3 = o3;
      }
      s3++;
    }
    if (i3 + 1 < r3) {
      n3.push(o3 = { children: [], index: 0 });
      g3.children[g3.index] = o3.children;
      g3 = o3;
    }
  }
  return n3[0].children;
}
function getBlockBufferOffset(e3, t3, i3) {
  return 64 * ((e3.blocksPerLine + 1) * t3 + i3);
}
function decodeScan(e3, t3, i3, a3, s3, r3, n3, o3, g3, c3 = false) {
  const C3 = i3.mcusPerLine, h2 = i3.progressive, l3 = t3;
  let Q3 = 0, E3 = 0;
  function readBit() {
    if (E3 > 0) {
      E3--;
      return Q3 >> E3 & 1;
    }
    Q3 = e3[t3++];
    if (255 === Q3) {
      const a4 = e3[t3++];
      if (a4) {
        if (220 === a4 && c3) {
          const a5 = readUint16(e3, t3 += 2);
          t3 += 2;
          if (a5 > 0 && a5 !== i3.scanLines)
            throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", a5);
        } else if (217 === a4) {
          if (c3) {
            const e4 = p2 * (8 === i3.precision ? 8 : 0);
            if (e4 > 0 && Math.round(i3.scanLines / e4) >= 5)
              throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e4);
          }
          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new JpegError(`unexpected marker ${(Q3 << 8 | a4).toString(16)}`);
      }
    }
    E3 = 7;
    return Q3 >>> 7;
  }
  function decodeHuffman(e4) {
    let t4 = e4;
    for (; ; ) {
      t4 = t4[readBit()];
      switch (typeof t4) {
        case "number":
          return t4;
        case "object":
          continue;
      }
      throw new JpegError("invalid huffman sequence");
    }
  }
  function receive(e4) {
    let t4 = 0;
    for (; e4 > 0; ) {
      t4 = t4 << 1 | readBit();
      e4--;
    }
    return t4;
  }
  function receiveAndExtend(e4) {
    if (1 === e4)
      return 1 === readBit() ? 1 : -1;
    const t4 = receive(e4);
    return t4 >= 1 << e4 - 1 ? t4 : t4 + (-1 << e4) + 1;
  }
  let u3 = 0;
  let d3, f2 = 0;
  let p2 = 0;
  function decodeMcu(e4, t4, i4, a4, s4) {
    const r4 = i4 % C3;
    p2 = (i4 / C3 | 0) * e4.v + a4;
    const n4 = r4 * e4.h + s4;
    t4(e4, getBlockBufferOffset(e4, p2, n4));
  }
  function decodeBlock(e4, t4, i4) {
    p2 = i4 / e4.blocksPerLine | 0;
    const a4 = i4 % e4.blocksPerLine;
    t4(e4, getBlockBufferOffset(e4, p2, a4));
  }
  const m3 = a3.length;
  let y3, w3, b3, D3, F3, S3;
  S3 = h2 ? 0 === r3 ? 0 === o3 ? function decodeDCFirst(e4, t4) {
    const i4 = decodeHuffman(e4.huffmanTableDC), a4 = 0 === i4 ? 0 : receiveAndExtend(i4) << g3;
    e4.blockData[t4] = e4.pred += a4;
  } : function decodeDCSuccessive(e4, t4) {
    e4.blockData[t4] |= readBit() << g3;
  } : 0 === o3 ? function decodeACFirst(e4, t4) {
    if (u3 > 0) {
      u3--;
      return;
    }
    let i4 = r3;
    const a4 = n3;
    for (; i4 <= a4; ) {
      const a5 = decodeHuffman(e4.huffmanTableAC), s4 = 15 & a5, r4 = a5 >> 4;
      if (0 === s4) {
        if (r4 < 15) {
          u3 = receive(r4) + (1 << r4) - 1;
          break;
        }
        i4 += 16;
        continue;
      }
      i4 += r4;
      const n4 = $t[i4];
      e4.blockData[t4 + n4] = receiveAndExtend(s4) * (1 << g3);
      i4++;
    }
  } : function decodeACSuccessive(e4, t4) {
    let i4 = r3;
    const a4 = n3;
    let s4, o4, c4 = 0;
    for (; i4 <= a4; ) {
      const a5 = t4 + $t[i4], r4 = e4.blockData[a5] < 0 ? -1 : 1;
      switch (f2) {
        case 0:
          o4 = decodeHuffman(e4.huffmanTableAC);
          s4 = 15 & o4;
          c4 = o4 >> 4;
          if (0 === s4)
            if (c4 < 15) {
              u3 = receive(c4) + (1 << c4);
              f2 = 4;
            } else {
              c4 = 16;
              f2 = 1;
            }
          else {
            if (1 !== s4)
              throw new JpegError("invalid ACn encoding");
            d3 = receiveAndExtend(s4);
            f2 = c4 ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          if (e4.blockData[a5])
            e4.blockData[a5] += r4 * (readBit() << g3);
          else {
            c4--;
            0 === c4 && (f2 = 2 === f2 ? 3 : 0);
          }
          break;
        case 3:
          if (e4.blockData[a5])
            e4.blockData[a5] += r4 * (readBit() << g3);
          else {
            e4.blockData[a5] = d3 << g3;
            f2 = 0;
          }
          break;
        case 4:
          e4.blockData[a5] && (e4.blockData[a5] += r4 * (readBit() << g3));
      }
      i4++;
    }
    if (4 === f2) {
      u3--;
      0 === u3 && (f2 = 0);
    }
  } : function decodeBaseline(e4, t4) {
    const i4 = decodeHuffman(e4.huffmanTableDC), a4 = 0 === i4 ? 0 : receiveAndExtend(i4);
    e4.blockData[t4] = e4.pred += a4;
    let s4 = 1;
    for (; s4 < 64; ) {
      const i5 = decodeHuffman(e4.huffmanTableAC), a5 = 15 & i5, r4 = i5 >> 4;
      if (0 === a5) {
        if (r4 < 15)
          break;
        s4 += 16;
        continue;
      }
      s4 += r4;
      const n4 = $t[s4];
      e4.blockData[t4 + n4] = receiveAndExtend(a5);
      s4++;
    }
  };
  let k3, N3 = 0;
  const R3 = 1 === m3 ? a3[0].blocksPerLine * a3[0].blocksPerColumn : C3 * i3.mcusPerColumn;
  let G3, x3;
  for (; N3 <= R3; ) {
    const i4 = s3 ? Math.min(R3 - N3, s3) : R3;
    if (i4 > 0) {
      for (w3 = 0; w3 < m3; w3++)
        a3[w3].pred = 0;
      u3 = 0;
      if (1 === m3) {
        y3 = a3[0];
        for (F3 = 0; F3 < i4; F3++) {
          decodeBlock(y3, S3, N3);
          N3++;
        }
      } else
        for (F3 = 0; F3 < i4; F3++) {
          for (w3 = 0; w3 < m3; w3++) {
            y3 = a3[w3];
            G3 = y3.h;
            x3 = y3.v;
            for (b3 = 0; b3 < x3; b3++)
              for (D3 = 0; D3 < G3; D3++)
                decodeMcu(y3, S3, N3, b3, D3);
          }
          N3++;
        }
    }
    E3 = 0;
    k3 = findNextFileMarker(e3, t3);
    if (!k3)
      break;
    if (k3.invalid) {
      warn(`decodeScan - ${i4 > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${k3.invalid}`);
      t3 = k3.offset;
    }
    if (!(k3.marker >= 65488 && k3.marker <= 65495))
      break;
    t3 += 2;
  }
  return t3 - l3;
}
function quantizeAndInverse(e3, t3, i3) {
  const a3 = e3.quantizationTable, s3 = e3.blockData;
  let r3, n3, o3, g3, c3, C3, h2, l3, Q3, E3, u3, d3, f2, p2, m3, y3, w3;
  if (!a3)
    throw new JpegError("missing required Quantization Table.");
  for (let e4 = 0; e4 < 64; e4 += 8) {
    Q3 = s3[t3 + e4];
    E3 = s3[t3 + e4 + 1];
    u3 = s3[t3 + e4 + 2];
    d3 = s3[t3 + e4 + 3];
    f2 = s3[t3 + e4 + 4];
    p2 = s3[t3 + e4 + 5];
    m3 = s3[t3 + e4 + 6];
    y3 = s3[t3 + e4 + 7];
    Q3 *= a3[e4];
    if (0 != (E3 | u3 | d3 | f2 | p2 | m3 | y3)) {
      E3 *= a3[e4 + 1];
      u3 *= a3[e4 + 2];
      d3 *= a3[e4 + 3];
      f2 *= a3[e4 + 4];
      p2 *= a3[e4 + 5];
      m3 *= a3[e4 + 6];
      y3 *= a3[e4 + 7];
      r3 = ri * Q3 + 128 >> 8;
      n3 = ri * f2 + 128 >> 8;
      o3 = u3;
      g3 = m3;
      c3 = ni * (E3 - y3) + 128 >> 8;
      l3 = ni * (E3 + y3) + 128 >> 8;
      C3 = d3 << 4;
      h2 = p2 << 4;
      r3 = r3 + n3 + 1 >> 1;
      n3 = r3 - n3;
      w3 = o3 * si + g3 * ai + 128 >> 8;
      o3 = o3 * ai - g3 * si + 128 >> 8;
      g3 = w3;
      c3 = c3 + h2 + 1 >> 1;
      h2 = c3 - h2;
      l3 = l3 + C3 + 1 >> 1;
      C3 = l3 - C3;
      r3 = r3 + g3 + 1 >> 1;
      g3 = r3 - g3;
      n3 = n3 + o3 + 1 >> 1;
      o3 = n3 - o3;
      w3 = c3 * ii + l3 * ti + 2048 >> 12;
      c3 = c3 * ti - l3 * ii + 2048 >> 12;
      l3 = w3;
      w3 = C3 * ei + h2 * Ai + 2048 >> 12;
      C3 = C3 * Ai - h2 * ei + 2048 >> 12;
      h2 = w3;
      i3[e4] = r3 + l3;
      i3[e4 + 7] = r3 - l3;
      i3[e4 + 1] = n3 + h2;
      i3[e4 + 6] = n3 - h2;
      i3[e4 + 2] = o3 + C3;
      i3[e4 + 5] = o3 - C3;
      i3[e4 + 3] = g3 + c3;
      i3[e4 + 4] = g3 - c3;
    } else {
      w3 = ri * Q3 + 512 >> 10;
      i3[e4] = w3;
      i3[e4 + 1] = w3;
      i3[e4 + 2] = w3;
      i3[e4 + 3] = w3;
      i3[e4 + 4] = w3;
      i3[e4 + 5] = w3;
      i3[e4 + 6] = w3;
      i3[e4 + 7] = w3;
    }
  }
  for (let e4 = 0; e4 < 8; ++e4) {
    Q3 = i3[e4];
    E3 = i3[e4 + 8];
    u3 = i3[e4 + 16];
    d3 = i3[e4 + 24];
    f2 = i3[e4 + 32];
    p2 = i3[e4 + 40];
    m3 = i3[e4 + 48];
    y3 = i3[e4 + 56];
    if (0 != (E3 | u3 | d3 | f2 | p2 | m3 | y3)) {
      r3 = ri * Q3 + 2048 >> 12;
      n3 = ri * f2 + 2048 >> 12;
      o3 = u3;
      g3 = m3;
      c3 = ni * (E3 - y3) + 2048 >> 12;
      l3 = ni * (E3 + y3) + 2048 >> 12;
      C3 = d3;
      h2 = p2;
      r3 = 4112 + (r3 + n3 + 1 >> 1);
      n3 = r3 - n3;
      w3 = o3 * si + g3 * ai + 2048 >> 12;
      o3 = o3 * ai - g3 * si + 2048 >> 12;
      g3 = w3;
      c3 = c3 + h2 + 1 >> 1;
      h2 = c3 - h2;
      l3 = l3 + C3 + 1 >> 1;
      C3 = l3 - C3;
      r3 = r3 + g3 + 1 >> 1;
      g3 = r3 - g3;
      n3 = n3 + o3 + 1 >> 1;
      o3 = n3 - o3;
      w3 = c3 * ii + l3 * ti + 2048 >> 12;
      c3 = c3 * ti - l3 * ii + 2048 >> 12;
      l3 = w3;
      w3 = C3 * ei + h2 * Ai + 2048 >> 12;
      C3 = C3 * Ai - h2 * ei + 2048 >> 12;
      h2 = w3;
      Q3 = r3 + l3;
      y3 = r3 - l3;
      E3 = n3 + h2;
      m3 = n3 - h2;
      u3 = o3 + C3;
      p2 = o3 - C3;
      d3 = g3 + c3;
      f2 = g3 - c3;
      Q3 < 16 ? Q3 = 0 : Q3 >= 4080 ? Q3 = 255 : Q3 >>= 4;
      E3 < 16 ? E3 = 0 : E3 >= 4080 ? E3 = 255 : E3 >>= 4;
      u3 < 16 ? u3 = 0 : u3 >= 4080 ? u3 = 255 : u3 >>= 4;
      d3 < 16 ? d3 = 0 : d3 >= 4080 ? d3 = 255 : d3 >>= 4;
      f2 < 16 ? f2 = 0 : f2 >= 4080 ? f2 = 255 : f2 >>= 4;
      p2 < 16 ? p2 = 0 : p2 >= 4080 ? p2 = 255 : p2 >>= 4;
      m3 < 16 ? m3 = 0 : m3 >= 4080 ? m3 = 255 : m3 >>= 4;
      y3 < 16 ? y3 = 0 : y3 >= 4080 ? y3 = 255 : y3 >>= 4;
      s3[t3 + e4] = Q3;
      s3[t3 + e4 + 8] = E3;
      s3[t3 + e4 + 16] = u3;
      s3[t3 + e4 + 24] = d3;
      s3[t3 + e4 + 32] = f2;
      s3[t3 + e4 + 40] = p2;
      s3[t3 + e4 + 48] = m3;
      s3[t3 + e4 + 56] = y3;
    } else {
      w3 = ri * Q3 + 8192 >> 14;
      w3 = w3 < -2040 ? 0 : w3 >= 2024 ? 255 : w3 + 2056 >> 4;
      s3[t3 + e4] = w3;
      s3[t3 + e4 + 8] = w3;
      s3[t3 + e4 + 16] = w3;
      s3[t3 + e4 + 24] = w3;
      s3[t3 + e4 + 32] = w3;
      s3[t3 + e4 + 40] = w3;
      s3[t3 + e4 + 48] = w3;
      s3[t3 + e4 + 56] = w3;
    }
  }
}
function buildComponentData(e3, t3) {
  const i3 = t3.blocksPerLine, a3 = t3.blocksPerColumn, s3 = new Int16Array(64);
  for (let e4 = 0; e4 < a3; e4++)
    for (let a4 = 0; a4 < i3; a4++) {
      quantizeAndInverse(t3, getBlockBufferOffset(t3, e4, a4), s3);
    }
  return t3.blockData;
}
function findNextFileMarker(e3, t3, i3 = t3) {
  const a3 = e3.length - 1;
  let s3 = i3 < t3 ? i3 : t3;
  if (t3 >= a3)
    return null;
  const r3 = readUint16(e3, t3);
  if (r3 >= 65472 && r3 <= 65534)
    return { invalid: null, marker: r3, offset: t3 };
  let n3 = readUint16(e3, s3);
  for (; !(n3 >= 65472 && n3 <= 65534); ) {
    if (++s3 >= a3)
      return null;
    n3 = readUint16(e3, s3);
  }
  return { invalid: r3.toString(16), marker: n3, offset: s3 };
}
function toHexDigit(e3) {
  return e3 >= 48 && e3 <= 57 ? 15 & e3 : e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 ? 9 + (15 & e3) : -1;
}
function strToInt(e3) {
  let t3 = 0;
  for (let i3 = 0; i3 < e3.length; i3++)
    t3 = t3 << 8 | e3.charCodeAt(i3);
  return t3 >>> 0;
}
function expectString(e3) {
  if ("string" != typeof e3)
    throw new FormatError("Malformed CMap: expected string.");
}
function expectInt(e3) {
  if (!Number.isInteger(e3))
    throw new FormatError("Malformed CMap: expected int.");
}
function parseBfChar(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === pt)
      break;
    if (isCmd(i3, "endbfchar"))
      return;
    expectString(i3);
    const a3 = strToInt(i3);
    i3 = t3.getObj();
    expectString(i3);
    const s3 = i3;
    e3.mapOne(a3, s3);
  }
}
function parseBfRange(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === pt)
      break;
    if (isCmd(i3, "endbfrange"))
      return;
    expectString(i3);
    const a3 = strToInt(i3);
    i3 = t3.getObj();
    expectString(i3);
    const s3 = strToInt(i3);
    i3 = t3.getObj();
    if (Number.isInteger(i3) || "string" == typeof i3) {
      const t4 = Number.isInteger(i3) ? String.fromCharCode(i3) : i3;
      e3.mapBfRange(a3, s3, t4);
    } else {
      if (!isCmd(i3, "["))
        break;
      {
        i3 = t3.getObj();
        const r3 = [];
        for (; !isCmd(i3, "]") && i3 !== pt; ) {
          r3.push(i3);
          i3 = t3.getObj();
        }
        e3.mapBfRangeToArray(a3, s3, r3);
      }
    }
  }
  throw new FormatError("Invalid bf range.");
}
function parseCidChar(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === pt)
      break;
    if (isCmd(i3, "endcidchar"))
      return;
    expectString(i3);
    const a3 = strToInt(i3);
    i3 = t3.getObj();
    expectInt(i3);
    const s3 = i3;
    e3.mapOne(a3, s3);
  }
}
function parseCidRange(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === pt)
      break;
    if (isCmd(i3, "endcidrange"))
      return;
    expectString(i3);
    const a3 = strToInt(i3);
    i3 = t3.getObj();
    expectString(i3);
    const s3 = strToInt(i3);
    i3 = t3.getObj();
    expectInt(i3);
    const r3 = i3;
    e3.mapCidRange(a3, s3, r3);
  }
}
function parseCodespaceRange(e3, t3) {
  for (; ; ) {
    let i3 = t3.getObj();
    if (i3 === pt)
      break;
    if (isCmd(i3, "endcodespacerange"))
      return;
    if ("string" != typeof i3)
      break;
    const a3 = strToInt(i3);
    i3 = t3.getObj();
    if ("string" != typeof i3)
      break;
    const s3 = strToInt(i3);
    e3.addCodespaceRange(i3.length, a3, s3);
  }
  throw new FormatError("Invalid codespace range.");
}
function parseWMode(e3, t3) {
  const i3 = t3.getObj();
  Number.isInteger(i3) && (e3.vertical = !!i3);
}
function parseCMapName(e3, t3) {
  const i3 = t3.getObj();
  i3 instanceof Name && (e3.name = i3.name);
}
async function parseCMap(e3, t3, i3, a3) {
  let s3, r3;
  A:
    for (; ; )
      try {
        const i4 = t3.getObj();
        if (i4 === pt)
          break;
        if (i4 instanceof Name) {
          "WMode" === i4.name ? parseWMode(e3, t3) : "CMapName" === i4.name && parseCMapName(e3, t3);
          s3 = i4;
        } else if (i4 instanceof Cmd)
          switch (i4.cmd) {
            case "endcmap":
              break A;
            case "usecmap":
              s3 instanceof Name && (r3 = s3.name);
              break;
            case "begincodespacerange":
              parseCodespaceRange(e3, t3);
              break;
            case "beginbfchar":
              parseBfChar(e3, t3);
              break;
            case "begincidchar":
              parseCidChar(e3, t3);
              break;
            case "beginbfrange":
              parseBfRange(e3, t3);
              break;
            case "begincidrange":
              parseCidRange(e3, t3);
          }
      } catch (e4) {
        if (e4 instanceof MissingDataException)
          throw e4;
        warn("Invalid cMap data: " + e4);
        continue;
      }
  !a3 && r3 && (a3 = r3);
  return a3 ? extendCMap(e3, i3, a3) : e3;
}
async function extendCMap(e3, t3, i3) {
  e3.useCMap = await createBuiltInCMap(i3, t3);
  if (0 === e3.numCodespaceRanges) {
    const t4 = e3.useCMap.codespaceRanges;
    for (let i4 = 0; i4 < t4.length; i4++)
      e3.codespaceRanges[i4] = t4[i4].slice();
    e3.numCodespaceRanges = e3.useCMap.numCodespaceRanges;
  }
  e3.useCMap.forEach(function(t4, i4) {
    e3.contains(t4) || e3.mapOne(t4, e3.useCMap.lookup(t4));
  });
  return e3;
}
async function createBuiltInCMap(e3, t3) {
  if ("Identity-H" === e3)
    return new IdentityCMap(false, 2);
  if ("Identity-V" === e3)
    return new IdentityCMap(true, 2);
  if (!Ci.includes(e3))
    throw new Error("Unknown CMap name: " + e3);
  if (!t3)
    throw new Error("Built-in CMap parameters are not provided.");
  const { cMapData: i3, compressionType: a3 } = await t3(e3), s3 = new CMap(true);
  if (a3 === mA.BINARY)
    return new BinaryCMapReader().process(i3, s3, (e4) => extendCMap(s3, t3, e4));
  if (a3 === mA.NONE) {
    const e4 = new Lexer(new Stream(i3));
    return parseCMap(s3, e4, t3, null);
  }
  throw new Error(`Invalid CMap "compressionType" value: ${a3}`);
}
function getEncoding(e3) {
  switch (e3) {
    case "WinAnsiEncoding":
      return pi;
    case "StandardEncoding":
      return fi;
    case "MacRomanEncoding":
      return di;
    case "SymbolSetEncoding":
      return mi;
    case "ZapfDingbatsEncoding":
      return yi;
    case "ExpertEncoding":
      return Ei;
    case "MacExpertEncoding":
      return ui;
    default:
      return null;
  }
}
function getUnicodeForGlyph(e3, t3) {
  let i3 = t3[e3];
  if (void 0 !== i3)
    return i3;
  if (!e3)
    return -1;
  if ("u" === e3[0]) {
    const t4 = e3.length;
    let a3;
    if (7 === t4 && "n" === e3[1] && "i" === e3[2])
      a3 = e3.substring(3);
    else {
      if (!(t4 >= 5 && t4 <= 7))
        return -1;
      a3 = e3.substring(1);
    }
    if (a3 === a3.toUpperCase()) {
      i3 = parseInt(a3, 16);
      if (i3 >= 0)
        return i3;
    }
  }
  return -1;
}
function getUnicodeRangeFor(e3, t3 = -1) {
  if (-1 !== t3) {
    const i3 = Mi[t3];
    for (let a3 = 0, s3 = i3.length; a3 < s3; a3 += 2)
      if (e3 >= i3[a3] && e3 <= i3[a3 + 1])
        return t3;
  }
  for (let t4 = 0, i3 = Mi.length; t4 < i3; t4++) {
    const i4 = Mi[t4];
    for (let a3 = 0, s3 = i4.length; a3 < s3; a3 += 2)
      if (e3 >= i4[a3] && e3 <= i4[a3 + 1])
        return t4;
  }
  return -1;
}
function recoverGlyphName(e3, t3) {
  if (void 0 !== t3[e3])
    return e3;
  const i3 = getUnicodeForGlyph(e3, t3);
  if (-1 !== i3) {
    for (const e4 in t3)
      if (t3[e4] === i3)
        return e4;
  }
  info("Unable to recover a standard glyph name for: " + e3);
  return e3;
}
function type1FontGlyphMapping(e3, t3, i3) {
  const a3 = /* @__PURE__ */ Object.create(null);
  let s3, r3, n3;
  const o3 = !!(e3.flags & Ti);
  if (e3.isInternalFont) {
    n3 = t3;
    for (r3 = 0; r3 < n3.length; r3++) {
      s3 = i3.indexOf(n3[r3]);
      a3[r3] = s3 >= 0 ? s3 : 0;
    }
  } else if (e3.baseEncodingName) {
    n3 = getEncoding(e3.baseEncodingName);
    for (r3 = 0; r3 < n3.length; r3++) {
      s3 = i3.indexOf(n3[r3]);
      a3[r3] = s3 >= 0 ? s3 : 0;
    }
  } else if (o3)
    for (r3 in t3)
      a3[r3] = t3[r3];
  else {
    n3 = fi;
    for (r3 = 0; r3 < n3.length; r3++) {
      s3 = i3.indexOf(n3[r3]);
      a3[r3] = s3 >= 0 ? s3 : 0;
    }
  }
  const g3 = e3.differences;
  let c3;
  if (g3)
    for (r3 in g3) {
      const e4 = g3[r3];
      s3 = i3.indexOf(e4);
      if (-1 === s3) {
        c3 || (c3 = Ri());
        const t4 = recoverGlyphName(e4, c3);
        t4 !== e4 && (s3 = i3.indexOf(t4));
      }
      a3[r3] = s3 >= 0 ? s3 : 0;
    }
  return a3;
}
function normalizeFontName(e3) {
  return e3.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
function getStandardFontName(e3) {
  const t3 = normalizeFontName(e3);
  return Pi()[t3];
}
function isKnownFontName(e3) {
  const t3 = normalizeFontName(e3);
  return !!(Pi()[t3] || ji()[t3] || Xi()[t3] || Zi()[t3]);
}
function getUint32(e3, t3) {
  return (e3[t3] << 24 | e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | e3[t3 + 3]) >>> 0;
}
function getUint16(e3, t3) {
  return e3[t3] << 8 | e3[t3 + 1];
}
function getInt16(e3, t3) {
  return (e3[t3] << 24 | e3[t3 + 1] << 16) >> 16;
}
function getInt8(e3, t3) {
  return e3[t3] << 24 >> 24;
}
function getFloat214(e3, t3) {
  return getInt16(e3, t3) / 16384;
}
function getSubroutineBias(e3) {
  const t3 = e3.length;
  let i3 = 32768;
  t3 < 1240 ? i3 = 107 : t3 < 33900 && (i3 = 1131);
  return i3;
}
function parseCmap(e3, t3, i3) {
  const a3 = 1 === getUint16(e3, t3 + 2) ? getUint32(e3, t3 + 8) : getUint32(e3, t3 + 16), s3 = getUint16(e3, t3 + a3);
  let r3, n3, o3;
  if (4 === s3) {
    getUint16(e3, t3 + a3 + 2);
    const i4 = getUint16(e3, t3 + a3 + 6) >> 1;
    n3 = t3 + a3 + 14;
    r3 = [];
    for (o3 = 0; o3 < i4; o3++, n3 += 2)
      r3[o3] = { end: getUint16(e3, n3) };
    n3 += 2;
    for (o3 = 0; o3 < i4; o3++, n3 += 2)
      r3[o3].start = getUint16(e3, n3);
    for (o3 = 0; o3 < i4; o3++, n3 += 2)
      r3[o3].idDelta = getUint16(e3, n3);
    for (o3 = 0; o3 < i4; o3++, n3 += 2) {
      let t4 = getUint16(e3, n3);
      if (0 !== t4) {
        r3[o3].ids = [];
        for (let i5 = 0, a4 = r3[o3].end - r3[o3].start + 1; i5 < a4; i5++) {
          r3[o3].ids[i5] = getUint16(e3, n3 + t4);
          t4 += 2;
        }
      }
    }
    return r3;
  }
  if (12 === s3) {
    const i4 = getUint32(e3, t3 + a3 + 12);
    n3 = t3 + a3 + 16;
    r3 = [];
    for (o3 = 0; o3 < i4; o3++) {
      t3 = getUint32(e3, n3);
      r3.push({ start: t3, end: getUint32(e3, n3 + 4), idDelta: getUint32(e3, n3 + 8) - t3 });
      n3 += 12;
    }
    return r3;
  }
  throw new FormatError(`unsupported cmap: ${s3}`);
}
function parseCff(e3, t3, i3, a3) {
  var _a3, _b2, _c2;
  const s3 = new CFFParser(new Stream(e3, t3, i3 - t3), {}, a3).parse();
  return { glyphs: s3.charStrings.objects, subrs: (_b2 = (_a3 = s3.topDict.privateDict) == null ? void 0 : _a3.subrsIndex) == null ? void 0 : _b2.objects, gsubrs: (_c2 = s3.globalSubrIndex) == null ? void 0 : _c2.objects, isCFFCIDFont: s3.isCIDFont, fdSelect: s3.fdSelect, fdArray: s3.fdArray };
}
function lookupCmap(e3, t3) {
  const i3 = t3.codePointAt(0);
  let a3 = 0, s3 = 0, r3 = e3.length - 1;
  for (; s3 < r3; ) {
    const t4 = s3 + r3 + 1 >> 1;
    i3 < e3[t4].start ? r3 = t4 - 1 : s3 = t4;
  }
  e3[s3].start <= i3 && i3 <= e3[s3].end && (a3 = e3[s3].idDelta + (e3[s3].ids ? e3[s3].ids[i3 - e3[s3].start] : i3) & 65535);
  return { charCode: i3, glyphId: a3 };
}
function compileGlyf(e3, t3, i3) {
  function moveTo(e4, i4) {
    t3.add(Ct, [e4, i4]);
  }
  function lineTo(e4, i4) {
    t3.add(ht, [e4, i4]);
  }
  function quadraticCurveTo(e4, i4, a4, s4) {
    t3.add(lt, [e4, i4, a4, s4]);
  }
  let a3 = 0;
  const s3 = getInt16(e3, a3);
  let r3, n3 = 0, o3 = 0;
  a3 += 10;
  if (s3 < 0)
    do {
      r3 = getUint16(e3, a3);
      const s4 = getUint16(e3, a3 + 2);
      a3 += 4;
      let g3, c3;
      if (1 & r3) {
        if (2 & r3) {
          g3 = getInt16(e3, a3);
          c3 = getInt16(e3, a3 + 2);
        } else {
          g3 = getUint16(e3, a3);
          c3 = getUint16(e3, a3 + 2);
        }
        a3 += 4;
      } else if (2 & r3) {
        g3 = getInt8(e3, a3++);
        c3 = getInt8(e3, a3++);
      } else {
        g3 = e3[a3++];
        c3 = e3[a3++];
      }
      if (2 & r3) {
        n3 = g3;
        o3 = c3;
      } else {
        n3 = 0;
        o3 = 0;
      }
      let C3 = 1, h2 = 1, l3 = 0, Q3 = 0;
      if (8 & r3) {
        C3 = h2 = getFloat214(e3, a3);
        a3 += 2;
      } else if (64 & r3) {
        C3 = getFloat214(e3, a3);
        h2 = getFloat214(e3, a3 + 2);
        a3 += 4;
      } else if (128 & r3) {
        C3 = getFloat214(e3, a3);
        l3 = getFloat214(e3, a3 + 2);
        Q3 = getFloat214(e3, a3 + 4);
        h2 = getFloat214(e3, a3 + 6);
        a3 += 8;
      }
      const E3 = i3.glyphs[s4];
      if (E3) {
        t3.add(Qt);
        t3.add(ut, [C3, l3, Q3, h2, n3, o3]);
        compileGlyf(E3, t3, i3);
        t3.add(Bt);
      }
    } while (32 & r3);
  else {
    const t4 = [];
    let i4, g3;
    for (i4 = 0; i4 < s3; i4++) {
      t4.push(getUint16(e3, a3));
      a3 += 2;
    }
    a3 += 2 + getUint16(e3, a3);
    const c3 = t4.at(-1) + 1, C3 = [];
    for (; C3.length < c3; ) {
      r3 = e3[a3++];
      let t5 = 1;
      8 & r3 && (t5 += e3[a3++]);
      for (; t5-- > 0; )
        C3.push({ flags: r3 });
    }
    for (i4 = 0; i4 < c3; i4++) {
      switch (18 & C3[i4].flags) {
        case 0:
          n3 += getInt16(e3, a3);
          a3 += 2;
          break;
        case 2:
          n3 -= e3[a3++];
          break;
        case 18:
          n3 += e3[a3++];
      }
      C3[i4].x = n3;
    }
    for (i4 = 0; i4 < c3; i4++) {
      switch (36 & C3[i4].flags) {
        case 0:
          o3 += getInt16(e3, a3);
          a3 += 2;
          break;
        case 4:
          o3 -= e3[a3++];
          break;
        case 36:
          o3 += e3[a3++];
      }
      C3[i4].y = o3;
    }
    let h2 = 0;
    for (a3 = 0; a3 < s3; a3++) {
      const e4 = t4[a3], s4 = C3.slice(h2, e4 + 1);
      if (1 & s4[0].flags)
        s4.push(s4[0]);
      else if (1 & s4.at(-1).flags)
        s4.unshift(s4.at(-1));
      else {
        const e5 = { flags: 1, x: (s4[0].x + s4.at(-1).x) / 2, y: (s4[0].y + s4.at(-1).y) / 2 };
        s4.unshift(e5);
        s4.push(e5);
      }
      moveTo(s4[0].x, s4[0].y);
      for (i4 = 1, g3 = s4.length; i4 < g3; i4++)
        if (1 & s4[i4].flags)
          lineTo(s4[i4].x, s4[i4].y);
        else if (1 & s4[i4 + 1].flags) {
          quadraticCurveTo(s4[i4].x, s4[i4].y, s4[i4 + 1].x, s4[i4 + 1].y);
          i4++;
        } else
          quadraticCurveTo(s4[i4].x, s4[i4].y, (s4[i4].x + s4[i4 + 1].x) / 2, (s4[i4].y + s4[i4 + 1].y) / 2);
      h2 = e4 + 1;
    }
  }
}
function compileCharString(e3, t3, i3, a3) {
  function moveTo(e4, i4) {
    t3.add(Ct, [e4, i4]);
  }
  function lineTo(e4, i4) {
    t3.add(ht, [e4, i4]);
  }
  function bezierCurveTo(e4, i4, a4, s4, r4, n4) {
    t3.add(ct, [e4, i4, a4, s4, r4, n4]);
  }
  const s3 = [];
  let r3 = 0, n3 = 0, o3 = 0;
  !function parse(e4) {
    var _a3;
    let g3 = 0;
    for (; g3 < e4.length; ) {
      let c3, C3, h2, l3, Q3, E3, u3, d3, f2, p2 = false, m3 = e4[g3++];
      switch (m3) {
        case 1:
        case 3:
        case 18:
        case 23:
          o3 += s3.length >> 1;
          p2 = true;
          break;
        case 4:
          n3 += s3.pop();
          moveTo(r3, n3);
          p2 = true;
          break;
        case 5:
          for (; s3.length > 0; ) {
            r3 += s3.shift();
            n3 += s3.shift();
            lineTo(r3, n3);
          }
          break;
        case 6:
          for (; s3.length > 0; ) {
            r3 += s3.shift();
            lineTo(r3, n3);
            if (0 === s3.length)
              break;
            n3 += s3.shift();
            lineTo(r3, n3);
          }
          break;
        case 7:
          for (; s3.length > 0; ) {
            n3 += s3.shift();
            lineTo(r3, n3);
            if (0 === s3.length)
              break;
            r3 += s3.shift();
            lineTo(r3, n3);
          }
          break;
        case 8:
          for (; s3.length > 0; ) {
            c3 = r3 + s3.shift();
            h2 = n3 + s3.shift();
            C3 = c3 + s3.shift();
            l3 = h2 + s3.shift();
            r3 = C3 + s3.shift();
            n3 = l3 + s3.shift();
            bezierCurveTo(c3, h2, C3, l3, r3, n3);
          }
          break;
        case 10:
          d3 = s3.pop();
          f2 = null;
          if (i3.isCFFCIDFont) {
            const e5 = i3.fdSelect.getFDIndex(a3);
            if (e5 >= 0 && e5 < i3.fdArray.length) {
              const t4 = i3.fdArray[e5];
              let a4;
              ((_a3 = t4.privateDict) == null ? void 0 : _a3.subrsIndex) && (a4 = t4.privateDict.subrsIndex.objects);
              if (a4) {
                d3 += getSubroutineBias(a4);
                f2 = a4[d3];
              }
            } else
              warn("Invalid fd index for glyph index.");
          } else
            f2 = i3.subrs[d3 + i3.subrsBias];
          f2 && parse(f2);
          break;
        case 11:
          return;
        case 12:
          m3 = e4[g3++];
          switch (m3) {
            case 34:
              c3 = r3 + s3.shift();
              C3 = c3 + s3.shift();
              Q3 = n3 + s3.shift();
              r3 = C3 + s3.shift();
              bezierCurveTo(c3, n3, C3, Q3, r3, Q3);
              c3 = r3 + s3.shift();
              C3 = c3 + s3.shift();
              r3 = C3 + s3.shift();
              bezierCurveTo(c3, Q3, C3, n3, r3, n3);
              break;
            case 35:
              c3 = r3 + s3.shift();
              h2 = n3 + s3.shift();
              C3 = c3 + s3.shift();
              l3 = h2 + s3.shift();
              r3 = C3 + s3.shift();
              n3 = l3 + s3.shift();
              bezierCurveTo(c3, h2, C3, l3, r3, n3);
              c3 = r3 + s3.shift();
              h2 = n3 + s3.shift();
              C3 = c3 + s3.shift();
              l3 = h2 + s3.shift();
              r3 = C3 + s3.shift();
              n3 = l3 + s3.shift();
              bezierCurveTo(c3, h2, C3, l3, r3, n3);
              s3.pop();
              break;
            case 36:
              c3 = r3 + s3.shift();
              Q3 = n3 + s3.shift();
              C3 = c3 + s3.shift();
              E3 = Q3 + s3.shift();
              r3 = C3 + s3.shift();
              bezierCurveTo(c3, Q3, C3, E3, r3, E3);
              c3 = r3 + s3.shift();
              C3 = c3 + s3.shift();
              u3 = E3 + s3.shift();
              r3 = C3 + s3.shift();
              bezierCurveTo(c3, E3, C3, u3, r3, n3);
              break;
            case 37:
              const e5 = r3, t4 = n3;
              c3 = r3 + s3.shift();
              h2 = n3 + s3.shift();
              C3 = c3 + s3.shift();
              l3 = h2 + s3.shift();
              r3 = C3 + s3.shift();
              n3 = l3 + s3.shift();
              bezierCurveTo(c3, h2, C3, l3, r3, n3);
              c3 = r3 + s3.shift();
              h2 = n3 + s3.shift();
              C3 = c3 + s3.shift();
              l3 = h2 + s3.shift();
              r3 = C3;
              n3 = l3;
              Math.abs(r3 - e5) > Math.abs(n3 - t4) ? r3 += s3.shift() : n3 += s3.shift();
              bezierCurveTo(c3, h2, C3, l3, r3, n3);
              break;
            default:
              throw new FormatError(`unknown operator: 12 ${m3}`);
          }
          break;
        case 14:
          if (s3.length >= 4) {
            const e5 = s3.pop(), a4 = s3.pop();
            n3 = s3.pop();
            r3 = s3.pop();
            t3.add(Qt);
            t3.add(dt, [r3, n3]);
            let o4 = lookupCmap(i3.cmap, String.fromCharCode(i3.glyphNameMap[fi[e5]]));
            compileCharString(i3.glyphs[o4.glyphId], t3, i3, o4.glyphId);
            t3.add(Bt);
            o4 = lookupCmap(i3.cmap, String.fromCharCode(i3.glyphNameMap[fi[a4]]));
            compileCharString(i3.glyphs[o4.glyphId], t3, i3, o4.glyphId);
          }
          return;
        case 19:
        case 20:
          o3 += s3.length >> 1;
          g3 += o3 + 7 >> 3;
          p2 = true;
          break;
        case 21:
          n3 += s3.pop();
          r3 += s3.pop();
          moveTo(r3, n3);
          p2 = true;
          break;
        case 22:
          r3 += s3.pop();
          moveTo(r3, n3);
          p2 = true;
          break;
        case 24:
          for (; s3.length > 2; ) {
            c3 = r3 + s3.shift();
            h2 = n3 + s3.shift();
            C3 = c3 + s3.shift();
            l3 = h2 + s3.shift();
            r3 = C3 + s3.shift();
            n3 = l3 + s3.shift();
            bezierCurveTo(c3, h2, C3, l3, r3, n3);
          }
          r3 += s3.shift();
          n3 += s3.shift();
          lineTo(r3, n3);
          break;
        case 25:
          for (; s3.length > 6; ) {
            r3 += s3.shift();
            n3 += s3.shift();
            lineTo(r3, n3);
          }
          c3 = r3 + s3.shift();
          h2 = n3 + s3.shift();
          C3 = c3 + s3.shift();
          l3 = h2 + s3.shift();
          r3 = C3 + s3.shift();
          n3 = l3 + s3.shift();
          bezierCurveTo(c3, h2, C3, l3, r3, n3);
          break;
        case 26:
          s3.length % 2 && (r3 += s3.shift());
          for (; s3.length > 0; ) {
            c3 = r3;
            h2 = n3 + s3.shift();
            C3 = c3 + s3.shift();
            l3 = h2 + s3.shift();
            r3 = C3;
            n3 = l3 + s3.shift();
            bezierCurveTo(c3, h2, C3, l3, r3, n3);
          }
          break;
        case 27:
          s3.length % 2 && (n3 += s3.shift());
          for (; s3.length > 0; ) {
            c3 = r3 + s3.shift();
            h2 = n3;
            C3 = c3 + s3.shift();
            l3 = h2 + s3.shift();
            r3 = C3 + s3.shift();
            n3 = l3;
            bezierCurveTo(c3, h2, C3, l3, r3, n3);
          }
          break;
        case 28:
          s3.push((e4[g3] << 24 | e4[g3 + 1] << 16) >> 16);
          g3 += 2;
          break;
        case 29:
          d3 = s3.pop() + i3.gsubrsBias;
          f2 = i3.gsubrs[d3];
          f2 && parse(f2);
          break;
        case 30:
          for (; s3.length > 0; ) {
            c3 = r3;
            h2 = n3 + s3.shift();
            C3 = c3 + s3.shift();
            l3 = h2 + s3.shift();
            r3 = C3 + s3.shift();
            n3 = l3 + (1 === s3.length ? s3.shift() : 0);
            bezierCurveTo(c3, h2, C3, l3, r3, n3);
            if (0 === s3.length)
              break;
            c3 = r3 + s3.shift();
            h2 = n3;
            C3 = c3 + s3.shift();
            l3 = h2 + s3.shift();
            n3 = l3 + s3.shift();
            r3 = C3 + (1 === s3.length ? s3.shift() : 0);
            bezierCurveTo(c3, h2, C3, l3, r3, n3);
          }
          break;
        case 31:
          for (; s3.length > 0; ) {
            c3 = r3 + s3.shift();
            h2 = n3;
            C3 = c3 + s3.shift();
            l3 = h2 + s3.shift();
            n3 = l3 + s3.shift();
            r3 = C3 + (1 === s3.length ? s3.shift() : 0);
            bezierCurveTo(c3, h2, C3, l3, r3, n3);
            if (0 === s3.length)
              break;
            c3 = r3;
            h2 = n3 + s3.shift();
            C3 = c3 + s3.shift();
            l3 = h2 + s3.shift();
            r3 = C3 + s3.shift();
            n3 = l3 + (1 === s3.length ? s3.shift() : 0);
            bezierCurveTo(c3, h2, C3, l3, r3, n3);
          }
          break;
        default:
          if (m3 < 32)
            throw new FormatError(`unknown operator: ${m3}`);
          if (m3 < 247)
            s3.push(m3 - 139);
          else if (m3 < 251)
            s3.push(256 * (m3 - 247) + e4[g3++] + 108);
          else if (m3 < 255)
            s3.push(256 * -(m3 - 251) - e4[g3++] - 108);
          else {
            s3.push((e4[g3] << 24 | e4[g3 + 1] << 16 | e4[g3 + 2] << 8 | e4[g3 + 3]) / 65536);
            g3 += 4;
          }
      }
      p2 && (s3.length = 0);
    }
  }(e3);
}
function writeInt16(e3, t3, i3) {
  e3[t3] = i3 >> 8 & 255;
  e3[t3 + 1] = 255 & i3;
}
function writeInt32(e3, t3, i3) {
  e3[t3] = i3 >> 24 & 255;
  e3[t3 + 1] = i3 >> 16 & 255;
  e3[t3 + 2] = i3 >> 8 & 255;
  e3[t3 + 3] = 255 & i3;
}
function writeData(e3, t3, i3) {
  if (i3 instanceof Uint8Array)
    e3.set(i3, t3);
  else if ("string" == typeof i3)
    for (let a3 = 0, s3 = i3.length; a3 < s3; a3++)
      e3[t3++] = 255 & i3.charCodeAt(a3);
  else
    for (const a3 of i3)
      e3[t3++] = 255 & a3;
}
function isHexDigit(e3) {
  return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
}
function decrypt(e3, t3, i3) {
  if (i3 >= e3.length)
    return new Uint8Array(0);
  let a3, s3, r3 = 0 | t3;
  for (a3 = 0; a3 < i3; a3++)
    r3 = 52845 * (e3[a3] + r3) + 22719 & 65535;
  const n3 = e3.length - i3, o3 = new Uint8Array(n3);
  for (a3 = i3, s3 = 0; s3 < n3; a3++, s3++) {
    const t4 = e3[a3];
    o3[s3] = t4 ^ r3 >> 8;
    r3 = 52845 * (t4 + r3) + 22719 & 65535;
  }
  return o3;
}
function isSpecial(e3) {
  return 47 === e3 || 91 === e3 || 93 === e3 || 123 === e3 || 125 === e3 || 40 === e3 || 41 === e3;
}
function findBlock(e3, t3, i3) {
  const a3 = e3.length, s3 = t3.length, r3 = a3 - s3;
  let n3 = i3, o3 = false;
  for (; n3 < r3; ) {
    let i4 = 0;
    for (; i4 < s3 && e3[n3 + i4] === t3[i4]; )
      i4++;
    if (i4 >= s3) {
      n3 += i4;
      for (; n3 < a3 && isWhiteSpace(e3[n3]); )
        n3++;
      o3 = true;
      break;
    }
    n3++;
  }
  return { found: o3, length: n3 };
}
function adjustWidths(e3) {
  if (!e3.fontMatrix)
    return;
  if (e3.fontMatrix[0] === a2[0])
    return;
  const t3 = 1e-3 / e3.fontMatrix[0], i3 = e3.widths;
  for (const e4 in i3)
    i3[e4] *= t3;
  e3.defaultWidth *= t3;
}
function amendFallbackToUnicode(e3) {
  if (!e3.fallbackToUnicode)
    return;
  if (e3.toUnicode instanceof IdentityToUnicodeMap)
    return;
  const t3 = [];
  for (const i3 in e3.fallbackToUnicode)
    e3.toUnicode.has(i3) || (t3[i3] = e3.fallbackToUnicode[i3]);
  t3.length > 0 && e3.toUnicode.amend(t3);
}
function int16(e3, t3) {
  return (e3 << 8) + t3;
}
function writeSignedInt16(e3, t3, i3) {
  e3[t3 + 1] = i3;
  e3[t3] = i3 >>> 8;
}
function signedInt16(e3, t3) {
  const i3 = (e3 << 8) + t3;
  return 32768 & i3 ? i3 - 65536 : i3;
}
function string16(e3) {
  return String.fromCharCode(e3 >> 8 & 255, 255 & e3);
}
function safeString16(e3) {
  e3 > 32767 ? e3 = 32767 : e3 < -32768 && (e3 = -32768);
  return String.fromCharCode(e3 >> 8 & 255, 255 & e3);
}
function isTrueTypeCollectionFile(e3) {
  return "ttcf" === bytesToString(e3.peekBytes(4));
}
function getFontFileType(e3, { type: t3, subtype: i3, composite: a3 }) {
  let s3, r3;
  if (function isTrueTypeFile(e4) {
    const t4 = e4.peekBytes(4);
    return 65536 === readUint32(t4, 0) || "true" === bytesToString(t4);
  }(e3) || isTrueTypeCollectionFile(e3))
    s3 = a3 ? "CIDFontType2" : "TrueType";
  else if (function isOpenTypeFile(e4) {
    return "OTTO" === bytesToString(e4.peekBytes(4));
  }(e3))
    s3 = a3 ? "CIDFontType2" : "OpenType";
  else if (function isType1File(e4) {
    const t4 = e4.peekBytes(2);
    return 37 === t4[0] && 33 === t4[1] || 128 === t4[0] && 1 === t4[1];
  }(e3))
    s3 = a3 ? "CIDFontType0" : "MMType1" === t3 ? "MMType1" : "Type1";
  else if (function isCFFFile(e4) {
    const t4 = e4.peekBytes(4);
    return t4[0] >= 1 && t4[3] >= 1 && t4[3] <= 4;
  }(e3))
    if (a3) {
      s3 = "CIDFontType0";
      r3 = "CIDFontType0C";
    } else {
      s3 = "MMType1" === t3 ? "MMType1" : "Type1";
      r3 = "Type1C";
    }
  else {
    warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
    s3 = t3;
    r3 = i3;
  }
  return [s3, r3];
}
function applyStandardFontGlyphMap(e3, t3) {
  for (const i3 in t3)
    e3[+i3] = t3[i3];
}
function buildToFontChar(e3, t3, i3) {
  const a3 = [];
  let s3;
  for (let i4 = 0, r3 = e3.length; i4 < r3; i4++) {
    s3 = getUnicodeForGlyph(e3[i4], t3);
    -1 !== s3 && (a3[i4] = s3);
  }
  for (const e4 in i3) {
    s3 = getUnicodeForGlyph(i3[e4], t3);
    -1 !== s3 && (a3[+e4] = s3);
  }
  return a3;
}
function isMacNameRecord(e3) {
  return 1 === e3.platform && 0 === e3.encoding && 0 === e3.language;
}
function isWinNameRecord(e3) {
  return 3 === e3.platform && 1 === e3.encoding && 1033 === e3.language;
}
function convertCidString(e3, t3, i3 = false) {
  switch (t3.length) {
    case 1:
      return t3.charCodeAt(0);
    case 2:
      return t3.charCodeAt(0) << 8 | t3.charCodeAt(1);
  }
  const a3 = `Unsupported CID string (charCode ${e3}): "${t3}".`;
  if (i3)
    throw new FormatError(a3);
  warn(a3);
  return t3;
}
function adjustMapping(e3, t3, i3, a3) {
  const s3 = /* @__PURE__ */ Object.create(null), r3 = /* @__PURE__ */ new Map(), n3 = [], o3 = /* @__PURE__ */ new Set();
  let g3 = 0;
  let c3 = ha[g3][0], C3 = ha[g3][1];
  for (let l3 in e3) {
    l3 |= 0;
    let Q3 = e3[l3];
    if (!t3(Q3))
      continue;
    if (c3 > C3) {
      g3++;
      if (g3 >= ha.length) {
        warn("Ran out of space in font private use area.");
        break;
      }
      c3 = ha[g3][0];
      C3 = ha[g3][1];
    }
    const E3 = c3++;
    0 === Q3 && (Q3 = i3);
    let u3 = a3.get(l3);
    "string" == typeof u3 && (u3 = u3.codePointAt(0));
    if (u3 && !(h2 = u3, ha[0][0] <= h2 && h2 <= ha[0][1] || ha[1][0] <= h2 && h2 <= ha[1][1]) && !o3.has(Q3)) {
      r3.set(u3, Q3);
      o3.add(Q3);
    }
    s3[E3] = Q3;
    n3[l3] = E3;
  }
  var h2;
  return { toFontChar: n3, charCodeToGlyphId: s3, toUnicodeExtraMap: r3, nextAvailableFontCharCode: c3 };
}
function createCmapTable(e3, t3, i3) {
  const a3 = function getRanges(e4, t4, i4) {
    const a4 = [];
    for (const t5 in e4)
      e4[t5] >= i4 || a4.push({ fontCharCode: 0 | t5, glyphId: e4[t5] });
    if (t4)
      for (const [e5, s5] of t4)
        s5 >= i4 || a4.push({ fontCharCode: e5, glyphId: s5 });
    0 === a4.length && a4.push({ fontCharCode: 0, glyphId: 0 });
    a4.sort(function fontGetRangesSort(e5, t5) {
      return e5.fontCharCode - t5.fontCharCode;
    });
    const s4 = [], r4 = a4.length;
    for (let e5 = 0; e5 < r4; ) {
      const t5 = a4[e5].fontCharCode, i5 = [a4[e5].glyphId];
      ++e5;
      let n4 = t5;
      for (; e5 < r4 && n4 + 1 === a4[e5].fontCharCode; ) {
        i5.push(a4[e5].glyphId);
        ++n4;
        ++e5;
        if (65535 === n4)
          break;
      }
      s4.push([t5, n4, i5]);
    }
    return s4;
  }(e3, t3, i3), s3 = a3.at(-1)[1] > 65535 ? 2 : 1;
  let r3, n3, o3, g3, c3 = "\0\0" + string16(s3) + "\0\0" + string32(4 + 8 * s3);
  for (r3 = a3.length - 1; r3 >= 0 && !(a3[r3][0] <= 65535); --r3)
    ;
  const C3 = r3 + 1;
  a3[r3][0] < 65535 && 65535 === a3[r3][1] && (a3[r3][1] = 65534);
  const h2 = a3[r3][1] < 65535 ? 1 : 0, l3 = C3 + h2, Q3 = OpenTypeFileBuilder.getSearchParams(l3, 2);
  let E3, u3, d3, f2, p2 = "", m3 = "", y3 = "", w3 = "", b3 = "", D3 = 0;
  for (r3 = 0, n3 = C3; r3 < n3; r3++) {
    E3 = a3[r3];
    u3 = E3[0];
    d3 = E3[1];
    p2 += string16(u3);
    m3 += string16(d3);
    f2 = E3[2];
    let e4 = true;
    for (o3 = 1, g3 = f2.length; o3 < g3; ++o3)
      if (f2[o3] !== f2[o3 - 1] + 1) {
        e4 = false;
        break;
      }
    if (e4) {
      y3 += string16(f2[0] - u3 & 65535);
      w3 += string16(0);
    } else {
      const e5 = 2 * (l3 - r3) + 2 * D3;
      D3 += d3 - u3 + 1;
      y3 += string16(0);
      w3 += string16(e5);
      for (o3 = 0, g3 = f2.length; o3 < g3; ++o3)
        b3 += string16(f2[o3]);
    }
  }
  if (h2 > 0) {
    m3 += "ÿÿ";
    p2 += "ÿÿ";
    y3 += "\0";
    w3 += "\0\0";
  }
  const F3 = "\0\0" + string16(2 * l3) + string16(Q3.range) + string16(Q3.entry) + string16(Q3.rangeShift) + m3 + "\0\0" + p2 + y3 + w3 + b3;
  let S3 = "", k3 = "";
  if (s3 > 1) {
    c3 += "\0\0\n" + string32(4 + 8 * s3 + 4 + F3.length);
    S3 = "";
    for (r3 = 0, n3 = a3.length; r3 < n3; r3++) {
      E3 = a3[r3];
      u3 = E3[0];
      f2 = E3[2];
      let e4 = f2[0];
      for (o3 = 1, g3 = f2.length; o3 < g3; ++o3)
        if (f2[o3] !== f2[o3 - 1] + 1) {
          d3 = E3[0] + o3 - 1;
          S3 += string32(u3) + string32(d3) + string32(e4);
          u3 = d3 + 1;
          e4 = f2[o3];
        }
      S3 += string32(u3) + string32(E3[1]) + string32(e4);
    }
    k3 = "\0\f\0\0" + string32(S3.length + 16) + "\0\0\0\0" + string32(S3.length / 12);
  }
  return c3 + "\0" + string16(F3.length + 4) + F3 + k3 + S3;
}
function createOS2Table(e3, t3, i3) {
  i3 || (i3 = { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 });
  let s3 = 0, r3 = 0, n3 = 0, o3 = 0, g3 = null, c3 = 0, C3 = -1;
  if (t3) {
    for (let e4 in t3) {
      e4 |= 0;
      (g3 > e4 || !g3) && (g3 = e4);
      c3 < e4 && (c3 = e4);
      C3 = getUnicodeRangeFor(e4, C3);
      if (C3 < 32)
        s3 |= 1 << C3;
      else if (C3 < 64)
        r3 |= 1 << C3 - 32;
      else if (C3 < 96)
        n3 |= 1 << C3 - 64;
      else {
        if (!(C3 < 123))
          throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
        o3 |= 1 << C3 - 96;
      }
    }
    c3 > 65535 && (c3 = 65535);
  } else {
    g3 = 0;
    c3 = 255;
  }
  const h2 = e3.bbox || [0, 0, 0, 0], l3 = i3.unitsPerEm || 1 / (e3.fontMatrix || a2)[0], Q3 = e3.ascentScaled ? 1 : l3 / la, E3 = i3.ascent || Math.round(Q3 * (e3.ascent || h2[3]));
  let u3 = i3.descent || Math.round(Q3 * (e3.descent || h2[1]));
  u3 > 0 && e3.descent > 0 && h2[1] < 0 && (u3 = -u3);
  const d3 = i3.yMax || E3, f2 = -i3.yMin || -u3;
  return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(e3.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32(s3) + string32(r3) + string32(n3) + string32(o3) + "*21*" + string16(e3.italicAngle ? 1 : 0) + string16(g3 || e3.firstChar) + string16(c3 || e3.lastChar) + string16(E3) + string16(u3) + "\0d" + string16(d3) + string16(f2) + "\0\0\0\0\0\0\0\0" + string16(e3.xHeight) + string16(e3.capHeight) + string16(0) + string16(g3 || e3.firstChar) + "\0";
}
function createPostTable(e3) {
  return "\0\0\0" + string32(Math.floor(65536 * e3.italicAngle)) + "\0\0\0\0" + string32(e3.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e3) {
  return e3.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e3, t3) {
  t3 || (t3 = [[], []]);
  const i3 = [t3[0][0] || "Original licence", t3[0][1] || e3, t3[0][2] || "Unknown", t3[0][3] || "uniqueID", t3[0][4] || e3, t3[0][5] || "Version 0.11", t3[0][6] || createPostscriptName(e3), t3[0][7] || "Unknown", t3[0][8] || "Unknown", t3[0][9] || "Unknown"], a3 = [];
  let s3, r3, n3, o3, g3;
  for (s3 = 0, r3 = i3.length; s3 < r3; s3++) {
    g3 = t3[1][s3] || i3[s3];
    const e4 = [];
    for (n3 = 0, o3 = g3.length; n3 < o3; n3++)
      e4.push(string16(g3.charCodeAt(n3)));
    a3.push(e4.join(""));
  }
  const c3 = [i3, a3], C3 = ["\0", "\0"], h2 = ["\0\0", "\0"], l3 = ["\0\0", "	"], Q3 = i3.length * C3.length;
  let E3 = "\0\0" + string16(Q3) + string16(12 * Q3 + 6), u3 = 0;
  for (s3 = 0, r3 = C3.length; s3 < r3; s3++) {
    const e4 = c3[s3];
    for (n3 = 0, o3 = e4.length; n3 < o3; n3++) {
      g3 = e4[n3];
      E3 += C3[s3] + h2[s3] + l3[s3] + string16(n3) + string16(g3.length) + string16(u3);
      u3 += g3.length;
    }
  }
  E3 += i3.join("") + a3.join("");
  return E3;
}
function getB(e3) {
  return ya[e3] || (ya[e3] = function buildB(e4) {
    const t3 = [];
    for (let i3 = 0; i3 <= e4; i3++) {
      const a3 = i3 / e4, s3 = 1 - a3;
      t3.push(new Float32Array([s3 ** 3, 3 * a3 * s3 ** 2, 3 * a3 ** 2 * s3, a3 ** 3]));
    }
    return t3;
  }(e3));
}
function getTilingPatternIR(e3, t3, i3) {
  const a3 = t3.getArray("Matrix"), s3 = Util.normalizeRect(t3.getArray("BBox")), r3 = t3.get("XStep"), n3 = t3.get("YStep"), o3 = t3.get("PaintType"), g3 = t3.get("TilingType");
  if (s3[2] - s3[0] == 0 || s3[3] - s3[1] == 0)
    throw new FormatError(`Invalid getTilingPatternIR /BBox array: [${s3}].`);
  return ["TilingPattern", i3, e3, a3, s3, r3, n3, o3, g3];
}
function getXfaFontName(e3) {
  const t3 = normalizeFontName(e3);
  return Is()[t3];
}
function getXfaFontDict(e3) {
  const t3 = function getXfaFontWidths(e4) {
    const t4 = getXfaFontName(e4);
    if (!t4)
      return null;
    const { baseWidths: i4, baseMapping: a4, factors: s4 } = t4, r3 = s4 ? i4.map((e5, t5) => e5 * s4[t5]) : i4;
    let n3, o3 = -2;
    const g3 = [];
    for (const [e5, t5] of a4.map((e6, t6) => [e6, t6]).sort(([e6], [t6]) => e6 - t6))
      if (-1 !== e5)
        if (e5 === o3 + 1) {
          n3.push(r3[t5]);
          o3 += 1;
        } else {
          o3 = e5;
          n3 = [r3[t5]];
          g3.push(e5, n3);
        }
    return g3;
  }(e3), i3 = new Dict(null);
  i3.set("BaseFont", Name.get(e3));
  i3.set("Type", Name.get("Font"));
  i3.set("Subtype", Name.get("CIDFontType2"));
  i3.set("Encoding", Name.get("Identity-H"));
  i3.set("CIDToGIDMap", Name.get("Identity"));
  i3.set("W", t3);
  i3.set("FirstChar", t3[0]);
  i3.set("LastChar", t3.at(-2) + t3.at(-1).length - 1);
  const a3 = new Dict(null);
  i3.set("FontDescriptor", a3);
  const s3 = new Dict(null);
  s3.set("Ordering", "Identity");
  s3.set("Registry", "Adobe");
  s3.set("Supplement", 0);
  i3.set("CIDSystemInfo", s3);
  return i3;
}
function toNumberArray(e3) {
  return Array.isArray(e3) ? isNumberArray(e3, null) ? e3 : e3.map((e4) => +e4) : null;
}
function isPDFFunction(e3) {
  let t3;
  if (e3 instanceof Dict)
    t3 = e3;
  else {
    if (!(e3 instanceof BaseStream))
      return false;
    t3 = e3.dict;
  }
  return t3.has("FunctionType");
}
function buildAddOperation(e3, t3) {
  return "literal" === t3.type && 0 === t3.number ? e3 : "literal" === e3.type && 0 === e3.number ? t3 : "literal" === t3.type && "literal" === e3.type ? new AstLiteral(e3.number + t3.number) : new AstBinaryOperation("+", e3, t3, e3.min + t3.min, e3.max + t3.max);
}
function buildMulOperation(e3, t3) {
  if ("literal" === t3.type) {
    if (0 === t3.number)
      return new AstLiteral(0);
    if (1 === t3.number)
      return e3;
    if ("literal" === e3.type)
      return new AstLiteral(e3.number * t3.number);
  }
  if ("literal" === e3.type) {
    if (0 === e3.number)
      return new AstLiteral(0);
    if (1 === e3.number)
      return t3;
  }
  const i3 = Math.min(e3.min * t3.min, e3.min * t3.max, e3.max * t3.min, e3.max * t3.max), a3 = Math.max(e3.min * t3.min, e3.min * t3.max, e3.max * t3.min, e3.max * t3.max);
  return new AstBinaryOperation("*", e3, t3, i3, a3);
}
function buildSubOperation(e3, t3) {
  if ("literal" === t3.type) {
    if (0 === t3.number)
      return e3;
    if ("literal" === e3.type)
      return new AstLiteral(e3.number - t3.number);
  }
  return "binary" === t3.type && "-" === t3.op && "literal" === e3.type && 1 === e3.number && "literal" === t3.arg1.type && 1 === t3.arg1.number ? t3.arg2 : new AstBinaryOperation("-", e3, t3, e3.min - t3.max, e3.max - t3.min);
}
function buildMinOperation(e3, t3) {
  return e3.min >= t3 ? new AstLiteral(t3) : e3.max <= t3 ? e3 : new AstMin(e3, t3);
}
function isOdd(e3) {
  return 0 != (1 & e3);
}
function isEven(e3) {
  return 0 == (1 & e3);
}
function findUnequal(e3, t3, i3) {
  let a3, s3;
  for (a3 = t3, s3 = e3.length; a3 < s3; ++a3)
    if (e3[a3] !== i3)
      return a3;
  return a3;
}
function setValues(e3, t3, i3, a3) {
  for (let s3 = t3; s3 < i3; ++s3)
    e3[s3] = a3;
}
function reverseValues(e3, t3, i3) {
  for (let a3 = t3, s3 = i3 - 1; a3 < s3; ++a3, --s3) {
    const t4 = e3[a3];
    e3[a3] = e3[s3];
    e3[s3] = t4;
  }
}
function createBidiText(e3, t3, i3 = false) {
  let a3 = "ltr";
  i3 ? a3 = "ttb" : t3 || (a3 = "rtl");
  return { str: e3, dir: a3 };
}
function bidi(e3, t3 = -1, i3 = false) {
  let a3 = true;
  const s3 = e3.length;
  if (0 === s3 || i3)
    return createBidiText(e3, a3, i3);
  ls.length = s3;
  Bs.length = s3;
  let r3, n3, o3 = 0;
  for (r3 = 0; r3 < s3; ++r3) {
    ls[r3] = e3.charAt(r3);
    const t4 = e3.charCodeAt(r3);
    let i4 = "L";
    if (t4 <= 255)
      i4 = Cs[t4];
    else if (1424 <= t4 && t4 <= 1524)
      i4 = "R";
    else if (1536 <= t4 && t4 <= 1791) {
      i4 = hs[255 & t4];
      i4 || warn("Bidi: invalid Unicode character " + t4.toString(16));
    } else
      (1792 <= t4 && t4 <= 2220 || 64336 <= t4 && t4 <= 65023 || 65136 <= t4 && t4 <= 65279) && (i4 = "AL");
    "R" !== i4 && "AL" !== i4 && "AN" !== i4 || o3++;
    Bs[r3] = i4;
  }
  if (0 === o3) {
    a3 = true;
    return createBidiText(e3, a3);
  }
  if (-1 === t3)
    if (o3 / s3 < 0.3 && s3 > 4) {
      a3 = true;
      t3 = 0;
    } else {
      a3 = false;
      t3 = 1;
    }
  const g3 = [];
  for (r3 = 0; r3 < s3; ++r3)
    g3[r3] = t3;
  const c3 = isOdd(t3) ? "R" : "L", C3 = c3, h2 = C3;
  let l3, Q3 = C3;
  for (r3 = 0; r3 < s3; ++r3)
    "NSM" === Bs[r3] ? Bs[r3] = Q3 : Q3 = Bs[r3];
  Q3 = C3;
  for (r3 = 0; r3 < s3; ++r3) {
    l3 = Bs[r3];
    "EN" === l3 ? Bs[r3] = "AL" === Q3 ? "AN" : "EN" : "R" !== l3 && "L" !== l3 && "AL" !== l3 || (Q3 = l3);
  }
  for (r3 = 0; r3 < s3; ++r3) {
    l3 = Bs[r3];
    "AL" === l3 && (Bs[r3] = "R");
  }
  for (r3 = 1; r3 < s3 - 1; ++r3) {
    "ES" === Bs[r3] && "EN" === Bs[r3 - 1] && "EN" === Bs[r3 + 1] && (Bs[r3] = "EN");
    "CS" !== Bs[r3] || "EN" !== Bs[r3 - 1] && "AN" !== Bs[r3 - 1] || Bs[r3 + 1] !== Bs[r3 - 1] || (Bs[r3] = Bs[r3 - 1]);
  }
  for (r3 = 0; r3 < s3; ++r3)
    if ("EN" === Bs[r3]) {
      for (let e4 = r3 - 1; e4 >= 0 && "ET" === Bs[e4]; --e4)
        Bs[e4] = "EN";
      for (let e4 = r3 + 1; e4 < s3 && "ET" === Bs[e4]; ++e4)
        Bs[e4] = "EN";
    }
  for (r3 = 0; r3 < s3; ++r3) {
    l3 = Bs[r3];
    "WS" !== l3 && "ES" !== l3 && "ET" !== l3 && "CS" !== l3 || (Bs[r3] = "ON");
  }
  Q3 = C3;
  for (r3 = 0; r3 < s3; ++r3) {
    l3 = Bs[r3];
    "EN" === l3 ? Bs[r3] = "L" === Q3 ? "L" : "EN" : "R" !== l3 && "L" !== l3 || (Q3 = l3);
  }
  for (r3 = 0; r3 < s3; ++r3)
    if ("ON" === Bs[r3]) {
      const e4 = findUnequal(Bs, r3 + 1, "ON");
      let t4 = C3;
      r3 > 0 && (t4 = Bs[r3 - 1]);
      let i4 = h2;
      e4 + 1 < s3 && (i4 = Bs[e4 + 1]);
      "L" !== t4 && (t4 = "R");
      "L" !== i4 && (i4 = "R");
      t4 === i4 && setValues(Bs, r3, e4, t4);
      r3 = e4 - 1;
    }
  for (r3 = 0; r3 < s3; ++r3)
    "ON" === Bs[r3] && (Bs[r3] = c3);
  for (r3 = 0; r3 < s3; ++r3) {
    l3 = Bs[r3];
    isEven(g3[r3]) ? "R" === l3 ? g3[r3] += 1 : "AN" !== l3 && "EN" !== l3 || (g3[r3] += 2) : "L" !== l3 && "AN" !== l3 && "EN" !== l3 || (g3[r3] += 1);
  }
  let E3, u3 = -1, d3 = 99;
  for (r3 = 0, n3 = g3.length; r3 < n3; ++r3) {
    E3 = g3[r3];
    u3 < E3 && (u3 = E3);
    d3 > E3 && isOdd(E3) && (d3 = E3);
  }
  for (E3 = u3; E3 >= d3; --E3) {
    let e4 = -1;
    for (r3 = 0, n3 = g3.length; r3 < n3; ++r3)
      if (g3[r3] < E3) {
        if (e4 >= 0) {
          reverseValues(ls, e4, r3);
          e4 = -1;
        }
      } else
        e4 < 0 && (e4 = r3);
    e4 >= 0 && reverseValues(ls, e4, g3.length);
  }
  for (r3 = 0, n3 = ls.length; r3 < n3; ++r3) {
    const e4 = ls[r3];
    "<" !== e4 && ">" !== e4 || (ls[r3] = "");
  }
  return createBidiText(ls.join(""), a3);
}
function getFamilyName(e3) {
  const t3 = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return e3.split(/[- ,+]+/g).filter((e4) => !t3.has(e4.toLowerCase())).join(" ");
}
function generateFont({ alias: e3, local: t3, path: i3, fallback: a3, style: s3, ultimate: r3 }, n3, o3, g3 = true, c3 = true, C3 = "") {
  const h2 = { style: null, ultimate: null };
  if (t3) {
    const e4 = C3 ? ` ${C3}` : "";
    for (const i4 of t3)
      n3.push(`local(${i4}${e4})`);
  }
  if (e3) {
    const t4 = fs.get(e3), r4 = C3 || function getStyleToAppend(e4) {
      switch (e4) {
        case Es:
          return "Bold";
        case us:
          return "Italic";
        case ds:
          return "Bold Italic";
        default:
          if ("bold" === (e4 == null ? void 0 : e4.weight))
            return "Bold";
          if ("italic" === (e4 == null ? void 0 : e4.style))
            return "Italic";
      }
      return "";
    }(s3);
    Object.assign(h2, generateFont(t4, n3, o3, g3 && !a3, c3 && !i3, r4));
  }
  s3 && (h2.style = s3);
  r3 && (h2.ultimate = r3);
  if (g3 && a3) {
    const e4 = fs.get(a3), { ultimate: t4 } = generateFont(e4, n3, o3, g3, c3 && !i3, C3);
    h2.ultimate || (h2.ultimate = t4);
  }
  c3 && i3 && o3 && n3.push(`url(${o3}${i3})`);
  return h2;
}
function getFontSubstitution(e3, t3, i3, a3, s3, r3) {
  if (a3.startsWith("InvalidPDFjsFont_"))
    return null;
  "TrueType" !== r3 && "Type1" !== r3 || !/^[A-Z]{6}\+/.test(a3) || (a3 = a3.slice(7));
  const n3 = a3 = normalizeFontName(a3);
  let o3 = e3.get(n3);
  if (o3)
    return o3;
  let g3 = fs.get(a3);
  if (!g3) {
    for (const [e4, t4] of ps)
      if (a3.startsWith(e4)) {
        a3 = `${t4}${a3.substring(e4.length)}`;
        g3 = fs.get(a3);
        break;
      }
  }
  let c3 = false;
  if (!g3) {
    g3 = fs.get(s3);
    c3 = true;
  }
  const C3 = `${t3.getDocId()}_s${t3.createFontId()}`;
  if (!g3) {
    if (!validateFontName(a3)) {
      warn(`Cannot substitute the font because of its name: ${a3}`);
      e3.set(n3, null);
      return null;
    }
    const t4 = /bold/gi.test(a3), i4 = /oblique|italic/gi.test(a3), s4 = t4 && i4 && ds || t4 && Es || i4 && us || Qs;
    o3 = { css: `"${getFamilyName(a3)}",${C3}`, guessFallback: true, loadedName: C3, baseFontName: a3, src: `local(${a3})`, style: s4 };
    e3.set(n3, o3);
    return o3;
  }
  const h2 = [];
  c3 && validateFontName(a3) && h2.push(`local(${a3})`);
  const { style: l3, ultimate: Q3 } = generateFont(g3, h2, i3), E3 = null === Q3, u3 = E3 ? "" : `,${Q3}`;
  o3 = { css: `"${getFamilyName(a3)}",${C3}${u3}`, guessFallback: E3, loadedName: C3, baseFontName: a3, src: h2.join(","), style: l3 };
  e3.set(n3, o3);
  return o3;
}
function addState(e3, t3, i3, a3, s3) {
  let r3 = e3;
  for (let e4 = 0, i4 = t3.length - 1; e4 < i4; e4++) {
    const i5 = t3[e4];
    r3 = r3[i5] || (r3[i5] = []);
  }
  r3[t3.at(-1)] = { checkFn: i3, iterateFn: a3, processFn: s3 };
}
function decodeAndClamp(e3, t3, i3, a3) {
  (e3 = t3 + e3 * i3) < 0 ? e3 = 0 : e3 > a3 && (e3 = a3);
  return e3;
}
function resizeImageMask(e3, t3, i3, a3, s3, r3) {
  const n3 = s3 * r3;
  let o3;
  o3 = t3 <= 8 ? new Uint8Array(n3) : t3 <= 16 ? new Uint16Array(n3) : new Uint32Array(n3);
  const g3 = i3 / s3, c3 = a3 / r3;
  let C3, h2, l3, Q3, E3 = 0;
  const u3 = new Uint16Array(s3), d3 = i3;
  for (C3 = 0; C3 < s3; C3++)
    u3[C3] = Math.floor(C3 * g3);
  for (C3 = 0; C3 < r3; C3++) {
    l3 = Math.floor(C3 * c3) * d3;
    for (h2 = 0; h2 < s3; h2++) {
      Q3 = l3 + u3[h2];
      o3[E3++] = e3[Q3];
    }
  }
  return o3;
}
function normalizeBlendMode(e3, t3 = false) {
  if (Array.isArray(e3)) {
    for (const t4 of e3) {
      const e4 = normalizeBlendMode(t4, true);
      if (e4)
        return e4;
    }
    warn(`Unsupported blend mode Array: ${e3}`);
    return "source-over";
  }
  if (!(e3 instanceof Name))
    return t3 ? null : "source-over";
  switch (e3.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  if (t3)
    return null;
  warn(`Unsupported blend mode: ${e3.name}`);
  return "source-over";
}
function incrementCachedImageMaskCount(e3) {
  var _a3;
  e3.fn === Xe2 && ((_a3 = e3.args[0]) == null ? void 0 : _a3.count) > 0 && e3.args[0].count++;
}
function parseDefaultAppearance(e3) {
  return new DefaultAppearanceEvaluator(e3).parse();
}
function getPdfColor(e3, t3) {
  if (e3[0] === e3[1] && e3[1] === e3[2]) {
    return `${numberToString(e3[0] / 255)} ${t3 ? "g" : "G"}`;
  }
  return Array.from(e3, (e4) => numberToString(e4 / 255)).join(" ") + " " + (t3 ? "rg" : "RG");
}
function clearGlobalCaches() {
  !function clearPatternCaches() {
    ya = /* @__PURE__ */ Object.create(null);
  }();
  !function clearPrimitiveCaches() {
    mt = /* @__PURE__ */ Object.create(null);
    yt = /* @__PURE__ */ Object.create(null);
    wt = /* @__PURE__ */ Object.create(null);
  }();
  !function clearUnicodeCaches() {
    Ji.clear();
  }();
  JpxImage.cleanup();
}
function pickPlatformItem(e3) {
  return e3.has("UF") ? e3.get("UF") : e3.has("F") ? e3.get("F") : e3.has("Unix") ? e3.get("Unix") : e3.has("Mac") ? e3.get("Mac") : e3.has("DOS") ? e3.get("DOS") : null;
}
function isWhitespace(e3, t3) {
  const i3 = e3[t3];
  return " " === i3 || "\n" === i3 || "\r" === i3 || "	" === i3;
}
async function writeObject(e3, t3, i3, { encrypt: a3 = null }) {
  const s3 = a3 == null ? void 0 : a3.createCipherTransform(e3.num, e3.gen);
  i3.push(`${e3.num} ${e3.gen} obj
`);
  t3 instanceof Dict ? await writeDict(t3, i3, s3) : t3 instanceof BaseStream ? await writeStream(t3, i3, s3) : (Array.isArray(t3) || ArrayBuffer.isView(t3)) && await writeArray(t3, i3, s3);
  i3.push("\nendobj\n");
}
async function writeDict(e3, t3, i3) {
  t3.push("<<");
  for (const a3 of e3.getKeys()) {
    t3.push(` /${escapePDFName(a3)} `);
    await writeValue(e3.getRaw(a3), t3, i3);
  }
  t3.push(">>");
}
async function writeStream(e3, t3, i3) {
  let a3 = e3.getBytes();
  const { dict: s3 } = e3, [r3, n3] = await Promise.all([s3.getAsync("Filter"), s3.getAsync("DecodeParms")]), o3 = isName(Array.isArray(r3) ? await s3.xref.fetchIfRefAsync(r3[0]) : r3, "FlateDecode");
  if (a3.length >= 256 || o3)
    try {
      const e4 = new CompressionStream("deflate"), t4 = e4.writable.getWriter();
      t4.write(a3);
      t4.close();
      const i4 = await new Response(e4.readable).arrayBuffer();
      a3 = new Uint8Array(i4);
      let g4, c3;
      if (r3) {
        if (!o3) {
          g4 = Array.isArray(r3) ? [Name.get("FlateDecode"), ...r3] : [Name.get("FlateDecode"), r3];
          n3 && (c3 = Array.isArray(n3) ? [null, ...n3] : [null, n3]);
        }
      } else
        g4 = Name.get("FlateDecode");
      g4 && s3.set("Filter", g4);
      c3 && s3.set("DecodeParms", c3);
    } catch (e4) {
      info(`writeStream - cannot compress data: "${e4}".`);
    }
  let g3 = bytesToString(a3);
  i3 && (g3 = i3.encryptString(g3));
  s3.set("Length", g3.length);
  await writeDict(s3, t3, i3);
  t3.push(" stream\n", g3, "\nendstream");
}
async function writeArray(e3, t3, i3) {
  t3.push("[");
  let a3 = true;
  for (const s3 of e3) {
    a3 ? a3 = false : t3.push(" ");
    await writeValue(s3, t3, i3);
  }
  t3.push("]");
}
async function writeValue(e3, t3, i3) {
  if (e3 instanceof Name)
    t3.push(`/${escapePDFName(e3.name)}`);
  else if (e3 instanceof Ref)
    t3.push(`${e3.num} ${e3.gen} R`);
  else if (Array.isArray(e3) || ArrayBuffer.isView(e3))
    await writeArray(e3, t3, i3);
  else if ("string" == typeof e3) {
    i3 && (e3 = i3.encryptString(e3));
    t3.push(`(${escapeString(e3)})`);
  } else
    "number" == typeof e3 ? t3.push(numberToString(e3)) : "boolean" == typeof e3 ? t3.push(e3.toString()) : e3 instanceof Dict ? await writeDict(e3, t3, i3) : e3 instanceof BaseStream ? await writeStream(e3, t3, i3) : null === e3 ? t3.push("null") : warn(`Unhandled value in writer: ${typeof e3}, please file a bug.`);
}
function writeInt(e3, t3, i3, a3) {
  for (let s3 = t3 + i3 - 1; s3 > i3 - 1; s3--) {
    a3[s3] = 255 & e3;
    e3 >>= 8;
  }
  return i3 + t3;
}
function writeString(e3, t3, i3) {
  for (let a3 = 0, s3 = e3.length; a3 < s3; a3++)
    i3[t3 + a3] = 255 & e3.charCodeAt(a3);
}
function updateXFA({ xfaData: e3, xfaDatasetsRef: t3, newRefs: i3, xref: a3 }) {
  if (null === e3) {
    e3 = function writeXFADataForAcroform(e4, t4) {
      const i4 = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e4);
      for (const { xfa: e5 } of t4) {
        if (!e5)
          continue;
        const { path: t5, value: a5 } = e5;
        if (!t5)
          continue;
        const s4 = parseXFAPath(t5);
        let r4 = i4.documentElement.searchNode(s4, 0);
        !r4 && s4.length > 1 && (r4 = i4.documentElement.searchNode([s4.at(-1)], 0));
        r4 ? r4.childNodes = Array.isArray(a5) ? a5.map((e6) => new SimpleDOMNode("value", e6)) : [new SimpleDOMNode("#text", a5)] : warn(`Node not found for path: ${t5}`);
      }
      const a4 = [];
      i4.documentElement.dump(a4);
      return a4.join("");
    }(a3.fetchIfRef(t3).getString(), i3);
  }
  const s3 = a3.encrypt;
  if (s3) {
    e3 = s3.createCipherTransform(t3.num, t3.gen).encryptString(e3);
  }
  const r3 = `${t3.num} ${t3.gen} obj
<< /Type /EmbeddedFile /Length ${e3.length}>>
stream
` + e3 + "\nendstream\nendobj\n";
  i3.push({ ref: t3, data: r3 });
}
function getIndexes(e3) {
  const t3 = [];
  for (const { ref: i3 } of e3)
    i3.num === t3.at(-2) + t3.at(-1) ? t3[t3.length - 1] += 1 : t3.push(i3.num, 1);
  return t3;
}
function computeIDs(e3, t3, i3) {
  if (Array.isArray(t3.fileIds) && t3.fileIds.length > 0) {
    const a3 = function computeMD5(e4, t4) {
      const i4 = Math.floor(Date.now() / 1e3), a4 = t4.filename || "", s3 = [i4.toString(), a4, e4.toString()];
      let r3 = s3.reduce((e5, t5) => e5 + t5.length, 0);
      for (const e5 of Object.values(t4.info)) {
        s3.push(e5);
        r3 += e5.length;
      }
      const n3 = new Uint8Array(r3);
      let o3 = 0;
      for (const e5 of s3) {
        writeString(e5, o3, n3);
        o3 += e5.length;
      }
      return bytesToString(Hs(n3));
    }(e3, t3);
    i3.set("ID", [t3.fileIds[0], a3]);
  }
}
async function incrementalUpdate({ originalData: e3, xrefInfo: t3, newRefs: i3, xref: a3 = null, hasXfa: s3 = false, xfaDatasetsRef: r3 = null, hasXfaDatasetsEntry: n3 = false, needAppearances: o3, acroFormRef: g3 = null, acroForm: c3 = null, xfaData: C3 = null, useXrefStream: h2 = false }) {
  await async function updateAcroform({ xref: e4, acroForm: t4, acroFormRef: i4, hasXfa: a4, hasXfaDatasetsEntry: s4, xfaDatasetsRef: r4, needAppearances: n4, newRefs: o4 }) {
    !a4 || s4 || r4 || warn("XFA - Cannot save it");
    if (!n4 && (!a4 || !r4 || s4))
      return;
    const g4 = t4.clone();
    if (a4 && !s4) {
      const e5 = t4.get("XFA").slice();
      e5.splice(2, 0, "datasets");
      e5.splice(3, 0, r4);
      g4.set("XFA", e5);
    }
    n4 && g4.set("NeedAppearances", true);
    const c4 = [];
    await writeObject(i4, g4, c4, e4);
    o4.push({ ref: i4, data: c4.join("") });
  }({ xref: a3, acroForm: c3, acroFormRef: g3, hasXfa: s3, hasXfaDatasetsEntry: n3, xfaDatasetsRef: r3, needAppearances: o3, newRefs: i3 });
  s3 && updateXFA({ xfaData: C3, xfaDatasetsRef: r3, newRefs: i3, xref: a3 });
  const l3 = [];
  let Q3 = e3.length;
  const E3 = e3.at(-1);
  if (10 !== E3 && 13 !== E3) {
    l3.push("\n");
    Q3 += 1;
  }
  const u3 = function getTrailerDict(e4, t4, i4) {
    const a4 = new Dict(null);
    a4.set("Prev", e4.startXRef);
    const s4 = e4.newRef;
    if (i4) {
      t4.push({ ref: s4, data: "" });
      a4.set("Size", s4.num + 1);
      a4.set("Type", Name.get("XRef"));
    } else
      a4.set("Size", s4.num);
    null !== e4.rootRef && a4.set("Root", e4.rootRef);
    null !== e4.infoRef && a4.set("Info", e4.infoRef);
    null !== e4.encryptRef && a4.set("Encrypt", e4.encryptRef);
    return a4;
  }(t3, i3, h2);
  i3 = i3.sort((e4, t4) => e4.ref.num - t4.ref.num);
  for (const { data: e4 } of i3)
    null !== e4 && l3.push(e4);
  await (h2 ? async function getXRefStreamTable(e4, t4, i4, a4, s4) {
    const r4 = [];
    let n4 = 0, o4 = 0;
    for (const { ref: e5, data: a5 } of i4) {
      let i5;
      n4 = Math.max(n4, t4);
      if (null !== a5) {
        i5 = Math.min(e5.gen, 65535);
        r4.push([1, t4, i5]);
        t4 += a5.length;
      } else {
        i5 = Math.min(e5.gen + 1, 65535);
        r4.push([0, 0, i5]);
      }
      o4 = Math.max(o4, i5);
    }
    a4.set("Index", getIndexes(i4));
    const g4 = [1, getSizeInBytes(n4), getSizeInBytes(o4)];
    a4.set("W", g4);
    computeIDs(t4, e4, a4);
    const c4 = g4.reduce((e5, t5) => e5 + t5, 0), C4 = new Uint8Array(c4 * r4.length), h3 = new Stream(C4);
    h3.dict = a4;
    let l4 = 0;
    for (const [e5, t5, i5] of r4) {
      l4 = writeInt(e5, g4[0], l4, C4);
      l4 = writeInt(t5, g4[1], l4, C4);
      l4 = writeInt(i5, g4[2], l4, C4);
    }
    await writeObject(e4.newRef, h3, s4, {});
    s4.push("startxref\n", t4.toString(), "\n%%EOF\n");
  }(t3, Q3, i3, u3, l3) : async function getXRefTable(e4, t4, i4, a4, s4) {
    s4.push("xref\n");
    const r4 = getIndexes(i4);
    let n4 = 0;
    for (const { ref: e5, data: a5 } of i4) {
      if (e5.num === r4[n4]) {
        s4.push(`${r4[n4]} ${r4[n4 + 1]}
`);
        n4 += 2;
      }
      if (null !== a5) {
        s4.push(`${t4.toString().padStart(10, "0")} ${Math.min(e5.gen, 65535).toString().padStart(5, "0")} n\r
`);
        t4 += a5.length;
      } else
        s4.push(`0000000000 ${Math.min(e5.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
    }
    computeIDs(t4, e4, a4);
    s4.push("trailer\n");
    await writeDict(a4, s4);
    s4.push("\nstartxref\n", t4.toString(), "\n%%EOF\n");
  }(t3, Q3, i3, u3, l3));
  const d3 = l3.reduce((e4, t4) => e4 + t4.length, e3.length), f2 = new Uint8Array(d3);
  f2.set(e3);
  let p2 = e3.length;
  for (const e4 of l3) {
    writeString(e4, p2, f2);
    p2 += e4.length;
  }
  return f2;
}
function isValidExplicitDest(e3) {
  if (!Array.isArray(e3) || e3.length < 2)
    return false;
  const [t3, i3, ...a3] = e3;
  if (!(t3 instanceof Ref || Number.isInteger(t3)))
    return false;
  if (!(i3 instanceof Name))
    return false;
  let s3 = true;
  switch (i3.name) {
    case "XYZ":
      if (3 !== a3.length)
        return false;
      break;
    case "Fit":
    case "FitB":
      return 0 === a3.length;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (1 !== a3.length)
        return false;
      break;
    case "FitR":
      if (4 !== a3.length)
        return false;
      s3 = false;
      break;
    default:
      return false;
  }
  for (const e4 of a3)
    if (!("number" == typeof e4 || s3 && null === e4))
      return false;
  return true;
}
function fetchDest(e3) {
  e3 instanceof Dict && (e3 = e3.get("D"));
  return isValidExplicitDest(e3) ? e3 : null;
}
function fetchRemoteDest(e3) {
  let t3 = e3.get("D");
  if (t3) {
    t3 instanceof Name && (t3 = t3.name);
    if ("string" == typeof t3)
      return stringToPDFString(t3);
    if (isValidExplicitDest(t3))
      return JSON.stringify(t3);
  }
  return null;
}
function addChildren(e3, t3) {
  if (e3 instanceof Dict)
    e3 = e3.getRawValues();
  else if (e3 instanceof BaseStream)
    e3 = e3.dict.getRawValues();
  else if (!Array.isArray(e3))
    return;
  for (const a3 of e3)
    ((i3 = a3) instanceof Ref || i3 instanceof Dict || i3 instanceof BaseStream || Array.isArray(i3)) && t3.push(a3);
  var i3;
}
function stripQuotes(e3) {
  return e3.startsWith("'") || e3.startsWith('"') ? e3.slice(1, -1) : e3;
}
function getInteger({ data: e3, defaultValue: t3, validate: i3 }) {
  if (!e3)
    return t3;
  e3 = e3.trim();
  const a3 = parseInt(e3, 10);
  return !isNaN(a3) && i3(a3) ? a3 : t3;
}
function getFloat({ data: e3, defaultValue: t3, validate: i3 }) {
  if (!e3)
    return t3;
  e3 = e3.trim();
  const a3 = parseFloat(e3);
  return !isNaN(a3) && i3(a3) ? a3 : t3;
}
function getKeyword({ data: e3, defaultValue: t3, validate: i3 }) {
  return e3 && i3(e3 = e3.trim()) ? e3 : t3;
}
function getStringOption(e3, t3) {
  return getKeyword({ data: e3, defaultValue: t3[0], validate: (e4) => t3.includes(e4) });
}
function getMeasurement(e3, t3 = "0") {
  t3 || (t3 = "0");
  if (!e3)
    return getMeasurement(t3);
  const i3 = e3.trim().match(cn);
  if (!i3)
    return getMeasurement(t3);
  const [, a3, s3] = i3, r3 = parseFloat(a3);
  if (isNaN(r3))
    return getMeasurement(t3);
  if (0 === r3)
    return 0;
  const n3 = In[s3];
  return n3 ? n3(r3) : r3;
}
function getRatio(e3) {
  if (!e3)
    return { num: 1, den: 1 };
  const t3 = e3.trim().split(/\s*:\s*/).map((e4) => parseFloat(e4)).filter((e4) => !isNaN(e4));
  1 === t3.length && t3.push(1);
  if (0 === t3.length)
    return { num: 1, den: 1 };
  const [i3, a3] = t3;
  return { num: i3, den: a3 };
}
function getRelevant(e3) {
  return e3 ? e3.trim().split(/\s+/).map((e4) => ({ excluded: "-" === e4[0], viewname: e4.substring(1) })) : [];
}
function selectFont(e3, t3) {
  return "italic" === e3.posture ? "bold" === e3.weight ? t3.bolditalic : t3.italic : "bold" === e3.weight ? t3.bold : t3.regular;
}
function parseExpression(e3, t3, i3 = true) {
  let a3 = e3.match(Cn);
  if (!a3)
    return null;
  let [s3] = a3;
  const r3 = [{ name: s3, cacheName: "." + s3, index: 0, js: null, formCalc: null, operator: ln.dot }];
  let n3 = s3.length;
  for (; n3 < e3.length; ) {
    const g3 = n3;
    if ("[" === e3.charAt(n3++)) {
      a3 = e3.slice(n3).match(hn);
      if (!a3) {
        warn("XFA - Invalid index in SOM expression");
        return null;
      }
      r3.at(-1).index = "*" === (o3 = (o3 = a3[0]).trim()) ? 1 / 0 : parseInt(o3, 10) || 0;
      n3 += a3[0].length + 1;
      continue;
    }
    let c3;
    switch (e3.charAt(n3)) {
      case ".":
        if (!t3)
          return null;
        n3++;
        c3 = ln.dotDot;
        break;
      case "#":
        n3++;
        c3 = ln.dotHash;
        break;
      case "[":
        if (i3) {
          warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
          return null;
        }
        c3 = ln.dotBracket;
        break;
      case "(":
        if (i3) {
          warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
          return null;
        }
        c3 = ln.dotParen;
        break;
      default:
        c3 = ln.dot;
    }
    a3 = e3.slice(n3).match(Cn);
    if (!a3)
      break;
    [s3] = a3;
    n3 += s3.length;
    r3.push({ name: s3, cacheName: e3.slice(g3, n3), operator: c3, index: 0, js: null, formCalc: null });
  }
  var o3;
  return r3;
}
function searchNode(e3, t3, i3, a3 = true, s3 = true) {
  const r3 = parseExpression(i3, a3);
  if (!r3)
    return null;
  const n3 = Bn.get(r3[0].name);
  let o3, g3 = 0;
  if (n3) {
    o3 = true;
    e3 = [n3(e3, t3)];
    g3 = 1;
  } else {
    o3 = null === t3;
    e3 = [t3 || e3];
  }
  for (let i4 = r3.length; g3 < i4; g3++) {
    const { name: i5, cacheName: a4, operator: n4, index: c3 } = r3[g3], C3 = [];
    for (const t4 of e3) {
      if (!t4.isXFAObject)
        continue;
      let e4, r4;
      if (s3) {
        r4 = Qn.get(t4);
        if (!r4) {
          r4 = /* @__PURE__ */ new Map();
          Qn.set(t4, r4);
        }
        e4 = r4.get(a4);
      }
      if (!e4) {
        switch (n4) {
          case ln.dot:
            e4 = t4[cr](i5, false);
            break;
          case ln.dotDot:
            e4 = t4[cr](i5, true);
            break;
          case ln.dotHash:
            e4 = t4[Ir](i5);
            e4 = e4.isXFAObjectArray ? e4.children : [e4];
        }
        s3 && r4.set(a4, e4);
      }
      e4.length > 0 && C3.push(e4);
    }
    if (0 !== C3.length || o3 || 0 !== g3)
      e3 = isFinite(c3) ? C3.filter((e4) => c3 < e4.length).map((e4) => e4[c3]) : C3.flat();
    else {
      const i6 = t3[pr]();
      if (!(t3 = i6))
        return null;
      g3 = -1;
      e3 = [t3];
    }
  }
  return 0 === e3.length ? null : e3;
}
function createDataNode(e3, t3, i3) {
  const a3 = parseExpression(i3);
  if (!a3)
    return null;
  if (a3.some((e4) => e4.operator === ln.dotDot))
    return null;
  const s3 = Bn.get(a3[0].name);
  let r3 = 0;
  if (s3) {
    e3 = s3(e3, t3);
    r3 = 1;
  } else
    e3 = t3 || e3;
  for (let t4 = a3.length; r3 < t4; r3++) {
    const { name: t5, operator: i4, index: s4 } = a3[r3];
    if (!isFinite(s4)) {
      a3[r3].index = 0;
      return e3.createNodes(a3.slice(r3));
    }
    let n3;
    switch (i4) {
      case ln.dot:
        n3 = e3[cr](t5, false);
        break;
      case ln.dotDot:
        n3 = e3[cr](t5, true);
        break;
      case ln.dotHash:
        n3 = e3[Ir](t5);
        n3 = n3.isXFAObjectArray ? n3.children : [n3];
    }
    if (0 === n3.length)
      return e3.createNodes(a3.slice(r3));
    if (!(s4 < n3.length)) {
      a3[r3].index = s4 - n3.length;
      return e3.createNodes(a3.slice(r3));
    }
    {
      const t6 = n3[s4];
      if (!t6.isXFAObject) {
        warn("XFA - Cannot create a node.");
        return null;
      }
      e3 = t6;
    }
  }
  return null;
}
function measureToString(e3) {
  return "string" == typeof e3 ? "0px" : Number.isInteger(e3) ? `${e3}px` : `${e3.toFixed(2)}px`;
}
function setMinMaxDimensions(e3, t3) {
  if ("position" === e3[fr]().layout) {
    e3.minW > 0 && (t3.minWidth = measureToString(e3.minW));
    e3.maxW > 0 && (t3.maxWidth = measureToString(e3.maxW));
    e3.minH > 0 && (t3.minHeight = measureToString(e3.minH));
    e3.maxH > 0 && (t3.maxHeight = measureToString(e3.maxH));
  }
}
function layoutText(e3, t3, i3, a3, s3, r3) {
  const n3 = new TextMeasure(t3, i3, a3, s3);
  "string" == typeof e3 ? n3.addString(e3) : e3[Or](n3);
  return n3.compute(r3);
}
function layoutNode(e3, t3) {
  let i3 = null, a3 = null, s3 = false;
  if ((!e3.w || !e3.h) && e3.value) {
    let r3 = 0, n3 = 0;
    if (e3.margin) {
      r3 = e3.margin.leftInset + e3.margin.rightInset;
      n3 = e3.margin.topInset + e3.margin.bottomInset;
    }
    let o3 = null, g3 = null;
    if (e3.para) {
      g3 = /* @__PURE__ */ Object.create(null);
      o3 = "" === e3.para.lineHeight ? null : e3.para.lineHeight;
      g3.top = "" === e3.para.spaceAbove ? 0 : e3.para.spaceAbove;
      g3.bottom = "" === e3.para.spaceBelow ? 0 : e3.para.spaceBelow;
      g3.left = "" === e3.para.marginLeft ? 0 : e3.para.marginLeft;
      g3.right = "" === e3.para.marginRight ? 0 : e3.para.marginRight;
    }
    let c3 = e3.font;
    if (!c3) {
      const t4 = e3[mr]();
      let i4 = e3[pr]();
      for (; i4 && i4 !== t4; ) {
        if (i4.font) {
          c3 = i4.font;
          break;
        }
        i4 = i4[pr]();
      }
    }
    const C3 = (e3.w || t3.width) - r3, h2 = e3[yr].fontFinder;
    if (e3.value.exData && e3.value.exData[er] && "text/html" === e3.value.exData.contentType) {
      const t4 = layoutText(e3.value.exData[er], c3, g3, o3, h2, C3);
      a3 = t4.width;
      i3 = t4.height;
      s3 = t4.isBroken;
    } else {
      const t4 = e3.value[en]();
      if (t4) {
        const e4 = layoutText(t4, c3, g3, o3, h2, C3);
        a3 = e4.width;
        i3 = e4.height;
        s3 = e4.isBroken;
      }
    }
    null === a3 || e3.w || (a3 += r3);
    null === i3 || e3.h || (i3 += n3);
  }
  return { w: a3, h: i3, isBroken: s3 };
}
function computeBbox(e3, t3, i3) {
  let a3;
  if ("" !== e3.w && "" !== e3.h)
    a3 = [e3.x, e3.y, e3.w, e3.h];
  else {
    if (!i3)
      return null;
    let s3 = e3.w;
    if ("" === s3) {
      if (0 === e3.maxW) {
        const t4 = e3[fr]();
        s3 = "position" === t4.layout && "" !== t4.w ? 0 : e3.minW;
      } else
        s3 = Math.min(e3.maxW, i3.width);
      t3.attributes.style.width = measureToString(s3);
    }
    let r3 = e3.h;
    if ("" === r3) {
      if (0 === e3.maxH) {
        const t4 = e3[fr]();
        r3 = "position" === t4.layout && "" !== t4.h ? 0 : e3.minH;
      } else
        r3 = Math.min(e3.maxH, i3.height);
      t3.attributes.style.height = measureToString(r3);
    }
    a3 = [e3.x, e3.y, s3, r3];
  }
  return a3;
}
function fixDimensions(e3) {
  var _a3;
  const t3 = e3[fr]();
  if ((_a3 = t3.layout) == null ? void 0 : _a3.includes("row")) {
    const i3 = t3[ar], a3 = e3.colSpan;
    let s3;
    s3 = -1 === a3 ? i3.columnWidths.slice(i3.currentColumn).reduce((e4, t4) => e4 + t4, 0) : i3.columnWidths.slice(i3.currentColumn, i3.currentColumn + a3).reduce((e4, t4) => e4 + t4, 0);
    isNaN(s3) || (e3.w = s3);
  }
  t3.layout && "position" !== t3.layout && (e3.x = e3.y = 0);
  "table" === e3.layout && "" === e3.w && Array.isArray(e3.columnWidths) && (e3.w = e3.columnWidths.reduce((e4, t4) => e4 + t4, 0));
}
function layoutClass(e3) {
  switch (e3.layout) {
    case "position":
    default:
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
  }
}
function toStyle(e3, ...t3) {
  const i3 = /* @__PURE__ */ Object.create(null);
  for (const a3 of t3) {
    const t4 = e3[a3];
    if (null !== t4) {
      if (Ln.hasOwnProperty(a3))
        Ln[a3](e3, i3);
      else if (t4 instanceof XFAObject) {
        const e4 = t4[rn]();
        e4 ? Object.assign(i3, e4) : warn(`(DEBUG) - XFA - style for ${a3} not implemented yet`);
      }
    }
  }
  return i3;
}
function createWrapper(e3, t3) {
  const { attributes: i3 } = t3, { style: a3 } = i3, s3 = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
  i3.class.push("xfaWrapped");
  if (e3.border) {
    const { widths: i4, insets: r3 } = e3.border[ar];
    let n3, o3, g3 = r3[0], c3 = r3[3];
    const C3 = r3[0] + r3[2], h2 = r3[1] + r3[3];
    switch (e3.border.hand) {
      case "even":
        g3 -= i4[0] / 2;
        c3 -= i4[3] / 2;
        n3 = `calc(100% + ${(i4[1] + i4[3]) / 2 - h2}px)`;
        o3 = `calc(100% + ${(i4[0] + i4[2]) / 2 - C3}px)`;
        break;
      case "left":
        g3 -= i4[0];
        c3 -= i4[3];
        n3 = `calc(100% + ${i4[1] + i4[3] - h2}px)`;
        o3 = `calc(100% + ${i4[0] + i4[2] - C3}px)`;
        break;
      case "right":
        n3 = h2 ? `calc(100% - ${h2}px)` : "100%";
        o3 = C3 ? `calc(100% - ${C3}px)` : "100%";
    }
    const l3 = ["xfaBorder"];
    isPrintOnly(e3.border) && l3.push("xfaPrintOnly");
    const Q3 = { name: "div", attributes: { class: l3, style: { top: `${g3}px`, left: `${c3}px`, width: n3, height: o3 } }, children: [] };
    for (const e4 of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
      if (void 0 !== a3[e4]) {
        Q3.attributes.style[e4] = a3[e4];
        delete a3[e4];
      }
    s3.children.push(Q3, t3);
  } else
    s3.children.push(t3);
  for (const e4 of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
    if (void 0 !== a3[e4]) {
      s3.attributes.style[e4] = a3[e4];
      delete a3[e4];
    }
  s3.attributes.style.position = "absolute" === a3.position ? "absolute" : "relative";
  delete a3.position;
  if (a3.alignSelf) {
    s3.attributes.style.alignSelf = a3.alignSelf;
    delete a3.alignSelf;
  }
  return s3;
}
function fixTextIndent(e3) {
  const t3 = getMeasurement(e3.textIndent, "0px");
  if (t3 >= 0)
    return;
  const i3 = "padding" + ("left" === ("right" === e3.textAlign ? "right" : "left") ? "Left" : "Right"), a3 = getMeasurement(e3[i3], "0px");
  e3[i3] = a3 - t3 + "px";
}
function setAccess(e3, t3) {
  switch (e3.access) {
    case "nonInteractive":
      t3.push("xfaNonInteractive");
      break;
    case "readOnly":
      t3.push("xfaReadOnly");
      break;
    case "protected":
      t3.push("xfaDisabled");
  }
}
function isPrintOnly(e3) {
  return e3.relevant.length > 0 && !e3.relevant[0].excluded && "print" === e3.relevant[0].viewname;
}
function getCurrentPara(e3) {
  const t3 = e3[mr]()[ar].paraStack;
  return t3.length ? t3.at(-1) : null;
}
function setPara(e3, t3, i3) {
  var _a3;
  if ((_a3 = i3.attributes.class) == null ? void 0 : _a3.includes("xfaRich")) {
    if (t3) {
      "" === e3.h && (t3.height = "auto");
      "" === e3.w && (t3.width = "auto");
    }
    const a3 = getCurrentPara(e3);
    if (a3) {
      const e4 = i3.attributes.style;
      e4.display = "flex";
      e4.flexDirection = "column";
      switch (a3.vAlign) {
        case "top":
          e4.justifyContent = "start";
          break;
        case "bottom":
          e4.justifyContent = "end";
          break;
        case "middle":
          e4.justifyContent = "center";
      }
      const t4 = a3[rn]();
      for (const [i4, a4] of Object.entries(t4))
        i4 in e4 || (e4[i4] = a4);
    }
  }
}
function setFontFamily(e3, t3, i3, a3) {
  if (!i3) {
    delete a3.fontFamily;
    return;
  }
  const s3 = stripQuotes(e3.typeface);
  a3.fontFamily = `"${s3}"`;
  const r3 = i3.find(s3);
  if (r3) {
    const { fontFamily: i4 } = r3.regular.cssFontInfo;
    i4 !== s3 && (a3.fontFamily = `"${i4}"`);
    const n3 = getCurrentPara(t3);
    if (n3 && "" !== n3.lineHeight)
      return;
    if (a3.lineHeight)
      return;
    const o3 = selectFont(e3, r3);
    o3 && (a3.lineHeight = Math.max(1.2, o3.lineHeight));
  }
}
function fixURL(e3) {
  const t3 = createValidAbsoluteUrl(e3, null, { addDefaultProtocol: true, tryConvertEncoding: true });
  return t3 ? t3.href : null;
}
function createLine(e3, t3) {
  return { name: "div", attributes: { class: ["lr-tb" === e3.layout ? "xfaLr" : "xfaRl"] }, children: t3 };
}
function flushHTML(e3) {
  if (!e3[ar])
    return null;
  const t3 = { name: "div", attributes: e3[ar].attributes, children: e3[ar].children };
  if (e3[ar].failingNode) {
    const i3 = e3[ar].failingNode[rr]();
    i3 && (e3.layout.endsWith("-tb") ? t3.children.push(createLine(e3, [i3])) : t3.children.push(i3));
  }
  return 0 === t3.children.length ? null : t3;
}
function addHTML(e3, t3, i3) {
  const a3 = e3[ar], s3 = a3.availableSpace, [r3, n3, o3, g3] = i3;
  switch (e3.layout) {
    case "position":
      a3.width = Math.max(a3.width, r3 + o3);
      a3.height = Math.max(a3.height, n3 + g3);
      a3.children.push(t3);
      break;
    case "lr-tb":
    case "rl-tb":
      if (!a3.line || 1 === a3.attempt) {
        a3.line = createLine(e3, []);
        a3.children.push(a3.line);
        a3.numberInLine = 0;
      }
      a3.numberInLine += 1;
      a3.line.children.push(t3);
      if (0 === a3.attempt) {
        a3.currentWidth += o3;
        a3.height = Math.max(a3.height, a3.prevHeight + g3);
      } else {
        a3.currentWidth = o3;
        a3.prevHeight = a3.height;
        a3.height += g3;
        a3.attempt = 0;
      }
      a3.width = Math.max(a3.width, a3.currentWidth);
      break;
    case "rl-row":
    case "row": {
      a3.children.push(t3);
      a3.width += o3;
      a3.height = Math.max(a3.height, g3);
      const e4 = measureToString(a3.height);
      for (const t4 of a3.children)
        t4.attributes.style.height = e4;
      break;
    }
    case "table":
    case "tb":
      a3.width = Math.min(s3.width, Math.max(a3.width, o3));
      a3.height += g3;
      a3.children.push(t3);
  }
}
function getAvailableSpace(e3) {
  const t3 = e3[ar].availableSpace, i3 = e3.margin ? e3.margin.topInset + e3.margin.bottomInset : 0, a3 = e3.margin ? e3.margin.leftInset + e3.margin.rightInset : 0;
  switch (e3.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === e3[ar].attempt ? { width: t3.width - a3 - e3[ar].currentWidth, height: t3.height - i3 - e3[ar].prevHeight } : { width: t3.width - a3, height: t3.height - i3 - e3[ar].height };
    case "rl-row":
    case "row":
      return { width: e3[ar].columnWidths.slice(e3[ar].currentColumn).reduce((e4, t4) => e4 + t4), height: t3.height - a3 };
    case "table":
    case "tb":
      return { width: t3.width - a3, height: t3.height - i3 - e3[ar].height };
    default:
      return t3;
  }
}
function checkDimensions(e3, t3) {
  var _a3;
  if (null === e3[mr]()[ar].firstUnsplittable)
    return true;
  if (0 === e3.w || 0 === e3.h)
    return true;
  const i3 = e3[fr](), a3 = ((_a3 = i3[ar]) == null ? void 0 : _a3.attempt) || 0, [, s3, r3, n3] = function getTransformedBBox(e4) {
    let t4, i4, a4 = "" === e4.w ? NaN : e4.w, s4 = "" === e4.h ? NaN : e4.h, [r4, n4] = [0, 0];
    switch (e4.anchorType || "") {
      case "bottomCenter":
        [r4, n4] = [a4 / 2, s4];
        break;
      case "bottomLeft":
        [r4, n4] = [0, s4];
        break;
      case "bottomRight":
        [r4, n4] = [a4, s4];
        break;
      case "middleCenter":
        [r4, n4] = [a4 / 2, s4 / 2];
        break;
      case "middleLeft":
        [r4, n4] = [0, s4 / 2];
        break;
      case "middleRight":
        [r4, n4] = [a4, s4 / 2];
        break;
      case "topCenter":
        [r4, n4] = [a4 / 2, 0];
        break;
      case "topRight":
        [r4, n4] = [a4, 0];
    }
    switch (e4.rotate || 0) {
      case 0:
        [t4, i4] = [-r4, -n4];
        break;
      case 90:
        [t4, i4] = [-n4, r4];
        [a4, s4] = [s4, -a4];
        break;
      case 180:
        [t4, i4] = [r4, n4];
        [a4, s4] = [-a4, -s4];
        break;
      case 270:
        [t4, i4] = [n4, -r4];
        [a4, s4] = [-s4, a4];
    }
    return [e4.x + t4 + Math.min(0, a4), e4.y + i4 + Math.min(0, s4), Math.abs(a4), Math.abs(s4)];
  }(e3);
  switch (i3.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === a3 ? e3[mr]()[ar].noLayoutFailure ? "" !== e3.w ? Math.round(r3 - t3.width) <= 2 : t3.width > 2 : !("" !== e3.h && Math.round(n3 - t3.height) > 2) && ("" !== e3.w ? Math.round(r3 - t3.width) <= 2 || 0 === i3[ar].numberInLine && t3.height > 2 : t3.width > 2) : !!e3[mr]()[ar].noLayoutFailure || !("" !== e3.h && Math.round(n3 - t3.height) > 2) && (("" === e3.w || Math.round(r3 - t3.width) <= 2 || !i3[Ur]()) && t3.height > 2);
    case "table":
    case "tb":
      return !!e3[mr]()[ar].noLayoutFailure || ("" === e3.h || e3[xr]() ? ("" === e3.w || Math.round(r3 - t3.width) <= 2 || !i3[Ur]()) && t3.height > 2 : Math.round(n3 - t3.height) <= 2);
    case "position":
      if (e3[mr]()[ar].noLayoutFailure)
        return true;
      if ("" === e3.h || Math.round(n3 + s3 - t3.height) <= 2)
        return true;
      return n3 + s3 > e3[mr]()[ar].currentContentArea.h;
    case "rl-row":
    case "row":
      return !!e3[mr]()[ar].noLayoutFailure || ("" === e3.h || Math.round(n3 - t3.height) <= 2);
    default:
      return true;
  }
}
function getBorderDims(e3) {
  if (!e3 || !e3.border)
    return { w: 0, h: 0 };
  const t3 = e3.border[lr]();
  return t3 ? { w: t3.widths[0] + t3.widths[2] + t3.insets[0] + t3.insets[2], h: t3.widths[1] + t3.widths[3] + t3.insets[1] + t3.insets[3] } : { w: 0, h: 0 };
}
function hasMargin(e3) {
  return e3.margin && (e3.margin.topInset || e3.margin.rightInset || e3.margin.bottomInset || e3.margin.leftInset);
}
function _setValue(e3, t3) {
  if (!e3.value) {
    const t4 = new Value({});
    e3[Xs](t4);
    e3.value = t4;
  }
  e3.value[$r](t3);
}
function* getContainedChildren(e3) {
  for (const t3 of e3[Er]())
    t3 instanceof SubformSet ? yield* t3[ur]() : yield t3;
}
function isRequired(e3) {
  var _a3;
  return "error" === ((_a3 = e3.validate) == null ? void 0 : _a3.nullTest);
}
function setTabIndex(e3) {
  for (; e3; ) {
    if (!e3.traversal) {
      e3[An] = e3[pr]()[An];
      return;
    }
    if (e3[An])
      return;
    let t3 = null;
    for (const i4 of e3.traversal[Er]())
      if ("next" === i4.operation) {
        t3 = i4;
        break;
      }
    if (!t3 || !t3.ref) {
      e3[An] = e3[pr]()[An];
      return;
    }
    const i3 = e3[mr]();
    e3[An] = ++i3[An];
    const a3 = i3[Vr](t3.ref, e3);
    if (!a3)
      return;
    e3 = a3[0];
  }
}
function applyAssist(e3, t3) {
  var _a3;
  const i3 = e3.assist;
  if (i3) {
    const e4 = i3[an]();
    e4 && (t3.title = e4);
    const a3 = i3.role.match(Yn);
    if (a3) {
      const e5 = "heading", i4 = a3[1];
      t3.role = e5;
      t3["aria-level"] = i4;
    }
  }
  if ("table" === e3.layout)
    t3.role = "table";
  else if ("row" === e3.layout)
    t3.role = "row";
  else {
    const i4 = e3[pr]();
    "row" === i4.layout && (t3.role = "TH" === ((_a3 = i4.assist) == null ? void 0 : _a3.role) ? "columnheader" : "cell");
  }
}
function ariaLabel(e3) {
  if (!e3.assist)
    return null;
  const t3 = e3.assist;
  return t3.speak && "" !== t3.speak[er] ? t3.speak[er] : t3.toolTip ? t3.toolTip[er] : null;
}
function valueToHtml(e3) {
  return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: e3 }] });
}
function setFirstUnsplittable(e3) {
  const t3 = e3[mr]();
  if (null === t3[ar].firstUnsplittable) {
    t3[ar].firstUnsplittable = e3;
    t3[ar].noLayoutFailure = true;
  }
}
function unsetFirstUnsplittable(e3) {
  const t3 = e3[mr]();
  t3[ar].firstUnsplittable === e3 && (t3[ar].noLayoutFailure = false);
}
function handleBreak(e3) {
  if (e3[ar])
    return false;
  e3[ar] = /* @__PURE__ */ Object.create(null);
  if ("auto" === e3.targetType)
    return false;
  const t3 = e3[mr]();
  let i3 = null;
  if (e3.target) {
    i3 = t3[Vr](e3.target, e3[pr]());
    if (!i3)
      return false;
    i3 = i3[0];
  }
  const { currentPageArea: a3, currentContentArea: s3 } = t3[ar];
  if ("pageArea" === e3.targetType) {
    i3 instanceof PageArea || (i3 = null);
    if (e3.startNew) {
      e3[ar].target = i3 || a3;
      return true;
    }
    if (i3 && i3 !== a3) {
      e3[ar].target = i3;
      return true;
    }
    return false;
  }
  i3 instanceof ContentArea || (i3 = null);
  const r3 = i3 && i3[pr]();
  let n3, o3 = r3;
  if (e3.startNew)
    if (i3) {
      const e4 = r3.contentArea.children, t4 = e4.indexOf(s3), a4 = e4.indexOf(i3);
      -1 !== t4 && t4 < a4 && (o3 = null);
      n3 = a4 - 1;
    } else
      n3 = a3.contentArea.children.indexOf(s3);
  else {
    if (!i3 || i3 === s3)
      return false;
    n3 = r3.contentArea.children.indexOf(i3) - 1;
    o3 = r3 === a3 ? null : r3;
  }
  e3[ar].target = o3;
  e3[ar].index = n3;
  return true;
}
function handleOverflow(e3, t3, i3) {
  const a3 = e3[mr](), s3 = a3[ar].noLayoutFailure, r3 = t3[fr];
  t3[fr] = () => e3;
  a3[ar].noLayoutFailure = true;
  const n3 = t3[an](i3);
  e3[js](n3.html, n3.bbox);
  a3[ar].noLayoutFailure = s3;
  t3[fr] = r3;
}
function createText(e3) {
  const t3 = new Text({});
  t3[er] = e3;
  return t3;
}
function mapStyle(e3, t3, i3) {
  const a3 = /* @__PURE__ */ Object.create(null);
  if (!e3)
    return a3;
  const s3 = /* @__PURE__ */ Object.create(null);
  for (const [t4, i4] of e3.split(";").map((e4) => e4.split(":", 2))) {
    const e4 = $n.get(t4);
    if ("" === e4)
      continue;
    let r3 = i4;
    e4 && (r3 = "string" == typeof e4 ? e4 : e4(i4, s3));
    t4.endsWith("scale") ? a3.transform = a3.transform ? `${a3[t4]} ${r3}` : r3 : a3[t4.replaceAll(/-([a-zA-Z])/g, (e5, t5) => t5.toUpperCase())] = r3;
  }
  a3.fontFamily && setFontFamily({ typeface: a3.fontFamily, weight: a3.fontWeight || "normal", posture: a3.fontStyle || "normal", size: s3.fontSize || 0 }, t3, t3[yr].fontFinder, a3);
  if (i3 && a3.verticalAlign && "0px" !== a3.verticalAlign && a3.fontSize) {
    const e4 = 0.583, t4 = 0.333, i4 = getMeasurement(a3.fontSize);
    a3.fontSize = measureToString(i4 * e4);
    a3.verticalAlign = measureToString(Math.sign(getMeasurement(a3.verticalAlign)) * i4 * t4);
  }
  i3 && a3.fontSize && (a3.fontSize = `calc(${a3.fontSize} * var(--scale-factor))`);
  fixTextIndent(a3);
  return a3;
}
function getRgbColor(e3, t3 = new Uint8ClampedArray(3)) {
  if (!Array.isArray(e3))
    return t3;
  const i3 = t3 || new Uint8ClampedArray(3);
  switch (e3.length) {
    case 0:
      return null;
    case 1:
      ColorSpace.singletons.gray.getRgbItem(e3, 0, i3, 0);
      return i3;
    case 3:
      ColorSpace.singletons.rgb.getRgbItem(e3, 0, i3, 0);
      return i3;
    case 4:
      ColorSpace.singletons.cmyk.getRgbItem(e3, 0, i3, 0);
      return i3;
    default:
      return t3;
  }
}
function getPdfColorArray(e3) {
  return Array.from(e3, (e4) => e4 / 255);
}
function getQuadPoints(e3, t3) {
  const i3 = e3.getArray("QuadPoints");
  if (!Array.isArray(i3) || 0 === i3.length || i3.length % 8 > 0)
    return null;
  const a3 = [];
  for (let e4 = 0, s3 = i3.length / 8; e4 < s3; e4++) {
    let s4 = 1 / 0, r3 = -1 / 0, n3 = 1 / 0, o3 = -1 / 0;
    for (let t4 = 8 * e4, a4 = 8 * e4 + 8; t4 < a4; t4 += 2) {
      const e5 = i3[t4], a5 = i3[t4 + 1];
      s4 = Math.min(e5, s4);
      r3 = Math.max(e5, r3);
      n3 = Math.min(a5, n3);
      o3 = Math.max(a5, o3);
    }
    if (null !== t3 && (s4 < t3[0] || r3 > t3[2] || n3 < t3[1] || o3 > t3[3]))
      return null;
    a3.push([{ x: s4, y: o3 }, { x: r3, y: o3 }, { x: s4, y: n3 }, { x: r3, y: n3 }]);
  }
  return a3;
}
function getTransformMatrix(e3, t3, i3) {
  const [a3, s3, r3, n3] = Util.getAxialAlignedBoundingBox(t3, i3);
  if (a3 === r3 || s3 === n3)
    return [1, 0, 0, 1, e3[0], e3[1]];
  const o3 = (e3[2] - e3[0]) / (r3 - a3), g3 = (e3[3] - e3[1]) / (n3 - s3);
  return [o3, 0, 0, g3, e3[0] - a3 * o3, e3[1] - s3 * g3];
}
function decodeString(e3) {
  try {
    return stringToUTF8String(e3);
  } catch (t3) {
    warn(`UTF-8 decoding failed: "${t3}".`);
    return e3;
  }
}
function find(e3, t3, i3 = 1024, a3 = false) {
  const s3 = t3.length, r3 = e3.peekBytes(i3), n3 = r3.length - s3;
  if (n3 <= 0)
    return false;
  if (a3) {
    const i4 = s3 - 1;
    let a4 = r3.length - 1;
    for (; a4 >= i4; ) {
      let n4 = 0;
      for (; n4 < s3 && r3[a4 - n4] === t3[i4 - n4]; )
        n4++;
      if (n4 >= s3) {
        e3.pos += a4 - i4;
        return true;
      }
      a4--;
    }
  } else {
    let i4 = 0;
    for (; i4 <= n3; ) {
      let a4 = 0;
      for (; a4 < s3 && r3[i4 + a4] === t3[a4]; )
        a4++;
      if (a4 >= s3) {
        e3.pos += i4;
        return true;
      }
      i4++;
    }
  }
  return false;
}
function wrapReason(e3) {
  e3 instanceof Error || "object" == typeof e3 && null !== e3 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  switch (e3.name) {
    case "AbortException":
      return new AbortException(e3.message);
    case "MissingPDFException":
      return new MissingPDFException(e3.message);
    case "PasswordException":
      return new PasswordException(e3.message, e3.code);
    case "UnexpectedResponseException":
      return new UnexpectedResponseException(e3.message, e3.status);
    case "UnknownErrorException":
      return new UnknownErrorException(e3.message, e3.details);
    default:
      return new UnknownErrorException(e3.message, e3.toString());
  }
}
var e2, __webpack_exports__2, t2, i2, a2, s2, r2, n2, o2, g2, c2, C2, h, l2, Q2, E2, u2, d2, f, p, m2, y2, w2, b2, D2, F2, S2, k2, N2, R2, G2, x2, U2, M2, L2, H2, J2, Y2, v2, K2, T2, q2, O2, W2, j2, X2, Z2, V2, z2, _2, $2, AA, eA, tA, iA, aA, sA, rA, nA, oA, gA, IA, cA, CA, hA, lA, BA, QA, EA, uA, dA, fA, pA, mA, yA, wA, bA, DA, FA, SA, kA, NA, RA, GA, xA, UA, MA, LA, HA, JA, YA, vA, KA, TA, qA, OA, PA, WA, jA, XA, ZA, VA, zA, _A, $A, Ae2, ee2, te2, ie2, ae2, se2, re2, ne2, oe2, ge2, Ie2, ce2, Ce2, he2, le2, Be2, Qe, Ee2, ue2, de2, fe2, pe2, me2, ye2, we2, be2, De2, Fe2, Se2, ke2, Ne2, Re2, Ge2, xe2, Ue2, Me2, Le2, He2, Je2, Ye2, ve2, Ke, Te2, qe2, Oe2, Pe2, We2, je2, Xe2, Ze2, Ve2, ze2, _e2, $e2, At, et, tt, it, at, st, rt, PasswordException, UnknownErrorException, InvalidPDFException, MissingPDFException, UnexpectedResponseException, FormatError, AbortException, FeatureTest, nt, _A2, A_fn, _e3, e_fn, Util, ot, gt, It, ct, Ct, ht, lt, Bt, Qt, Et, ut, dt, ft, pt, mt, yt, wt, Name, Cmd, bt, Dict, Ref, RefSet, RefSetCache, BaseStream, Dt, MissingDataException, ParserEOFException, XRefEntryException, XRefParseException, Ft, St, Stream, StringStream, NullStream, ChunkedStream, ChunkedStreamManager, ColorSpace, AlternateCS, PatternCS, IndexedCS, DeviceGrayCS, DeviceRgbCS, _t, t_fn, DeviceCmykCS, _t2, t_fn2, CalGrayCS, _i, _a, _s, _r, _n, _o, _g, _I, _c, c_fn, _C, C_fn, _h, h_fn, _l, l_fn, _B, B_fn, _Q, Q_fn, _E, E_fn, _u, u_fn, _d, d_fn, _t3, t_fn3, _CalRGBCS, CalRGBCS, _f, f_fn, _p, p_fn, _t4, t_fn4, LabCS, kt, BinaryCMapStream, BinaryCMapReader, Nt, DecodeStream, StreamsSequenceStream, Ascii85Stream, AsciiHexStream, Rt, Gt, xt, Ut, Mt, Lt, Ht, CCITTFaxDecoder, CCITTFaxStream, Jt, Yt, vt, Kt, Tt, _m, m_fn, FlateStream, qt, ArithmeticDecoder, Jbig2Error, ContextCache, DecodingContext, Ot, Pt, Wt, jt, Xt, Zt, Vt, zt, SimpleSegmentVisitor, HuffmanLine, HuffmanTreeNode, HuffmanTable, _t5, Reader, Jbig2Image, Jbig2Stream, JpegError, DNLMarkerError, EOIMarkerError, $t, Ai, ei, ti, ii, ai, si, ri, ni, JpegImage, JpegStream, oi, gi, Ii, JpxError, _y, JpxImage, JpxStream, LZWStream, PredictorStream, RunLengthStream, Parser, ci, Lexer, Linearization, Ci, hi, CMap, IdentityCMap, CMapFactory, li, Bi, Qi, Ei, ui, di, fi, pi, mi, yi, wi, bi, Di, Fi, CFFParser, CFF, CFFHeader, CFFStrings, CFFIndex, CFFDict, Si, CFFTopDict, ki, CFFPrivateDict, Ni, CFFCharset, CFFEncoding, CFFFDSelect, CFFOffsetTracker, CFFCompiler, Ri, Gi, xi, Mi, Hi, Ji, Yi, vi, Ki, Ti, qi, Oi, Pi, Wi, ji, Xi, Zi, Vi, zi, _i2, ToUnicodeMap, IdentityToUnicodeMap, CFFFont, $i, Commands, CompiledFont, TrueTypeCompiled, Type2Compiled, FontRendererFactory, Aa, ea, GlyfTable, Glyph, GlyphHeader, Contour, SimpleGlyph, CompositeGlyph, OpenTypeFileBuilder, ta, ia, aa, sa, ra, na, oa, ga, Ia, ca, Ca, Type1CharString, Type1Parser, Type1Font, ha, la, Ba, Qa, fonts_Glyph, Font, ErrorFont, Ea, ua, da, fa, pa, ma, Pattern, _BaseShading, BaseShading, RadialAxialShading, MeshStreamReader, ya, _MeshShading, MeshShading, DummyShading, wa, ba, Da, Fa, Sa, ka, Na, Ra, Ga, xa, Ua, Ma, La, Ha, Ja, Ya, va, Ka, Ta, qa, Oa, Pa, Wa, ja, Xa, Za, Va, za, _a2, $a, As, es, ts, is, as, ss, rs, ns, os, gs, Is, PostScriptParser, cs, PostScriptToken, PostScriptLexer, BaseLocalCache, LocalImageCache, LocalColorSpaceCache, LocalFunctionCache, LocalGStateCache, LocalTilingPatternCache, RegionalImageCache, _GlobalImageCache, GlobalImageCache, PDFFunctionFactory, PDFFunction, _PostScriptStack, PostScriptStack, PostScriptEvaluator, AstNode, AstArgument, AstLiteral, AstBinaryOperation, AstMin, AstVariable, AstVariableDefinition, ExpressionBuilderVisitor, PostScriptCompiler, Cs, hs, ls, Bs, Qs, Es, us, ds, fs, ps, ImageResizer, ms, ys, ws, MurmurHash3_64, bs, NullOptimizer, QueueOptimizer, _OperatorList, OperatorList, PDFImage, Ds, Fs, Ss, ks, _TimeSlotManager, TimeSlotManager, PartialEvaluator, TranslatedFont, StateManager, TextState, EvalState, _EvaluatorPreprocessor, EvaluatorPreprocessor, DefaultAppearanceEvaluator, AppearanceStreamEvaluator, FakeUnicodeFont, NameOrNumberTree, NameTree, NumberTree, _w, FileSpec, Ns, Rs, Gs, xs, Us, Ms, Ls, XMLParserBase, SimpleDOMNode, SimpleXMLParser, MetadataParser, DecryptStream, ARCFourCipher, Hs, Word64, Js, Ys, NullCipher, AESBaseCipher, AES128Cipher, AES256Cipher, PDF17, PDF20, CipherTransform, _b, _D, D_fn, _F, F_fn, _S, S_fn, _k, k_fn, _N, N_fn, _CipherTransformFactory, CipherTransformFactory, vs, Ks, Ts, qs, Os, _R, R_fn, _G, G_fn, _x, x_fn, _U, U_fn, _StructTreeRoot, StructTreeRoot, StructElementNode, StructElement, StructTreePage, _M, M_fn, _L, L_fn, _Catalog, Catalog, ObjectLoader, Ws, js, Xs, Zs, Vs, zs, _s2, $s, Ar, er, tr, ir, ar, sr, rr, nr, or, gr, Ir, cr, Cr, hr, lr, Qr, Er, ur, dr, fr, pr, mr, yr, wr, br, Dr, Fr, Sr, kr, Nr, Rr, Gr, xr, Ur, Mr, Lr, Hr, Jr, Yr, vr, Kr, Tr, qr, Or, Pr, Wr, jr, Xr, Zr, Vr, zr, _r2, $r, An, en, tn, an, sn, rn, nn, on, gn, In, cn, HTMLResult, FontFinder, FontInfo, FontSelector, TextMeasure, Cn, hn, ln, Bn, Qn, En, un, dn, fn, pn, mn, yn, wn, bn, Dn, Fn, Sn, kn, Nn, Rn, Gn, xn, Un, Mn, XFAObject, XFAObjectArray, XFAAttribute, XmlObject, ContentObject, OptionObject, StringObject, IntegerObject, Option01, Option10, Ln, Hn, Jn, Yn, vn, Kn, AppearanceFilter, Arc, Area, Assist, Barcode, Bind, BindItems, Bookend, BooleanElement, Border, Break, BreakAfter, BreakBefore, Button, Calculate, Caption, Certificate, Certificates, CheckButton, ChoiceList, Color, Comb, Connect, ContentArea, Corner, DateElement, DateTime, DateTimeEdit, Decimal, DefaultUi, Desc, DigestMethod, DigestMethods, Draw, Edge, Encoding, Encodings, Encrypt, EncryptData, Encryption, EncryptionMethod, EncryptionMethods, Event2, ExData, ExObject, ExclGroup, Execute, Extras, Field, Fill, Filter, Float, template_Font, Format, Handler, Hyphenation, Image2, ImageEdit, Integer, Issuers, Items, Keep, KeyUsage, Line, Linear, LockDocument, Manifest, Margin, Mdp, Medium, Message, NumericEdit, Occur, Oid, Oids, Overflow, PageArea, PageSet, Para, PasswordEdit, template_Pattern, Picture, Proto, Radial, Reason, Reasons, Rectangle, RefElement, Script, SetProperty, SignData, Signature, Signing, Solid, Speak, Stipple, Subform, SubformSet, SubjectDN, SubjectDNs, Submit, Template, Text, TextEdit, Time, TimeStamp, ToolTip, Traversal, Traverse, Ui, Validate, Value, Variables, TemplateNamespace, Tn, Binder, DataHandler, qn, Acrobat, Acrobat7, ADBE_JSConsole, ADBE_JSDebugger, AddSilentPrint, AddViewerPreferences, AdjustData, AdobeExtensionLevel, Agent, AlwaysEmbed, Amd, config_Area, Attributes, AutoSave, Base, BatchOutput, BehaviorOverride, Cache, Change, Common, Compress, CompressLogicalStructure, CompressObjectStream, Compression, Config, Conformance, ContentCopy, Copies, Creator, CurrentPage, Data, Debug, DefaultTypeface, Destination, DocumentAssembly, Driver, DuplexOption, DynamicRender, Embed, config_Encrypt, config_Encryption, EncryptionLevel, Enforce, Equate, EquateRange, Exclude, ExcludeNS, FlipLabel, config_FontInfo, FormFieldFilling, GroupParent, IfEmpty, IncludeXDPContent, IncrementalLoad, IncrementalMerge, Interactive, Jog, LabelPrinter, Layout, Level, Linearized, Locale, LocaleSet, Log, MapElement, MediumInfo, config_Message, Messaging, Mode, ModifyAnnots, MsgId, NameAttr, NeverEmbed, NumberOfCopies, OpenAction, Output, OutputBin, OutputXSL, Overprint, Packets, PageOffset, PageRange, Pagination, PaginationOverride, Part, Pcl, Pdf, Pdfa, Permissions, PickTrayByPDFSize, config_Picture, PlaintextMetadata, Presence, Present, Print, PrintHighQuality, PrintScaling, PrinterName, Producer, Ps, Range, Record, Relevant, Rename, RenderPolicy, RunScripts, config_Script, ScriptModel, Severity, SilentPrint, Staple, StartNode, StartPage, SubmitFormat, SubmitUrl, SubsetBelow, SuppressBanner, Tagged, config_Template, Threshold, To, TemplateCache, Trace, Transform, Type, Uri, config_Validate, ValidateApprovalSignatures, ValidationMessaging, Version, VersionControl, ViewerPreferences, WebClient, Whitespace, Window, Xdc, Xdp, Xsl, Zpl, ConfigNamespace, On, ConnectionSet, EffectiveInputPolicy, EffectiveOutputPolicy, Operation, RootElement, SoapAction, SoapAddress, connection_set_Uri, WsdlAddress, WsdlConnection, XmlConnection, XsdConnection, ConnectionSetNamespace, Pn, datasets_Data, Datasets, DatasetsNamespace, Wn, CalendarSymbols, CurrencySymbol, CurrencySymbols, DatePattern, DatePatterns, DateTimeSymbols, Day, DayNames, Era, EraNames, locale_set_Locale, locale_set_LocaleSet, Meridiem, MeridiemNames, Month, MonthNames, NumberPattern, NumberPatterns, NumberSymbol, NumberSymbols, TimePattern, TimePatterns, TypeFace, TypeFaces, LocaleSetNamespace, jn, signature_Signature, SignatureNamespace, Xn, Stylesheet, StylesheetNamespace, Zn, xdp_Xdp, XdpNamespace, Vn, zn, _n2, $n, Ao, eo, to, io, XhtmlObject, A2, B2, Body, Br, Html, I2, Li, Ol, P2, Span, Sub, Sup, Ul, XhtmlNamespace, ao, UnknownNamespace, Root, Empty, Builder, XFAParser, XFAFactory, AnnotationFactory, Annotation, AnnotationBorderStyle, MarkupAnnotation, WidgetAnnotation, TextWidgetAnnotation, ButtonWidgetAnnotation, ChoiceWidgetAnnotation, SignatureWidgetAnnotation, TextAnnotation, LinkAnnotation, PopupAnnotation, FreeTextAnnotation, LineAnnotation, SquareAnnotation, CircleAnnotation, PolylineAnnotation, PolygonAnnotation, CaretAnnotation, InkAnnotation, HighlightAnnotation, UnderlineAnnotation, SquigglyAnnotation, StrikeOutAnnotation, StampAnnotation, FileAttachmentAnnotation, DatasetXMLParser, DatasetReader, _H, XRef, so, _J, J_fn, Page, ro, no, oo, _Y, Y_fn, PDFDocument, BasePdfManager, LocalPdfManager, NetworkPdfManager, go, Io, co, Co, ho, lo, Bo, Qo, Eo, uo, _K, K_fn, _v, v_fn, _T, T_fn, MessageHandler, PDFWorkerStream, PDFWorkerStreamReader, PDFWorkerStreamRangeReader, WorkerTask, WorkerMessageHandler, fo;
var init_pdf_worker_min = __esm({
  "node_modules/pdfjs-dist/build/pdf.worker.min.mjs"() {
    e2 = { d: (t3, i3) => {
      for (var a3 in i3)
        e2.o(i3, a3) && !e2.o(t3, a3) && Object.defineProperty(t3, a3, { enumerable: true, get: i3[a3] });
    }, o: (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3) };
    __webpack_exports__2 = globalThis.pdfjsWorker = {};
    e2.d(__webpack_exports__2, { WorkerMessageHandler: () => WorkerMessageHandler });
    t2 = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type);
    i2 = [1, 0, 0, 1, 0, 0];
    a2 = [1e-3, 0, 0, 1e-3, 0, 0];
    s2 = 1.35;
    r2 = 0.35;
    n2 = 0.25925925925925924;
    o2 = 1;
    g2 = 2;
    c2 = 4;
    C2 = 8;
    h = 16;
    l2 = 64;
    Q2 = 256;
    E2 = "pdfjs_internal_editor_";
    u2 = 3;
    d2 = 9;
    f = 13;
    p = 15;
    m2 = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
    y2 = 0;
    w2 = 4;
    b2 = 1;
    D2 = 2;
    F2 = 3;
    S2 = 1;
    k2 = 2;
    N2 = 3;
    R2 = 4;
    G2 = 5;
    x2 = 6;
    U2 = 7;
    M2 = 8;
    L2 = 9;
    H2 = 10;
    J2 = 11;
    Y2 = 12;
    v2 = 13;
    K2 = 14;
    T2 = 15;
    q2 = 16;
    O2 = 17;
    W2 = 20;
    j2 = "Group";
    X2 = "R";
    Z2 = 1;
    V2 = 2;
    z2 = 4;
    _2 = 16;
    $2 = 32;
    AA = 128;
    eA = 512;
    tA = 1;
    iA = 2;
    aA = 4096;
    sA = 8192;
    rA = 32768;
    nA = 65536;
    oA = 131072;
    gA = 1048576;
    IA = 2097152;
    cA = 8388608;
    CA = 16777216;
    hA = 1;
    lA = 2;
    BA = 3;
    QA = 4;
    EA = 5;
    uA = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" };
    dA = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" };
    fA = { O: "PageOpen", C: "PageClose" };
    pA = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
    mA = { NONE: 0, BINARY: 1 };
    yA = 1;
    wA = 2;
    bA = 3;
    DA = 4;
    FA = 5;
    SA = 6;
    kA = 7;
    NA = 8;
    RA = 9;
    GA = 10;
    xA = 11;
    UA = 12;
    MA = 13;
    LA = 14;
    HA = 15;
    JA = 16;
    YA = 17;
    vA = 18;
    KA = 19;
    TA = 20;
    qA = 21;
    OA = 22;
    PA = 23;
    WA = 24;
    jA = 25;
    XA = 26;
    ZA = 27;
    VA = 28;
    zA = 29;
    _A = 30;
    $A = 31;
    Ae2 = 32;
    ee2 = 33;
    te2 = 34;
    ie2 = 35;
    ae2 = 36;
    se2 = 37;
    re2 = 38;
    ne2 = 39;
    oe2 = 40;
    ge2 = 41;
    Ie2 = 42;
    ce2 = 43;
    Ce2 = 44;
    he2 = 45;
    le2 = 46;
    Be2 = 47;
    Qe = 48;
    Ee2 = 49;
    ue2 = 50;
    de2 = 51;
    fe2 = 52;
    pe2 = 53;
    me2 = 54;
    ye2 = 55;
    we2 = 56;
    be2 = 57;
    De2 = 58;
    Fe2 = 59;
    Se2 = 60;
    ke2 = 61;
    Ne2 = 62;
    Re2 = 63;
    Ge2 = 64;
    xe2 = 65;
    Ue2 = 66;
    Me2 = 67;
    Le2 = 68;
    He2 = 69;
    Je2 = 70;
    Ye2 = 71;
    ve2 = 72;
    Ke = 73;
    Te2 = 74;
    qe2 = 75;
    Oe2 = 76;
    Pe2 = 77;
    We2 = 80;
    je2 = 81;
    Xe2 = 83;
    Ze2 = 84;
    Ve2 = 85;
    ze2 = 86;
    _e2 = 87;
    $e2 = 88;
    At = 89;
    et = 90;
    tt = 91;
    it = 1;
    at = 2;
    st = pA.WARNINGS;
    rt = function BaseExceptionClosure() {
      function BaseException(e3, t3) {
        this.constructor === BaseException && unreachable("Cannot initialize BaseException.");
        this.message = e3;
        this.name = t3;
      }
      BaseException.prototype = new Error();
      BaseException.constructor = BaseException;
      return BaseException;
    }();
    PasswordException = class extends rt {
      constructor(e3, t3) {
        super(e3, "PasswordException");
        this.code = t3;
      }
    };
    UnknownErrorException = class extends rt {
      constructor(e3, t3) {
        super(e3, "UnknownErrorException");
        this.details = t3;
      }
    };
    InvalidPDFException = class extends rt {
      constructor(e3) {
        super(e3, "InvalidPDFException");
      }
    };
    MissingPDFException = class extends rt {
      constructor(e3) {
        super(e3, "MissingPDFException");
      }
    };
    UnexpectedResponseException = class extends rt {
      constructor(e3, t3) {
        super(e3, "UnexpectedResponseException");
        this.status = t3;
      }
    };
    FormatError = class extends rt {
      constructor(e3) {
        super(e3, "FormatError");
      }
    };
    AbortException = class extends rt {
      constructor(e3) {
        super(e3, "AbortException");
      }
    };
    FeatureTest = class {
      static get isLittleEndian() {
        return shadow(this, "isLittleEndian", function isLittleEndian() {
          const e3 = new Uint8Array(4);
          e3[0] = 1;
          return 1 === new Uint32Array(e3.buffer, 0, 1)[0];
        }());
      }
      static get isEvalSupported() {
        return shadow(this, "isEvalSupported", function isEvalSupported() {
          try {
            new Function("");
            return true;
          } catch {
            return false;
          }
        }());
      }
      static get isOffscreenCanvasSupported() {
        return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
      }
      static get platform() {
        return "undefined" != typeof navigator && "string" == typeof (navigator == null ? void 0 : navigator.platform) ? shadow(this, "platform", { isMac: navigator.platform.includes("Mac") }) : shadow(this, "platform", { isMac: false });
      }
      static get isCSSRoundSupported() {
        var _a3, _b2;
        return shadow(this, "isCSSRoundSupported", (_b2 = (_a3 = globalThis.CSS) == null ? void 0 : _a3.supports) == null ? void 0 : _b2.call(_a3, "width: round(1.5px, 1px)"));
      }
    };
    nt = Array.from(Array(256).keys(), (e3) => e3.toString(16).padStart(2, "0"));
    Util = class {
      static makeHexColor(e3, t3, i3) {
        return `#${nt[e3]}${nt[t3]}${nt[i3]}`;
      }
      static scaleMinMax(e3, t3) {
        let i3;
        if (e3[0]) {
          if (e3[0] < 0) {
            i3 = t3[0];
            t3[0] = t3[2];
            t3[2] = i3;
          }
          t3[0] *= e3[0];
          t3[2] *= e3[0];
          if (e3[3] < 0) {
            i3 = t3[1];
            t3[1] = t3[3];
            t3[3] = i3;
          }
          t3[1] *= e3[3];
          t3[3] *= e3[3];
        } else {
          i3 = t3[0];
          t3[0] = t3[1];
          t3[1] = i3;
          i3 = t3[2];
          t3[2] = t3[3];
          t3[3] = i3;
          if (e3[1] < 0) {
            i3 = t3[1];
            t3[1] = t3[3];
            t3[3] = i3;
          }
          t3[1] *= e3[1];
          t3[3] *= e3[1];
          if (e3[2] < 0) {
            i3 = t3[0];
            t3[0] = t3[2];
            t3[2] = i3;
          }
          t3[0] *= e3[2];
          t3[2] *= e3[2];
        }
        t3[0] += e3[4];
        t3[1] += e3[5];
        t3[2] += e3[4];
        t3[3] += e3[5];
      }
      static transform(e3, t3) {
        return [e3[0] * t3[0] + e3[2] * t3[1], e3[1] * t3[0] + e3[3] * t3[1], e3[0] * t3[2] + e3[2] * t3[3], e3[1] * t3[2] + e3[3] * t3[3], e3[0] * t3[4] + e3[2] * t3[5] + e3[4], e3[1] * t3[4] + e3[3] * t3[5] + e3[5]];
      }
      static applyTransform(e3, t3) {
        return [e3[0] * t3[0] + e3[1] * t3[2] + t3[4], e3[0] * t3[1] + e3[1] * t3[3] + t3[5]];
      }
      static applyInverseTransform(e3, t3) {
        const i3 = t3[0] * t3[3] - t3[1] * t3[2];
        return [(e3[0] * t3[3] - e3[1] * t3[2] + t3[2] * t3[5] - t3[4] * t3[3]) / i3, (-e3[0] * t3[1] + e3[1] * t3[0] + t3[4] * t3[1] - t3[5] * t3[0]) / i3];
      }
      static getAxialAlignedBoundingBox(e3, t3) {
        const i3 = this.applyTransform(e3, t3), a3 = this.applyTransform(e3.slice(2, 4), t3), s3 = this.applyTransform([e3[0], e3[3]], t3), r3 = this.applyTransform([e3[2], e3[1]], t3);
        return [Math.min(i3[0], a3[0], s3[0], r3[0]), Math.min(i3[1], a3[1], s3[1], r3[1]), Math.max(i3[0], a3[0], s3[0], r3[0]), Math.max(i3[1], a3[1], s3[1], r3[1])];
      }
      static inverseTransform(e3) {
        const t3 = e3[0] * e3[3] - e3[1] * e3[2];
        return [e3[3] / t3, -e3[1] / t3, -e3[2] / t3, e3[0] / t3, (e3[2] * e3[5] - e3[4] * e3[3]) / t3, (e3[4] * e3[1] - e3[5] * e3[0]) / t3];
      }
      static singularValueDecompose2dScale(e3) {
        const t3 = [e3[0], e3[2], e3[1], e3[3]], i3 = e3[0] * t3[0] + e3[1] * t3[2], a3 = e3[0] * t3[1] + e3[1] * t3[3], s3 = e3[2] * t3[0] + e3[3] * t3[2], r3 = e3[2] * t3[1] + e3[3] * t3[3], n3 = (i3 + r3) / 2, o3 = Math.sqrt((i3 + r3) ** 2 - 4 * (i3 * r3 - s3 * a3)) / 2, g3 = n3 + o3 || 1, c3 = n3 - o3 || 1;
        return [Math.sqrt(g3), Math.sqrt(c3)];
      }
      static normalizeRect(e3) {
        const t3 = e3.slice(0);
        if (e3[0] > e3[2]) {
          t3[0] = e3[2];
          t3[2] = e3[0];
        }
        if (e3[1] > e3[3]) {
          t3[1] = e3[3];
          t3[3] = e3[1];
        }
        return t3;
      }
      static intersect(e3, t3) {
        const i3 = Math.max(Math.min(e3[0], e3[2]), Math.min(t3[0], t3[2])), a3 = Math.min(Math.max(e3[0], e3[2]), Math.max(t3[0], t3[2]));
        if (i3 > a3)
          return null;
        const s3 = Math.max(Math.min(e3[1], e3[3]), Math.min(t3[1], t3[3])), r3 = Math.min(Math.max(e3[1], e3[3]), Math.max(t3[1], t3[3]));
        return s3 > r3 ? null : [i3, s3, a3, r3];
      }
      static bezierBoundingBox(e3, t3, i3, a3, s3, r3, n3, o3, g3) {
        if (g3) {
          g3[0] = Math.min(g3[0], e3, n3);
          g3[1] = Math.min(g3[1], t3, o3);
          g3[2] = Math.max(g3[2], e3, n3);
          g3[3] = Math.max(g3[3], t3, o3);
        } else
          g3 = [Math.min(e3, n3), Math.min(t3, o3), Math.max(e3, n3), Math.max(t3, o3)];
        __privateMethod(this, _e3, e_fn).call(this, e3, i3, s3, n3, t3, a3, r3, o3, 3 * (3 * (i3 - s3) - e3 + n3), 6 * (e3 - 2 * i3 + s3), 3 * (i3 - e3), g3);
        __privateMethod(this, _e3, e_fn).call(this, e3, i3, s3, n3, t3, a3, r3, o3, 3 * (3 * (a3 - r3) - t3 + o3), 6 * (t3 - 2 * a3 + r3), 3 * (a3 - t3), g3);
        return g3;
      }
    };
    _A2 = new WeakSet();
    A_fn = function(e3, t3, i3, a3, s3, r3, n3, o3, g3, c3) {
      if (g3 <= 0 || g3 >= 1)
        return;
      const C3 = 1 - g3, h2 = g3 * g3, l3 = h2 * g3, Q3 = C3 * (C3 * (C3 * e3 + 3 * g3 * t3) + 3 * h2 * i3) + l3 * a3, E3 = C3 * (C3 * (C3 * s3 + 3 * g3 * r3) + 3 * h2 * n3) + l3 * o3;
      c3[0] = Math.min(c3[0], Q3);
      c3[1] = Math.min(c3[1], E3);
      c3[2] = Math.max(c3[2], Q3);
      c3[3] = Math.max(c3[3], E3);
    };
    _e3 = new WeakSet();
    e_fn = function(e3, t3, i3, a3, s3, r3, n3, o3, g3, c3, C3, h2) {
      if (Math.abs(g3) < 1e-12) {
        Math.abs(c3) >= 1e-12 && __privateMethod(this, _A2, A_fn).call(this, e3, t3, i3, a3, s3, r3, n3, o3, -C3 / c3, h2);
        return;
      }
      const l3 = c3 ** 2 - 4 * C3 * g3;
      if (l3 < 0)
        return;
      const Q3 = Math.sqrt(l3), E3 = 2 * g3;
      __privateMethod(this, _A2, A_fn).call(this, e3, t3, i3, a3, s3, r3, n3, o3, (-c3 + Q3) / E3, h2);
      __privateMethod(this, _A2, A_fn).call(this, e3, t3, i3, a3, s3, r3, n3, o3, (-c3 - Q3) / E3, h2);
    };
    __privateAdd(Util, _A2);
    __privateAdd(Util, _e3);
    ot = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
    gt = null;
    It = null;
    ct = 0;
    Ct = 1;
    ht = 2;
    lt = 3;
    Bt = 4;
    Qt = 5;
    Et = 6;
    ut = 7;
    dt = 8;
    ft = Symbol("CIRCULAR_REF");
    pt = Symbol("EOF");
    mt = /* @__PURE__ */ Object.create(null);
    yt = /* @__PURE__ */ Object.create(null);
    wt = /* @__PURE__ */ Object.create(null);
    Name = class _Name {
      constructor(e3) {
        this.name = e3;
      }
      static get(e3) {
        return yt[e3] || (yt[e3] = new _Name(e3));
      }
    };
    Cmd = class _Cmd {
      constructor(e3) {
        this.cmd = e3;
      }
      static get(e3) {
        return mt[e3] || (mt[e3] = new _Cmd(e3));
      }
    };
    bt = function nonSerializableClosure() {
      return bt;
    };
    Dict = class _Dict {
      constructor(e3 = null) {
        this._map = /* @__PURE__ */ Object.create(null);
        this.xref = e3;
        this.objId = null;
        this.suppressEncryption = false;
        this.__nonSerializable__ = bt;
      }
      assignXref(e3) {
        this.xref = e3;
      }
      get size() {
        return Object.keys(this._map).length;
      }
      get(e3, t3, i3) {
        let a3 = this._map[e3];
        if (void 0 === a3 && void 0 !== t3) {
          a3 = this._map[t3];
          void 0 === a3 && void 0 !== i3 && (a3 = this._map[i3]);
        }
        return a3 instanceof Ref && this.xref ? this.xref.fetch(a3, this.suppressEncryption) : a3;
      }
      async getAsync(e3, t3, i3) {
        let a3 = this._map[e3];
        if (void 0 === a3 && void 0 !== t3) {
          a3 = this._map[t3];
          void 0 === a3 && void 0 !== i3 && (a3 = this._map[i3]);
        }
        return a3 instanceof Ref && this.xref ? this.xref.fetchAsync(a3, this.suppressEncryption) : a3;
      }
      getArray(e3, t3, i3) {
        let a3 = this._map[e3];
        if (void 0 === a3 && void 0 !== t3) {
          a3 = this._map[t3];
          void 0 === a3 && void 0 !== i3 && (a3 = this._map[i3]);
        }
        a3 instanceof Ref && this.xref && (a3 = this.xref.fetch(a3, this.suppressEncryption));
        if (Array.isArray(a3)) {
          a3 = a3.slice();
          for (let e4 = 0, t4 = a3.length; e4 < t4; e4++)
            a3[e4] instanceof Ref && this.xref && (a3[e4] = this.xref.fetch(a3[e4], this.suppressEncryption));
        }
        return a3;
      }
      getRaw(e3) {
        return this._map[e3];
      }
      getKeys() {
        return Object.keys(this._map);
      }
      getRawValues() {
        return Object.values(this._map);
      }
      set(e3, t3) {
        this._map[e3] = t3;
      }
      has(e3) {
        return void 0 !== this._map[e3];
      }
      forEach(e3) {
        for (const t3 in this._map)
          e3(t3, this.get(t3));
      }
      static get empty() {
        const e3 = new _Dict(null);
        e3.set = (e4, t3) => {
          unreachable("Should not call `set` on the empty dictionary.");
        };
        return shadow(this, "empty", e3);
      }
      static merge({ xref: e3, dictArray: t3, mergeSubDicts: i3 = false }) {
        const a3 = new _Dict(e3), s3 = /* @__PURE__ */ new Map();
        for (const e4 of t3)
          if (e4 instanceof _Dict)
            for (const [t4, a4] of Object.entries(e4._map)) {
              let e5 = s3.get(t4);
              if (void 0 === e5) {
                e5 = [];
                s3.set(t4, e5);
              } else if (!(i3 && a4 instanceof _Dict))
                continue;
              e5.push(a4);
            }
        for (const [t4, i4] of s3) {
          if (1 === i4.length || !(i4[0] instanceof _Dict)) {
            a3._map[t4] = i4[0];
            continue;
          }
          const s4 = new _Dict(e3);
          for (const e4 of i4)
            for (const [t5, i5] of Object.entries(e4._map))
              void 0 === s4._map[t5] && (s4._map[t5] = i5);
          s4.size > 0 && (a3._map[t4] = s4);
        }
        s3.clear();
        return a3.size > 0 ? a3 : _Dict.empty;
      }
      clone() {
        const e3 = new _Dict(this.xref);
        for (const t3 of this.getKeys())
          e3.set(t3, this.getRaw(t3));
        return e3;
      }
    };
    Ref = class _Ref {
      constructor(e3, t3) {
        this.num = e3;
        this.gen = t3;
      }
      toString() {
        return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
      }
      static fromString(e3) {
        const t3 = wt[e3];
        if (t3)
          return t3;
        const i3 = /^(\d+)R(\d*)$/.exec(e3);
        return i3 && "0" !== i3[1] ? wt[e3] = new _Ref(parseInt(i3[1]), i3[2] ? parseInt(i3[2]) : 0) : null;
      }
      static get(e3, t3) {
        const i3 = 0 === t3 ? `${e3}R` : `${e3}R${t3}`;
        return wt[i3] || (wt[i3] = new _Ref(e3, t3));
      }
    };
    RefSet = class {
      constructor(e3 = null) {
        this._set = new Set(e3 == null ? void 0 : e3._set);
      }
      has(e3) {
        return this._set.has(e3.toString());
      }
      put(e3) {
        this._set.add(e3.toString());
      }
      remove(e3) {
        this._set.delete(e3.toString());
      }
      [Symbol.iterator]() {
        return this._set.values();
      }
      clear() {
        this._set.clear();
      }
    };
    RefSetCache = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      get size() {
        return this._map.size;
      }
      get(e3) {
        return this._map.get(e3.toString());
      }
      has(e3) {
        return this._map.has(e3.toString());
      }
      put(e3, t3) {
        this._map.set(e3.toString(), t3);
      }
      putAlias(e3, t3) {
        this._map.set(e3.toString(), this.get(t3));
      }
      [Symbol.iterator]() {
        return this._map.values();
      }
      clear() {
        this._map.clear();
      }
      *items() {
        for (const [e3, t3] of this._map)
          yield [Ref.fromString(e3), t3];
      }
    };
    BaseStream = class _BaseStream {
      constructor() {
        this.constructor === _BaseStream && unreachable("Cannot initialize BaseStream.");
      }
      get length() {
        unreachable("Abstract getter `length` accessed");
      }
      get isEmpty() {
        unreachable("Abstract getter `isEmpty` accessed");
      }
      get isDataLoaded() {
        return shadow(this, "isDataLoaded", true);
      }
      getByte() {
        unreachable("Abstract method `getByte` called");
      }
      getBytes(e3) {
        unreachable("Abstract method `getBytes` called");
      }
      peekByte() {
        const e3 = this.getByte();
        -1 !== e3 && this.pos--;
        return e3;
      }
      peekBytes(e3) {
        const t3 = this.getBytes(e3);
        this.pos -= t3.length;
        return t3;
      }
      getUint16() {
        const e3 = this.getByte(), t3 = this.getByte();
        return -1 === e3 || -1 === t3 ? -1 : (e3 << 8) + t3;
      }
      getInt32() {
        return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
      }
      getByteRange(e3, t3) {
        unreachable("Abstract method `getByteRange` called");
      }
      getString(e3) {
        return bytesToString(this.getBytes(e3));
      }
      skip(e3) {
        this.pos += e3 || 1;
      }
      reset() {
        unreachable("Abstract method `reset` called");
      }
      moveStart() {
        unreachable("Abstract method `moveStart` called");
      }
      makeSubStream(e3, t3, i3 = null) {
        unreachable("Abstract method `makeSubStream` called");
      }
      getBaseStreams() {
        return null;
      }
    };
    Dt = /^[1-9]\.\d$/;
    MissingDataException = class extends rt {
      constructor(e3, t3) {
        super(`Missing data [${e3}, ${t3})`, "MissingDataException");
        this.begin = e3;
        this.end = t3;
      }
    };
    ParserEOFException = class extends rt {
      constructor(e3) {
        super(e3, "ParserEOFException");
      }
    };
    XRefEntryException = class extends rt {
      constructor(e3) {
        super(e3, "XRefEntryException");
      }
    };
    XRefParseException = class extends rt {
      constructor(e3) {
        super(e3, "XRefParseException");
      }
    };
    Ft = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
    St = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
    Stream = class _Stream extends BaseStream {
      constructor(e3, t3, i3, a3) {
        super();
        this.bytes = e3 instanceof Uint8Array ? e3 : new Uint8Array(e3);
        this.start = t3 || 0;
        this.pos = this.start;
        this.end = t3 + i3 || this.bytes.length;
        this.dict = a3;
      }
      get length() {
        return this.end - this.start;
      }
      get isEmpty() {
        return 0 === this.length;
      }
      getByte() {
        return this.pos >= this.end ? -1 : this.bytes[this.pos++];
      }
      getBytes(e3) {
        const t3 = this.bytes, i3 = this.pos, a3 = this.end;
        if (!e3)
          return t3.subarray(i3, a3);
        let s3 = i3 + e3;
        s3 > a3 && (s3 = a3);
        this.pos = s3;
        return t3.subarray(i3, s3);
      }
      getByteRange(e3, t3) {
        e3 < 0 && (e3 = 0);
        t3 > this.end && (t3 = this.end);
        return this.bytes.subarray(e3, t3);
      }
      reset() {
        this.pos = this.start;
      }
      moveStart() {
        this.start = this.pos;
      }
      makeSubStream(e3, t3, i3 = null) {
        return new _Stream(this.bytes.buffer, e3, t3, i3);
      }
    };
    StringStream = class extends Stream {
      constructor(e3) {
        super(stringToBytes(e3));
      }
    };
    NullStream = class extends Stream {
      constructor() {
        super(new Uint8Array(0));
      }
    };
    ChunkedStream = class extends Stream {
      constructor(e3, t3, i3) {
        super(new Uint8Array(e3), 0, e3, null);
        this.chunkSize = t3;
        this._loadedChunks = /* @__PURE__ */ new Set();
        this.numChunks = Math.ceil(e3 / t3);
        this.manager = i3;
        this.progressiveDataLength = 0;
        this.lastSuccessfulEnsureByteChunk = -1;
      }
      getMissingChunks() {
        const e3 = [];
        for (let t3 = 0, i3 = this.numChunks; t3 < i3; ++t3)
          this._loadedChunks.has(t3) || e3.push(t3);
        return e3;
      }
      get numChunksLoaded() {
        return this._loadedChunks.size;
      }
      get isDataLoaded() {
        return this.numChunksLoaded === this.numChunks;
      }
      onReceiveData(e3, t3) {
        const i3 = this.chunkSize;
        if (e3 % i3 != 0)
          throw new Error(`Bad begin offset: ${e3}`);
        const a3 = e3 + t3.byteLength;
        if (a3 % i3 != 0 && a3 !== this.bytes.length)
          throw new Error(`Bad end offset: ${a3}`);
        this.bytes.set(new Uint8Array(t3), e3);
        const s3 = Math.floor(e3 / i3), r3 = Math.floor((a3 - 1) / i3) + 1;
        for (let e4 = s3; e4 < r3; ++e4)
          this._loadedChunks.add(e4);
      }
      onReceiveProgressiveData(e3) {
        let t3 = this.progressiveDataLength;
        const i3 = Math.floor(t3 / this.chunkSize);
        this.bytes.set(new Uint8Array(e3), t3);
        t3 += e3.byteLength;
        this.progressiveDataLength = t3;
        const a3 = t3 >= this.end ? this.numChunks : Math.floor(t3 / this.chunkSize);
        for (let e4 = i3; e4 < a3; ++e4)
          this._loadedChunks.add(e4);
      }
      ensureByte(e3) {
        if (e3 < this.progressiveDataLength)
          return;
        const t3 = Math.floor(e3 / this.chunkSize);
        if (!(t3 > this.numChunks) && t3 !== this.lastSuccessfulEnsureByteChunk) {
          if (!this._loadedChunks.has(t3))
            throw new MissingDataException(e3, e3 + 1);
          this.lastSuccessfulEnsureByteChunk = t3;
        }
      }
      ensureRange(e3, t3) {
        if (e3 >= t3)
          return;
        if (t3 <= this.progressiveDataLength)
          return;
        const i3 = Math.floor(e3 / this.chunkSize);
        if (i3 > this.numChunks)
          return;
        const a3 = Math.min(Math.floor((t3 - 1) / this.chunkSize) + 1, this.numChunks);
        for (let s3 = i3; s3 < a3; ++s3)
          if (!this._loadedChunks.has(s3))
            throw new MissingDataException(e3, t3);
      }
      nextEmptyChunk(e3) {
        const t3 = this.numChunks;
        for (let i3 = 0; i3 < t3; ++i3) {
          const a3 = (e3 + i3) % t3;
          if (!this._loadedChunks.has(a3))
            return a3;
        }
        return null;
      }
      hasChunk(e3) {
        return this._loadedChunks.has(e3);
      }
      getByte() {
        const e3 = this.pos;
        if (e3 >= this.end)
          return -1;
        e3 >= this.progressiveDataLength && this.ensureByte(e3);
        return this.bytes[this.pos++];
      }
      getBytes(e3) {
        const t3 = this.bytes, i3 = this.pos, a3 = this.end;
        if (!e3) {
          a3 > this.progressiveDataLength && this.ensureRange(i3, a3);
          return t3.subarray(i3, a3);
        }
        let s3 = i3 + e3;
        s3 > a3 && (s3 = a3);
        s3 > this.progressiveDataLength && this.ensureRange(i3, s3);
        this.pos = s3;
        return t3.subarray(i3, s3);
      }
      getByteRange(e3, t3) {
        e3 < 0 && (e3 = 0);
        t3 > this.end && (t3 = this.end);
        t3 > this.progressiveDataLength && this.ensureRange(e3, t3);
        return this.bytes.subarray(e3, t3);
      }
      makeSubStream(e3, t3, i3 = null) {
        t3 ? e3 + t3 > this.progressiveDataLength && this.ensureRange(e3, e3 + t3) : e3 >= this.progressiveDataLength && this.ensureByte(e3);
        function ChunkedStreamSubstream() {
        }
        ChunkedStreamSubstream.prototype = Object.create(this);
        ChunkedStreamSubstream.prototype.getMissingChunks = function() {
          const e4 = this.chunkSize, t4 = Math.floor(this.start / e4), i4 = Math.floor((this.end - 1) / e4) + 1, a4 = [];
          for (let e5 = t4; e5 < i4; ++e5)
            this._loadedChunks.has(e5) || a4.push(e5);
          return a4;
        };
        Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", { get() {
          return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
        }, configurable: true });
        const a3 = new ChunkedStreamSubstream();
        a3.pos = a3.start = e3;
        a3.end = e3 + t3 || this.end;
        a3.dict = i3;
        return a3;
      }
      getBaseStreams() {
        return [this];
      }
    };
    ChunkedStreamManager = class {
      constructor(e3, t3) {
        this.length = t3.length;
        this.chunkSize = t3.rangeChunkSize;
        this.stream = new ChunkedStream(this.length, this.chunkSize, this);
        this.pdfNetworkStream = e3;
        this.disableAutoFetch = t3.disableAutoFetch;
        this.msgHandler = t3.msgHandler;
        this.currRequestId = 0;
        this._chunksNeededByRequest = /* @__PURE__ */ new Map();
        this._requestsByChunk = /* @__PURE__ */ new Map();
        this._promisesByRequest = /* @__PURE__ */ new Map();
        this.progressiveDataLength = 0;
        this.aborted = false;
        this._loadedStreamCapability = Promise.withResolvers();
      }
      sendRequest(e3, t3) {
        const i3 = this.pdfNetworkStream.getRangeReader(e3, t3);
        i3.isStreamingSupported || (i3.onProgress = this.onProgress.bind(this));
        let a3 = [], s3 = 0;
        return new Promise((e4, t4) => {
          const readChunk = ({ value: r3, done: n3 }) => {
            try {
              if (n3) {
                const t5 = arrayBuffersToBytes(a3);
                a3 = null;
                e4(t5);
                return;
              }
              s3 += r3.byteLength;
              i3.isStreamingSupported && this.onProgress({ loaded: s3 });
              a3.push(r3);
              i3.read().then(readChunk, t4);
            } catch (e5) {
              t4(e5);
            }
          };
          i3.read().then(readChunk, t4);
        }).then((t4) => {
          this.aborted || this.onReceiveData({ chunk: t4, begin: e3 });
        });
      }
      requestAllChunks(e3 = false) {
        if (!e3) {
          const e4 = this.stream.getMissingChunks();
          this._requestChunks(e4);
        }
        return this._loadedStreamCapability.promise;
      }
      _requestChunks(e3) {
        const t3 = this.currRequestId++, i3 = /* @__PURE__ */ new Set();
        this._chunksNeededByRequest.set(t3, i3);
        for (const t4 of e3)
          this.stream.hasChunk(t4) || i3.add(t4);
        if (0 === i3.size)
          return Promise.resolve();
        const a3 = Promise.withResolvers();
        this._promisesByRequest.set(t3, a3);
        const s3 = [];
        for (const e4 of i3) {
          let i4 = this._requestsByChunk.get(e4);
          if (!i4) {
            i4 = [];
            this._requestsByChunk.set(e4, i4);
            s3.push(e4);
          }
          i4.push(t3);
        }
        if (s3.length > 0) {
          const e4 = this.groupChunks(s3);
          for (const t4 of e4) {
            const e5 = t4.beginChunk * this.chunkSize, i4 = Math.min(t4.endChunk * this.chunkSize, this.length);
            this.sendRequest(e5, i4).catch(a3.reject);
          }
        }
        return a3.promise.catch((e4) => {
          if (!this.aborted)
            throw e4;
        });
      }
      getStream() {
        return this.stream;
      }
      requestRange(e3, t3) {
        t3 = Math.min(t3, this.length);
        const i3 = this.getBeginChunk(e3), a3 = this.getEndChunk(t3), s3 = [];
        for (let e4 = i3; e4 < a3; ++e4)
          s3.push(e4);
        return this._requestChunks(s3);
      }
      requestRanges(e3 = []) {
        const t3 = [];
        for (const i3 of e3) {
          const e4 = this.getBeginChunk(i3.begin), a3 = this.getEndChunk(i3.end);
          for (let i4 = e4; i4 < a3; ++i4)
            t3.includes(i4) || t3.push(i4);
        }
        t3.sort(function(e4, t4) {
          return e4 - t4;
        });
        return this._requestChunks(t3);
      }
      groupChunks(e3) {
        const t3 = [];
        let i3 = -1, a3 = -1;
        for (let s3 = 0, r3 = e3.length; s3 < r3; ++s3) {
          const r4 = e3[s3];
          i3 < 0 && (i3 = r4);
          if (a3 >= 0 && a3 + 1 !== r4) {
            t3.push({ beginChunk: i3, endChunk: a3 + 1 });
            i3 = r4;
          }
          s3 + 1 === e3.length && t3.push({ beginChunk: i3, endChunk: r4 + 1 });
          a3 = r4;
        }
        return t3;
      }
      onProgress(e3) {
        this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + e3.loaded, total: this.length });
      }
      onReceiveData(e3) {
        const t3 = e3.chunk, i3 = void 0 === e3.begin, a3 = i3 ? this.progressiveDataLength : e3.begin, s3 = a3 + t3.byteLength, r3 = Math.floor(a3 / this.chunkSize), n3 = s3 < this.length ? Math.floor(s3 / this.chunkSize) : Math.ceil(s3 / this.chunkSize);
        if (i3) {
          this.stream.onReceiveProgressiveData(t3);
          this.progressiveDataLength = s3;
        } else
          this.stream.onReceiveData(a3, t3);
        this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
        const o3 = [];
        for (let e4 = r3; e4 < n3; ++e4) {
          const t4 = this._requestsByChunk.get(e4);
          if (t4) {
            this._requestsByChunk.delete(e4);
            for (const i4 of t4) {
              const t5 = this._chunksNeededByRequest.get(i4);
              t5.has(e4) && t5.delete(e4);
              t5.size > 0 || o3.push(i4);
            }
          }
        }
        if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
          let e4;
          if (1 === this.stream.numChunksLoaded) {
            const t4 = this.stream.numChunks - 1;
            this.stream.hasChunk(t4) || (e4 = t4);
          } else
            e4 = this.stream.nextEmptyChunk(n3);
          Number.isInteger(e4) && this._requestChunks([e4]);
        }
        for (const e4 of o3) {
          const t4 = this._promisesByRequest.get(e4);
          this._promisesByRequest.delete(e4);
          t4.resolve();
        }
        this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
      }
      onError(e3) {
        this._loadedStreamCapability.reject(e3);
      }
      getBeginChunk(e3) {
        return Math.floor(e3 / this.chunkSize);
      }
      getEndChunk(e3) {
        return Math.floor((e3 - 1) / this.chunkSize) + 1;
      }
      abort(e3) {
        var _a3;
        this.aborted = true;
        (_a3 = this.pdfNetworkStream) == null ? void 0 : _a3.cancelAllRequests(e3);
        for (const t3 of this._promisesByRequest.values())
          t3.reject(e3);
      }
    };
    ColorSpace = class _ColorSpace {
      constructor(e3, t3) {
        this.constructor === _ColorSpace && unreachable("Cannot initialize ColorSpace.");
        this.name = e3;
        this.numComps = t3;
      }
      getRgb(e3, t3) {
        const i3 = new Uint8ClampedArray(3);
        this.getRgbItem(e3, t3, i3, 0);
        return i3;
      }
      getRgbItem(e3, t3, i3, a3) {
        unreachable("Should not call ColorSpace.getRgbItem");
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        unreachable("Should not call ColorSpace.getRgbBuffer");
      }
      getOutputLength(e3, t3) {
        unreachable("Should not call ColorSpace.getOutputLength");
      }
      isPassthrough(e3) {
        return false;
      }
      isDefaultDecode(e3, t3) {
        return _ColorSpace.isDefaultDecode(e3, this.numComps);
      }
      fillRgb(e3, t3, i3, a3, s3, r3, n3, o3, g3) {
        const c3 = t3 * i3;
        let C3 = null;
        const h2 = 1 << n3, l3 = i3 !== s3 || t3 !== a3;
        if (this.isPassthrough(n3))
          C3 = o3;
        else if (1 === this.numComps && c3 > h2 && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
          const t4 = n3 <= 8 ? new Uint8Array(h2) : new Uint16Array(h2);
          for (let e4 = 0; e4 < h2; e4++)
            t4[e4] = e4;
          const i4 = new Uint8ClampedArray(3 * h2);
          this.getRgbBuffer(t4, 0, h2, i4, 0, n3, 0);
          if (l3) {
            C3 = new Uint8Array(3 * c3);
            let e4 = 0;
            for (let t5 = 0; t5 < c3; ++t5) {
              const a4 = 3 * o3[t5];
              C3[e4++] = i4[a4];
              C3[e4++] = i4[a4 + 1];
              C3[e4++] = i4[a4 + 2];
            }
          } else {
            let t5 = 0;
            for (let a4 = 0; a4 < c3; ++a4) {
              const s4 = 3 * o3[a4];
              e3[t5++] = i4[s4];
              e3[t5++] = i4[s4 + 1];
              e3[t5++] = i4[s4 + 2];
              t5 += g3;
            }
          }
        } else if (l3) {
          C3 = new Uint8ClampedArray(3 * c3);
          this.getRgbBuffer(o3, 0, c3, C3, 0, n3, 0);
        } else
          this.getRgbBuffer(o3, 0, a3 * r3, e3, 0, n3, g3);
        if (C3)
          if (l3)
            !function resizeRgbImage(e4, t4, i4, a4, s4, r4, n4) {
              n4 = 1 !== n4 ? 0 : n4;
              const o4 = i4 / s4, g4 = a4 / r4;
              let c4, C4 = 0;
              const h3 = new Uint16Array(s4), l4 = 3 * i4;
              for (let e5 = 0; e5 < s4; e5++)
                h3[e5] = 3 * Math.floor(e5 * o4);
              for (let i5 = 0; i5 < r4; i5++) {
                const a5 = Math.floor(i5 * g4) * l4;
                for (let i6 = 0; i6 < s4; i6++) {
                  c4 = a5 + h3[i6];
                  t4[C4++] = e4[c4++];
                  t4[C4++] = e4[c4++];
                  t4[C4++] = e4[c4++];
                  C4 += n4;
                }
              }
            }(C3, e3, t3, i3, a3, s3, g3);
          else {
            let t4 = 0, i4 = 0;
            for (let s4 = 0, n4 = a3 * r3; s4 < n4; s4++) {
              e3[t4++] = C3[i4++];
              e3[t4++] = C3[i4++];
              e3[t4++] = C3[i4++];
              t4 += g3;
            }
          }
      }
      get usesZeroToOneRange() {
        return shadow(this, "usesZeroToOneRange", true);
      }
      static _cache(e3, t3, i3, a3) {
        if (!i3)
          throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
        if (!a3)
          throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
        let s3, r3;
        if (e3 instanceof Ref) {
          r3 = e3;
          e3 = t3.fetch(e3);
        }
        e3 instanceof Name && (s3 = e3.name);
        (s3 || r3) && i3.set(s3, r3, a3);
      }
      static getCached(e3, t3, i3) {
        if (!i3)
          throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
        if (e3 instanceof Ref) {
          const a3 = i3.getByRef(e3);
          if (a3)
            return a3;
          try {
            e3 = t3.fetch(e3);
          } catch (e4) {
            if (e4 instanceof MissingDataException)
              throw e4;
          }
        }
        if (e3 instanceof Name) {
          const t4 = i3.getByName(e3.name);
          if (t4)
            return t4;
        }
        return null;
      }
      static async parseAsync({ cs: e3, xref: t3, resources: i3 = null, pdfFunctionFactory: a3, localColorSpaceCache: s3 }) {
        const r3 = this._parse(e3, t3, i3, a3);
        this._cache(e3, t3, s3, r3);
        return r3;
      }
      static parse({ cs: e3, xref: t3, resources: i3 = null, pdfFunctionFactory: a3, localColorSpaceCache: s3 }) {
        const r3 = this.getCached(e3, t3, s3);
        if (r3)
          return r3;
        const n3 = this._parse(e3, t3, i3, a3);
        this._cache(e3, t3, s3, n3);
        return n3;
      }
      static _parse(e3, t3, i3 = null, a3) {
        if ((e3 = t3.fetchIfRef(e3)) instanceof Name)
          switch (e3.name) {
            case "G":
            case "DeviceGray":
              return this.singletons.gray;
            case "RGB":
            case "DeviceRGB":
              return this.singletons.rgb;
            case "CMYK":
            case "DeviceCMYK":
              return this.singletons.cmyk;
            case "Pattern":
              return new PatternCS(null);
            default:
              if (i3 instanceof Dict) {
                const s3 = i3.get("ColorSpace");
                if (s3 instanceof Dict) {
                  const r3 = s3.get(e3.name);
                  if (r3) {
                    if (r3 instanceof Name)
                      return this._parse(r3, t3, i3, a3);
                    e3 = r3;
                    break;
                  }
                }
              }
              throw new FormatError(`Unrecognized ColorSpace: ${e3.name}`);
          }
        if (Array.isArray(e3)) {
          const s3 = t3.fetchIfRef(e3[0]).name;
          let r3, n3, o3, g3, c3, C3;
          switch (s3) {
            case "G":
            case "DeviceGray":
              return this.singletons.gray;
            case "RGB":
            case "DeviceRGB":
              return this.singletons.rgb;
            case "CMYK":
            case "DeviceCMYK":
              return this.singletons.cmyk;
            case "CalGray":
              r3 = t3.fetchIfRef(e3[1]);
              g3 = r3.getArray("WhitePoint");
              c3 = r3.getArray("BlackPoint");
              C3 = r3.get("Gamma");
              return new CalGrayCS(g3, c3, C3);
            case "CalRGB":
              r3 = t3.fetchIfRef(e3[1]);
              g3 = r3.getArray("WhitePoint");
              c3 = r3.getArray("BlackPoint");
              C3 = r3.getArray("Gamma");
              const h2 = r3.getArray("Matrix");
              return new CalRGBCS(g3, c3, C3, h2);
            case "ICCBased":
              const l3 = t3.fetchIfRef(e3[1]).dict;
              n3 = l3.get("N");
              const Q3 = l3.get("Alternate");
              if (Q3) {
                const e4 = this._parse(Q3, t3, i3, a3);
                if (e4.numComps === n3)
                  return e4;
                warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
              }
              if (1 === n3)
                return this.singletons.gray;
              if (3 === n3)
                return this.singletons.rgb;
              if (4 === n3)
                return this.singletons.cmyk;
              break;
            case "Pattern":
              o3 = e3[1] || null;
              o3 && (o3 = this._parse(o3, t3, i3, a3));
              return new PatternCS(o3);
            case "I":
            case "Indexed":
              o3 = this._parse(e3[1], t3, i3, a3);
              const E3 = t3.fetchIfRef(e3[2]) + 1, u3 = t3.fetchIfRef(e3[3]);
              return new IndexedCS(o3, E3, u3);
            case "Separation":
            case "DeviceN":
              const d3 = t3.fetchIfRef(e3[1]);
              n3 = Array.isArray(d3) ? d3.length : 1;
              o3 = this._parse(e3[2], t3, i3, a3);
              const f2 = a3.create(e3[3]);
              return new AlternateCS(n3, o3, f2);
            case "Lab":
              r3 = t3.fetchIfRef(e3[1]);
              g3 = r3.getArray("WhitePoint");
              c3 = r3.getArray("BlackPoint");
              const p2 = r3.getArray("Range");
              return new LabCS(g3, c3, p2);
            default:
              throw new FormatError(`Unimplemented ColorSpace object: ${s3}`);
          }
        }
        throw new FormatError(`Unrecognized ColorSpace object: ${e3}`);
      }
      static isDefaultDecode(e3, t3) {
        if (!Array.isArray(e3))
          return true;
        if (2 * t3 !== e3.length) {
          warn("The decode map is not the correct length");
          return true;
        }
        for (let t4 = 0, i3 = e3.length; t4 < i3; t4 += 2)
          if (0 !== e3[t4] || 1 !== e3[t4 + 1])
            return false;
        return true;
      }
      static get singletons() {
        return shadow(this, "singletons", { get gray() {
          return shadow(this, "gray", new DeviceGrayCS());
        }, get rgb() {
          return shadow(this, "rgb", new DeviceRgbCS());
        }, get cmyk() {
          return shadow(this, "cmyk", new DeviceCmykCS());
        } });
      }
    };
    AlternateCS = class extends ColorSpace {
      constructor(e3, t3, i3) {
        super("Alternate", e3);
        this.base = t3;
        this.tintFn = i3;
        this.tmpBuf = new Float32Array(t3.numComps);
      }
      getRgbItem(e3, t3, i3, a3) {
        const s3 = this.tmpBuf;
        this.tintFn(e3, t3, s3, 0);
        this.base.getRgbItem(s3, 0, i3, a3);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        const o3 = this.tintFn, g3 = this.base, c3 = 1 / ((1 << r3) - 1), C3 = g3.numComps, h2 = g3.usesZeroToOneRange, l3 = (g3.isPassthrough(8) || !h2) && 0 === n3;
        let Q3 = l3 ? s3 : 0;
        const E3 = l3 ? a3 : new Uint8ClampedArray(C3 * i3), u3 = this.numComps, d3 = new Float32Array(u3), f2 = new Float32Array(C3);
        let p2, m3;
        for (p2 = 0; p2 < i3; p2++) {
          for (m3 = 0; m3 < u3; m3++)
            d3[m3] = e3[t3++] * c3;
          o3(d3, 0, f2, 0);
          if (h2)
            for (m3 = 0; m3 < C3; m3++)
              E3[Q3++] = 255 * f2[m3];
          else {
            g3.getRgbItem(f2, 0, E3, Q3);
            Q3 += C3;
          }
        }
        l3 || g3.getRgbBuffer(E3, 0, i3, a3, s3, 8, n3);
      }
      getOutputLength(e3, t3) {
        return this.base.getOutputLength(e3 * this.base.numComps / this.numComps, t3);
      }
    };
    PatternCS = class extends ColorSpace {
      constructor(e3) {
        super("Pattern", null);
        this.base = e3;
      }
      isDefaultDecode(e3, t3) {
        unreachable("Should not call PatternCS.isDefaultDecode");
      }
    };
    IndexedCS = class extends ColorSpace {
      constructor(e3, t3, i3) {
        super("Indexed", 1);
        this.base = e3;
        this.highVal = t3;
        const a3 = e3.numComps * t3;
        this.lookup = new Uint8Array(a3);
        if (i3 instanceof BaseStream) {
          const e4 = i3.getBytes(a3);
          this.lookup.set(e4);
        } else {
          if ("string" != typeof i3)
            throw new FormatError(`IndexedCS - unrecognized lookup table: ${i3}`);
          for (let e4 = 0; e4 < a3; ++e4)
            this.lookup[e4] = 255 & i3.charCodeAt(e4);
        }
      }
      getRgbItem(e3, t3, i3, a3) {
        const s3 = this.base.numComps, r3 = e3[t3] * s3;
        this.base.getRgbBuffer(this.lookup, r3, 1, i3, a3, 8, 0);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        const o3 = this.base, g3 = o3.numComps, c3 = o3.getOutputLength(g3, n3), C3 = this.lookup;
        for (let r4 = 0; r4 < i3; ++r4) {
          const i4 = e3[t3++] * g3;
          o3.getRgbBuffer(C3, i4, 1, a3, s3, 8, n3);
          s3 += c3;
        }
      }
      getOutputLength(e3, t3) {
        return this.base.getOutputLength(e3 * this.base.numComps, t3);
      }
      isDefaultDecode(e3, t3) {
        if (!Array.isArray(e3))
          return true;
        if (2 !== e3.length) {
          warn("Decode map length is not correct");
          return true;
        }
        if (!Number.isInteger(t3) || t3 < 1) {
          warn("Bits per component is not correct");
          return true;
        }
        return 0 === e3[0] && e3[1] === (1 << t3) - 1;
      }
    };
    DeviceGrayCS = class extends ColorSpace {
      constructor() {
        super("DeviceGray", 1);
      }
      getRgbItem(e3, t3, i3, a3) {
        const s3 = 255 * e3[t3];
        i3[a3] = i3[a3 + 1] = i3[a3 + 2] = s3;
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        const o3 = 255 / ((1 << r3) - 1);
        let g3 = t3, c3 = s3;
        for (let t4 = 0; t4 < i3; ++t4) {
          const t5 = o3 * e3[g3++];
          a3[c3++] = t5;
          a3[c3++] = t5;
          a3[c3++] = t5;
          c3 += n3;
        }
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3);
      }
    };
    DeviceRgbCS = class extends ColorSpace {
      constructor() {
        super("DeviceRGB", 3);
      }
      getRgbItem(e3, t3, i3, a3) {
        i3[a3] = 255 * e3[t3];
        i3[a3 + 1] = 255 * e3[t3 + 1];
        i3[a3 + 2] = 255 * e3[t3 + 2];
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        if (8 === r3 && 0 === n3) {
          a3.set(e3.subarray(t3, t3 + 3 * i3), s3);
          return;
        }
        const o3 = 255 / ((1 << r3) - 1);
        let g3 = t3, c3 = s3;
        for (let t4 = 0; t4 < i3; ++t4) {
          a3[c3++] = o3 * e3[g3++];
          a3[c3++] = o3 * e3[g3++];
          a3[c3++] = o3 * e3[g3++];
          c3 += n3;
        }
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3) / 3 | 0;
      }
      isPassthrough(e3) {
        return 8 === e3;
      }
    };
    DeviceCmykCS = class extends ColorSpace {
      constructor() {
        super("DeviceCMYK", 4);
        __privateAdd(this, _t);
      }
      getRgbItem(e3, t3, i3, a3) {
        __privateMethod(this, _t, t_fn).call(this, e3, t3, 1, i3, a3);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        const o3 = 1 / ((1 << r3) - 1);
        for (let r4 = 0; r4 < i3; r4++) {
          __privateMethod(this, _t, t_fn).call(this, e3, t3, o3, a3, s3);
          t3 += 4;
          s3 += 3 + n3;
        }
      }
      getOutputLength(e3, t3) {
        return e3 / 4 * (3 + t3) | 0;
      }
    };
    _t = new WeakSet();
    t_fn = function(e3, t3, i3, a3, s3) {
      const r3 = e3[t3] * i3, n3 = e3[t3 + 1] * i3, o3 = e3[t3 + 2] * i3, g3 = e3[t3 + 3] * i3;
      a3[s3] = 255 + r3 * (-4.387332384609988 * r3 + 54.48615194189176 * n3 + 18.82290502165302 * o3 + 212.25662451639585 * g3 - 285.2331026137004) + n3 * (1.7149763477362134 * n3 - 5.6096736904047315 * o3 + -17.873870861415444 * g3 - 5.497006427196366) + o3 * (-2.5217340131683033 * o3 - 21.248923337353073 * g3 + 17.5119270841813) + g3 * (-21.86122147463605 * g3 - 189.48180835922747);
      a3[s3 + 1] = 255 + r3 * (8.841041422036149 * r3 + 60.118027045597366 * n3 + 6.871425592049007 * o3 + 31.159100130055922 * g3 - 79.2970844816548) + n3 * (-15.310361306967817 * n3 + 17.575251261109482 * o3 + 131.35250912493976 * g3 - 190.9453302588951) + o3 * (4.444339102852739 * o3 + 9.8632861493405 * g3 - 24.86741582555878) + g3 * (-20.737325471181034 * g3 - 187.80453709719578);
      a3[s3 + 2] = 255 + r3 * (0.8842522430003296 * r3 + 8.078677503112928 * n3 + 30.89978309703729 * o3 - 0.23883238689178934 * g3 - 14.183576799673286) + n3 * (10.49593273432072 * n3 + 63.02378494754052 * o3 + 50.606957656360734 * g3 - 112.23884253719248) + o3 * (0.03296041114873217 * o3 + 115.60384449646641 * g3 - 193.58209356861505) + g3 * (-22.33816807309886 * g3 - 180.12613974708367);
    };
    CalGrayCS = class extends ColorSpace {
      constructor(e3, t3, i3) {
        super("CalGray", 1);
        __privateAdd(this, _t2);
        if (!e3)
          throw new FormatError("WhitePoint missing - required for color space CalGray");
        [this.XW, this.YW, this.ZW] = e3;
        [this.XB, this.YB, this.ZB] = t3 || [0, 0, 0];
        this.G = i3 || 1;
        if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW)
          throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
          info(`Invalid BlackPoint for ${this.name}, falling back to default.`);
          this.XB = this.YB = this.ZB = 0;
        }
        0 === this.XB && 0 === this.YB && 0 === this.ZB || warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
        if (this.G < 1) {
          info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
          this.G = 1;
        }
      }
      getRgbItem(e3, t3, i3, a3) {
        __privateMethod(this, _t2, t_fn2).call(this, e3, t3, i3, a3, 1);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        const o3 = 1 / ((1 << r3) - 1);
        for (let r4 = 0; r4 < i3; ++r4) {
          __privateMethod(this, _t2, t_fn2).call(this, e3, t3, a3, s3, o3);
          t3 += 1;
          s3 += 3 + n3;
        }
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3);
      }
    };
    _t2 = new WeakSet();
    t_fn2 = function(e3, t3, i3, a3, s3) {
      const r3 = (e3[t3] * s3) ** this.G, n3 = this.YW * r3, o3 = Math.max(295.8 * n3 ** 0.3333333333333333 - 40.8, 0);
      i3[a3] = o3;
      i3[a3 + 1] = o3;
      i3[a3 + 2] = o3;
    };
    _CalRGBCS = class _CalRGBCS extends ColorSpace {
      constructor(e3, t3, i3, a3) {
        super("CalRGB", 3);
        __privateAdd(this, _c);
        __privateAdd(this, _C);
        __privateAdd(this, _h);
        __privateAdd(this, _l);
        __privateAdd(this, _B);
        __privateAdd(this, _Q);
        __privateAdd(this, _E);
        __privateAdd(this, _u);
        __privateAdd(this, _d);
        __privateAdd(this, _t3);
        if (!e3)
          throw new FormatError("WhitePoint missing - required for color space CalRGB");
        const [s3, r3, n3] = this.whitePoint = e3, [o3, g3, c3] = this.blackPoint = t3 || new Float32Array(3);
        [this.GR, this.GG, this.GB] = i3 || new Float32Array([1, 1, 1]);
        [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = a3 || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        if (s3 < 0 || n3 < 0 || 1 !== r3)
          throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        if (o3 < 0 || g3 < 0 || c3 < 0) {
          info(`Invalid BlackPoint for ${this.name} [${o3}, ${g3}, ${c3}], falling back to default.`);
          this.blackPoint = new Float32Array(3);
        }
        if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
          info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
          this.GR = this.GG = this.GB = 1;
        }
      }
      getRgbItem(e3, t3, i3, a3) {
        __privateMethod(this, _t3, t_fn3).call(this, e3, t3, i3, a3, 1);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        const o3 = 1 / ((1 << r3) - 1);
        for (let r4 = 0; r4 < i3; ++r4) {
          __privateMethod(this, _t3, t_fn3).call(this, e3, t3, a3, s3, o3);
          t3 += 3;
          s3 += 3 + n3;
        }
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3) / 3 | 0;
      }
    };
    _i = new WeakMap();
    _a = new WeakMap();
    _s = new WeakMap();
    _r = new WeakMap();
    _n = new WeakMap();
    _o = new WeakMap();
    _g = new WeakMap();
    _I = new WeakMap();
    _c = new WeakSet();
    c_fn = function(e3, t3, i3) {
      i3[0] = e3[0] * t3[0] + e3[1] * t3[1] + e3[2] * t3[2];
      i3[1] = e3[3] * t3[0] + e3[4] * t3[1] + e3[5] * t3[2];
      i3[2] = e3[6] * t3[0] + e3[7] * t3[1] + e3[8] * t3[2];
    };
    _C = new WeakSet();
    C_fn = function(e3, t3, i3) {
      i3[0] = 1 * t3[0] / e3[0];
      i3[1] = 1 * t3[1] / e3[1];
      i3[2] = 1 * t3[2] / e3[2];
    };
    _h = new WeakSet();
    h_fn = function(e3, t3, i3) {
      i3[0] = 0.95047 * t3[0] / e3[0];
      i3[1] = 1 * t3[1] / e3[1];
      i3[2] = 1.08883 * t3[2] / e3[2];
    };
    _l = new WeakSet();
    l_fn = function(e3) {
      return e3 <= 31308e-7 ? __privateMethod(this, _B, B_fn).call(this, 0, 1, 12.92 * e3) : e3 >= 0.99554525 ? 1 : __privateMethod(this, _B, B_fn).call(this, 0, 1, 1.055 * e3 ** (1 / 2.4) - 0.055);
    };
    _B = new WeakSet();
    B_fn = function(e3, t3, i3) {
      return Math.max(e3, Math.min(t3, i3));
    };
    _Q = new WeakSet();
    Q_fn = function(e3) {
      return e3 < 0 ? -__privateMethod(this, _Q, Q_fn).call(this, -e3) : e3 > 8 ? ((e3 + 16) / 116) ** 3 : e3 * __privateGet(_CalRGBCS, _I);
    };
    _E = new WeakSet();
    E_fn = function(e3, t3, i3) {
      if (0 === e3[0] && 0 === e3[1] && 0 === e3[2]) {
        i3[0] = t3[0];
        i3[1] = t3[1];
        i3[2] = t3[2];
        return;
      }
      const a3 = __privateMethod(this, _Q, Q_fn).call(this, 0), s3 = (1 - a3) / (1 - __privateMethod(this, _Q, Q_fn).call(this, e3[0])), r3 = 1 - s3, n3 = (1 - a3) / (1 - __privateMethod(this, _Q, Q_fn).call(this, e3[1])), o3 = 1 - n3, g3 = (1 - a3) / (1 - __privateMethod(this, _Q, Q_fn).call(this, e3[2])), c3 = 1 - g3;
      i3[0] = t3[0] * s3 + r3;
      i3[1] = t3[1] * n3 + o3;
      i3[2] = t3[2] * g3 + c3;
    };
    _u = new WeakSet();
    u_fn = function(e3, t3, i3) {
      if (1 === e3[0] && 1 === e3[2]) {
        i3[0] = t3[0];
        i3[1] = t3[1];
        i3[2] = t3[2];
        return;
      }
      const a3 = i3;
      __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _i), t3, a3);
      const s3 = __privateGet(_CalRGBCS, _n);
      __privateMethod(this, _C, C_fn).call(this, e3, a3, s3);
      __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _a), s3, i3);
    };
    _d = new WeakSet();
    d_fn = function(e3, t3, i3) {
      const a3 = i3;
      __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _i), t3, a3);
      const s3 = __privateGet(_CalRGBCS, _n);
      __privateMethod(this, _h, h_fn).call(this, e3, a3, s3);
      __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _a), s3, i3);
    };
    _t3 = new WeakSet();
    t_fn3 = function(e3, t3, i3, a3, s3) {
      const r3 = __privateMethod(this, _B, B_fn).call(this, 0, 1, e3[t3] * s3), n3 = __privateMethod(this, _B, B_fn).call(this, 0, 1, e3[t3 + 1] * s3), o3 = __privateMethod(this, _B, B_fn).call(this, 0, 1, e3[t3 + 2] * s3), g3 = 1 === r3 ? 1 : r3 ** this.GR, c3 = 1 === n3 ? 1 : n3 ** this.GG, C3 = 1 === o3 ? 1 : o3 ** this.GB, h2 = this.MXA * g3 + this.MXB * c3 + this.MXC * C3, l3 = this.MYA * g3 + this.MYB * c3 + this.MYC * C3, Q3 = this.MZA * g3 + this.MZB * c3 + this.MZC * C3, E3 = __privateGet(_CalRGBCS, _o);
      E3[0] = h2;
      E3[1] = l3;
      E3[2] = Q3;
      const u3 = __privateGet(_CalRGBCS, _g);
      __privateMethod(this, _u, u_fn).call(this, this.whitePoint, E3, u3);
      const d3 = __privateGet(_CalRGBCS, _o);
      __privateMethod(this, _E, E_fn).call(this, this.blackPoint, u3, d3);
      const f2 = __privateGet(_CalRGBCS, _g);
      __privateMethod(this, _d, d_fn).call(this, __privateGet(_CalRGBCS, _r), d3, f2);
      const p2 = __privateGet(_CalRGBCS, _o);
      __privateMethod(this, _c, c_fn).call(this, __privateGet(_CalRGBCS, _s), f2, p2);
      i3[a3] = 255 * __privateMethod(this, _l, l_fn).call(this, p2[0]);
      i3[a3 + 1] = 255 * __privateMethod(this, _l, l_fn).call(this, p2[1]);
      i3[a3 + 2] = 255 * __privateMethod(this, _l, l_fn).call(this, p2[2]);
    };
    __privateAdd(_CalRGBCS, _i, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]));
    __privateAdd(_CalRGBCS, _a, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]));
    __privateAdd(_CalRGBCS, _s, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]));
    __privateAdd(_CalRGBCS, _r, new Float32Array([1, 1, 1]));
    __privateAdd(_CalRGBCS, _n, new Float32Array(3));
    __privateAdd(_CalRGBCS, _o, new Float32Array(3));
    __privateAdd(_CalRGBCS, _g, new Float32Array(3));
    __privateAdd(_CalRGBCS, _I, (24 / 116) ** 3 / 8);
    CalRGBCS = _CalRGBCS;
    LabCS = class extends ColorSpace {
      constructor(e3, t3, i3) {
        super("Lab", 3);
        __privateAdd(this, _f);
        __privateAdd(this, _p);
        __privateAdd(this, _t4);
        if (!e3)
          throw new FormatError("WhitePoint missing - required for color space Lab");
        [this.XW, this.YW, this.ZW] = e3;
        [this.amin, this.amax, this.bmin, this.bmax] = i3 || [-100, 100, -100, 100];
        [this.XB, this.YB, this.ZB] = t3 || [0, 0, 0];
        if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW)
          throw new FormatError("Invalid WhitePoint components, no fallback available");
        if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
          info("Invalid BlackPoint, falling back to default");
          this.XB = this.YB = this.ZB = 0;
        }
        if (this.amin > this.amax || this.bmin > this.bmax) {
          info("Invalid Range, falling back to defaults");
          this.amin = -100;
          this.amax = 100;
          this.bmin = -100;
          this.bmax = 100;
        }
      }
      getRgbItem(e3, t3, i3, a3) {
        __privateMethod(this, _t4, t_fn4).call(this, e3, t3, false, i3, a3);
      }
      getRgbBuffer(e3, t3, i3, a3, s3, r3, n3) {
        const o3 = (1 << r3) - 1;
        for (let r4 = 0; r4 < i3; r4++) {
          __privateMethod(this, _t4, t_fn4).call(this, e3, t3, o3, a3, s3);
          t3 += 3;
          s3 += 3 + n3;
        }
      }
      getOutputLength(e3, t3) {
        return e3 * (3 + t3) / 3 | 0;
      }
      isDefaultDecode(e3, t3) {
        return true;
      }
      get usesZeroToOneRange() {
        return shadow(this, "usesZeroToOneRange", false);
      }
    };
    _f = new WeakSet();
    f_fn = function(e3) {
      return e3 >= 6 / 29 ? e3 ** 3 : 108 / 841 * (e3 - 4 / 29);
    };
    _p = new WeakSet();
    p_fn = function(e3, t3, i3, a3) {
      return i3 + e3 * (a3 - i3) / t3;
    };
    _t4 = new WeakSet();
    t_fn4 = function(e3, t3, i3, a3, s3) {
      let r3 = e3[t3], n3 = e3[t3 + 1], o3 = e3[t3 + 2];
      if (false !== i3) {
        r3 = __privateMethod(this, _p, p_fn).call(this, r3, i3, 0, 100);
        n3 = __privateMethod(this, _p, p_fn).call(this, n3, i3, this.amin, this.amax);
        o3 = __privateMethod(this, _p, p_fn).call(this, o3, i3, this.bmin, this.bmax);
      }
      n3 > this.amax ? n3 = this.amax : n3 < this.amin && (n3 = this.amin);
      o3 > this.bmax ? o3 = this.bmax : o3 < this.bmin && (o3 = this.bmin);
      const g3 = (r3 + 16) / 116, c3 = g3 + n3 / 500, C3 = g3 - o3 / 200, h2 = this.XW * __privateMethod(this, _f, f_fn).call(this, c3), l3 = this.YW * __privateMethod(this, _f, f_fn).call(this, g3), Q3 = this.ZW * __privateMethod(this, _f, f_fn).call(this, C3);
      let E3, u3, d3;
      if (this.ZW < 1) {
        E3 = 3.1339 * h2 + -1.617 * l3 + -0.4906 * Q3;
        u3 = -0.9785 * h2 + 1.916 * l3 + 0.0333 * Q3;
        d3 = 0.072 * h2 + -0.229 * l3 + 1.4057 * Q3;
      } else {
        E3 = 3.2406 * h2 + -1.5372 * l3 + -0.4986 * Q3;
        u3 = -0.9689 * h2 + 1.8758 * l3 + 0.0415 * Q3;
        d3 = 0.0557 * h2 + -0.204 * l3 + 1.057 * Q3;
      }
      a3[s3] = 255 * Math.sqrt(E3);
      a3[s3 + 1] = 255 * Math.sqrt(u3);
      a3[s3 + 2] = 255 * Math.sqrt(d3);
    };
    kt = 16;
    BinaryCMapStream = class {
      constructor(e3) {
        this.buffer = e3;
        this.pos = 0;
        this.end = e3.length;
        this.tmpBuf = new Uint8Array(19);
      }
      readByte() {
        return this.pos >= this.end ? -1 : this.buffer[this.pos++];
      }
      readNumber() {
        let e3, t3 = 0;
        do {
          const i3 = this.readByte();
          if (i3 < 0)
            throw new FormatError("unexpected EOF in bcmap");
          e3 = !(128 & i3);
          t3 = t3 << 7 | 127 & i3;
        } while (!e3);
        return t3;
      }
      readSigned() {
        const e3 = this.readNumber();
        return 1 & e3 ? ~(e3 >>> 1) : e3 >>> 1;
      }
      readHex(e3, t3) {
        e3.set(this.buffer.subarray(this.pos, this.pos + t3 + 1));
        this.pos += t3 + 1;
      }
      readHexNumber(e3, t3) {
        let i3;
        const a3 = this.tmpBuf;
        let s3 = 0;
        do {
          const e4 = this.readByte();
          if (e4 < 0)
            throw new FormatError("unexpected EOF in bcmap");
          i3 = !(128 & e4);
          a3[s3++] = 127 & e4;
        } while (!i3);
        let r3 = t3, n3 = 0, o3 = 0;
        for (; r3 >= 0; ) {
          for (; o3 < 8 && a3.length > 0; ) {
            n3 |= a3[--s3] << o3;
            o3 += 7;
          }
          e3[r3] = 255 & n3;
          r3--;
          n3 >>= 8;
          o3 -= 8;
        }
      }
      readHexSigned(e3, t3) {
        this.readHexNumber(e3, t3);
        const i3 = 1 & e3[t3] ? 255 : 0;
        let a3 = 0;
        for (let s3 = 0; s3 <= t3; s3++) {
          a3 = (1 & a3) << 8 | e3[s3];
          e3[s3] = a3 >> 1 ^ i3;
        }
      }
      readString() {
        const e3 = this.readNumber(), t3 = new Array(e3);
        for (let i3 = 0; i3 < e3; i3++)
          t3[i3] = this.readNumber();
        return String.fromCharCode(...t3);
      }
    };
    BinaryCMapReader = class {
      async process(e3, t3, i3) {
        const a3 = new BinaryCMapStream(e3), s3 = a3.readByte();
        t3.vertical = !!(1 & s3);
        let r3 = null;
        const n3 = new Uint8Array(kt), o3 = new Uint8Array(kt), g3 = new Uint8Array(kt), c3 = new Uint8Array(kt), C3 = new Uint8Array(kt);
        let h2, l3;
        for (; (l3 = a3.readByte()) >= 0; ) {
          const e4 = l3 >> 5;
          if (7 === e4) {
            switch (31 & l3) {
              case 0:
                a3.readString();
                break;
              case 1:
                r3 = a3.readString();
            }
            continue;
          }
          const i4 = !!(16 & l3), s4 = 15 & l3;
          if (s4 + 1 > kt)
            throw new Error("BinaryCMapReader.process: Invalid dataSize.");
          const Q3 = 1, E3 = a3.readNumber();
          switch (e4) {
            case 0:
              a3.readHex(n3, s4);
              a3.readHexNumber(o3, s4);
              addHex(o3, n3, s4);
              t3.addCodespaceRange(s4 + 1, hexToInt(n3, s4), hexToInt(o3, s4));
              for (let e5 = 1; e5 < E3; e5++) {
                incHex(o3, s4);
                a3.readHexNumber(n3, s4);
                addHex(n3, o3, s4);
                a3.readHexNumber(o3, s4);
                addHex(o3, n3, s4);
                t3.addCodespaceRange(s4 + 1, hexToInt(n3, s4), hexToInt(o3, s4));
              }
              break;
            case 1:
              a3.readHex(n3, s4);
              a3.readHexNumber(o3, s4);
              addHex(o3, n3, s4);
              a3.readNumber();
              for (let e5 = 1; e5 < E3; e5++) {
                incHex(o3, s4);
                a3.readHexNumber(n3, s4);
                addHex(n3, o3, s4);
                a3.readHexNumber(o3, s4);
                addHex(o3, n3, s4);
                a3.readNumber();
              }
              break;
            case 2:
              a3.readHex(g3, s4);
              h2 = a3.readNumber();
              t3.mapOne(hexToInt(g3, s4), h2);
              for (let e5 = 1; e5 < E3; e5++) {
                incHex(g3, s4);
                if (!i4) {
                  a3.readHexNumber(C3, s4);
                  addHex(g3, C3, s4);
                }
                h2 = a3.readSigned() + (h2 + 1);
                t3.mapOne(hexToInt(g3, s4), h2);
              }
              break;
            case 3:
              a3.readHex(n3, s4);
              a3.readHexNumber(o3, s4);
              addHex(o3, n3, s4);
              h2 = a3.readNumber();
              t3.mapCidRange(hexToInt(n3, s4), hexToInt(o3, s4), h2);
              for (let e5 = 1; e5 < E3; e5++) {
                incHex(o3, s4);
                if (i4)
                  n3.set(o3);
                else {
                  a3.readHexNumber(n3, s4);
                  addHex(n3, o3, s4);
                }
                a3.readHexNumber(o3, s4);
                addHex(o3, n3, s4);
                h2 = a3.readNumber();
                t3.mapCidRange(hexToInt(n3, s4), hexToInt(o3, s4), h2);
              }
              break;
            case 4:
              a3.readHex(g3, Q3);
              a3.readHex(c3, s4);
              t3.mapOne(hexToInt(g3, Q3), hexToStr(c3, s4));
              for (let e5 = 1; e5 < E3; e5++) {
                incHex(g3, Q3);
                if (!i4) {
                  a3.readHexNumber(C3, Q3);
                  addHex(g3, C3, Q3);
                }
                incHex(c3, s4);
                a3.readHexSigned(C3, s4);
                addHex(c3, C3, s4);
                t3.mapOne(hexToInt(g3, Q3), hexToStr(c3, s4));
              }
              break;
            case 5:
              a3.readHex(n3, Q3);
              a3.readHexNumber(o3, Q3);
              addHex(o3, n3, Q3);
              a3.readHex(c3, s4);
              t3.mapBfRange(hexToInt(n3, Q3), hexToInt(o3, Q3), hexToStr(c3, s4));
              for (let e5 = 1; e5 < E3; e5++) {
                incHex(o3, Q3);
                if (i4)
                  n3.set(o3);
                else {
                  a3.readHexNumber(n3, Q3);
                  addHex(n3, o3, Q3);
                }
                a3.readHexNumber(o3, Q3);
                addHex(o3, n3, Q3);
                a3.readHex(c3, s4);
                t3.mapBfRange(hexToInt(n3, Q3), hexToInt(o3, Q3), hexToStr(c3, s4));
              }
              break;
            default:
              throw new Error(`BinaryCMapReader.process - unknown type: ${e4}`);
          }
        }
        return r3 ? i3(r3) : t3;
      }
    };
    Nt = new Uint8Array(0);
    DecodeStream = class extends BaseStream {
      constructor(e3) {
        super();
        this._rawMinBufferLength = e3 || 0;
        this.pos = 0;
        this.bufferLength = 0;
        this.eof = false;
        this.buffer = Nt;
        this.minBufferLength = 512;
        if (e3)
          for (; this.minBufferLength < e3; )
            this.minBufferLength *= 2;
      }
      get isEmpty() {
        for (; !this.eof && 0 === this.bufferLength; )
          this.readBlock();
        return 0 === this.bufferLength;
      }
      ensureBuffer(e3) {
        const t3 = this.buffer;
        if (e3 <= t3.byteLength)
          return t3;
        let i3 = this.minBufferLength;
        for (; i3 < e3; )
          i3 *= 2;
        const a3 = new Uint8Array(i3);
        a3.set(t3);
        return this.buffer = a3;
      }
      getByte() {
        const e3 = this.pos;
        for (; this.bufferLength <= e3; ) {
          if (this.eof)
            return -1;
          this.readBlock();
        }
        return this.buffer[this.pos++];
      }
      getBytes(e3, t3 = false) {
        const i3 = this.pos;
        let a3;
        if (e3) {
          this.ensureBuffer(i3 + e3);
          a3 = i3 + e3;
          for (; !this.eof && this.bufferLength < a3; )
            this.readBlock(t3);
          const s3 = this.bufferLength;
          a3 > s3 && (a3 = s3);
        } else {
          for (; !this.eof; )
            this.readBlock(t3);
          a3 = this.bufferLength;
        }
        this.pos = a3;
        return this.buffer.subarray(i3, a3);
      }
      reset() {
        this.pos = 0;
      }
      makeSubStream(e3, t3, i3 = null) {
        if (void 0 === t3)
          for (; !this.eof; )
            this.readBlock();
        else {
          const i4 = e3 + t3;
          for (; this.bufferLength <= i4 && !this.eof; )
            this.readBlock();
        }
        return new Stream(this.buffer, e3, t3, i3);
      }
      getBaseStreams() {
        return this.str ? this.str.getBaseStreams() : null;
      }
    };
    StreamsSequenceStream = class extends DecodeStream {
      constructor(e3, t3 = null) {
        let i3 = 0;
        for (const t4 of e3)
          i3 += t4 instanceof DecodeStream ? t4._rawMinBufferLength : t4.length;
        super(i3);
        this.streams = e3;
        this._onError = t3;
      }
      readBlock() {
        var _a3;
        const e3 = this.streams;
        if (0 === e3.length) {
          this.eof = true;
          return;
        }
        const t3 = e3.shift();
        let i3;
        try {
          i3 = t3.getBytes();
        } catch (e4) {
          if (this._onError) {
            this._onError(e4, (_a3 = t3.dict) == null ? void 0 : _a3.objId);
            return;
          }
          throw e4;
        }
        const a3 = this.bufferLength, s3 = a3 + i3.length;
        this.ensureBuffer(s3).set(i3, a3);
        this.bufferLength = s3;
      }
      getBaseStreams() {
        const e3 = [];
        for (const t3 of this.streams) {
          const i3 = t3.getBaseStreams();
          i3 && e3.push(...i3);
        }
        return e3.length > 0 ? e3 : null;
      }
    };
    Ascii85Stream = class extends DecodeStream {
      constructor(e3, t3) {
        t3 && (t3 *= 0.8);
        super(t3);
        this.str = e3;
        this.dict = e3.dict;
        this.input = new Uint8Array(5);
      }
      readBlock() {
        const e3 = this.str;
        let t3 = e3.getByte();
        for (; isWhiteSpace(t3); )
          t3 = e3.getByte();
        if (-1 === t3 || 126 === t3) {
          this.eof = true;
          return;
        }
        const i3 = this.bufferLength;
        let a3, s3;
        if (122 === t3) {
          a3 = this.ensureBuffer(i3 + 4);
          for (s3 = 0; s3 < 4; ++s3)
            a3[i3 + s3] = 0;
          this.bufferLength += 4;
        } else {
          const r3 = this.input;
          r3[0] = t3;
          for (s3 = 1; s3 < 5; ++s3) {
            t3 = e3.getByte();
            for (; isWhiteSpace(t3); )
              t3 = e3.getByte();
            r3[s3] = t3;
            if (-1 === t3 || 126 === t3)
              break;
          }
          a3 = this.ensureBuffer(i3 + s3 - 1);
          this.bufferLength += s3 - 1;
          if (s3 < 5) {
            for (; s3 < 5; ++s3)
              r3[s3] = 117;
            this.eof = true;
          }
          let n3 = 0;
          for (s3 = 0; s3 < 5; ++s3)
            n3 = 85 * n3 + (r3[s3] - 33);
          for (s3 = 3; s3 >= 0; --s3) {
            a3[i3 + s3] = 255 & n3;
            n3 >>= 8;
          }
        }
      }
    };
    AsciiHexStream = class extends DecodeStream {
      constructor(e3, t3) {
        t3 && (t3 *= 0.5);
        super(t3);
        this.str = e3;
        this.dict = e3.dict;
        this.firstDigit = -1;
      }
      readBlock() {
        const e3 = this.str.getBytes(8e3);
        if (!e3.length) {
          this.eof = true;
          return;
        }
        const t3 = e3.length + 1 >> 1, i3 = this.ensureBuffer(this.bufferLength + t3);
        let a3 = this.bufferLength, s3 = this.firstDigit;
        for (const t4 of e3) {
          let e4;
          if (t4 >= 48 && t4 <= 57)
            e4 = 15 & t4;
          else {
            if (!(t4 >= 65 && t4 <= 70 || t4 >= 97 && t4 <= 102)) {
              if (62 === t4) {
                this.eof = true;
                break;
              }
              continue;
            }
            e4 = 9 + (15 & t4);
          }
          if (s3 < 0)
            s3 = e4;
          else {
            i3[a3++] = s3 << 4 | e4;
            s3 = -1;
          }
        }
        if (s3 >= 0 && this.eof) {
          i3[a3++] = s3 << 4;
          s3 = -1;
        }
        this.firstDigit = s3;
        this.bufferLength = a3;
      }
    };
    Rt = -1;
    Gt = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]];
    xt = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
    Ut = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
    Mt = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
    Lt = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
    Ht = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
    CCITTFaxDecoder = class {
      constructor(e3, t3 = {}) {
        if (!e3 || "function" != typeof e3.next)
          throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
        this.source = e3;
        this.eof = false;
        this.encoding = t3.K || 0;
        this.eoline = t3.EndOfLine || false;
        this.byteAlign = t3.EncodedByteAlign || false;
        this.columns = t3.Columns || 1728;
        this.rows = t3.Rows || 0;
        this.eoblock = t3.EndOfBlock ?? true;
        this.black = t3.BlackIs1 || false;
        this.codingLine = new Uint32Array(this.columns + 1);
        this.refLine = new Uint32Array(this.columns + 2);
        this.codingLine[0] = this.columns;
        this.codingPos = 0;
        this.row = 0;
        this.nextLine2D = this.encoding < 0;
        this.inputBits = 0;
        this.inputBuf = 0;
        this.outputBits = 0;
        this.rowsDone = false;
        let i3;
        for (; 0 === (i3 = this._lookBits(12)); )
          this._eatBits(1);
        1 === i3 && this._eatBits(12);
        if (this.encoding > 0) {
          this.nextLine2D = !this._lookBits(1);
          this._eatBits(1);
        }
      }
      readNextChar() {
        if (this.eof)
          return -1;
        const e3 = this.refLine, t3 = this.codingLine, i3 = this.columns;
        let a3, s3, r3, n3, o3;
        if (0 === this.outputBits) {
          this.rowsDone && (this.eof = true);
          if (this.eof)
            return -1;
          this.err = false;
          let r4, o4, g3;
          if (this.nextLine2D) {
            for (n3 = 0; t3[n3] < i3; ++n3)
              e3[n3] = t3[n3];
            e3[n3++] = i3;
            e3[n3] = i3;
            t3[0] = 0;
            this.codingPos = 0;
            a3 = 0;
            s3 = 0;
            for (; t3[this.codingPos] < i3; ) {
              r4 = this._getTwoDimCode();
              switch (r4) {
                case 0:
                  this._addPixels(e3[a3 + 1], s3);
                  e3[a3 + 1] < i3 && (a3 += 2);
                  break;
                case 1:
                  r4 = o4 = 0;
                  if (s3) {
                    do {
                      r4 += g3 = this._getBlackCode();
                    } while (g3 >= 64);
                    do {
                      o4 += g3 = this._getWhiteCode();
                    } while (g3 >= 64);
                  } else {
                    do {
                      r4 += g3 = this._getWhiteCode();
                    } while (g3 >= 64);
                    do {
                      o4 += g3 = this._getBlackCode();
                    } while (g3 >= 64);
                  }
                  this._addPixels(t3[this.codingPos] + r4, s3);
                  t3[this.codingPos] < i3 && this._addPixels(t3[this.codingPos] + o4, 1 ^ s3);
                  for (; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; )
                    a3 += 2;
                  break;
                case 7:
                  this._addPixels(e3[a3] + 3, s3);
                  s3 ^= 1;
                  if (t3[this.codingPos] < i3) {
                    ++a3;
                    for (; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; )
                      a3 += 2;
                  }
                  break;
                case 5:
                  this._addPixels(e3[a3] + 2, s3);
                  s3 ^= 1;
                  if (t3[this.codingPos] < i3) {
                    ++a3;
                    for (; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; )
                      a3 += 2;
                  }
                  break;
                case 3:
                  this._addPixels(e3[a3] + 1, s3);
                  s3 ^= 1;
                  if (t3[this.codingPos] < i3) {
                    ++a3;
                    for (; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; )
                      a3 += 2;
                  }
                  break;
                case 2:
                  this._addPixels(e3[a3], s3);
                  s3 ^= 1;
                  if (t3[this.codingPos] < i3) {
                    ++a3;
                    for (; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; )
                      a3 += 2;
                  }
                  break;
                case 8:
                  this._addPixelsNeg(e3[a3] - 3, s3);
                  s3 ^= 1;
                  if (t3[this.codingPos] < i3) {
                    a3 > 0 ? --a3 : ++a3;
                    for (; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; )
                      a3 += 2;
                  }
                  break;
                case 6:
                  this._addPixelsNeg(e3[a3] - 2, s3);
                  s3 ^= 1;
                  if (t3[this.codingPos] < i3) {
                    a3 > 0 ? --a3 : ++a3;
                    for (; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; )
                      a3 += 2;
                  }
                  break;
                case 4:
                  this._addPixelsNeg(e3[a3] - 1, s3);
                  s3 ^= 1;
                  if (t3[this.codingPos] < i3) {
                    a3 > 0 ? --a3 : ++a3;
                    for (; e3[a3] <= t3[this.codingPos] && e3[a3] < i3; )
                      a3 += 2;
                  }
                  break;
                case Rt:
                  this._addPixels(i3, 0);
                  this.eof = true;
                  break;
                default:
                  info("bad 2d code");
                  this._addPixels(i3, 0);
                  this.err = true;
              }
            }
          } else {
            t3[0] = 0;
            this.codingPos = 0;
            s3 = 0;
            for (; t3[this.codingPos] < i3; ) {
              r4 = 0;
              if (s3)
                do {
                  r4 += g3 = this._getBlackCode();
                } while (g3 >= 64);
              else
                do {
                  r4 += g3 = this._getWhiteCode();
                } while (g3 >= 64);
              this._addPixels(t3[this.codingPos] + r4, s3);
              s3 ^= 1;
            }
          }
          let c3 = false;
          this.byteAlign && (this.inputBits &= -8);
          if (this.eoblock || this.row !== this.rows - 1) {
            r4 = this._lookBits(12);
            if (this.eoline)
              for (; r4 !== Rt && 1 !== r4; ) {
                this._eatBits(1);
                r4 = this._lookBits(12);
              }
            else
              for (; 0 === r4; ) {
                this._eatBits(1);
                r4 = this._lookBits(12);
              }
            if (1 === r4) {
              this._eatBits(12);
              c3 = true;
            } else
              r4 === Rt && (this.eof = true);
          } else
            this.rowsDone = true;
          if (!this.eof && this.encoding > 0 && !this.rowsDone) {
            this.nextLine2D = !this._lookBits(1);
            this._eatBits(1);
          }
          if (this.eoblock && c3 && this.byteAlign) {
            r4 = this._lookBits(12);
            if (1 === r4) {
              this._eatBits(12);
              if (this.encoding > 0) {
                this._lookBits(1);
                this._eatBits(1);
              }
              if (this.encoding >= 0)
                for (n3 = 0; n3 < 4; ++n3) {
                  r4 = this._lookBits(12);
                  1 !== r4 && info("bad rtc code: " + r4);
                  this._eatBits(12);
                  if (this.encoding > 0) {
                    this._lookBits(1);
                    this._eatBits(1);
                  }
                }
              this.eof = true;
            }
          } else if (this.err && this.eoline) {
            for (; ; ) {
              r4 = this._lookBits(13);
              if (r4 === Rt) {
                this.eof = true;
                return -1;
              }
              if (r4 >> 1 == 1)
                break;
              this._eatBits(1);
            }
            this._eatBits(12);
            if (this.encoding > 0) {
              this._eatBits(1);
              this.nextLine2D = !(1 & r4);
            }
          }
          this.outputBits = t3[0] > 0 ? t3[this.codingPos = 0] : t3[this.codingPos = 1];
          this.row++;
        }
        if (this.outputBits >= 8) {
          o3 = 1 & this.codingPos ? 0 : 255;
          this.outputBits -= 8;
          if (0 === this.outputBits && t3[this.codingPos] < i3) {
            this.codingPos++;
            this.outputBits = t3[this.codingPos] - t3[this.codingPos - 1];
          }
        } else {
          r3 = 8;
          o3 = 0;
          do {
            if ("number" != typeof this.outputBits)
              throw new FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
            if (this.outputBits > r3) {
              o3 <<= r3;
              1 & this.codingPos || (o3 |= 255 >> 8 - r3);
              this.outputBits -= r3;
              r3 = 0;
            } else {
              o3 <<= this.outputBits;
              1 & this.codingPos || (o3 |= 255 >> 8 - this.outputBits);
              r3 -= this.outputBits;
              this.outputBits = 0;
              if (t3[this.codingPos] < i3) {
                this.codingPos++;
                this.outputBits = t3[this.codingPos] - t3[this.codingPos - 1];
              } else if (r3 > 0) {
                o3 <<= r3;
                r3 = 0;
              }
            }
          } while (r3);
        }
        this.black && (o3 ^= 255);
        return o3;
      }
      _addPixels(e3, t3) {
        const i3 = this.codingLine;
        let a3 = this.codingPos;
        if (e3 > i3[a3]) {
          if (e3 > this.columns) {
            info("row is wrong length");
            this.err = true;
            e3 = this.columns;
          }
          1 & a3 ^ t3 && ++a3;
          i3[a3] = e3;
        }
        this.codingPos = a3;
      }
      _addPixelsNeg(e3, t3) {
        const i3 = this.codingLine;
        let a3 = this.codingPos;
        if (e3 > i3[a3]) {
          if (e3 > this.columns) {
            info("row is wrong length");
            this.err = true;
            e3 = this.columns;
          }
          1 & a3 ^ t3 && ++a3;
          i3[a3] = e3;
        } else if (e3 < i3[a3]) {
          if (e3 < 0) {
            info("invalid code");
            this.err = true;
            e3 = 0;
          }
          for (; a3 > 0 && e3 < i3[a3 - 1]; )
            --a3;
          i3[a3] = e3;
        }
        this.codingPos = a3;
      }
      _findTableCode(e3, t3, i3, a3) {
        const s3 = a3 || 0;
        for (let a4 = e3; a4 <= t3; ++a4) {
          let e4 = this._lookBits(a4);
          if (e4 === Rt)
            return [true, 1, false];
          a4 < t3 && (e4 <<= t3 - a4);
          if (!s3 || e4 >= s3) {
            const t4 = i3[e4 - s3];
            if (t4[0] === a4) {
              this._eatBits(a4);
              return [true, t4[1], true];
            }
          }
        }
        return [false, 0, false];
      }
      _getTwoDimCode() {
        let e3, t3 = 0;
        if (this.eoblock) {
          t3 = this._lookBits(7);
          e3 = Gt[t3];
          if ((e3 == null ? void 0 : e3[0]) > 0) {
            this._eatBits(e3[0]);
            return e3[1];
          }
        } else {
          const e4 = this._findTableCode(1, 7, Gt);
          if (e4[0] && e4[2])
            return e4[1];
        }
        info("Bad two dim code");
        return Rt;
      }
      _getWhiteCode() {
        let e3, t3 = 0;
        if (this.eoblock) {
          t3 = this._lookBits(12);
          if (t3 === Rt)
            return 1;
          e3 = t3 >> 5 == 0 ? xt[t3] : Ut[t3 >> 3];
          if (e3[0] > 0) {
            this._eatBits(e3[0]);
            return e3[1];
          }
        } else {
          let e4 = this._findTableCode(1, 9, Ut);
          if (e4[0])
            return e4[1];
          e4 = this._findTableCode(11, 12, xt);
          if (e4[0])
            return e4[1];
        }
        info("bad white code");
        this._eatBits(1);
        return 1;
      }
      _getBlackCode() {
        let e3, t3;
        if (this.eoblock) {
          e3 = this._lookBits(13);
          if (e3 === Rt)
            return 1;
          t3 = e3 >> 7 == 0 ? Mt[e3] : e3 >> 9 == 0 && e3 >> 7 != 0 ? Lt[(e3 >> 1) - 64] : Ht[e3 >> 7];
          if (t3[0] > 0) {
            this._eatBits(t3[0]);
            return t3[1];
          }
        } else {
          let e4 = this._findTableCode(2, 6, Ht);
          if (e4[0])
            return e4[1];
          e4 = this._findTableCode(7, 12, Lt, 64);
          if (e4[0])
            return e4[1];
          e4 = this._findTableCode(10, 13, Mt);
          if (e4[0])
            return e4[1];
        }
        info("bad black code");
        this._eatBits(1);
        return 1;
      }
      _lookBits(e3) {
        let t3;
        for (; this.inputBits < e3; ) {
          if (-1 === (t3 = this.source.next()))
            return 0 === this.inputBits ? Rt : this.inputBuf << e3 - this.inputBits & 65535 >> 16 - e3;
          this.inputBuf = this.inputBuf << 8 | t3;
          this.inputBits += 8;
        }
        return this.inputBuf >> this.inputBits - e3 & 65535 >> 16 - e3;
      }
      _eatBits(e3) {
        (this.inputBits -= e3) < 0 && (this.inputBits = 0);
      }
    };
    CCITTFaxStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3);
        this.str = e3;
        this.dict = e3.dict;
        i3 instanceof Dict || (i3 = Dict.empty);
        const a3 = { next: () => e3.getByte() };
        this.ccittFaxDecoder = new CCITTFaxDecoder(a3, { K: i3.get("K"), EndOfLine: i3.get("EndOfLine"), EncodedByteAlign: i3.get("EncodedByteAlign"), Columns: i3.get("Columns"), Rows: i3.get("Rows"), EndOfBlock: i3.get("EndOfBlock"), BlackIs1: i3.get("BlackIs1") });
      }
      readBlock() {
        for (; !this.eof; ) {
          const e3 = this.ccittFaxDecoder.readNextChar();
          if (-1 === e3) {
            this.eof = true;
            return;
          }
          this.ensureBuffer(this.bufferLength + 1);
          this.buffer[this.bufferLength++] = e3;
        }
      }
    };
    Jt = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    Yt = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
    vt = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
    Kt = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
    Tt = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
    FlateStream = class extends DecodeStream {
      constructor(e3, t3) {
        super(t3);
        __privateAdd(this, _m);
        this.str = e3;
        this.dict = e3.dict;
        const i3 = e3.getByte(), a3 = e3.getByte();
        if (-1 === i3 || -1 === a3)
          throw new FormatError(`Invalid header in flate stream: ${i3}, ${a3}`);
        if (8 != (15 & i3))
          throw new FormatError(`Unknown compression method in flate stream: ${i3}, ${a3}`);
        if (((i3 << 8) + a3) % 31 != 0)
          throw new FormatError(`Bad FCHECK in flate stream: ${i3}, ${a3}`);
        if (32 & a3)
          throw new FormatError(`FDICT bit set in flate stream: ${i3}, ${a3}`);
        this.codeSize = 0;
        this.codeBuf = 0;
      }
      getBits(e3) {
        const t3 = this.str;
        let i3, a3 = this.codeSize, s3 = this.codeBuf;
        for (; a3 < e3; ) {
          if (-1 === (i3 = t3.getByte()))
            throw new FormatError("Bad encoding in flate stream");
          s3 |= i3 << a3;
          a3 += 8;
        }
        i3 = s3 & (1 << e3) - 1;
        this.codeBuf = s3 >> e3;
        this.codeSize = a3 -= e3;
        return i3;
      }
      getCode(e3) {
        const t3 = this.str, i3 = e3[0], a3 = e3[1];
        let s3, r3 = this.codeSize, n3 = this.codeBuf;
        for (; r3 < a3 && -1 !== (s3 = t3.getByte()); ) {
          n3 |= s3 << r3;
          r3 += 8;
        }
        const o3 = i3[n3 & (1 << a3) - 1], g3 = o3 >> 16, c3 = 65535 & o3;
        if (g3 < 1 || r3 < g3)
          throw new FormatError("Bad encoding in flate stream");
        this.codeBuf = n3 >> g3;
        this.codeSize = r3 - g3;
        return c3;
      }
      generateHuffmanTable(e3) {
        const t3 = e3.length;
        let i3, a3 = 0;
        for (i3 = 0; i3 < t3; ++i3)
          e3[i3] > a3 && (a3 = e3[i3]);
        const s3 = 1 << a3, r3 = new Int32Array(s3);
        for (let n3 = 1, o3 = 0, g3 = 2; n3 <= a3; ++n3, o3 <<= 1, g3 <<= 1)
          for (let a4 = 0; a4 < t3; ++a4)
            if (e3[a4] === n3) {
              let e4 = 0, t4 = o3;
              for (i3 = 0; i3 < n3; ++i3) {
                e4 = e4 << 1 | 1 & t4;
                t4 >>= 1;
              }
              for (i3 = e4; i3 < s3; i3 += g3)
                r3[i3] = n3 << 16 | a4;
              ++o3;
            }
        return [r3, a3];
      }
      readBlock() {
        let e3, t3;
        const i3 = this.str;
        let a3, s3, r3 = this.getBits(3);
        1 & r3 && (this.eof = true);
        r3 >>= 1;
        if (0 === r3) {
          let t4;
          if (-1 === (t4 = i3.getByte())) {
            __privateMethod(this, _m, m_fn).call(this, "Bad block header in flate stream");
            return;
          }
          let a4 = t4;
          if (-1 === (t4 = i3.getByte())) {
            __privateMethod(this, _m, m_fn).call(this, "Bad block header in flate stream");
            return;
          }
          a4 |= t4 << 8;
          if (-1 === (t4 = i3.getByte())) {
            __privateMethod(this, _m, m_fn).call(this, "Bad block header in flate stream");
            return;
          }
          let s4 = t4;
          if (-1 === (t4 = i3.getByte())) {
            __privateMethod(this, _m, m_fn).call(this, "Bad block header in flate stream");
            return;
          }
          s4 |= t4 << 8;
          if (s4 !== (65535 & ~a4) && (0 !== a4 || 0 !== s4))
            throw new FormatError("Bad uncompressed block length in flate stream");
          this.codeBuf = 0;
          this.codeSize = 0;
          const r4 = this.bufferLength, n4 = r4 + a4;
          e3 = this.ensureBuffer(n4);
          this.bufferLength = n4;
          if (0 === a4)
            -1 === i3.peekByte() && (this.eof = true);
          else {
            const t5 = i3.getBytes(a4);
            e3.set(t5, r4);
            t5.length < a4 && (this.eof = true);
          }
          return;
        }
        if (1 === r3) {
          a3 = Kt;
          s3 = Tt;
        } else {
          if (2 !== r3)
            throw new FormatError("Unknown block type in flate stream");
          {
            const e4 = this.getBits(5) + 257, i4 = this.getBits(5) + 1, r4 = this.getBits(4) + 4, n4 = new Uint8Array(Jt.length);
            let o4;
            for (o4 = 0; o4 < r4; ++o4)
              n4[Jt[o4]] = this.getBits(3);
            const g3 = this.generateHuffmanTable(n4);
            t3 = 0;
            o4 = 0;
            const c3 = e4 + i4, C3 = new Uint8Array(c3);
            let h2, l3, Q3;
            for (; o4 < c3; ) {
              const e5 = this.getCode(g3);
              if (16 === e5) {
                h2 = 2;
                l3 = 3;
                Q3 = t3;
              } else if (17 === e5) {
                h2 = 3;
                l3 = 3;
                Q3 = t3 = 0;
              } else {
                if (18 !== e5) {
                  C3[o4++] = t3 = e5;
                  continue;
                }
                h2 = 7;
                l3 = 11;
                Q3 = t3 = 0;
              }
              let i5 = this.getBits(h2) + l3;
              for (; i5-- > 0; )
                C3[o4++] = Q3;
            }
            a3 = this.generateHuffmanTable(C3.subarray(0, e4));
            s3 = this.generateHuffmanTable(C3.subarray(e4, c3));
          }
        }
        e3 = this.buffer;
        let n3 = e3 ? e3.length : 0, o3 = this.bufferLength;
        for (; ; ) {
          let i4 = this.getCode(a3);
          if (i4 < 256) {
            if (o3 + 1 >= n3) {
              e3 = this.ensureBuffer(o3 + 1);
              n3 = e3.length;
            }
            e3[o3++] = i4;
            continue;
          }
          if (256 === i4) {
            this.bufferLength = o3;
            return;
          }
          i4 -= 257;
          i4 = Yt[i4];
          let r4 = i4 >> 16;
          r4 > 0 && (r4 = this.getBits(r4));
          t3 = (65535 & i4) + r4;
          i4 = this.getCode(s3);
          i4 = vt[i4];
          r4 = i4 >> 16;
          r4 > 0 && (r4 = this.getBits(r4));
          const g3 = (65535 & i4) + r4;
          if (o3 + t3 >= n3) {
            e3 = this.ensureBuffer(o3 + t3);
            n3 = e3.length;
          }
          for (let i5 = 0; i5 < t3; ++i5, ++o3)
            e3[o3] = e3[o3 - g3];
        }
      }
    };
    _m = new WeakSet();
    m_fn = function(e3) {
      info(e3);
      this.eof = true;
    };
    qt = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
    ArithmeticDecoder = class {
      constructor(e3, t3, i3) {
        this.data = e3;
        this.bp = t3;
        this.dataEnd = i3;
        this.chigh = e3[t3];
        this.clow = 0;
        this.byteIn();
        this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
        this.clow = this.clow << 7 & 65535;
        this.ct -= 7;
        this.a = 32768;
      }
      byteIn() {
        const e3 = this.data;
        let t3 = this.bp;
        if (255 === e3[t3])
          if (e3[t3 + 1] > 143) {
            this.clow += 65280;
            this.ct = 8;
          } else {
            t3++;
            this.clow += e3[t3] << 9;
            this.ct = 7;
            this.bp = t3;
          }
        else {
          t3++;
          this.clow += t3 < this.dataEnd ? e3[t3] << 8 : 65280;
          this.ct = 8;
          this.bp = t3;
        }
        if (this.clow > 65535) {
          this.chigh += this.clow >> 16;
          this.clow &= 65535;
        }
      }
      readBit(e3, t3) {
        let i3 = e3[t3] >> 1, a3 = 1 & e3[t3];
        const s3 = qt[i3], r3 = s3.qe;
        let n3, o3 = this.a - r3;
        if (this.chigh < r3)
          if (o3 < r3) {
            o3 = r3;
            n3 = a3;
            i3 = s3.nmps;
          } else {
            o3 = r3;
            n3 = 1 ^ a3;
            1 === s3.switchFlag && (a3 = n3);
            i3 = s3.nlps;
          }
        else {
          this.chigh -= r3;
          if (0 != (32768 & o3)) {
            this.a = o3;
            return a3;
          }
          if (o3 < r3) {
            n3 = 1 ^ a3;
            1 === s3.switchFlag && (a3 = n3);
            i3 = s3.nlps;
          } else {
            n3 = a3;
            i3 = s3.nmps;
          }
        }
        do {
          0 === this.ct && this.byteIn();
          o3 <<= 1;
          this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
          this.clow = this.clow << 1 & 65535;
          this.ct--;
        } while (0 == (32768 & o3));
        this.a = o3;
        e3[t3] = i3 << 1 | a3;
        return n3;
      }
    };
    Jbig2Error = class extends rt {
      constructor(e3) {
        super(e3, "Jbig2Error");
      }
    };
    ContextCache = class {
      getContexts(e3) {
        return e3 in this ? this[e3] : this[e3] = new Int8Array(65536);
      }
    };
    DecodingContext = class {
      constructor(e3, t3, i3) {
        this.data = e3;
        this.start = t3;
        this.end = i3;
      }
      get decoder() {
        return shadow(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
      }
      get contextCache() {
        return shadow(this, "contextCache", new ContextCache());
      }
    };
    Ot = 2 ** 31 - 1;
    Pt = -(2 ** 31);
    Wt = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
    jt = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]];
    Xt = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }];
    Zt = [39717, 1941, 229, 405];
    Vt = [32, 8];
    zt = 17;
    SimpleSegmentVisitor = class {
      onPageInformation(e3) {
        this.currentPageInfo = e3;
        const t3 = e3.width + 7 >> 3, i3 = new Uint8ClampedArray(t3 * e3.height);
        e3.defaultPixelValue && i3.fill(255);
        this.buffer = i3;
      }
      drawBitmap(e3, t3) {
        const i3 = this.currentPageInfo, a3 = e3.width, s3 = e3.height, r3 = i3.width + 7 >> 3, n3 = i3.combinationOperatorOverride ? e3.combinationOperator : i3.combinationOperator, o3 = this.buffer, g3 = 128 >> (7 & e3.x);
        let c3, C3, h2, l3, Q3 = e3.y * r3 + (e3.x >> 3);
        switch (n3) {
          case 0:
            for (c3 = 0; c3 < s3; c3++) {
              h2 = g3;
              l3 = Q3;
              for (C3 = 0; C3 < a3; C3++) {
                t3[c3][C3] && (o3[l3] |= h2);
                h2 >>= 1;
                if (!h2) {
                  h2 = 128;
                  l3++;
                }
              }
              Q3 += r3;
            }
            break;
          case 2:
            for (c3 = 0; c3 < s3; c3++) {
              h2 = g3;
              l3 = Q3;
              for (C3 = 0; C3 < a3; C3++) {
                t3[c3][C3] && (o3[l3] ^= h2);
                h2 >>= 1;
                if (!h2) {
                  h2 = 128;
                  l3++;
                }
              }
              Q3 += r3;
            }
            break;
          default:
            throw new Jbig2Error(`operator ${n3} is not supported`);
        }
      }
      onImmediateGenericRegion(e3, t3, i3, a3) {
        const s3 = e3.info, r3 = new DecodingContext(t3, i3, a3), n3 = decodeBitmap(e3.mmr, s3.width, s3.height, e3.template, e3.prediction, null, e3.at, r3);
        this.drawBitmap(s3, n3);
      }
      onImmediateLosslessGenericRegion() {
        this.onImmediateGenericRegion(...arguments);
      }
      onSymbolDictionary(e3, t3, i3, a3, s3, r3) {
        let n3, o3;
        if (e3.huffman) {
          n3 = function getSymbolDictionaryHuffmanTables(e4, t4, i4) {
            let a4, s4, r4, n4, o4 = 0;
            switch (e4.huffmanDHSelector) {
              case 0:
              case 1:
                a4 = getStandardTable(e4.huffmanDHSelector + 4);
                break;
              case 3:
                a4 = getCustomHuffmanTable(o4, t4, i4);
                o4++;
                break;
              default:
                throw new Jbig2Error("invalid Huffman DH selector");
            }
            switch (e4.huffmanDWSelector) {
              case 0:
              case 1:
                s4 = getStandardTable(e4.huffmanDWSelector + 2);
                break;
              case 3:
                s4 = getCustomHuffmanTable(o4, t4, i4);
                o4++;
                break;
              default:
                throw new Jbig2Error("invalid Huffman DW selector");
            }
            if (e4.bitmapSizeSelector) {
              r4 = getCustomHuffmanTable(o4, t4, i4);
              o4++;
            } else
              r4 = getStandardTable(1);
            n4 = e4.aggregationInstancesSelector ? getCustomHuffmanTable(o4, t4, i4) : getStandardTable(1);
            return { tableDeltaHeight: a4, tableDeltaWidth: s4, tableBitmapSize: r4, tableAggregateInstances: n4 };
          }(e3, i3, this.customTables);
          o3 = new Reader(a3, s3, r3);
        }
        let g3 = this.symbols;
        g3 || (this.symbols = g3 = {});
        const c3 = [];
        for (const e4 of i3) {
          const t4 = g3[e4];
          t4 && c3.push(...t4);
        }
        const C3 = new DecodingContext(a3, s3, r3);
        g3[t3] = function decodeSymbolDictionary(e4, t4, i4, a4, s4, r4, n4, o4, g4, c4, C4, h2) {
          if (e4 && t4)
            throw new Jbig2Error("symbol refinement with Huffman is not supported");
          const l3 = [];
          let Q3 = 0, E3 = log2(i4.length + a4);
          const u3 = C4.decoder, d3 = C4.contextCache;
          let f2, p2;
          if (e4) {
            f2 = getStandardTable(1);
            p2 = [];
            E3 = Math.max(E3, 1);
          }
          for (; l3.length < a4; ) {
            Q3 += e4 ? r4.tableDeltaHeight.decode(h2) : decodeInteger(d3, "IADH", u3);
            let a5 = 0, s5 = 0;
            const f3 = e4 ? p2.length : 0;
            for (; ; ) {
              const f4 = e4 ? r4.tableDeltaWidth.decode(h2) : decodeInteger(d3, "IADW", u3);
              if (null === f4)
                break;
              a5 += f4;
              s5 += a5;
              let m4;
              if (t4) {
                const s6 = decodeInteger(d3, "IAAI", u3);
                if (s6 > 1)
                  m4 = decodeTextRegion(e4, t4, a5, Q3, 0, s6, 1, i4.concat(l3), E3, 0, 0, 1, 0, r4, g4, c4, C4, 0, h2);
                else {
                  const e5 = decodeIAID(d3, u3, E3), t5 = decodeInteger(d3, "IARDX", u3), s7 = decodeInteger(d3, "IARDY", u3);
                  m4 = decodeRefinement(a5, Q3, g4, e5 < i4.length ? i4[e5] : l3[e5 - i4.length], t5, s7, false, c4, C4);
                }
                l3.push(m4);
              } else if (e4)
                p2.push(a5);
              else {
                m4 = decodeBitmap(false, a5, Q3, n4, false, null, o4, C4);
                l3.push(m4);
              }
            }
            if (e4 && !t4) {
              const e5 = r4.tableBitmapSize.decode(h2);
              h2.byteAlign();
              let t5;
              if (0 === e5)
                t5 = readUncompressedBitmap(h2, s5, Q3);
              else {
                const i6 = h2.end, a6 = h2.position + e5;
                h2.end = a6;
                t5 = decodeMMRBitmap(h2, s5, Q3, false);
                h2.end = i6;
                h2.position = a6;
              }
              const i5 = p2.length;
              if (f3 === i5 - 1)
                l3.push(t5);
              else {
                let e6, a6, s6, r5, n5, o5 = 0;
                for (e6 = f3; e6 < i5; e6++) {
                  r5 = p2[e6];
                  s6 = o5 + r5;
                  n5 = [];
                  for (a6 = 0; a6 < Q3; a6++)
                    n5.push(t5[a6].subarray(o5, s6));
                  l3.push(n5);
                  o5 = s6;
                }
              }
            }
          }
          const m3 = [], y3 = [];
          let w3, b3, D3 = false;
          const F3 = i4.length + a4;
          for (; y3.length < F3; ) {
            let t5 = e4 ? f2.decode(h2) : decodeInteger(d3, "IAEX", u3);
            for (; t5--; )
              y3.push(D3);
            D3 = !D3;
          }
          for (w3 = 0, b3 = i4.length; w3 < b3; w3++)
            y3[w3] && m3.push(i4[w3]);
          for (let e5 = 0; e5 < a4; w3++, e5++)
            y3[w3] && m3.push(l3[e5]);
          return m3;
        }(e3.huffman, e3.refinement, c3, e3.numberOfNewSymbols, e3.numberOfExportedSymbols, n3, e3.template, e3.at, e3.refinementTemplate, e3.refinementAt, C3, o3);
      }
      onImmediateTextRegion(e3, t3, i3, a3, s3) {
        const r3 = e3.info;
        let n3, o3;
        const g3 = this.symbols, c3 = [];
        for (const e4 of t3) {
          const t4 = g3[e4];
          t4 && c3.push(...t4);
        }
        const C3 = log2(c3.length);
        if (e3.huffman) {
          o3 = new Reader(i3, a3, s3);
          n3 = function getTextRegionHuffmanTables(e4, t4, i4, a4, s4) {
            const r4 = [];
            for (let e5 = 0; e5 <= 34; e5++) {
              const t5 = s4.readBits(4);
              r4.push(new HuffmanLine([e5, t5, 0, 0]));
            }
            const n4 = new HuffmanTable(r4, false);
            r4.length = 0;
            for (let e5 = 0; e5 < a4; ) {
              const t5 = n4.decode(s4);
              if (t5 >= 32) {
                let i5, a5, n5;
                switch (t5) {
                  case 32:
                    if (0 === e5)
                      throw new Jbig2Error("no previous value in symbol ID table");
                    a5 = s4.readBits(2) + 3;
                    i5 = r4[e5 - 1].prefixLength;
                    break;
                  case 33:
                    a5 = s4.readBits(3) + 3;
                    i5 = 0;
                    break;
                  case 34:
                    a5 = s4.readBits(7) + 11;
                    i5 = 0;
                    break;
                  default:
                    throw new Jbig2Error("invalid code length in symbol ID table");
                }
                for (n5 = 0; n5 < a5; n5++) {
                  r4.push(new HuffmanLine([e5, i5, 0, 0]));
                  e5++;
                }
              } else {
                r4.push(new HuffmanLine([e5, t5, 0, 0]));
                e5++;
              }
            }
            s4.byteAlign();
            const o4 = new HuffmanTable(r4, false);
            let g4, c4, C4, h3 = 0;
            switch (e4.huffmanFS) {
              case 0:
              case 1:
                g4 = getStandardTable(e4.huffmanFS + 6);
                break;
              case 3:
                g4 = getCustomHuffmanTable(h3, t4, i4);
                h3++;
                break;
              default:
                throw new Jbig2Error("invalid Huffman FS selector");
            }
            switch (e4.huffmanDS) {
              case 0:
              case 1:
              case 2:
                c4 = getStandardTable(e4.huffmanDS + 8);
                break;
              case 3:
                c4 = getCustomHuffmanTable(h3, t4, i4);
                h3++;
                break;
              default:
                throw new Jbig2Error("invalid Huffman DS selector");
            }
            switch (e4.huffmanDT) {
              case 0:
              case 1:
              case 2:
                C4 = getStandardTable(e4.huffmanDT + 11);
                break;
              case 3:
                C4 = getCustomHuffmanTable(h3, t4, i4);
                h3++;
                break;
              default:
                throw new Jbig2Error("invalid Huffman DT selector");
            }
            if (e4.refinement)
              throw new Jbig2Error("refinement with Huffman is not supported");
            return { symbolIDTable: o4, tableFirstS: g4, tableDeltaS: c4, tableDeltaT: C4 };
          }(e3, t3, this.customTables, c3.length, o3);
        }
        const h2 = new DecodingContext(i3, a3, s3), l3 = decodeTextRegion(e3.huffman, e3.refinement, r3.width, r3.height, e3.defaultPixelValue, e3.numberOfSymbolInstances, e3.stripSize, c3, C3, e3.transposed, e3.dsOffset, e3.referenceCorner, e3.combinationOperator, n3, e3.refinementTemplate, e3.refinementAt, h2, e3.logStripSize, o3);
        this.drawBitmap(r3, l3);
      }
      onImmediateLosslessTextRegion() {
        this.onImmediateTextRegion(...arguments);
      }
      onPatternDictionary(e3, t3, i3, a3, s3) {
        let r3 = this.patterns;
        r3 || (this.patterns = r3 = {});
        const n3 = new DecodingContext(i3, a3, s3);
        r3[t3] = function decodePatternDictionary(e4, t4, i4, a4, s4, r4) {
          const n4 = [];
          if (!e4) {
            n4.push({ x: -t4, y: 0 });
            0 === s4 && n4.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 });
          }
          const o3 = decodeBitmap(e4, (a4 + 1) * t4, i4, s4, false, null, n4, r4), g3 = [];
          for (let e5 = 0; e5 <= a4; e5++) {
            const a5 = [], s5 = t4 * e5, r5 = s5 + t4;
            for (let e6 = 0; e6 < i4; e6++)
              a5.push(o3[e6].subarray(s5, r5));
            g3.push(a5);
          }
          return g3;
        }(e3.mmr, e3.patternWidth, e3.patternHeight, e3.maxPatternIndex, e3.template, n3);
      }
      onImmediateHalftoneRegion(e3, t3, i3, a3, s3) {
        const r3 = this.patterns[t3[0]], n3 = e3.info, o3 = new DecodingContext(i3, a3, s3), g3 = function decodeHalftoneRegion(e4, t4, i4, a4, s4, r4, n4, o4, g4, c3, C3, h2, l3, Q3, E3) {
          if (n4)
            throw new Jbig2Error("skip is not supported");
          if (0 !== o4)
            throw new Jbig2Error(`operator "${o4}" is not supported in halftone region`);
          const u3 = [];
          let d3, f2, p2;
          for (d3 = 0; d3 < s4; d3++) {
            p2 = new Uint8Array(a4);
            if (r4)
              for (f2 = 0; f2 < a4; f2++)
                p2[f2] = r4;
            u3.push(p2);
          }
          const m3 = t4.length, y3 = t4[0], w3 = y3[0].length, b3 = y3.length, D3 = log2(m3), F3 = [];
          if (!e4) {
            F3.push({ x: i4 <= 1 ? 3 : 2, y: -1 });
            0 === i4 && F3.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 });
          }
          const S3 = [];
          let k3, N3, R3, G3, x3, U3, M3, L3, H3, J3, Y3;
          e4 && (k3 = new Reader(E3.data, E3.start, E3.end));
          for (d3 = D3 - 1; d3 >= 0; d3--) {
            N3 = e4 ? decodeMMRBitmap(k3, g4, c3, true) : decodeBitmap(false, g4, c3, i4, false, null, F3, E3);
            S3[d3] = N3;
          }
          for (R3 = 0; R3 < c3; R3++)
            for (G3 = 0; G3 < g4; G3++) {
              x3 = 0;
              U3 = 0;
              for (f2 = D3 - 1; f2 >= 0; f2--) {
                x3 ^= S3[f2][R3][G3];
                U3 |= x3 << f2;
              }
              M3 = t4[U3];
              L3 = C3 + R3 * Q3 + G3 * l3 >> 8;
              H3 = h2 + R3 * l3 - G3 * Q3 >> 8;
              if (L3 >= 0 && L3 + w3 <= a4 && H3 >= 0 && H3 + b3 <= s4)
                for (d3 = 0; d3 < b3; d3++) {
                  Y3 = u3[H3 + d3];
                  J3 = M3[d3];
                  for (f2 = 0; f2 < w3; f2++)
                    Y3[L3 + f2] |= J3[f2];
                }
              else {
                let e5, t5;
                for (d3 = 0; d3 < b3; d3++) {
                  t5 = H3 + d3;
                  if (!(t5 < 0 || t5 >= s4)) {
                    Y3 = u3[t5];
                    J3 = M3[d3];
                    for (f2 = 0; f2 < w3; f2++) {
                      e5 = L3 + f2;
                      e5 >= 0 && e5 < a4 && (Y3[e5] |= J3[f2]);
                    }
                  }
                }
              }
            }
          return u3;
        }(e3.mmr, r3, e3.template, n3.width, n3.height, e3.defaultPixelValue, e3.enableSkip, e3.combinationOperator, e3.gridWidth, e3.gridHeight, e3.gridOffsetX, e3.gridOffsetY, e3.gridVectorX, e3.gridVectorY, o3);
        this.drawBitmap(n3, g3);
      }
      onImmediateLosslessHalftoneRegion() {
        this.onImmediateHalftoneRegion(...arguments);
      }
      onTables(e3, t3, i3, a3) {
        let s3 = this.customTables;
        s3 || (this.customTables = s3 = {});
        s3[e3] = function decodeTablesSegment(e4, t4, i4) {
          const a4 = e4[t4], s4 = 4294967295 & readUint32(e4, t4 + 1), r3 = 4294967295 & readUint32(e4, t4 + 5), n3 = new Reader(e4, t4 + 9, i4), o3 = 1 + (a4 >> 1 & 7), g3 = 1 + (a4 >> 4 & 7), c3 = [];
          let C3, h2, l3 = s4;
          do {
            C3 = n3.readBits(o3);
            h2 = n3.readBits(g3);
            c3.push(new HuffmanLine([l3, C3, h2, 0]));
            l3 += 1 << h2;
          } while (l3 < r3);
          C3 = n3.readBits(o3);
          c3.push(new HuffmanLine([s4 - 1, C3, 32, 0, "lower"]));
          C3 = n3.readBits(o3);
          c3.push(new HuffmanLine([r3, C3, 32, 0]));
          if (1 & a4) {
            C3 = n3.readBits(o3);
            c3.push(new HuffmanLine([C3, 0]));
          }
          return new HuffmanTable(c3, false);
        }(t3, i3, a3);
      }
    };
    HuffmanLine = class {
      constructor(e3) {
        if (2 === e3.length) {
          this.isOOB = true;
          this.rangeLow = 0;
          this.prefixLength = e3[0];
          this.rangeLength = 0;
          this.prefixCode = e3[1];
          this.isLowerRange = false;
        } else {
          this.isOOB = false;
          this.rangeLow = e3[0];
          this.prefixLength = e3[1];
          this.rangeLength = e3[2];
          this.prefixCode = e3[3];
          this.isLowerRange = "lower" === e3[4];
        }
      }
    };
    HuffmanTreeNode = class _HuffmanTreeNode {
      constructor(e3) {
        this.children = [];
        if (e3) {
          this.isLeaf = true;
          this.rangeLength = e3.rangeLength;
          this.rangeLow = e3.rangeLow;
          this.isLowerRange = e3.isLowerRange;
          this.isOOB = e3.isOOB;
        } else
          this.isLeaf = false;
      }
      buildTree(e3, t3) {
        const i3 = e3.prefixCode >> t3 & 1;
        if (t3 <= 0)
          this.children[i3] = new _HuffmanTreeNode(e3);
        else {
          let a3 = this.children[i3];
          a3 || (this.children[i3] = a3 = new _HuffmanTreeNode(null));
          a3.buildTree(e3, t3 - 1);
        }
      }
      decodeNode(e3) {
        if (this.isLeaf) {
          if (this.isOOB)
            return null;
          const t4 = e3.readBits(this.rangeLength);
          return this.rangeLow + (this.isLowerRange ? -t4 : t4);
        }
        const t3 = this.children[e3.readBit()];
        if (!t3)
          throw new Jbig2Error("invalid Huffman data");
        return t3.decodeNode(e3);
      }
    };
    HuffmanTable = class {
      constructor(e3, t3) {
        t3 || this.assignPrefixCodes(e3);
        this.rootNode = new HuffmanTreeNode(null);
        for (let t4 = 0, i3 = e3.length; t4 < i3; t4++) {
          const i4 = e3[t4];
          i4.prefixLength > 0 && this.rootNode.buildTree(i4, i4.prefixLength - 1);
        }
      }
      decode(e3) {
        return this.rootNode.decodeNode(e3);
      }
      assignPrefixCodes(e3) {
        const t3 = e3.length;
        let i3 = 0;
        for (let a4 = 0; a4 < t3; a4++)
          i3 = Math.max(i3, e3[a4].prefixLength);
        const a3 = new Uint32Array(i3 + 1);
        for (let i4 = 0; i4 < t3; i4++)
          a3[e3[i4].prefixLength]++;
        let s3, r3, n3, o3 = 1, g3 = 0;
        a3[0] = 0;
        for (; o3 <= i3; ) {
          g3 = g3 + a3[o3 - 1] << 1;
          s3 = g3;
          r3 = 0;
          for (; r3 < t3; ) {
            n3 = e3[r3];
            if (n3.prefixLength === o3) {
              n3.prefixCode = s3;
              s3++;
            }
            r3++;
          }
          o3++;
        }
      }
    };
    _t5 = {};
    Reader = class {
      constructor(e3, t3, i3) {
        this.data = e3;
        this.start = t3;
        this.end = i3;
        this.position = t3;
        this.shift = -1;
        this.currentByte = 0;
      }
      readBit() {
        if (this.shift < 0) {
          if (this.position >= this.end)
            throw new Jbig2Error("end of data while reading bit");
          this.currentByte = this.data[this.position++];
          this.shift = 7;
        }
        const e3 = this.currentByte >> this.shift & 1;
        this.shift--;
        return e3;
      }
      readBits(e3) {
        let t3, i3 = 0;
        for (t3 = e3 - 1; t3 >= 0; t3--)
          i3 |= this.readBit() << t3;
        return i3;
      }
      byteAlign() {
        this.shift = -1;
      }
      next() {
        return this.position >= this.end ? -1 : this.data[this.position++];
      }
    };
    Jbig2Image = class {
      parseChunks(e3) {
        return function parseJbig2Chunks(e4) {
          const t3 = new SimpleSegmentVisitor();
          for (let i3 = 0, a3 = e4.length; i3 < a3; i3++) {
            const a4 = e4[i3];
            processSegments(readSegments({}, a4.data, a4.start, a4.end), t3);
          }
          return t3.buffer;
        }(e3);
      }
      parse(e3) {
        throw new Error("Not implemented: Jbig2Image.parse");
      }
    };
    Jbig2Stream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3);
        this.stream = e3;
        this.dict = e3.dict;
        this.maybeLength = t3;
        this.params = i3;
      }
      get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e3) {
      }
      readBlock() {
        if (this.eof)
          return;
        const e3 = new Jbig2Image(), t3 = [];
        if (this.params instanceof Dict) {
          const e4 = this.params.get("JBIG2Globals");
          if (e4 instanceof BaseStream) {
            const i4 = e4.getBytes();
            t3.push({ data: i4, start: 0, end: i4.length });
          }
        }
        t3.push({ data: this.bytes, start: 0, end: this.bytes.length });
        const i3 = e3.parseChunks(t3), a3 = i3.length;
        for (let e4 = 0; e4 < a3; e4++)
          i3[e4] ^= 255;
        this.buffer = i3;
        this.bufferLength = a3;
        this.eof = true;
      }
    };
    JpegError = class extends rt {
      constructor(e3) {
        super(e3, "JpegError");
      }
    };
    DNLMarkerError = class extends rt {
      constructor(e3, t3) {
        super(e3, "DNLMarkerError");
        this.scanLines = t3;
      }
    };
    EOIMarkerError = class extends rt {
      constructor(e3) {
        super(e3, "EOIMarkerError");
      }
    };
    $t = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    Ai = 4017;
    ei = 799;
    ti = 3406;
    ii = 2276;
    ai = 1567;
    si = 3784;
    ri = 5793;
    ni = 2896;
    JpegImage = class {
      constructor({ decodeTransform: e3 = null, colorTransform: t3 = -1 } = {}) {
        this._decodeTransform = e3;
        this._colorTransform = t3;
      }
      parse(e3, { dnlScanLines: t3 = null } = {}) {
        function readDataBlock() {
          const t4 = readUint16(e3, s3);
          s3 += 2;
          let i4 = s3 + t4 - 2;
          const a4 = findNextFileMarker(e3, i4, s3);
          if (a4 == null ? void 0 : a4.invalid) {
            warn("readDataBlock - incorrect length, current marker is: " + a4.invalid);
            i4 = a4.offset;
          }
          const r4 = e3.subarray(s3, i4);
          s3 += r4.length;
          return r4;
        }
        function prepareComponents(e4) {
          const t4 = Math.ceil(e4.samplesPerLine / 8 / e4.maxH), i4 = Math.ceil(e4.scanLines / 8 / e4.maxV);
          for (const a4 of e4.components) {
            const s4 = Math.ceil(Math.ceil(e4.samplesPerLine / 8) * a4.h / e4.maxH), r4 = Math.ceil(Math.ceil(e4.scanLines / 8) * a4.v / e4.maxV), n4 = t4 * a4.h, o4 = 64 * (i4 * a4.v) * (n4 + 1);
            a4.blockData = new Int16Array(o4);
            a4.blocksPerLine = s4;
            a4.blocksPerColumn = r4;
          }
          e4.mcusPerLine = t4;
          e4.mcusPerColumn = i4;
        }
        let i3, a3, s3 = 0, r3 = null, n3 = null, o3 = 0;
        const g3 = [], c3 = [], C3 = [];
        let h2 = readUint16(e3, s3);
        s3 += 2;
        if (65496 !== h2)
          throw new JpegError("SOI not found");
        h2 = readUint16(e3, s3);
        s3 += 2;
        A:
          for (; 65497 !== h2; ) {
            let l3, Q3, E3;
            switch (h2) {
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                const u3 = readDataBlock();
                65504 === h2 && 74 === u3[0] && 70 === u3[1] && 73 === u3[2] && 70 === u3[3] && 0 === u3[4] && (r3 = { version: { major: u3[5], minor: u3[6] }, densityUnits: u3[7], xDensity: u3[8] << 8 | u3[9], yDensity: u3[10] << 8 | u3[11], thumbWidth: u3[12], thumbHeight: u3[13], thumbData: u3.subarray(14, 14 + 3 * u3[12] * u3[13]) });
                65518 === h2 && 65 === u3[0] && 100 === u3[1] && 111 === u3[2] && 98 === u3[3] && 101 === u3[4] && (n3 = { version: u3[5] << 8 | u3[6], flags0: u3[7] << 8 | u3[8], flags1: u3[9] << 8 | u3[10], transformCode: u3[11] });
                break;
              case 65499:
                const d3 = readUint16(e3, s3);
                s3 += 2;
                const f2 = d3 + s3 - 2;
                let p2;
                for (; s3 < f2; ) {
                  const t4 = e3[s3++], i4 = new Uint16Array(64);
                  if (t4 >> 4 == 0)
                    for (Q3 = 0; Q3 < 64; Q3++) {
                      p2 = $t[Q3];
                      i4[p2] = e3[s3++];
                    }
                  else {
                    if (t4 >> 4 != 1)
                      throw new JpegError("DQT - invalid table spec");
                    for (Q3 = 0; Q3 < 64; Q3++) {
                      p2 = $t[Q3];
                      i4[p2] = readUint16(e3, s3);
                      s3 += 2;
                    }
                  }
                  g3[15 & t4] = i4;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                if (i3)
                  throw new JpegError("Only single frame JPEGs supported");
                s3 += 2;
                i3 = {};
                i3.extended = 65473 === h2;
                i3.progressive = 65474 === h2;
                i3.precision = e3[s3++];
                const m3 = readUint16(e3, s3);
                s3 += 2;
                i3.scanLines = t3 || m3;
                i3.samplesPerLine = readUint16(e3, s3);
                s3 += 2;
                i3.components = [];
                i3.componentIds = {};
                const y3 = e3[s3++];
                let w3 = 0, b3 = 0;
                for (l3 = 0; l3 < y3; l3++) {
                  const t4 = e3[s3], a4 = e3[s3 + 1] >> 4, r4 = 15 & e3[s3 + 1];
                  w3 < a4 && (w3 = a4);
                  b3 < r4 && (b3 = r4);
                  const n4 = e3[s3 + 2];
                  E3 = i3.components.push({ h: a4, v: r4, quantizationId: n4, quantizationTable: null });
                  i3.componentIds[t4] = E3 - 1;
                  s3 += 3;
                }
                i3.maxH = w3;
                i3.maxV = b3;
                prepareComponents(i3);
                break;
              case 65476:
                const D3 = readUint16(e3, s3);
                s3 += 2;
                for (l3 = 2; l3 < D3; ) {
                  const t4 = e3[s3++], i4 = new Uint8Array(16);
                  let a4 = 0;
                  for (Q3 = 0; Q3 < 16; Q3++, s3++)
                    a4 += i4[Q3] = e3[s3];
                  const r4 = new Uint8Array(a4);
                  for (Q3 = 0; Q3 < a4; Q3++, s3++)
                    r4[Q3] = e3[s3];
                  l3 += 17 + a4;
                  (t4 >> 4 == 0 ? C3 : c3)[15 & t4] = buildHuffmanTable(i4, r4);
                }
                break;
              case 65501:
                s3 += 2;
                a3 = readUint16(e3, s3);
                s3 += 2;
                break;
              case 65498:
                const F3 = 1 == ++o3 && !t3;
                s3 += 2;
                const S3 = e3[s3++], k3 = [];
                for (l3 = 0; l3 < S3; l3++) {
                  const t4 = e3[s3++], a4 = i3.componentIds[t4], r4 = i3.components[a4];
                  r4.index = t4;
                  const n4 = e3[s3++];
                  r4.huffmanTableDC = C3[n4 >> 4];
                  r4.huffmanTableAC = c3[15 & n4];
                  k3.push(r4);
                }
                const N3 = e3[s3++], R3 = e3[s3++], G3 = e3[s3++];
                try {
                  const t4 = decodeScan(e3, s3, i3, k3, a3, N3, R3, G3 >> 4, 15 & G3, F3);
                  s3 += t4;
                } catch (t4) {
                  if (t4 instanceof DNLMarkerError) {
                    warn(`${t4.message} -- attempting to re-parse the JPEG image.`);
                    return this.parse(e3, { dnlScanLines: t4.scanLines });
                  }
                  if (t4 instanceof EOIMarkerError) {
                    warn(`${t4.message} -- ignoring the rest of the image data.`);
                    break A;
                  }
                  throw t4;
                }
                break;
              case 65500:
                s3 += 4;
                break;
              case 65535:
                255 !== e3[s3] && s3--;
                break;
              default:
                const x3 = findNextFileMarker(e3, s3 - 2, s3 - 3);
                if (x3 == null ? void 0 : x3.invalid) {
                  warn("JpegImage.parse - unexpected data, current marker is: " + x3.invalid);
                  s3 = x3.offset;
                  break;
                }
                if (!x3 || s3 >= e3.length - 1) {
                  warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                  break A;
                }
                throw new JpegError("JpegImage.parse - unknown marker: " + h2.toString(16));
            }
            h2 = readUint16(e3, s3);
            s3 += 2;
          }
        if (!i3)
          throw new JpegError("JpegImage.parse - no frame data found.");
        this.width = i3.samplesPerLine;
        this.height = i3.scanLines;
        this.jfif = r3;
        this.adobe = n3;
        this.components = [];
        for (const e4 of i3.components) {
          const t4 = g3[e4.quantizationId];
          t4 && (e4.quantizationTable = t4);
          this.components.push({ index: e4.index, output: buildComponentData(0, e4), scaleX: e4.h / i3.maxH, scaleY: e4.v / i3.maxV, blocksPerLine: e4.blocksPerLine, blocksPerColumn: e4.blocksPerColumn });
        }
        this.numComponents = this.components.length;
      }
      _getLinearizedBlockData(e3, t3, i3 = false) {
        const a3 = this.width / e3, s3 = this.height / t3;
        let r3, n3, o3, g3, c3, C3, h2, l3, Q3, E3, u3, d3 = 0;
        const f2 = this.components.length, p2 = e3 * t3 * f2, m3 = new Uint8ClampedArray(p2), y3 = new Uint32Array(e3), w3 = 4294967288;
        let b3;
        for (h2 = 0; h2 < f2; h2++) {
          r3 = this.components[h2];
          n3 = r3.scaleX * a3;
          o3 = r3.scaleY * s3;
          d3 = h2;
          u3 = r3.output;
          g3 = r3.blocksPerLine + 1 << 3;
          if (n3 !== b3) {
            for (c3 = 0; c3 < e3; c3++) {
              l3 = 0 | c3 * n3;
              y3[c3] = (l3 & w3) << 3 | 7 & l3;
            }
            b3 = n3;
          }
          for (C3 = 0; C3 < t3; C3++) {
            l3 = 0 | C3 * o3;
            E3 = g3 * (l3 & w3) | (7 & l3) << 3;
            for (c3 = 0; c3 < e3; c3++) {
              m3[d3] = u3[E3 + y3[c3]];
              d3 += f2;
            }
          }
        }
        let D3 = this._decodeTransform;
        i3 || 4 !== f2 || D3 || (D3 = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]));
        if (D3)
          for (h2 = 0; h2 < p2; )
            for (l3 = 0, Q3 = 0; l3 < f2; l3++, h2++, Q3 += 2)
              m3[h2] = (m3[h2] * D3[Q3] >> 8) + D3[Q3 + 1];
        return m3;
      }
      get _isColorConversionNeeded() {
        return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
      }
      _convertYccToRgb(e3) {
        let t3, i3, a3;
        for (let s3 = 0, r3 = e3.length; s3 < r3; s3 += 3) {
          t3 = e3[s3];
          i3 = e3[s3 + 1];
          a3 = e3[s3 + 2];
          e3[s3] = t3 - 179.456 + 1.402 * a3;
          e3[s3 + 1] = t3 + 135.459 - 0.344 * i3 - 0.714 * a3;
          e3[s3 + 2] = t3 - 226.816 + 1.772 * i3;
        }
        return e3;
      }
      _convertYccToRgba(e3, t3) {
        for (let i3 = 0, a3 = 0, s3 = e3.length; i3 < s3; i3 += 3, a3 += 4) {
          const s4 = e3[i3], r3 = e3[i3 + 1], n3 = e3[i3 + 2];
          t3[a3] = s4 - 179.456 + 1.402 * n3;
          t3[a3 + 1] = s4 + 135.459 - 0.344 * r3 - 0.714 * n3;
          t3[a3 + 2] = s4 - 226.816 + 1.772 * r3;
          t3[a3 + 3] = 255;
        }
        return t3;
      }
      _convertYcckToRgb(e3) {
        let t3, i3, a3, s3, r3 = 0;
        for (let n3 = 0, o3 = e3.length; n3 < o3; n3 += 4) {
          t3 = e3[n3];
          i3 = e3[n3 + 1];
          a3 = e3[n3 + 2];
          s3 = e3[n3 + 3];
          e3[r3++] = i3 * (-660635669420364e-19 * i3 + 437130475926232e-18 * a3 - 54080610064599e-18 * t3 + 48449797120281e-17 * s3 - 0.154362151871126) - 122.67195406894 + a3 * (-957964378445773e-18 * a3 + 817076911346625e-18 * t3 - 0.00477271405408747 * s3 + 1.53380253221734) + t3 * (961250184130688e-18 * t3 - 0.00266257332283933 * s3 + 0.48357088451265) + s3 * (-336197177618394e-18 * s3 + 0.484791561490776);
          e3[r3++] = 107.268039397724 + i3 * (219927104525741e-19 * i3 - 640992018297945e-18 * a3 + 659397001245577e-18 * t3 + 426105652938837e-18 * s3 - 0.176491792462875) + a3 * (-778269941513683e-18 * a3 + 0.00130872261408275 * t3 + 770482631801132e-18 * s3 - 0.151051492775562) + t3 * (0.00126935368114843 * t3 - 0.00265090189010898 * s3 + 0.25802910206845) + s3 * (-318913117588328e-18 * s3 - 0.213742400323665);
          e3[r3++] = i3 * (-570115196973677e-18 * i3 - 263409051004589e-19 * a3 + 0.0020741088115012 * t3 - 0.00288260236853442 * s3 + 0.814272968359295) - 20.810012546947 + a3 * (-153496057440975e-19 * a3 - 132689043961446e-18 * t3 + 560833691242812e-18 * s3 - 0.195152027534049) + t3 * (0.00174418132927582 * t3 - 0.00255243321439347 * s3 + 0.116935020465145) + s3 * (-343531996510555e-18 * s3 + 0.24165260232407);
        }
        return e3.subarray(0, r3);
      }
      _convertYcckToRgba(e3) {
        for (let t3 = 0, i3 = e3.length; t3 < i3; t3 += 4) {
          const i4 = e3[t3], a3 = e3[t3 + 1], s3 = e3[t3 + 2], r3 = e3[t3 + 3];
          e3[t3] = a3 * (-660635669420364e-19 * a3 + 437130475926232e-18 * s3 - 54080610064599e-18 * i4 + 48449797120281e-17 * r3 - 0.154362151871126) - 122.67195406894 + s3 * (-957964378445773e-18 * s3 + 817076911346625e-18 * i4 - 0.00477271405408747 * r3 + 1.53380253221734) + i4 * (961250184130688e-18 * i4 - 0.00266257332283933 * r3 + 0.48357088451265) + r3 * (-336197177618394e-18 * r3 + 0.484791561490776);
          e3[t3 + 1] = 107.268039397724 + a3 * (219927104525741e-19 * a3 - 640992018297945e-18 * s3 + 659397001245577e-18 * i4 + 426105652938837e-18 * r3 - 0.176491792462875) + s3 * (-778269941513683e-18 * s3 + 0.00130872261408275 * i4 + 770482631801132e-18 * r3 - 0.151051492775562) + i4 * (0.00126935368114843 * i4 - 0.00265090189010898 * r3 + 0.25802910206845) + r3 * (-318913117588328e-18 * r3 - 0.213742400323665);
          e3[t3 + 2] = a3 * (-570115196973677e-18 * a3 - 263409051004589e-19 * s3 + 0.0020741088115012 * i4 - 0.00288260236853442 * r3 + 0.814272968359295) - 20.810012546947 + s3 * (-153496057440975e-19 * s3 - 132689043961446e-18 * i4 + 560833691242812e-18 * r3 - 0.195152027534049) + i4 * (0.00174418132927582 * i4 - 0.00255243321439347 * r3 + 0.116935020465145) + r3 * (-343531996510555e-18 * r3 + 0.24165260232407);
          e3[t3 + 3] = 255;
        }
        return e3;
      }
      _convertYcckToCmyk(e3) {
        let t3, i3, a3;
        for (let s3 = 0, r3 = e3.length; s3 < r3; s3 += 4) {
          t3 = e3[s3];
          i3 = e3[s3 + 1];
          a3 = e3[s3 + 2];
          e3[s3] = 434.456 - t3 - 1.402 * a3;
          e3[s3 + 1] = 119.541 - t3 + 0.344 * i3 + 0.714 * a3;
          e3[s3 + 2] = 481.816 - t3 - 1.772 * i3;
        }
        return e3;
      }
      _convertCmykToRgb(e3) {
        let t3, i3, a3, s3, r3 = 0;
        for (let n3 = 0, o3 = e3.length; n3 < o3; n3 += 4) {
          t3 = e3[n3];
          i3 = e3[n3 + 1];
          a3 = e3[n3 + 2];
          s3 = e3[n3 + 3];
          e3[r3++] = 255 + t3 * (-6747147073602441e-20 * t3 + 8379262121013727e-19 * i3 + 2894718188643294e-19 * a3 + 0.003264231057537806 * s3 - 1.1185611867203937) + i3 * (26374107616089405e-21 * i3 - 8626949158638572e-20 * a3 - 2748769067499491e-19 * s3 - 0.02155688794978967) + a3 * (-3878099212869363e-20 * a3 - 3267808279485286e-19 * s3 + 0.0686742238595345) - s3 * (3361971776183937e-19 * s3 + 0.7430659151342254);
          e3[r3++] = 255 + t3 * (13596372813588848e-20 * t3 + 924537132573585e-18 * i3 + 10567359618683593e-20 * a3 + 4791864687436512e-19 * s3 - 0.3109689587515875) + i3 * (-23545346108370344e-20 * i3 + 2702845253534714e-19 * a3 + 0.0020200308977307156 * s3 - 0.7488052167015494) + a3 * (6834815998235662e-20 * a3 + 15168452363460973e-20 * s3 - 0.09751927774728933) - s3 * (3189131175883281e-19 * s3 + 0.7364883807733168);
          e3[r3++] = 255 + t3 * (13598650411385307e-21 * t3 + 12423956175490851e-20 * i3 + 4751985097583589e-19 * a3 - 36729317476630422e-22 * s3 - 0.05562186980264034) + i3 * (16141380598724676e-20 * i3 + 9692239130725186e-19 * a3 + 7782692450036253e-19 * s3 - 0.44015232367526463) + a3 * (5068882914068769e-22 * a3 + 0.0017778369011375071 * s3 - 0.7591454649749609) - s3 * (3435319965105553e-19 * s3 + 0.7063770186160144);
        }
        return e3.subarray(0, r3);
      }
      _convertCmykToRgba(e3) {
        for (let t3 = 0, i3 = e3.length; t3 < i3; t3 += 4) {
          const i4 = e3[t3], a3 = e3[t3 + 1], s3 = e3[t3 + 2], r3 = e3[t3 + 3];
          e3[t3] = 255 + i4 * (-6747147073602441e-20 * i4 + 8379262121013727e-19 * a3 + 2894718188643294e-19 * s3 + 0.003264231057537806 * r3 - 1.1185611867203937) + a3 * (26374107616089405e-21 * a3 - 8626949158638572e-20 * s3 - 2748769067499491e-19 * r3 - 0.02155688794978967) + s3 * (-3878099212869363e-20 * s3 - 3267808279485286e-19 * r3 + 0.0686742238595345) - r3 * (3361971776183937e-19 * r3 + 0.7430659151342254);
          e3[t3 + 1] = 255 + i4 * (13596372813588848e-20 * i4 + 924537132573585e-18 * a3 + 10567359618683593e-20 * s3 + 4791864687436512e-19 * r3 - 0.3109689587515875) + a3 * (-23545346108370344e-20 * a3 + 2702845253534714e-19 * s3 + 0.0020200308977307156 * r3 - 0.7488052167015494) + s3 * (6834815998235662e-20 * s3 + 15168452363460973e-20 * r3 - 0.09751927774728933) - r3 * (3189131175883281e-19 * r3 + 0.7364883807733168);
          e3[t3 + 2] = 255 + i4 * (13598650411385307e-21 * i4 + 12423956175490851e-20 * a3 + 4751985097583589e-19 * s3 - 36729317476630422e-22 * r3 - 0.05562186980264034) + a3 * (16141380598724676e-20 * a3 + 9692239130725186e-19 * s3 + 7782692450036253e-19 * r3 - 0.44015232367526463) + s3 * (5068882914068769e-22 * s3 + 0.0017778369011375071 * r3 - 0.7591454649749609) - r3 * (3435319965105553e-19 * r3 + 0.7063770186160144);
          e3[t3 + 3] = 255;
        }
        return e3;
      }
      getData({ width: e3, height: t3, forceRGBA: i3 = false, forceRGB: a3 = false, isSourcePDF: s3 = false }) {
        if (this.numComponents > 4)
          throw new JpegError("Unsupported color mode");
        const r3 = this._getLinearizedBlockData(e3, t3, s3);
        if (1 === this.numComponents && (i3 || a3)) {
          const e4 = r3.length * (i3 ? 4 : 3), t4 = new Uint8ClampedArray(e4);
          let a4 = 0;
          if (i3)
            !function grayToRGBA(e5, t5) {
              if (FeatureTest.isLittleEndian)
                for (let i4 = 0, a5 = e5.length; i4 < a5; i4++)
                  t5[i4] = 65793 * e5[i4] | 4278190080;
              else
                for (let i4 = 0, a5 = e5.length; i4 < a5; i4++)
                  t5[i4] = 16843008 * e5[i4] | 255;
            }(r3, new Uint32Array(t4.buffer));
          else
            for (const e5 of r3) {
              t4[a4++] = e5;
              t4[a4++] = e5;
              t4[a4++] = e5;
            }
          return t4;
        }
        if (3 === this.numComponents && this._isColorConversionNeeded) {
          if (i3) {
            const e4 = new Uint8ClampedArray(r3.length / 3 * 4);
            return this._convertYccToRgba(r3, e4);
          }
          return this._convertYccToRgb(r3);
        }
        if (4 === this.numComponents) {
          if (this._isColorConversionNeeded)
            return i3 ? this._convertYcckToRgba(r3) : a3 ? this._convertYcckToRgb(r3) : this._convertYcckToCmyk(r3);
          if (i3)
            return this._convertCmykToRgba(r3);
          if (a3)
            return this._convertCmykToRgb(r3);
        }
        return r3;
      }
    };
    JpegStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        let a3;
        for (; -1 !== (a3 = e3.getByte()); )
          if (255 === a3) {
            e3.skip(-1);
            break;
          }
        super(t3);
        this.stream = e3;
        this.dict = e3.dict;
        this.maybeLength = t3;
        this.params = i3;
      }
      get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e3) {
      }
      readBlock() {
        if (this.eof)
          return;
        const e3 = { decodeTransform: void 0, colorTransform: void 0 }, t3 = this.dict.getArray("D", "Decode");
        if ((this.forceRGBA || this.forceRGB) && Array.isArray(t3)) {
          const i4 = this.dict.get("BPC", "BitsPerComponent") || 8, a4 = t3.length, s3 = new Int32Array(a4);
          let r3 = false;
          const n3 = (1 << i4) - 1;
          for (let e4 = 0; e4 < a4; e4 += 2) {
            s3[e4] = 256 * (t3[e4 + 1] - t3[e4]) | 0;
            s3[e4 + 1] = t3[e4] * n3 | 0;
            256 === s3[e4] && 0 === s3[e4 + 1] || (r3 = true);
          }
          r3 && (e3.decodeTransform = s3);
        }
        if (this.params instanceof Dict) {
          const t4 = this.params.get("ColorTransform");
          Number.isInteger(t4) && (e3.colorTransform = t4);
        }
        const i3 = new JpegImage(e3);
        i3.parse(this.bytes);
        const a3 = i3.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: true });
        this.buffer = a3;
        this.bufferLength = a3.length;
        this.eof = true;
      }
    };
    gi = (oi = "file:///C:/pdfjs/botio-files-pdfjs/private/d6919bed03c6677/external/openjpeg/openjpeg.js", function(e3 = {}) {
      var t3, i3, a3 = e3;
      new Promise((e4, a4) => {
        t3 = e4;
        i3 = a4;
      });
      a3.decode = function(e4, t4) {
        const i4 = e4.length, s4 = a3._malloc(i4);
        a3.HEAPU8.set(e4, s4);
        const r4 = a3._jp2_decode(s4, i4, t4 ? 1 : 0);
        a3._free(s4);
        if (r4) {
          const { errorMessages: e5 } = a3;
          if (e5) {
            delete a3.errorMessages;
            return e5;
          }
          return "Unknown error";
        }
        const { imageData: n4 } = a3;
        a3.imageData = null;
        return n4;
      };
      var s3, r3 = Object.assign({}, a3), n3 = "./this.program", o3 = "";
      "undefined" != typeof document && document.currentScript && (o3 = document.currentScript.src);
      oi && (o3 = oi);
      o3 = o3.startsWith("blob:") ? "" : o3.substr(0, o3.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      var g3, c3, C3, h2, l3, Q3 = a3.print || console.log.bind(console), E3 = a3.printErr || console.error.bind(console);
      Object.assign(a3, r3);
      r3 = null;
      a3.arguments && a3.arguments;
      a3.thisProgram && (n3 = a3.thisProgram);
      a3.quit && a3.quit;
      a3.wasmBinary && (g3 = a3.wasmBinary);
      function tryParseAsDataURI(e4) {
        if (isDataURI(e4))
          return function intArrayFromBase64(e5) {
            for (var t4 = atob(e5), i4 = new Uint8Array(t4.length), a4 = 0; a4 < t4.length; ++a4)
              i4[a4] = t4.charCodeAt(a4);
            return i4;
          }(e4.slice(b3.length));
      }
      function updateMemoryViews() {
        var e4 = c3.buffer;
        a3.HEAP8 = C3 = new Int8Array(e4);
        a3.HEAP16 = new Int16Array(e4);
        a3.HEAPU8 = h2 = new Uint8Array(e4);
        a3.HEAPU16 = new Uint16Array(e4);
        a3.HEAP32 = new Int32Array(e4);
        a3.HEAPU32 = l3 = new Uint32Array(e4);
        a3.HEAPF32 = new Float32Array(e4);
        a3.HEAPF64 = new Float64Array(e4);
      }
      var u3, d3 = [], f2 = [], p2 = [], m3 = 0, y3 = null, w3 = null, b3 = "data:application/octet-stream;base64,", isDataURI = (e4) => e4.startsWith(b3);
      u3 = "data:application/octet-stream;base64,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AkAgFSAYIA1BAnRqQRBJckUEQANAIAEgAEECdCIEaiAEIAVq/QACAP0LAgAgAEEEaiIAIBNHDQALIBMiBCAIRg0BCyAEIQAgEQRAA0AgASAAIAJsQQJ0aiAFIABBAnRqKAIANgIAIABBAWohACAGQQFqIgYgEUcNAAsLIAQgCGtBfEsNAANAIAEgACACbEECdGogBSAAQQJ0aigCADYCACABIABBAWoiBCACbEECdGogBSAEQQJ0aigCADYCACABIABBAmoiBCACbEECdGogBSAEQQJ0aigCADYCACABIABBA2oiBCACbEECdGogBSAEQQJ0aigCADYCACAAQQRqIgAgCEcNAAsLIAFBBGohASANQQFqIg0gA0cNAAsMAQsCQAJAAkAgCEEBaw4CAAECCyADQQBMDQJBACECAkAgA0EESQRAIAEhAAwBCyABIANB/P///wdxIgJBAnRqIQADQCABIAZBAnRqIgQgBP0AAgAiIf0bAEECbf0RICH9GwFBAm39HAEgIf0bAkECbf0cAiAh/RsDQQJt/RwD/QsCACAGQQRqIgYgAkcNAAsgAiADRg0DCwNAIAAgACgCAEECbTYCACAAQQRqIQAgAkEBaiICIANHDQALDAILIANBAEwNASAAKAIAIQkgAiAKbEECdCEHA0AgCSABKAIAIAEgB2oiBCgCAEEBakEBdWsiADYCBCAJIAAgBCgCAGoiADYCACABIAA2AgAgASACQQJ0aiAJKAIENgIAIAFBBGohASAGQQFqIgYgA0cNAAsMAQsgCEEDSA0AIANBAEwNACAAKAIAIgUgCCAIQQFxIhRFIgZrQQRrIglBAXYiC0ECdCIHIAEgA0ECdCIAampJIAUgC0EDdGpBDGoiBCABQQRqS3EgBUEEaiAAIAEgCkECdGoiAGogB2pBCGpJIABBCGogBElxciEVIAJBAUcgCEEESXIhFiACQQFGIAlBBUtxIRcgCEH8////B3EhECAIQQNxIREgASAFayEYIAUgCEECdGpBBGshGSAFIAhBAmsiAEECdGohGiALQQFqIhJBfHEiDEEBciETIAxBAXRBAXIhCyACIApsQQJ0IRsgACAGa0ECSSEcIAhBAXZBAWsgAmxBAnQhHQNAIAUgASgCACABIBtqIg8gAkECdGooAgAiCSAPKAIAIgBqQQJqQQJ1ayIHIABqNgIA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aCk9AAkJCSBzdGVwc2l6ZXMgKG0sZSk9AC4AKG51bGwpACglZCwlZCkgACVzfQoACQkgfQoAW0RFVl0gRHVtcCBhbiBpbWFnZV9jb21wX2hlYWRlciBzdHJ1Y3QgewoAW0RFVl0gRHVtcCBhbiBpbWFnZV9oZWFkZXIgc3RydWN0IHsKAEltYWdlIGluZm8gewoACSBkZWZhdWx0IHRpbGUgewoAJXMJIGNvbXBvbmVudCAlZCB7CgAJCSBjb21wICVkIHsKAAkgVGlsZSBpbmRleDogewoACSBNYXJrZXIgbGlzdDogewoAQ29kZXN0cmVhbSBpbmRleCBmcm9tIG1haW4gaGVhZGVyOiB7CgBDb2Rlc3RyZWFtIGluZm8gZnJvbSBtYWluIGhlYWRlcjogewoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3gKAEZvdW5kIGEgbWlzcGxhY2VkICclYyVjJWMlYycgYm94IG91dHNpZGUganAyaCBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IGZpcnN0IGJveCBtdXN0IGJlIEpQRUcgMjAwMCBzaWduYXR1cmUgYm94CgBNYWxmb3JtZWQgSlAyIGZpbGUgZm9ybWF0OiBzZWNvbmQgYm94IG11c3QgYmUgZmlsZSB0eXBlIGJveAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGpwZWcyMDAwIGJveAoATm90IGVub3VnaCBtZW1vcnkgd2l0aCBGVFlQIEJveAoAQSBtYXJrZXIgSUQgd2FzIGV4cGVjdGVkICgweGZmLS0pIGluc3RlYWQgb2YgJS44eAoACQkgbWN0PSV4CgAJCQkgY2Jsa3N0eT0lI3gKAAkJCSBjc3R5PSUjeAoACQkgcHJnPSUjeAoASW50ZWdlciBvdmVyZmxvdwoACSB0ZHg9JXUsIHRkeT0ldQoACSB0dz0ldSwgdGg9JXUKAAkgdHgwPSV1LCB0eTA9JXUKAEludmFsaWQgY29tcG9uZW50IGluZGV4OiAldQoAU3RyZWFtIHRvbyBzaG9ydAoATWFya2VyIGhhbmRsZXIgZnVuY3Rpb24gZmFpbGVkIHRvIHJlYWQgdGhlIG1hcmtlciBzZWdtZW50CgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgY3VycmVudCBwcmVjaW5jdCBjb2RlYmxvY2sgZWxlbWVudAoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNRY2Qgb3IgU1FjYyBlbGVtZW50CgBBIEJQQ0MgaGVhZGVyIGJveCBpcyBhdmFpbGFibGUgYWx0aG91Z2ggQlBDIGdpdmVuIGJ5IHRoZSBJSERSIGJveCAoJWQpIGluZGljYXRlIGNvbXBvbmVudHMgYml0IGRlcHRoIGlzIGNvbnN0YW50CgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGlsbGVnYWwgdGlsZSBvZmZzZXQKAEludmFsaWQgcHJlY2luY3QKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBiYW5kIHByZWNpbnRzCgBGYWlsZWQgdG8gZGVjb2RlIGFsbCB1c2VkIGNvbXBvbmVudHMKAFNpemUgb2YgY29kZSBibG9jayBkYXRhIGV4Y2VlZHMgc3lzdGVtIGxpbWl0cwoAU2l6ZSBvZiB0aWxlIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgTUNUIG1hcmtlcnMKAENvcnJ1cHRlZCBQUE0gbWFya2VycwoATm90IGVub3VnaCBtZW1vcnkgZm9yIHRpbGUgcmVzb2x1dGlvbnMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBjb2xsZWN0aW9ucwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAwIHBhbGV0dGUgY29sdW1ucwoAV2UgZG8gbm90IHN1cHBvcnQgUk9JIGluIGRlY29kaW5nIEhUIGNvZGVibG9ja3MKAENhbm5vdCBoYW5kbGUgYm94IG9mIHVuZGVmaW5lZCBzaXplcwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIHdpdGhvdXQgc2FtZSBudW1iZXIgb2YgaW5kaXhlcwoASW52YWxpZCB0aWxlYy0+d2luX3h4eCB2YWx1ZXMKAENhbm5vdCBoYW5kbGUgYm94IG9mIGxlc3MgdGhhbiA4IGJ5dGVzCgBDYW5ub3QgaGFuZGxlIFhMIGJveCBvZiBsZXNzIHRoYW4gMTYgYnl0ZXMKAENvbXBvbmVudCBpbmRleCAldSB1c2VkIHNldmVyYWwgdGltZXMKAEludmFsaWQgUENMUiBib3guIFJlcG9ydHMgJWQgZW50cmllcwoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlIG5vZGVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbWN0IGRhdGEgd2l0aGluIG11bHRpcGxlIE1DVCByZWNvcmRzCgBDYW5ub3QgZGVjb2RlIHRpbGUsIG1lbW9yeSBlcnJvcgoAb3BqX2oya19hcHBseV9uYl90aWxlX3BhcnRzX2NvcnJlY3Rpb24gZXJyb3IKAFByb2JsZW0gd2l0aCBza2lwcGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAUHJvYmxlbSB3aXRoIHJlYWRpbmcgSlBFRzIwMDAgYm94LCBzdHJlYW0gZXJyb3IKAFVua25vd24gbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgdGwgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgbWggbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byB0YWtlIGluIGNoYXJnZSBTSVogbWFya2VyCgBFcnJvciByZWFkaW5nIFBQVCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBTT1QgbWFya2VyCgBFcnJvciByZWFkaW5nIFBMVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIHNwYWNlIGZvciBleHBlY3RlZCBTT1AgbWFya2VyCgBFeHBlY3RlZCBTT1AgbWFya2VyCgBFcnJvciByZWFkaW5nIE1DTyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUkdOIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQUE0gbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFBQTSBtYXJrZXIKAEVycm9yIHJlYWRpbmcgVExNIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQTE0gbWFya2VyCgBOb3QgZW5vdWdoIHNwYWNlIGZvciBleHBlY3RlZCBFUEggbWFya2VyCgBFeHBlY3RlZCBFUEggbWFya2VyCgBFcnJvciByZWFkaW5nIENSRyBtYXJrZXIKAFVua25vd24gcHJvZ3Jlc3Npb24gb3JkZXIgaW4gQ09EIG1hcmtlcgoAVW5rbm93biBTY29kIHZhbHVlIGluIENPRCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ09EIG1hcmtlcgoARXJyb3IgcmVhZGluZyBRQ0QgbWFya2VyCgBDcnJvciByZWFkaW5nIENCRCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUE9DIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDT0MgbWFya2VyCgBFcnJvciByZWFkaW5nIFFDQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNDIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBNQ0MgbWFya2VyCgByZXF1aXJlZCBTSVogbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoAcmVxdWlyZWQgQ09EIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAHJlcXVpcmVkIFFDRCBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUganBlZzIwMDAgZmlsZSBoZWFkZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgaGVhZGVyCgBFcnJvciB3aXRoIEpQIFNpZ25hdHVyZSA6IGJhZCBtYWdpYyBudW1iZXIKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHRpbGUtcGFydCAoJWQpLCBnaXZpbmcgdXAKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIHByZXZpb3VzIG51bWJlciBvZiB0aWxlLXBhcnQgKCVkKSwgZ2l2aW5nIHVwCgBJbiBTT1QgbWFya2VyLCBUUFNvdCAoJWQpIGlzIG5vdCB2YWxpZCByZWdhcmRzIHRvIHRoZSBjdXJyZW50IG51bWJlciBvZiB0aWxlLXBhcnQgKGhlYWRlcikgKCVkKSwgZ2l2aW5nIHVwCgB0aWxlcyByZXF1aXJlIGF0IGxlYXN0IG9uZSByZXNvbHV0aW9uCgBNYXJrZXIgaXMgbm90IGNvbXBsaWFudCB3aXRoIGl0cyBwb3NpdGlvbgoAUHJvYmxlbSB3aXRoIHNlZWsgZnVuY3Rpb24KAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudCwgSW52YWxpZCBjYmxrdy9jYmxraCBjb21iaW5hdGlvbgoASW52YWxpZCBtdWx0aXBsZSBjb21wb25lbnQgdHJhbnNmb3JtYXRpb24KAENhbm5vdCB0YWtlIGluIGNoYXJnZSBjb2xsZWN0aW9ucyBvdGhlciB0aGFuIGFycmF5IGRlY29ycmVsYXRpb24KAFRvbyBsYXJnZSB2YWx1ZSBmb3IgTnBwbQoATm90IGVub3VnaCBieXRlcyB0byByZWFkIE5wcG0KAGJhZCBwbGFjZWQganBlZyBjb2Rlc3RyZWFtCgAJIE1haW4gaGVhZGVyIHN0YXJ0IHBvc2l0aW9uPSVsbGkKCSBNYWluIGhlYWRlciBlbmQgcG9zaXRpb249JWxsaQoATWFya2VyIHNpemUgaW5jb25zaXN0ZW50IHdpdGggc3RyZWFtIGxlbmd0aAoAVGlsZSBwYXJ0IGxlbmd0aCBzaXplIGluY29uc2lzdGVudCB3aXRoIHN0cmVhbSBsZW5ndGgKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBkYXRhIHNwYW5uaW5nCgBXcm9uZyBmbGFnCgBFcnJvciB3aXRoIEZUWVAgc2lnbmF0dXJlIEJveCBzaXplCgBFcnJvciB3aXRoIEpQIHNpZ25hdHVyZSBCb3ggc2l6ZQoASW52YWxpZCBwcmVjaW5jdCBzaXplCgBJbmNvbnNpc3RlbnQgbWFya2VyIHNpemUKAEludmFsaWQgbWFya2VyIHNpemUKAEVycm9yIHdpdGggU0laIG1hcmtlciBzaXplCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgYSBuZXcgdmFsaWRhdGlvbiBwcm9jZWR1cmUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGRlY29kZSB0aWxlCgBGYWlsZWQgdG8gZGVjb2RlIHRoZSBjb2Rlc3RyZWFtIGluIHRoZSBKUDIgZmlsZQoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIHdpdGggaW5kaXggc2h1ZmZsZQoAQ2Fubm90IGFsbG9jYXRlIFRpZXIgMSBoYW5kbGUKAE5vIGRlY29kZWQgYXJlYSBwYXJhbWV0ZXJzLCBzZXQgdGhlIGRlY29kZWQgYXJlYSB0byB0aGUgd2hvbGUgaW1hZ2UKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGNyZWF0ZSBUYWctdHJlZQoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVpbml0aWFsaXplIHRoZSB0YWcgdHJlZQoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LCBJbnZhbGlkIHRyYW5zZm9ybWF0aW9uIGZvdW5kCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQuIFVuc3VwcG9ydGVkIE1peGVkIEhUIGNvZGUtYmxvY2sgc3R5bGUgZm91bmQKAFRpbGUgWSBjb29yZGluYXRlcyBhcmUgbm90IHN1cHBvcnRlZAoAVGlsZSBYIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9ydGVkCgBJbWFnZSBjb29yZGluYXRlcyBhYm92ZSBJTlRfTUFYIGFyZSBub3Qgc3VwcG9ydGVkCgBKUEVHMjAwMCBIZWFkZXIgYm94IG5vdCByZWFkIHlldCwgJyVjJWMlYyVjJyBib3ggd2lsbCBiZSBpZ25vcmVkCgBvcGpfajJrX21lcmdlX3BwdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFNPVCBtYXJrZXIuIFRpbGUgaW5kZXggYWxsb2NhdGlvbiBmYWlsZWQKAElnbm9yaW5nIGloZHIgYm94LiBGaXJzdCBpaGRyIGJveCBhbHJlYWR5IHJlYWQKAFpwcHQgJXUgYWxyZWFkeSByZWFkCgBacHBtICV1IGFscmVhZHkgcmVhZAoAUFRFUk0gY2hlY2sgZmFpbHVyZTogJWQgc3ludGhldGl6ZWQgMHhGRiBtYXJrZXJzIHJlYWQKAAkJCSBjYmxrdz0yXiVkCgAJCQkgY2Jsa2g9Ml4lZAoACQkJIHFudHN0eT0lZAoAJXMgZHg9JWQsIGR5PSVkCgAJCQkgcm9pc2hpZnQ9JWQKAAkJCSBudW1nYml0cz0lZAoACQkgbnVtbGF5ZXJzPSVkCgAlcyBudW1jb21wcz0lZAoAb3BqX2pwMl9hcHBseV9jZGVmOiBhY249JWQsIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGNuPSVkLCBudW1jb21wcz0lZAoACQkJIG51bXJlc29sdXRpb25zPSVkCgAJCSB0eXBlPSUjeCwgcG9zPSVsbGksIGxlbj0lZAoAJXMgc2duZD0lZAoACQkJIHFtZmJpZD0lZAoAJXMgcHJlYz0lZAoACQkgbmIgb2YgdGlsZS1wYXJ0IGluIHRpbGUgWyVkXT0lZAoAJXMgeDE9JWQsIHkxPSVkCgAlcyB4MD0lZCwgeTA9JWQKAEZhaWxlZCB0byBkZWNvZGUgdGlsZSAlZC8lZAoAU2V0dGluZyBkZWNvZGluZyBhcmVhIHRvICVkLCVkLCVkLCVkCgBGYWlsZWQgdG8gZGVjb2RlIGNvbXBvbmVudCAlZAoASW52YWxpZCB2YWx1ZSBmb3IgbnVtcmVzb2x1dGlvbnMgOiAlZCwgbWF4IHZhbHVlIGlzIHNldCBpbiBvcGVuanBlZy5oIGF0ICVkCgBJbnZhbGlkIGNvbXBvbmVudCBudW1iZXI6ICVkLCByZWdhcmRpbmcgdGhlIG51bWJlciBvZiBjb21wb25lbnRzICVkCgBUb28gbWFueSBQT0NzICVkCgBJbnZhbGlkIHRpbGUgbnVtYmVyICVkCgBJbnZhbGlkIHRpbGUgcGFydCBpbmRleCBmb3IgdGlsZSBudW1iZXIgJWQuIEdvdCAlZCwgZXhwZWN0ZWQgJWQKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbnVtYmVyIG9mIGNvbXBvbmVudCBpcyBpbGxlZ2FsIC0+ICVkCgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgY2llbGFiCgBDYW5ub3QgYWxsb2NhdGUgY2Jsay0+ZGVjb2RlZF9kYXRhCgBGYWlsZWQgdG8gbWVyZ2UgUFBUIGRhdGEKAEZhaWxlZCB0byBtZXJnZSBQUE0gZGF0YQoASW52YWxpZCBudW1iZXIgb2YgbGF5ZXJzIGluIENPRCBtYXJrZXIgOiAlZCBub3QgaW4gcmFuZ2UgWzEtNjU1MzVdCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU3RyZWFtIGRvZXMgbm90IGVuZCB3aXRoIEVPQwoAQ2Fubm90IGhhbmRsZSBib3ggc2l6ZXMgaGlnaGVyIHRoYW4gMl4zMgoAb3BqX3BpX25leHRfbHJjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcmxjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfY3BybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcGNybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcnBjbCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3QxX2RlY29kZV9jYmxrKCk6IHVuc3VwcG9ydGVkIGJwbm9fcGx1c19vbmUgPSAlZCA+PSAzMQoARmFpbGVkIHRvIGRlY29kZSB0aWxlIDEvMQoASW5zdWZmaWNpZW50IGRhdGEgZm9yIENNQVAgYm94LgoATmVlZCB0byByZWFkIGEgUENMUiBib3ggYmVmb3JlIHRoZSBDTUFQIGJveC4KAEluc3VmZmljaWVudCBkYXRhIGZvciBDREVGIGJveC4KAE51bWJlciBvZiBjaGFubmVsIGRlc2NyaXB0aW9uIGlzIGVxdWFsIHRvIHplcm8gaW4gQ0RFRiBib3guCgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveDogbm8gJ2loZHInIGJveC4KAE5vbiBjb25mb3JtYW50IGNvZGVzdHJlYW0gVFBzb3Q9PVROc290LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IGJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAQm94IGxlbmd0aCBpcyBpbmNvbnNpc3RlbnQuCgBSZXNvbHV0aW9uIGZhY3RvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBpbiB0aGUgY29tcG9uZW50LgoAQ29tcG9uZW50IG1hcHBpbmcgc2VlbXMgd3JvbmcuIFRyeWluZyB0byBjb3JyZWN0LgoASW5jb21wbGV0ZSBjaGFubmVsIGRlZmluaXRpb25zLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW52YWxpZCBjb2RlYmxvY2sgbGVuZ3RoIHZhbHVlcy4KAFdlIGRvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiAzIGNvZGluZyBwYXNzZXMgaW4gYW4gSFQgY29kZWJsb2NrOyBUaGlzIGNvZGVibG9ja3MgaGFzICVkIHBhc3Nlcy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFRoZXJlIGFyZSAlZCB6ZXJvIGJpdHBsYW5lcyBpbiAlZCBiaXRwbGFuZXMuCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgdHJhbnNmb3JtYXRpb24gc3RhZ2VzLgoAVW5rbm93biBtYXJrZXIgaGFzIGJlZW4gZGV0ZWN0ZWQgYW5kIGdlbmVyYXRlZCBlcnJvci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0X2RlY29kZWRfY29tcG9uZW50cyBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0dXBfZGVjb2RlciBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfcmVhZF9oZWFkZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBUaWxlcyBkb24ndCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uIFNraXAgdGhlIE1DVCBzdGVwLgoATnVtYmVyIG9mIGNvbXBvbmVudHMgKCVkKSBpcyBpbmNvbnNpc3RlbnQgd2l0aCBhIE1DVC4gU2tpcCB0aGUgTUNUIHN0ZXAuCgBKUDIgYm94IHdoaWNoIGFyZSBhZnRlciB0aGUgY29kZXN0cmVhbSB3aWxsIG5vdCBiZSByZWFkIGJ5IHRoaXMgZnVuY3Rpb24uCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBXaGVuIHRoZSBudW1iZXIgb2YgemVybyBwbGFuZXMgYml0cGxhbmVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYml0cGxhbmVzLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3MgbWFrZXMgc2Vuc2UsIGJ1dCB3ZSBoYXZlICVkIHBhc3NlcyBpbiB0aGlzIGNvZGVibG9jay4gVGhlcmVmb3JlLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3Mgd2lsbCBiZSBkZWNvZGVkLiBUaGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgZGlzcGxheWVkIGFnYWluLgoASW1hZ2UgaGFzIGxlc3MgY29tcG9uZW50cyB0aGFuIGNvZGVzdHJlYW0uCgBOZWVkIHRvIGRlY29kZSB0aGUgbWFpbiBoZWFkZXIgYmVmb3JlIGJlZ2luIHRvIGRlY29kZSB0aGUgcmVtYWluaW5nIGNvZGVzdHJlYW0uCgBQc290IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbGUtcGFydCBpcyBlcXVhbCB0byB6ZXJvLCB3ZSBhc3N1bWluZyBpdCBpcyB0aGUgbGFzdCB0aWxlLXBhcnQgb2YgdGhlIGNvZGVzdHJlYW0uCgBBIG1hbGZvcm1lZCBjb2RlYmxvY2sgdGhhdCBoYXMgbW9yZSB0aGFuIG9uZSBjb2RpbmcgcGFzcywgYnV0IHplcm8gbGVuZ3RoIGZvciAybmQgYW5kIHBvdGVudGlhbGx5IHRoZSAzcmQgcGFzcyBpbiBhbiBIVCBjb2RlYmxvY2suCgAJCQkgdGlsZS1wYXJ0WyVkXTogc3Rhcl9wb3M9JWxsaSwgZW5kX2hlYWRlcj0lbGxpLCBlbmRfcG9zPSVsbGkuCgBUaWxlICV1IGhhcyBUUHNvdCA9PSAwIGFuZCBUTnNvdCA9PSAwLCBidXQgbm8gb3RoZXIgdGlsZS1wYXJ0cyB3ZXJlIGZvdW5kLiBFT0MgaXMgYWxzbyBtaXNzaW5nLgoAQ29tcG9uZW50ICVkIGRvZXNuJ3QgaGF2ZSBhIG1hcHBpbmcuCgBBIGNvbmZvcm1pbmcgSlAyIHJlYWRlciBzaGFsbCBpZ25vcmUgYWxsIENvbG91ciBTcGVjaWZpY2F0aW9uIGJveGVzIGFmdGVyIHRoZSBmaXJzdCwgc28gd2UgaWdub3JlIHRoaXMgb25lLgoAVGhlIHNpZ25hdHVyZSBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlICBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlIGZ0eXAgYm94IG11c3QgYmUgdGhlIHNlY29uZCBib3ggaW4gdGhlIGZpbGUuCgBGYWlsZWQgdG8gZGVjb2RlLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW5jb3JyZWN0IE1FTCBzZWdtZW50IHNlcXVlbmNlLgoAQ29tcG9uZW50ICVkIGlzIG1hcHBlZCB0d2ljZS4KAE9ubHkgb25lIENNQVAgYm94IGlzIGFsbG93ZWQuCgBhcHBseV9jb2xvcl90cmFuc2Zvcm1zID0gT1BKX1RSVUUgaXMgbm90IHN1cHBvcnRlZC4KAFdlIG5lZWQgYW4gaW1hZ2UgcHJldmlvdXNseSBjcmVhdGVkLgoASUhEUiBib3hfbWlzc2luZy4gUmVxdWlyZWQuCgBKUDJIIGJveCBtaXNzaW5nLiBSZXF1aXJlZC4KAE5vdCBzdXJlIGhvdyB0aGF0IGhhcHBlbmVkLgoATWFpbiBoZWFkZXIgaGFzIGJlZW4gY29ycmVjdGx5IGRlY29kZWQuCgBUaWxlICVkLyVkIGhhcyBiZWVuIGRlY29kZWQuCgBIZWFkZXIgb2YgdGlsZSAlZCAvICVkIGhhcyBiZWVuIHJlYWQuCgBFbXB0eSBTT1QgbWFya2VyIGRldGVjdGVkOiBQc290PSVkLgoARGlyZWN0IHVzZSBhdCAjJWQgaG93ZXZlciBwY29sPSVkLgoASW1wbGVtZW50YXRpb24gbGltaXRhdGlvbjogZm9yIHBhbGV0dGUgbWFwcGluZywgcGNvbFslZF0gc2hvdWxkIGJlIGVxdWFsIHRvICVkLCBidXQgaXMgZXF1YWwgdG8gJWQuCgBJbnZhbGlkIGNvbXBvbmVudC9wYWxldHRlIGluZGV4IGZvciBkaXJlY3QgbWFwcGluZyAlZC4KAEludmFsaWQgdmFsdWUgZm9yIGNtYXBbJWRdLm10eXAgPSAlZC4KAFBzb3QgdmFsdWUgaXMgbm90IGNvcnJlY3QgcmVnYXJkcyB0byB0aGUgSlBFRzIwMDAgbm9ybTogJWQuCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBWTEMgY29kZSBwcm9kdWNlcyBzaWduaWZpY2FudCBzYW1wbGVzIG91dHNpZGUgdGhlIGNvZGVibG9jayBhcmVhLgoAVW5leHBlY3RlZCBPT00uCgAzMiBiaXRzIGFyZSBub3QgZW5vdWdoIHRvIGRlY29kZSB0aGlzIGNvZGVibG9jaywgc2luY2UgdGhlIG51bWJlciBvZiBiaXRwbGFuZSwgJWQsIGlzIGxhcmdlciB0aGFuIDMwLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgc2hvdWxkIGJlID4gMC4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgc2hvdWxkIGJlID4gMC4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgc2hvdWxkIGJlID49IDAuCgBMZWZ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MD0lZCkgc2hvdWxkIGJlID49IDAuCgBFcnJvciByZWFkaW5nIFBQVCBtYXJrZXI6IHBhY2tldCBoZWFkZXIgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZm91bmQgaW4gdGhlIG1haW4gaGVhZGVyIChQUE0gbWFya2VyKS4KAFN0YXJ0IHRvIHJlYWQgajJrIG1haW4gaGVhZGVyICglbGxkKS4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFlzaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWHNpej0lZCkuCgBMZWZ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWHNpej0lZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFlPc2l6PSVkKS4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWE9zaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAFNpemUgeCBvZiB0aGUgZGVjb2RlZCBjb21wb25lbnQgaW1hZ2UgaXMgaW5jb3JyZWN0IChjb21wWyVkXS53PSVkKS4KAFNpemUgeSBvZiB0aGUgZGVjb2RlZCBjb21wb25lbnQgaW1hZ2UgaXMgaW5jb3JyZWN0IChjb21wWyVkXS5oPSVkKS4KAFRpbGUgcmVhZCwgZGVjb2RlZCBhbmQgdXBkYXRlZCBpcyBub3QgdGhlIGRlc2lyZWQgb25lICglZCB2cyAlZCkuCgBJbnZhbGlkIGNvbXBvbmVudCBpbmRleCAlZCAoPj0gJWQpLgoAb3BqX3JlYWRfaGVhZGVyKCkgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgb3BqX3NldF9kZWNvZGVkX2NvbXBvbmVudHMoKS4KAE1lbW9yeSBhbGxvY2F0aW9uIGZhaWx1cmUgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbWFnZS0+Y29tcHNbJWRdLmRhdGEgPT0gTlVMTCBpbiBvcGpfanAyX2FwcGx5X3BjbHIoKS4KAGludmFsaWQgYm94IHNpemUgJWQgKCV4KQoARmFpbCB0byByZWFkIHRoZSBjdXJyZW50IG1hcmtlciBzZWdtZW50ICglI3gpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IElIRFIgdygldSkgaCgldSkgdnMuIFNJWiB3KCV1KSBoKCV1KQoARXJyb3IgcmVhZGluZyBDT0MgbWFya2VyIChiYWQgbnVtYmVyIG9mIGNvbXBvbmVudHMpCgBJbnZhbGlkIG51bWJlciBvZiB0aWxlcyA6ICV1IHggJXUgKG1heGltdW0gZml4ZWQgYnkganBlZzIwMDAgbm9ybSBpcyA2NTUzNSB0aWxlcykKAEludmFsaWQgbnVtYmVyIG9mIGNvbXBvbmVudHMgKGloZHIpCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUgaW1hZ2UgaGVhZGVyIChpaGRyKQoAV3JvbmcgdmFsdWVzIGZvcjogdyglZCkgaCglZCkgbnVtY29tcHMoJWQpIChpaGRyKQoASW52YWxpZCB2YWx1ZXMgZm9yIGNvbXAgPSAlZCA6IGR4PSV1IGR5PSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAyNTUgYWNjb3JkaW5nIHRvIHRoZSBKUEVHMjAwMCBub3JtKQoAQmFkIGltYWdlIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBCYWQgQlBDQyBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbmVnYXRpdmUgb3IgemVybyBpbWFnZSBzaXplICglbGxkIHggJWxsZCkKAHNraXA6IHNlZ21lbnQgdG9vIGxvbmcgKCVkKSB3aXRoIG1heCAoJWQpIGZvciBjb2RlYmxvY2sgJWQgKHA9JWQsIGI9JWQsIHI9JWQsIGM9JWQpCgByZWFkOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoARGVzcGl0ZSBKUDIgQlBDIT0yNTUsIHByZWNpc2lvbiBhbmQvb3Igc2duZCB2YWx1ZXMgZm9yIGNvbXBbJWRdIGlzIGRpZmZlcmVudCB0aGFuIGNvbXBbMF06CiAgICAgICAgWzBdIHByZWMoJWQpIHNnbmQoJWQpIFslZF0gcHJlYyglZCkgc2duZCglZCkKAGJhZCBjb21wb25lbnQgbnVtYmVyIGluIFJHTiAoJWQgd2hlbiB0aGVyZSBhcmUgb25seSAlZCkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbnVtYmVyIG9mIGNvbXBvbmVudCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCAlZCB2cyAlZCkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaW52YWxpZCB0aWxlIHNpemUgKHRkeDogJWQsIHRkeTogJWQpCgBCYWQgQ09MUiBoZWFkZXIgYm94IChiYWQgc2l6ZTogJWQpCgBCYWQgQ09MUiBoZWFkZXIgYm94IChDSUVMYWIsIGJhZCBzaXplOiAlZCkKAFBURVJNIGNoZWNrIGZhaWx1cmU6ICVkIHJlbWFpbmluZyBieXRlcyBpbiBjb2RlIGJsb2NrICglZCB1c2VkIC8gJWQpCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBPbmUgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaXMgbm90IG1ldDogMiA8PSBTY3VwIDw9IG1pbihMY3VwLCA0MDc5KQoASW52YWxpZCB2YWx1ZXMgZm9yIGNvbXAgPSAlZCA6IHByZWM9JXUgKHNob3VsZCBiZSBiZXR3ZWVuIDEgYW5kIDM4IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybS4gT3BlbkpwZWcgb25seSBzdXBwb3J0cyB1cCB0byAzMSkKAEludmFsaWQgYml0IG51bWJlciAlZCBpbiBvcGpfdDJfcmVhZF9wYWNrZXRfaGVhZGVyKCkKAFN0cmVhbSBlcnJvciEKAEVycm9yIG9uIHdyaXRpbmcgc3RyZWFtIQoAU3RyZWFtIHJlYWNoZWQgaXRzIGVuZCAhCgBFeHBlY3RlZCBhIFNPQyBtYXJrZXIgCgBJbnZhbGlkIGJveCBzaXplICVkIGZvciBib3ggJyVjJWMlYyVjJy4gTmVlZCAlZCBieXRlcywgJWQgYnl0ZXMgcmVtYWluaW5nIAoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gRGVjb2RpbmcgdGhpcyBjb2RlYmxvY2sgaXMgc3RvcHBlZC4gVV9xIGlzIGxhcmdlciB0aGFuIHplcm8gYml0cGxhbmVzICsgMSAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpc2xhcmdlciB0aGFuIGJpdHBsYW5lcyArIDEgCgBDT0xSIEJPWCBtZXRoIHZhbHVlIGlzIG5vdCBhIHJlZ3VsYXIgdmFsdWUgKCVkKSwgc28gd2Ugd2lsbCBpZ25vcmUgdGhlIGVudGlyZSBDb2xvdXIgU3BlY2lmaWNhdGlvbiBib3guIAoAV2hpbGUgcmVhZGluZyBDQ1BfUU5UU1RZIGVsZW1lbnQgaW5zaWRlIFFDRCBvciBRQ0MgbWFya2VyIHNlZ21lbnQsIG51bWJlciBvZiBzdWJiYW5kcyAoJWQpIGlzIGdyZWF0ZXIgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpLiBTbyB3ZSBsaW1pdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHN0b3JlZCB0byBPUEpfSjJLX01BWEJBTkRTICglZCkgYW5kIHNraXAgdGhlIHJlc3QuIAoASlAyIElIRFIgYm94OiBjb21wcmVzc2lvbiB0eXBlIGluZGljYXRlIHRoYXQgdGhlIGZpbGUgaXMgbm90IGEgY29uZm9ybWluZyBKUDIgZmlsZSAoJWQpIAoAVGlsZSBpbmRleCBwcm92aWRlZCBieSB0aGUgdXNlciBpcyBpbmNvcnJlY3QgJWQgKG1heCA9ICVkKSAKAEVycm9yIGRlY29kaW5nIGNvbXBvbmVudCAlZC4KVGhlIG51bWJlciBvZiByZXNvbHV0aW9ucyB0byByZW1vdmUgKCVkKSBpcyBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIG51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4E8AANBPAAABVgAAAQAAAPBPAADATwAAAVQAAAAAAAAAUAAAwFAAAAFUAAABAAAAEFAAANBQAAABSAAAAAAAACBQAADAUAAAAUgAAAEAAAAwUAAA0FAAAAE4AAAAAAAAQFAAAMBQAAABOAAAAQAAAFBQAADQUAAAATAAAAAAAABgUAAAIFEAAAEwAAABAAAAcFAAADBRAAABJAAAAAAAAIBQAABAUQAAASQAAAEAAACQUAAAUFEAAAEcAAAAAAAAoFAAAIBRAAABHAAAAQAAALBQAACQUQAAARYAAAAAAACgUgAAoFEAAAEWAAABAAAAsFIAALBRAAABVgAAAAAAAOBQAADQUAAAAVYAAAEAAADwUAAAwFAAAAFUAAAAAAAAAFEAAMBQAAABVAAAAQAAABBRAADQUAAAAVEAAAAAAAAgUQAA4FAAAAFRAAABAAAAMFEAAPBQAAABSAAAAAAAAEBRAAAAUQAAAUgAAAEAAABQUQAAEFEAAAE4AAAAAAAAYFEAACBRAAABOAAAAQAAAHBRAAAwUQAAATQAAAAAAACAUQAAQFEAAAE0AAABAAAAkFEAAFBRAAABMAAAAAAAAKBRAABgUQAAATAAAAEAAACwUQAAcFEAAAEoAAAAAAAAwFEAAGBRAAABKAAAAQAAANBRAABwUQAAASQAAAAAAADgUQAAgFEAAAEkAAABAAAA8FEAAJBRAAABIgAAAAAAAABSAACgUQAAASIAAAEAAAAQUgAAsFEAAAEcAAAAAAAAIFIAAMBRAAABHAAAAQAAADBSAADQUQAAARgAAAAAAABAUgAA4FEAAAEYAAABAAAAUFIAAPBRAAABFgAAAAAAAGBSAAAAUgAAARYAAAEAAABwUgAAEFIAAAEUAAAAAAAAgFIAACBSAAABFAAAAQAAAJBSAAAwUgAAARIAAAAAAACgUgAAQFIAAAESAAABAAAAsFIAAFBSAAABEQAAAAAAAMBSAABgUgAAAREAAAEAAADQUgAAcFIAAMEKAAAAAAAA4FIAAIBSAADBCgAAAQAAAPBSAACQUgAAwQkAAAAAAAAAUwAAoFIAAMEJAAABAAAAEFMAALBSAAChCAAAAAAAACBTAADAUgAAoQgAAAEAAAAwUwAA0FIAACEFAAAAAAAAQFMAAOBSAAAhBQAAAQAAAFBTAADwUgAAQQQAAAAAAABgUwAAAFMAAEEEAAABAAAAcFMAABBTAAChAgAAAAAAAIBTAAAgUwAAoQIAAAEAAACQUwAAMFMAACECAAAAAAAAoFMAAEBTAAAhAgAAAQAAALBTAABQUwAAQQEAAAAAAADAUwAAYFMAAEEBAAABAAAA0FMAAHBTAAARAQAAAAAAAOBTAACAUwAAEQEAAAEAAADwUwAAkFMAAIUAAAAAAAAAAFQAAKBTAACFAAAAAQAAABBUAACwUwAASQAAAAAAAAAgVAAAwFMAAEkAAAABAAAAMFQAANBTAAAlAAAAAAAAAEBUAADgUwAAJQAAAAEAAABQVAAA8FMAABUAAAAAAAAAYFQAAABUAAAVAAAAAQAAAHBUAAAQVAAACQAAAAAAAACAVAAAIFQAAAkAAAABAAAAkFQAADBUAAAFAAAAAAAAAKBUAABAVAAABQAAAAEAAACwVAAAUFQAAAEAAAAAAAAAoFQAAGBUAAABAAAAAQAAALBUAABwVAAAAVYAAAAAAADAVAAAwFQAAAFWAAABAAAA0FQAANBUAAAAAQMDAQIDAwUGBwcGBgcHAAEDAwECAwMFBgcHBgYHBwUGBwcGBgcHCAgICAgICAgFBgcHBgYHBwgICAgICAgIAQIDAwICAwMGBgcHBgYHBwECAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAQIDAwICAwMGBgcHBgYHBwECAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAICAwMCAgMDBgYHBwYGBwcCAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAABBQYBAgYGAwMHBwMDBwcAAQUGAQIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcBAgYGAgIGBgMDBwcDAwcHAQIGBgICBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHBQYICAYGCAgHBwgIBwcICAUGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgBAgYGAgIGBgMDBwcDAwcHAQIGBgICBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAgIGBgICBgYDAwcHAwMHBwICBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwYGCAgGBggIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAwEEAwYEBwEEAgUEBwUHAAMBBAMGBAcBBAIFBAcFBwEEAgUEBwUHAgUCBQUHBQcBBAIFBAcFBwIFAgUFBwUHAwYEBwYIBwgEBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAEEAgUEBwUHAgUCBQUHBQcBBAIFBAcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcEBwUHBwgHCAUHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIAwYEBwYIBwgEBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAYIBwgICAgIBwgHCAgICAgGCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgEBwUHBwgHCAUHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAkJCgoJCQoKDAwNCwwMDQsJCQoKCQkKCgwMCw0MDAsNDAwNDQwMCwsMCQ0KCQwKCwwMCwsMDA0NDAkLCgkMCg0JCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCgoKCgoKCgoNCw0LDQsNCwoKCQkKCgkJDQsMDA0LDAwNDQ0NCwsLCw0KDQoKCwoLDQ0MDAsLDAwNCgwJCgsJDAoKCQkKCgkJCw0MDAsNDAwKCgoKCgoKCgsNCw0LDQsNCwsMDA0NDAwLCgwJCg0JDAsLCwsNDQ0NCwoLCgoNCg0AQem7AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBBqbwBCzcBAAEAAQABAAABAQAAAQEAAQABAAEAAQAAAAABAQEBAAAAAAABAAEAAAAAAQEBAQAAAAEAAQEBAEHpvAELBwEAAQABAAEAQfm8AQuVAgEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAAAAAEAAQEBAAABAQAAAAEAAQABAAEBAQEBAQEBAQABAAEAAQABAAAAAAEBAQEAAQAAAQEAAQAAAAABAQEBAAEAAQEBAQECAAAABAAAAAQAAAAIAAAAkP8AAAwAAAAYAAAAUv8AABQAAAAZAAAAU/8AABQAAAAaAAAAXv8AABQAAAAbAAAAXP8AABQAAAAcAAAAXf8AABQAAAAdAAAAX/8AABQAAAAeAAAAUf8AAAIAAAAfAAAAVf8AAAQAAAAgAAAAV/8AAAQAAAAhAAAAWP8AABAAAAAiAAAAYP8AAAQAAAAjAAAAYf8AABAAAAAkAAAAkf8AQZi/AQtlY/8AAAQAAAAlAAAAZP8AABQAAAAmAAAAdP8AABQAAAAnAAAAeP8AAAQAAAAoAAAAUP8AAAQAAAApAAAAWf8AAAQAAAAqAAAAdf8AABQAAAArAAAAd/8AABQAAAAsAAAAAAAAABQAQZDAAQs1LQAAAC4AAAAvAAAAMAAAADEAAAAyAAAAMwAAADQAAAAgIFBqNgAAAHB5dGY3AAAAaDJwajgAQdDAAQsycmRoaTkAAABybG9jOgAAAGNjcGI7AAAAcmxjcDwAAABwYW1jPQAAAGZlZGM+AAAAeGIAQZDBAQtBGQALABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZAAoKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRkAQeHBAQshDgAAAAAAAAAAGQALDRkZGQANAAACAAkOAAAACQAOAAAOAEGbwgELAQwAQafCAQsVEwAAAAATAAAAAAkMAAAAAAAMAAAMAEHVwgELARAAQeHCAQsVDwAAAAQPAAAAAAkQAAAAAAAQAAAQAEGPwwELARIAQZvDAQseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHSwwELDhoAAAAaGhoAAAAAAAAJAEGDxAELARQAQY/EAQsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEG9xAELARYAQcnEAQsnFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVGAEHxxAELCGwBAAAAAAAFAEGExQELAWkAQZzFAQsOagAAAGsAAAD4ZwAAAAQAQbTFAQsBAQBBxMUBCwX/////Cg==";
      function instantiateSync(e4, t4) {
        var i4, a4 = function getBinarySync(e5) {
          if (e5 == u3 && g3)
            return new Uint8Array(g3);
          var t5 = tryParseAsDataURI(e5);
          if (t5)
            return t5;
          if (s3)
            return s3(e5);
          throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
        }(e4);
        i4 = new WebAssembly.Module(a4);
        return [new WebAssembly.Instance(i4, t4), i4];
      }
      var D3, callRuntimeCallbacks = (e4) => {
        for (; e4.length > 0; )
          e4.shift()(a3);
      }, F3 = (a3.noExitRuntime, (e4) => {
        var t4 = (e4 - c3.buffer.byteLength + 65535) / 65536;
        try {
          c3.grow(t4);
          updateMemoryViews();
          return 1;
        } catch (e5) {
        }
      }), S3 = {}, getEnvStrings = () => {
        if (!getEnvStrings.strings) {
          var e4 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: n3 || "./this.program" };
          for (var t4 in S3)
            void 0 === S3[t4] ? delete e4[t4] : e4[t4] = S3[t4];
          var i4 = [];
          for (var t4 in e4)
            i4.push(`${t4}=${e4[t4]}`);
          getEnvStrings.strings = i4;
        }
        return getEnvStrings.strings;
      }, k3 = [null, [], []], N3 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, UTF8ArrayToString = (e4, t4, i4) => {
        for (var a4 = t4 + i4, s4 = t4; e4[s4] && !(s4 >= a4); )
          ++s4;
        if (s4 - t4 > 16 && e4.buffer && N3)
          return N3.decode(e4.subarray(t4, s4));
        for (var r4 = ""; t4 < s4; ) {
          var n4 = e4[t4++];
          if (128 & n4) {
            var o4 = 63 & e4[t4++];
            if (192 != (224 & n4)) {
              var g4 = 63 & e4[t4++];
              if ((n4 = 224 == (240 & n4) ? (15 & n4) << 12 | o4 << 6 | g4 : (7 & n4) << 18 | o4 << 12 | g4 << 6 | 63 & e4[t4++]) < 65536)
                r4 += String.fromCharCode(n4);
              else {
                var c4 = n4 - 65536;
                r4 += String.fromCharCode(55296 | c4 >> 10, 56320 | 1023 & c4);
              }
            } else
              r4 += String.fromCharCode((31 & n4) << 6 | o4);
          } else
            r4 += String.fromCharCode(n4);
        }
        return r4;
      }, printChar = (e4, t4) => {
        var i4 = k3[e4];
        if (0 === t4 || 10 === t4) {
          (1 === e4 ? Q3 : E3)(UTF8ArrayToString(i4, 0));
          i4.length = 0;
        } else
          i4.push(t4);
      }, UTF8ToString = (e4, t4) => e4 ? UTF8ArrayToString(h2, e4, t4) : "", R3 = { f: (e4, t4, i4) => h2.copyWithin(e4, t4, t4 + i4), b: (e4) => {
        var t4 = h2.length, i4 = 2147483648;
        if ((e4 >>>= 0) > i4)
          return false;
        for (var a4, s4, r4 = 1; r4 <= 4; r4 *= 2) {
          var n4 = t4 * (1 + 0.2 / r4);
          n4 = Math.min(n4, e4 + 100663296);
          var o4 = Math.min(i4, (a4 = Math.max(e4, n4)) + ((s4 = 65536) - a4 % s4) % s4);
          if (F3(o4))
            return true;
        }
        return false;
      }, c: (e4, t4) => {
        var i4 = 0;
        getEnvStrings().forEach((a4, s4) => {
          var r4 = t4 + i4;
          l3[e4 + 4 * s4 >> 2] = r4;
          ((e5, t5) => {
            for (var i5 = 0; i5 < e5.length; ++i5)
              C3[t5++] = e5.charCodeAt(i5);
            C3[t5] = 0;
          })(a4, r4);
          i4 += a4.length + 1;
        });
        return 0;
      }, d: (e4, t4) => {
        var i4 = getEnvStrings();
        l3[e4 >> 2] = i4.length;
        var a4 = 0;
        i4.forEach((e5) => a4 += e5.length + 1);
        l3[t4 >> 2] = a4;
        return 0;
      }, e: (e4, t4, i4, a4) => {
        for (var s4 = 0, r4 = 0; r4 < i4; r4++) {
          var n4 = l3[t4 >> 2], o4 = l3[t4 + 4 >> 2];
          t4 += 8;
          for (var g4 = 0; g4 < o4; g4++)
            printChar(e4, h2[n4 + g4]);
          s4 += o4;
        }
        l3[a4 >> 2] = s4;
        return 0;
      }, g: function _jsPrintWarning(e4) {
        const t4 = UTF8ToString(e4);
        (a3.warn || console.warn)(`OpenJPEG: ${t4}`);
      }, h: function _setImageData(e4, t4) {
        a3.imageData = new Uint8ClampedArray(a3.HEAPU8.subarray(e4, e4 + t4));
      }, a: function _storeErrorMessage(e4) {
        const t4 = UTF8ToString(e4);
        a3.errorMessages ? a3.errorMessages += "\n" + t4 : a3.errorMessages = t4;
      } }, G3 = function createWasm() {
        var e4 = { a: R3 };
        function receiveInstance(e5, t4) {
          G3 = e5.exports;
          c3 = G3.i;
          updateMemoryViews();
          !function addOnInit(e6) {
            f2.unshift(e6);
          }(G3.j);
          !function removeRunDependency(e6) {
            var _a3;
            m3--;
            (_a3 = a3.monitorRunDependencies) == null ? void 0 : _a3.call(a3, m3);
            if (0 == m3) {
              if (null !== y3) {
                clearInterval(y3);
                y3 = null;
              }
              if (w3) {
                var t5 = w3;
                w3 = null;
                t5();
              }
            }
          }();
          return G3;
        }
        !function addRunDependency(e5) {
          var _a3;
          m3++;
          (_a3 = a3.monitorRunDependencies) == null ? void 0 : _a3.call(a3, m3);
        }();
        if (a3.instantiateWasm)
          try {
            return a3.instantiateWasm(e4, receiveInstance);
          } catch (e5) {
            E3(`Module.instantiateWasm callback failed with error: ${e5}`);
            i3(e5);
          }
        return receiveInstance(instantiateSync(u3, e4)[0]);
      }();
      G3.j, a3._malloc = G3.k, a3._free = G3.l, a3._jp2_decode = G3.n, G3._emscripten_stack_restore, G3._emscripten_stack_alloc, G3.emscripten_stack_get_current;
      w3 = function runCaller() {
        D3 || run();
        D3 || (w3 = runCaller);
      };
      function run() {
        if (!(m3 > 0)) {
          !function preRun() {
            if (a3.preRun) {
              "function" == typeof a3.preRun && (a3.preRun = [a3.preRun]);
              for (; a3.preRun.length; )
                e4 = a3.preRun.shift(), d3.unshift(e4);
            }
            var e4;
            callRuntimeCallbacks(d3);
          }();
          if (!(m3 > 0))
            if (a3.setStatus) {
              a3.setStatus("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  a3.setStatus("");
                }, 1);
                doRun();
              }, 1);
            } else
              doRun();
        }
        function doRun() {
          if (!D3) {
            D3 = true;
            a3.calledRun = true;
            !function initRuntime() {
              callRuntimeCallbacks(f2);
            }();
            t3(a3);
            a3.onRuntimeInitialized && a3.onRuntimeInitialized();
            !function postRun() {
              if (a3.postRun) {
                "function" == typeof a3.postRun && (a3.postRun = [a3.postRun]);
                for (; a3.postRun.length; )
                  e4 = a3.postRun.shift(), p2.unshift(e4);
              }
              var e4;
              callRuntimeCallbacks(p2);
            }();
          }
        }
      }
      if (a3.preInit) {
        "function" == typeof a3.preInit && (a3.preInit = [a3.preInit]);
        for (; a3.preInit.length > 0; )
          a3.preInit.pop()();
      }
      run();
      return e3;
    });
    Ii = gi;
    JpxError = class extends rt {
      constructor(e3) {
        super(e3, "JpxError");
      }
    };
    JpxImage = class {
      static decode(e3, t3 = false) {
        __privateGet(this, _y) || __privateSet(this, _y, Ii({ warn }));
        const i3 = __privateGet(this, _y).decode(e3, t3);
        if ("string" == typeof i3)
          throw new JpxError(i3);
        return i3;
      }
      static cleanup() {
        __privateSet(this, _y, null);
      }
      static parseImageProperties(e3) {
        let t3 = e3.getByte();
        for (; t3 >= 0; ) {
          const i3 = t3;
          t3 = e3.getByte();
          if (65361 === (i3 << 8 | t3)) {
            e3.skip(4);
            const t4 = e3.getInt32() >>> 0, i4 = e3.getInt32() >>> 0, a3 = e3.getInt32() >>> 0, s3 = e3.getInt32() >>> 0;
            e3.skip(16);
            return { width: t4 - a3, height: i4 - s3, bitsPerComponent: 8, componentsCount: e3.getUint16() };
          }
        }
        throw new JpxError("No size marker found in JPX stream");
      }
    };
    _y = new WeakMap();
    __privateAdd(JpxImage, _y, null);
    JpxStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3);
        this.stream = e3;
        this.dict = e3.dict;
        this.maybeLength = t3;
        this.params = i3;
      }
      get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
      }
      ensureBuffer(e3) {
      }
      readBlock(e3) {
        if (!this.eof) {
          this.buffer = JpxImage.decode(this.bytes, e3);
          this.bufferLength = this.buffer.length;
          this.eof = true;
        }
      }
    };
    LZWStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3);
        this.str = e3;
        this.dict = e3.dict;
        this.cachedData = 0;
        this.bitsCached = 0;
        const a3 = 4096, s3 = { earlyChange: i3, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(a3), dictionaryLengths: new Uint16Array(a3), dictionaryPrevCodes: new Uint16Array(a3), currentSequence: new Uint8Array(a3), currentSequenceLength: 0 };
        for (let e4 = 0; e4 < 256; ++e4) {
          s3.dictionaryValues[e4] = e4;
          s3.dictionaryLengths[e4] = 1;
        }
        this.lzwState = s3;
      }
      readBits(e3) {
        let t3 = this.bitsCached, i3 = this.cachedData;
        for (; t3 < e3; ) {
          const e4 = this.str.getByte();
          if (-1 === e4) {
            this.eof = true;
            return null;
          }
          i3 = i3 << 8 | e4;
          t3 += 8;
        }
        this.bitsCached = t3 -= e3;
        this.cachedData = i3;
        this.lastCode = null;
        return i3 >>> t3 & (1 << e3) - 1;
      }
      readBlock() {
        let e3, t3, i3, a3 = 1024;
        const s3 = this.lzwState;
        if (!s3)
          return;
        const r3 = s3.earlyChange;
        let n3 = s3.nextCode;
        const o3 = s3.dictionaryValues, g3 = s3.dictionaryLengths, c3 = s3.dictionaryPrevCodes;
        let C3 = s3.codeLength, h2 = s3.prevCode;
        const l3 = s3.currentSequence;
        let Q3 = s3.currentSequenceLength, E3 = 0, u3 = this.bufferLength, d3 = this.ensureBuffer(this.bufferLength + a3);
        for (e3 = 0; e3 < 512; e3++) {
          const e4 = this.readBits(C3), s4 = Q3 > 0;
          if (e4 < 256) {
            l3[0] = e4;
            Q3 = 1;
          } else {
            if (!(e4 >= 258)) {
              if (256 === e4) {
                C3 = 9;
                n3 = 258;
                Q3 = 0;
                continue;
              }
              this.eof = true;
              delete this.lzwState;
              break;
            }
            if (e4 < n3) {
              Q3 = g3[e4];
              for (t3 = Q3 - 1, i3 = e4; t3 >= 0; t3--) {
                l3[t3] = o3[i3];
                i3 = c3[i3];
              }
            } else
              l3[Q3++] = l3[0];
          }
          if (s4) {
            c3[n3] = h2;
            g3[n3] = g3[h2] + 1;
            o3[n3] = l3[0];
            n3++;
            C3 = n3 + r3 & n3 + r3 - 1 ? C3 : 0 | Math.min(Math.log(n3 + r3) / 0.6931471805599453 + 1, 12);
          }
          h2 = e4;
          E3 += Q3;
          if (a3 < E3) {
            do {
              a3 += 512;
            } while (a3 < E3);
            d3 = this.ensureBuffer(this.bufferLength + a3);
          }
          for (t3 = 0; t3 < Q3; t3++)
            d3[u3++] = l3[t3];
        }
        s3.nextCode = n3;
        s3.codeLength = C3;
        s3.prevCode = h2;
        s3.currentSequenceLength = Q3;
        this.bufferLength = u3;
      }
    };
    PredictorStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3);
        if (!(i3 instanceof Dict))
          return e3;
        const a3 = this.predictor = i3.get("Predictor") || 1;
        if (a3 <= 1)
          return e3;
        if (2 !== a3 && (a3 < 10 || a3 > 15))
          throw new FormatError(`Unsupported predictor: ${a3}`);
        this.readBlock = 2 === a3 ? this.readBlockTiff : this.readBlockPng;
        this.str = e3;
        this.dict = e3.dict;
        const s3 = this.colors = i3.get("Colors") || 1, r3 = this.bits = i3.get("BPC", "BitsPerComponent") || 8, n3 = this.columns = i3.get("Columns") || 1;
        this.pixBytes = s3 * r3 + 7 >> 3;
        this.rowBytes = n3 * s3 * r3 + 7 >> 3;
        return this;
      }
      readBlockTiff() {
        const e3 = this.rowBytes, t3 = this.bufferLength, i3 = this.ensureBuffer(t3 + e3), a3 = this.bits, s3 = this.colors, r3 = this.str.getBytes(e3);
        this.eof = !r3.length;
        if (this.eof)
          return;
        let n3, o3 = 0, g3 = 0, c3 = 0, C3 = 0, h2 = t3;
        if (1 === a3 && 1 === s3)
          for (n3 = 0; n3 < e3; ++n3) {
            let e4 = r3[n3] ^ o3;
            e4 ^= e4 >> 1;
            e4 ^= e4 >> 2;
            e4 ^= e4 >> 4;
            o3 = (1 & e4) << 7;
            i3[h2++] = e4;
          }
        else if (8 === a3) {
          for (n3 = 0; n3 < s3; ++n3)
            i3[h2++] = r3[n3];
          for (; n3 < e3; ++n3) {
            i3[h2] = i3[h2 - s3] + r3[n3];
            h2++;
          }
        } else if (16 === a3) {
          const t4 = 2 * s3;
          for (n3 = 0; n3 < t4; ++n3)
            i3[h2++] = r3[n3];
          for (; n3 < e3; n3 += 2) {
            const e4 = ((255 & r3[n3]) << 8) + (255 & r3[n3 + 1]) + ((255 & i3[h2 - t4]) << 8) + (255 & i3[h2 - t4 + 1]);
            i3[h2++] = e4 >> 8 & 255;
            i3[h2++] = 255 & e4;
          }
        } else {
          const e4 = new Uint8Array(s3 + 1), h3 = (1 << a3) - 1;
          let l3 = 0, Q3 = t3;
          const E3 = this.columns;
          for (n3 = 0; n3 < E3; ++n3)
            for (let t4 = 0; t4 < s3; ++t4) {
              if (c3 < a3) {
                o3 = o3 << 8 | 255 & r3[l3++];
                c3 += 8;
              }
              e4[t4] = e4[t4] + (o3 >> c3 - a3) & h3;
              c3 -= a3;
              g3 = g3 << a3 | e4[t4];
              C3 += a3;
              if (C3 >= 8) {
                i3[Q3++] = g3 >> C3 - 8 & 255;
                C3 -= 8;
              }
            }
          C3 > 0 && (i3[Q3++] = (g3 << 8 - C3) + (o3 & (1 << 8 - C3) - 1));
        }
        this.bufferLength += e3;
      }
      readBlockPng() {
        const e3 = this.rowBytes, t3 = this.pixBytes, i3 = this.str.getByte(), a3 = this.str.getBytes(e3);
        this.eof = !a3.length;
        if (this.eof)
          return;
        const s3 = this.bufferLength, r3 = this.ensureBuffer(s3 + e3);
        let n3 = r3.subarray(s3 - e3, s3);
        0 === n3.length && (n3 = new Uint8Array(e3));
        let o3, g3, c3, C3 = s3;
        switch (i3) {
          case 0:
            for (o3 = 0; o3 < e3; ++o3)
              r3[C3++] = a3[o3];
            break;
          case 1:
            for (o3 = 0; o3 < t3; ++o3)
              r3[C3++] = a3[o3];
            for (; o3 < e3; ++o3) {
              r3[C3] = r3[C3 - t3] + a3[o3] & 255;
              C3++;
            }
            break;
          case 2:
            for (o3 = 0; o3 < e3; ++o3)
              r3[C3++] = n3[o3] + a3[o3] & 255;
            break;
          case 3:
            for (o3 = 0; o3 < t3; ++o3)
              r3[C3++] = (n3[o3] >> 1) + a3[o3];
            for (; o3 < e3; ++o3) {
              r3[C3] = (n3[o3] + r3[C3 - t3] >> 1) + a3[o3] & 255;
              C3++;
            }
            break;
          case 4:
            for (o3 = 0; o3 < t3; ++o3) {
              g3 = n3[o3];
              c3 = a3[o3];
              r3[C3++] = g3 + c3;
            }
            for (; o3 < e3; ++o3) {
              g3 = n3[o3];
              const e4 = n3[o3 - t3], i4 = r3[C3 - t3], s4 = i4 + g3 - e4;
              let h2 = s4 - i4;
              h2 < 0 && (h2 = -h2);
              let l3 = s4 - g3;
              l3 < 0 && (l3 = -l3);
              let Q3 = s4 - e4;
              Q3 < 0 && (Q3 = -Q3);
              c3 = a3[o3];
              r3[C3++] = h2 <= l3 && h2 <= Q3 ? i4 + c3 : l3 <= Q3 ? g3 + c3 : e4 + c3;
            }
            break;
          default:
            throw new FormatError(`Unsupported predictor: ${i3}`);
        }
        this.bufferLength += e3;
      }
    };
    RunLengthStream = class extends DecodeStream {
      constructor(e3, t3) {
        super(t3);
        this.str = e3;
        this.dict = e3.dict;
      }
      readBlock() {
        const e3 = this.str.getBytes(2);
        if (!e3 || e3.length < 2 || 128 === e3[0]) {
          this.eof = true;
          return;
        }
        let t3, i3 = this.bufferLength, a3 = e3[0];
        if (a3 < 128) {
          t3 = this.ensureBuffer(i3 + a3 + 1);
          t3[i3++] = e3[1];
          if (a3 > 0) {
            const e4 = this.str.getBytes(a3);
            t3.set(e4, i3);
            i3 += a3;
          }
        } else {
          a3 = 257 - a3;
          const s3 = e3[1];
          t3 = this.ensureBuffer(i3 + a3 + 1);
          for (let e4 = 0; e4 < a3; e4++)
            t3[i3++] = s3;
        }
        this.bufferLength = i3;
      }
    };
    Parser = class {
      constructor({ lexer: e3, xref: t3, allowStreams: i3 = false, recoveryMode: a3 = false }) {
        this.lexer = e3;
        this.xref = t3;
        this.allowStreams = i3;
        this.recoveryMode = a3;
        this.imageCache = /* @__PURE__ */ Object.create(null);
        this._imageId = 0;
        this.refill();
      }
      refill() {
        this.buf1 = this.lexer.getObj();
        this.buf2 = this.lexer.getObj();
      }
      shift() {
        if (this.buf2 instanceof Cmd && "ID" === this.buf2.cmd) {
          this.buf1 = this.buf2;
          this.buf2 = null;
        } else {
          this.buf1 = this.buf2;
          this.buf2 = this.lexer.getObj();
        }
      }
      tryShift() {
        try {
          this.shift();
          return true;
        } catch (e3) {
          if (e3 instanceof MissingDataException)
            throw e3;
          return false;
        }
      }
      getObj(e3 = null) {
        const t3 = this.buf1;
        this.shift();
        if (t3 instanceof Cmd)
          switch (t3.cmd) {
            case "BI":
              return this.makeInlineImage(e3);
            case "[":
              const i3 = [];
              for (; !isCmd(this.buf1, "]") && this.buf1 !== pt; )
                i3.push(this.getObj(e3));
              if (this.buf1 === pt) {
                if (this.recoveryMode)
                  return i3;
                throw new ParserEOFException("End of file inside array.");
              }
              this.shift();
              return i3;
            case "<<":
              const a3 = new Dict(this.xref);
              for (; !isCmd(this.buf1, ">>") && this.buf1 !== pt; ) {
                if (!(this.buf1 instanceof Name)) {
                  info("Malformed dictionary: key must be a name object");
                  this.shift();
                  continue;
                }
                const t4 = this.buf1.name;
                this.shift();
                if (this.buf1 === pt)
                  break;
                a3.set(t4, this.getObj(e3));
              }
              if (this.buf1 === pt) {
                if (this.recoveryMode)
                  return a3;
                throw new ParserEOFException("End of file inside dictionary.");
              }
              if (isCmd(this.buf2, "stream"))
                return this.allowStreams ? this.makeStream(a3, e3) : a3;
              this.shift();
              return a3;
            default:
              return t3;
          }
        if (Number.isInteger(t3)) {
          if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
            const e4 = Ref.get(t3, this.buf1);
            this.shift();
            this.shift();
            return e4;
          }
          return t3;
        }
        return "string" == typeof t3 && e3 ? e3.decryptString(t3) : t3;
      }
      findDefaultInlineStreamEnd(e3) {
        const { knownCommands: t3 } = this.lexer, i3 = e3.pos;
        let a3, s3, r3 = 0;
        for (; -1 !== (a3 = e3.getByte()); )
          if (0 === r3)
            r3 = 69 === a3 ? 1 : 0;
          else if (1 === r3)
            r3 = 73 === a3 ? 2 : 0;
          else if (32 === a3 || 10 === a3 || 13 === a3) {
            s3 = e3.pos;
            const i4 = e3.peekBytes(15), n4 = i4.length;
            if (0 === n4)
              break;
            for (let e4 = 0; e4 < n4; e4++) {
              a3 = i4[e4];
              if ((0 !== a3 || 0 === i4[e4 + 1]) && (10 !== a3 && 13 !== a3 && (a3 < 32 || a3 > 127))) {
                r3 = 0;
                break;
              }
            }
            if (2 !== r3)
              continue;
            if (!t3) {
              warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
              continue;
            }
            const o3 = new Lexer(new Stream(i4.slice()), t3);
            o3._hexStringWarn = () => {
            };
            let g3 = 0;
            for (; ; ) {
              const e4 = o3.getObj();
              if (e4 === pt) {
                r3 = 0;
                break;
              }
              if (e4 instanceof Cmd) {
                const i5 = t3[e4.cmd];
                if (!i5) {
                  r3 = 0;
                  break;
                }
                if (i5.variableArgs ? g3 <= i5.numArgs : g3 === i5.numArgs)
                  break;
                g3 = 0;
              } else
                g3++;
            }
            if (2 === r3)
              break;
          } else
            r3 = 0;
        if (-1 === a3) {
          warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
          if (s3) {
            warn('... trying to recover by using the last "EI" occurrence.');
            e3.skip(-(e3.pos - s3));
          }
        }
        let n3 = 4;
        e3.skip(-n3);
        a3 = e3.peekByte();
        e3.skip(n3);
        isWhiteSpace(a3) || n3--;
        return e3.pos - n3 - i3;
      }
      findDCTDecodeInlineStreamEnd(e3) {
        const t3 = e3.pos;
        let i3, a3, s3 = false;
        for (; -1 !== (i3 = e3.getByte()); )
          if (255 === i3) {
            switch (e3.getByte()) {
              case 0:
                break;
              case 255:
                e3.skip(-1);
                break;
              case 217:
                s3 = true;
                break;
              case 192:
              case 193:
              case 194:
              case 195:
              case 197:
              case 198:
              case 199:
              case 201:
              case 202:
              case 203:
              case 205:
              case 206:
              case 207:
              case 196:
              case 204:
              case 218:
              case 219:
              case 220:
              case 221:
              case 222:
              case 223:
              case 224:
              case 225:
              case 226:
              case 227:
              case 228:
              case 229:
              case 230:
              case 231:
              case 232:
              case 233:
              case 234:
              case 235:
              case 236:
              case 237:
              case 238:
              case 239:
              case 254:
                a3 = e3.getUint16();
                a3 > 2 ? e3.skip(a3 - 2) : e3.skip(-2);
            }
            if (s3)
              break;
          }
        const r3 = e3.pos - t3;
        if (-1 === i3) {
          warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
          e3.skip(-r3);
          return this.findDefaultInlineStreamEnd(e3);
        }
        this.inlineStreamSkipEI(e3);
        return r3;
      }
      findASCII85DecodeInlineStreamEnd(e3) {
        const t3 = e3.pos;
        let i3;
        for (; -1 !== (i3 = e3.getByte()); )
          if (126 === i3) {
            const t4 = e3.pos;
            i3 = e3.peekByte();
            for (; isWhiteSpace(i3); ) {
              e3.skip();
              i3 = e3.peekByte();
            }
            if (62 === i3) {
              e3.skip();
              break;
            }
            if (e3.pos > t4) {
              const t5 = e3.peekBytes(2);
              if (69 === t5[0] && 73 === t5[1])
                break;
            }
          }
        const a3 = e3.pos - t3;
        if (-1 === i3) {
          warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
          e3.skip(-a3);
          return this.findDefaultInlineStreamEnd(e3);
        }
        this.inlineStreamSkipEI(e3);
        return a3;
      }
      findASCIIHexDecodeInlineStreamEnd(e3) {
        const t3 = e3.pos;
        let i3;
        for (; -1 !== (i3 = e3.getByte()) && 62 !== i3; )
          ;
        const a3 = e3.pos - t3;
        if (-1 === i3) {
          warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
          e3.skip(-a3);
          return this.findDefaultInlineStreamEnd(e3);
        }
        this.inlineStreamSkipEI(e3);
        return a3;
      }
      inlineStreamSkipEI(e3) {
        let t3, i3 = 0;
        for (; -1 !== (t3 = e3.getByte()); )
          if (0 === i3)
            i3 = 69 === t3 ? 1 : 0;
          else if (1 === i3)
            i3 = 73 === t3 ? 2 : 0;
          else if (2 === i3)
            break;
      }
      makeInlineImage(e3) {
        const t3 = this.lexer, i3 = t3.stream, a3 = /* @__PURE__ */ Object.create(null);
        let s3;
        for (; !isCmd(this.buf1, "ID") && this.buf1 !== pt; ) {
          if (!(this.buf1 instanceof Name))
            throw new FormatError("Dictionary key must be a name object");
          const t4 = this.buf1.name;
          this.shift();
          if (this.buf1 === pt)
            break;
          a3[t4] = this.getObj(e3);
        }
        -1 !== t3.beginInlineImagePos && (s3 = i3.pos - t3.beginInlineImagePos);
        const r3 = this.xref.fetchIfRef(a3.F || a3.Filter);
        let n3;
        if (r3 instanceof Name)
          n3 = r3.name;
        else if (Array.isArray(r3)) {
          const e4 = this.xref.fetchIfRef(r3[0]);
          e4 instanceof Name && (n3 = e4.name);
        }
        const o3 = i3.pos;
        let g3, c3;
        switch (n3) {
          case "DCT":
          case "DCTDecode":
            g3 = this.findDCTDecodeInlineStreamEnd(i3);
            break;
          case "A85":
          case "ASCII85Decode":
            g3 = this.findASCII85DecodeInlineStreamEnd(i3);
            break;
          case "AHx":
          case "ASCIIHexDecode":
            g3 = this.findASCIIHexDecodeInlineStreamEnd(i3);
            break;
          default:
            g3 = this.findDefaultInlineStreamEnd(i3);
        }
        if (g3 < 1e3 && s3 > 0) {
          const e4 = i3.pos;
          i3.pos = t3.beginInlineImagePos;
          c3 = function getInlineImageCacheKey(e5) {
            const t4 = [], i4 = e5.length;
            let a5 = 0;
            for (; a5 < i4 - 1; )
              t4.push(e5[a5++] << 8 | e5[a5++]);
            a5 < i4 && t4.push(e5[a5]);
            return i4 + "_" + String.fromCharCode.apply(null, t4);
          }(i3.getBytes(s3 + g3));
          i3.pos = e4;
          const a4 = this.imageCache[c3];
          if (void 0 !== a4) {
            this.buf2 = Cmd.get("EI");
            this.shift();
            a4.reset();
            return a4;
          }
        }
        const C3 = new Dict(this.xref);
        for (const e4 in a3)
          C3.set(e4, a3[e4]);
        let h2 = i3.makeSubStream(o3, g3, C3);
        e3 && (h2 = e3.createStream(h2, g3));
        h2 = this.filter(h2, C3, g3);
        h2.dict = C3;
        if (void 0 !== c3) {
          h2.cacheKey = "inline_img_" + ++this._imageId;
          this.imageCache[c3] = h2;
        }
        this.buf2 = Cmd.get("EI");
        this.shift();
        return h2;
      }
      _findStreamLength(e3, t3) {
        const { stream: i3 } = this.lexer;
        i3.pos = e3;
        const a3 = t3.length;
        for (; i3.pos < i3.end; ) {
          const s3 = i3.peekBytes(2048), r3 = s3.length - a3;
          if (r3 <= 0)
            break;
          let n3 = 0;
          for (; n3 < r3; ) {
            let r4 = 0;
            for (; r4 < a3 && s3[n3 + r4] === t3[r4]; )
              r4++;
            if (r4 >= a3) {
              i3.pos += n3;
              return i3.pos - e3;
            }
            n3++;
          }
          i3.pos += r3;
        }
        return -1;
      }
      makeStream(e3, t3) {
        const i3 = this.lexer;
        let a3 = i3.stream;
        i3.skipToNextLine();
        const s3 = a3.pos - 1;
        let r3 = e3.get("Length");
        if (!Number.isInteger(r3)) {
          info(`Bad length "${r3 && r3.toString()}" in stream.`);
          r3 = 0;
        }
        a3.pos = s3 + r3;
        i3.nextChar();
        if (this.tryShift() && isCmd(this.buf2, "endstream"))
          this.shift();
        else {
          const e4 = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
          let t4 = this._findStreamLength(s3, e4);
          if (t4 < 0) {
            const i4 = 1;
            for (let r4 = 1; r4 <= i4; r4++) {
              const i5 = e4.length - r4, n3 = e4.slice(0, i5), o3 = this._findStreamLength(s3, n3);
              if (o3 >= 0) {
                if (!isWhiteSpace(a3.peekBytes(i5 + 1)[i5]))
                  break;
                info(`Found "${bytesToString(n3)}" when searching for endstream command.`);
                t4 = o3;
                break;
              }
            }
            if (t4 < 0)
              throw new FormatError("Missing endstream command.");
          }
          r3 = t4;
          i3.nextChar();
          this.shift();
          this.shift();
        }
        this.shift();
        a3 = a3.makeSubStream(s3, r3, e3);
        t3 && (a3 = t3.createStream(a3, r3));
        a3 = this.filter(a3, e3, r3);
        a3.dict = e3;
        return a3;
      }
      filter(e3, t3, i3) {
        let a3 = t3.get("F", "Filter"), s3 = t3.get("DP", "DecodeParms");
        if (a3 instanceof Name) {
          Array.isArray(s3) && warn("/DecodeParms should not be an Array, when /Filter is a Name.");
          return this.makeFilter(e3, a3.name, i3, s3);
        }
        let r3 = i3;
        if (Array.isArray(a3)) {
          const t4 = a3, i4 = s3;
          for (let n3 = 0, o3 = t4.length; n3 < o3; ++n3) {
            a3 = this.xref.fetchIfRef(t4[n3]);
            if (!(a3 instanceof Name))
              throw new FormatError(`Bad filter name "${a3}"`);
            s3 = null;
            Array.isArray(i4) && n3 in i4 && (s3 = this.xref.fetchIfRef(i4[n3]));
            e3 = this.makeFilter(e3, a3.name, r3, s3);
            r3 = null;
          }
        }
        return e3;
      }
      makeFilter(e3, t3, i3, a3) {
        if (0 === i3) {
          warn(`Empty "${t3}" stream.`);
          return new NullStream();
        }
        try {
          switch (t3) {
            case "Fl":
            case "FlateDecode":
              return a3 ? new PredictorStream(new FlateStream(e3, i3), i3, a3) : new FlateStream(e3, i3);
            case "LZW":
            case "LZWDecode":
              let t4 = 1;
              if (a3) {
                a3.has("EarlyChange") && (t4 = a3.get("EarlyChange"));
                return new PredictorStream(new LZWStream(e3, i3, t4), i3, a3);
              }
              return new LZWStream(e3, i3, t4);
            case "DCT":
            case "DCTDecode":
              return new JpegStream(e3, i3, a3);
            case "JPX":
            case "JPXDecode":
              return new JpxStream(e3, i3, a3);
            case "A85":
            case "ASCII85Decode":
              return new Ascii85Stream(e3, i3);
            case "AHx":
            case "ASCIIHexDecode":
              return new AsciiHexStream(e3, i3);
            case "CCF":
            case "CCITTFaxDecode":
              return new CCITTFaxStream(e3, i3, a3);
            case "RL":
            case "RunLengthDecode":
              return new RunLengthStream(e3, i3);
            case "JBIG2Decode":
              return new Jbig2Stream(e3, i3, a3);
          }
          warn(`Filter "${t3}" is not supported.`);
          return e3;
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn(`Invalid stream: "${e4}"`);
          return new NullStream();
        }
      }
    };
    ci = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    Lexer = class {
      constructor(e3, t3 = null) {
        this.stream = e3;
        this.nextChar();
        this.strBuf = [];
        this.knownCommands = t3;
        this._hexStringNumWarn = 0;
        this.beginInlineImagePos = -1;
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      peekChar() {
        return this.stream.peekByte();
      }
      getNumber() {
        let e3 = this.currentChar, t3 = false, i3 = 0, a3 = 1;
        if (45 === e3) {
          a3 = -1;
          e3 = this.nextChar();
          45 === e3 && (e3 = this.nextChar());
        } else
          43 === e3 && (e3 = this.nextChar());
        if (10 === e3 || 13 === e3)
          do {
            e3 = this.nextChar();
          } while (10 === e3 || 13 === e3);
        if (46 === e3) {
          i3 = 10;
          e3 = this.nextChar();
        }
        if (e3 < 48 || e3 > 57) {
          const t4 = `Invalid number: ${String.fromCharCode(e3)} (charCode ${e3})`;
          if (isWhiteSpace(e3) || -1 === e3) {
            info(`Lexer.getNumber - "${t4}".`);
            return 0;
          }
          throw new FormatError(t4);
        }
        let s3 = e3 - 48, r3 = 0, n3 = 1;
        for (; (e3 = this.nextChar()) >= 0; )
          if (e3 >= 48 && e3 <= 57) {
            const a4 = e3 - 48;
            if (t3)
              r3 = 10 * r3 + a4;
            else {
              0 !== i3 && (i3 *= 10);
              s3 = 10 * s3 + a4;
            }
          } else if (46 === e3) {
            if (0 !== i3)
              break;
            i3 = 1;
          } else if (45 === e3)
            warn("Badly formatted number: minus sign in the middle");
          else {
            if (69 !== e3 && 101 !== e3)
              break;
            e3 = this.peekChar();
            if (43 === e3 || 45 === e3) {
              n3 = 45 === e3 ? -1 : 1;
              this.nextChar();
            } else if (e3 < 48 || e3 > 57)
              break;
            t3 = true;
          }
        0 !== i3 && (s3 /= i3);
        t3 && (s3 *= 10 ** (n3 * r3));
        return a3 * s3;
      }
      getString() {
        let e3 = 1, t3 = false;
        const i3 = this.strBuf;
        i3.length = 0;
        let a3 = this.nextChar();
        for (; ; ) {
          let s3 = false;
          switch (0 | a3) {
            case -1:
              warn("Unterminated string");
              t3 = true;
              break;
            case 40:
              ++e3;
              i3.push("(");
              break;
            case 41:
              if (0 == --e3) {
                this.nextChar();
                t3 = true;
              } else
                i3.push(")");
              break;
            case 92:
              a3 = this.nextChar();
              switch (a3) {
                case -1:
                  warn("Unterminated string");
                  t3 = true;
                  break;
                case 110:
                  i3.push("\n");
                  break;
                case 114:
                  i3.push("\r");
                  break;
                case 116:
                  i3.push("	");
                  break;
                case 98:
                  i3.push("\b");
                  break;
                case 102:
                  i3.push("\f");
                  break;
                case 92:
                case 40:
                case 41:
                  i3.push(String.fromCharCode(a3));
                  break;
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                  let e4 = 15 & a3;
                  a3 = this.nextChar();
                  s3 = true;
                  if (a3 >= 48 && a3 <= 55) {
                    e4 = (e4 << 3) + (15 & a3);
                    a3 = this.nextChar();
                    if (a3 >= 48 && a3 <= 55) {
                      s3 = false;
                      e4 = (e4 << 3) + (15 & a3);
                    }
                  }
                  i3.push(String.fromCharCode(e4));
                  break;
                case 13:
                  10 === this.peekChar() && this.nextChar();
                  break;
                case 10:
                  break;
                default:
                  i3.push(String.fromCharCode(a3));
              }
              break;
            default:
              i3.push(String.fromCharCode(a3));
          }
          if (t3)
            break;
          s3 || (a3 = this.nextChar());
        }
        return i3.join("");
      }
      getName() {
        let e3, t3;
        const i3 = this.strBuf;
        i3.length = 0;
        for (; (e3 = this.nextChar()) >= 0 && !ci[e3]; )
          if (35 === e3) {
            e3 = this.nextChar();
            if (ci[e3]) {
              warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
              i3.push("#");
              break;
            }
            const a3 = toHexDigit(e3);
            if (-1 !== a3) {
              t3 = e3;
              e3 = this.nextChar();
              const s3 = toHexDigit(e3);
              if (-1 === s3) {
                warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e3)}) in hexadecimal number.`);
                i3.push("#", String.fromCharCode(t3));
                if (ci[e3])
                  break;
                i3.push(String.fromCharCode(e3));
                continue;
              }
              i3.push(String.fromCharCode(a3 << 4 | s3));
            } else
              i3.push("#", String.fromCharCode(e3));
          } else
            i3.push(String.fromCharCode(e3));
        i3.length > 127 && warn(`Name token is longer than allowed by the spec: ${i3.length}`);
        return Name.get(i3.join(""));
      }
      _hexStringWarn(e3) {
        5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn(`getHexString - ignoring invalid character: ${e3}`) : warn("getHexString - ignoring additional invalid characters.");
      }
      getHexString() {
        const e3 = this.strBuf;
        e3.length = 0;
        let t3, i3, a3 = this.currentChar, s3 = true;
        this._hexStringNumWarn = 0;
        for (; ; ) {
          if (a3 < 0) {
            warn("Unterminated hex string");
            break;
          }
          if (62 === a3) {
            this.nextChar();
            break;
          }
          if (1 !== ci[a3]) {
            if (s3) {
              t3 = toHexDigit(a3);
              if (-1 === t3) {
                this._hexStringWarn(a3);
                a3 = this.nextChar();
                continue;
              }
            } else {
              i3 = toHexDigit(a3);
              if (-1 === i3) {
                this._hexStringWarn(a3);
                a3 = this.nextChar();
                continue;
              }
              e3.push(String.fromCharCode(t3 << 4 | i3));
            }
            s3 = !s3;
            a3 = this.nextChar();
          } else
            a3 = this.nextChar();
        }
        return e3.join("");
      }
      getObj() {
        let e3 = false, t3 = this.currentChar;
        for (; ; ) {
          if (t3 < 0)
            return pt;
          if (e3)
            10 !== t3 && 13 !== t3 || (e3 = false);
          else if (37 === t3)
            e3 = true;
          else if (1 !== ci[t3])
            break;
          t3 = this.nextChar();
        }
        switch (0 | t3) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 43:
          case 45:
          case 46:
            return this.getNumber();
          case 40:
            return this.getString();
          case 47:
            return this.getName();
          case 91:
            this.nextChar();
            return Cmd.get("[");
          case 93:
            this.nextChar();
            return Cmd.get("]");
          case 60:
            t3 = this.nextChar();
            if (60 === t3) {
              this.nextChar();
              return Cmd.get("<<");
            }
            return this.getHexString();
          case 62:
            t3 = this.nextChar();
            if (62 === t3) {
              this.nextChar();
              return Cmd.get(">>");
            }
            return Cmd.get(">");
          case 123:
            this.nextChar();
            return Cmd.get("{");
          case 125:
            this.nextChar();
            return Cmd.get("}");
          case 41:
            this.nextChar();
            throw new FormatError(`Illegal character: ${t3}`);
        }
        let i3 = String.fromCharCode(t3);
        if (t3 < 32 || t3 > 127) {
          const e4 = this.peekChar();
          if (e4 >= 32 && e4 <= 127) {
            this.nextChar();
            return Cmd.get(i3);
          }
        }
        const a3 = this.knownCommands;
        let s3 = void 0 !== (a3 == null ? void 0 : a3[i3]);
        for (; (t3 = this.nextChar()) >= 0 && !ci[t3]; ) {
          const e4 = i3 + String.fromCharCode(t3);
          if (s3 && void 0 === a3[e4])
            break;
          if (128 === i3.length)
            throw new FormatError(`Command token too long: ${i3.length}`);
          i3 = e4;
          s3 = void 0 !== (a3 == null ? void 0 : a3[i3]);
        }
        if ("true" === i3)
          return true;
        if ("false" === i3)
          return false;
        if ("null" === i3)
          return null;
        "BI" === i3 && (this.beginInlineImagePos = this.stream.pos);
        return Cmd.get(i3);
      }
      skipToNextLine() {
        let e3 = this.currentChar;
        for (; e3 >= 0; ) {
          if (13 === e3) {
            e3 = this.nextChar();
            10 === e3 && this.nextChar();
            break;
          }
          if (10 === e3) {
            this.nextChar();
            break;
          }
          e3 = this.nextChar();
        }
      }
    };
    Linearization = class {
      static create(e3) {
        function getInt(e4, t4, i4 = false) {
          const a4 = e4.get(t4);
          if (Number.isInteger(a4) && (i4 ? a4 >= 0 : a4 > 0))
            return a4;
          throw new Error(`The "${t4}" parameter in the linearization dictionary is invalid.`);
        }
        const t3 = new Parser({ lexer: new Lexer(e3), xref: null }), i3 = t3.getObj(), a3 = t3.getObj(), s3 = t3.getObj(), r3 = t3.getObj();
        let n3, o3;
        if (!(Number.isInteger(i3) && Number.isInteger(a3) && isCmd(s3, "obj") && r3 instanceof Dict && "number" == typeof (n3 = r3.get("Linearized")) && n3 > 0))
          return null;
        if ((o3 = getInt(r3, "L")) !== e3.length)
          throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
        return { length: o3, hints: function getHints(e4) {
          const t4 = e4.get("H");
          let i4;
          if (Array.isArray(t4) && (2 === (i4 = t4.length) || 4 === i4)) {
            for (let e5 = 0; e5 < i4; e5++) {
              const i5 = t4[e5];
              if (!(Number.isInteger(i5) && i5 > 0))
                throw new Error(`Hint (${e5}) in the linearization dictionary is invalid.`);
            }
            return t4;
          }
          throw new Error("Hint array in the linearization dictionary is invalid.");
        }(r3), objectNumberFirst: getInt(r3, "O"), endFirst: getInt(r3, "E"), numPages: getInt(r3, "N"), mainXRefEntriesOffset: getInt(r3, "T"), pageFirst: r3.has("P") ? getInt(r3, "P", true) : 0 };
      }
    };
    Ci = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
    hi = 2 ** 24 - 1;
    CMap = class {
      constructor(e3 = false) {
        this.codespaceRanges = [[], [], [], []];
        this.numCodespaceRanges = 0;
        this._map = [];
        this.name = "";
        this.vertical = false;
        this.useCMap = null;
        this.builtInCMap = e3;
      }
      addCodespaceRange(e3, t3, i3) {
        this.codespaceRanges[e3 - 1].push(t3, i3);
        this.numCodespaceRanges++;
      }
      mapCidRange(e3, t3, i3) {
        if (t3 - e3 > hi)
          throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
        for (; e3 <= t3; )
          this._map[e3++] = i3++;
      }
      mapBfRange(e3, t3, i3) {
        if (t3 - e3 > hi)
          throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
        const a3 = i3.length - 1;
        for (; e3 <= t3; ) {
          this._map[e3++] = i3;
          const t4 = i3.charCodeAt(a3) + 1;
          t4 > 255 ? i3 = i3.substring(0, a3 - 1) + String.fromCharCode(i3.charCodeAt(a3 - 1) + 1) + "\0" : i3 = i3.substring(0, a3) + String.fromCharCode(t4);
        }
      }
      mapBfRangeToArray(e3, t3, i3) {
        if (t3 - e3 > hi)
          throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
        const a3 = i3.length;
        let s3 = 0;
        for (; e3 <= t3 && s3 < a3; ) {
          this._map[e3] = i3[s3++];
          ++e3;
        }
      }
      mapOne(e3, t3) {
        this._map[e3] = t3;
      }
      lookup(e3) {
        return this._map[e3];
      }
      contains(e3) {
        return void 0 !== this._map[e3];
      }
      forEach(e3) {
        const t3 = this._map, i3 = t3.length;
        if (i3 <= 65536)
          for (let a3 = 0; a3 < i3; a3++)
            void 0 !== t3[a3] && e3(a3, t3[a3]);
        else
          for (const i4 in t3)
            e3(i4, t3[i4]);
      }
      charCodeOf(e3) {
        const t3 = this._map;
        if (t3.length <= 65536)
          return t3.indexOf(e3);
        for (const i3 in t3)
          if (t3[i3] === e3)
            return 0 | i3;
        return -1;
      }
      getMap() {
        return this._map;
      }
      readCharCode(e3, t3, i3) {
        let a3 = 0;
        const s3 = this.codespaceRanges;
        for (let r3 = 0, n3 = s3.length; r3 < n3; r3++) {
          a3 = (a3 << 8 | e3.charCodeAt(t3 + r3)) >>> 0;
          const n4 = s3[r3];
          for (let e4 = 0, t4 = n4.length; e4 < t4; ) {
            const t5 = n4[e4++], s4 = n4[e4++];
            if (a3 >= t5 && a3 <= s4) {
              i3.charcode = a3;
              i3.length = r3 + 1;
              return;
            }
          }
        }
        i3.charcode = 0;
        i3.length = 1;
      }
      getCharCodeLength(e3) {
        const t3 = this.codespaceRanges;
        for (let i3 = 0, a3 = t3.length; i3 < a3; i3++) {
          const a4 = t3[i3];
          for (let t4 = 0, s3 = a4.length; t4 < s3; ) {
            const s4 = a4[t4++], r3 = a4[t4++];
            if (e3 >= s4 && e3 <= r3)
              return i3 + 1;
          }
        }
        return 1;
      }
      get length() {
        return this._map.length;
      }
      get isIdentityCMap() {
        if ("Identity-H" !== this.name && "Identity-V" !== this.name)
          return false;
        if (65536 !== this._map.length)
          return false;
        for (let e3 = 0; e3 < 65536; e3++)
          if (this._map[e3] !== e3)
            return false;
        return true;
      }
    };
    IdentityCMap = class extends CMap {
      constructor(e3, t3) {
        super();
        this.vertical = e3;
        this.addCodespaceRange(t3, 0, 65535);
      }
      mapCidRange(e3, t3, i3) {
        unreachable("should not call mapCidRange");
      }
      mapBfRange(e3, t3, i3) {
        unreachable("should not call mapBfRange");
      }
      mapBfRangeToArray(e3, t3, i3) {
        unreachable("should not call mapBfRangeToArray");
      }
      mapOne(e3, t3) {
        unreachable("should not call mapCidOne");
      }
      lookup(e3) {
        return Number.isInteger(e3) && e3 <= 65535 ? e3 : void 0;
      }
      contains(e3) {
        return Number.isInteger(e3) && e3 <= 65535;
      }
      forEach(e3) {
        for (let t3 = 0; t3 <= 65535; t3++)
          e3(t3, t3);
      }
      charCodeOf(e3) {
        return Number.isInteger(e3) && e3 <= 65535 ? e3 : -1;
      }
      getMap() {
        const e3 = new Array(65536);
        for (let t3 = 0; t3 <= 65535; t3++)
          e3[t3] = t3;
        return e3;
      }
      get length() {
        return 65536;
      }
      get isIdentityCMap() {
        unreachable("should not access .isIdentityCMap");
      }
    };
    CMapFactory = class {
      static async create({ encoding: e3, fetchBuiltInCMap: t3, useCMap: i3 }) {
        if (e3 instanceof Name)
          return createBuiltInCMap(e3.name, t3);
        if (e3 instanceof BaseStream) {
          const a3 = await parseCMap(new CMap(), new Lexer(e3), t3, i3);
          return a3.isIdentityCMap ? createBuiltInCMap(a3.name, t3) : a3;
        }
        throw new Error("Encoding required.");
      }
    };
    li = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
    Bi = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
    Qi = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
    Ei = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
    ui = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
    di = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
    fi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
    pi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
    mi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
    yi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
    wi = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
    bi = 391;
    Di = [null, { id: "hstem", min: 2, stackClearing: true, stem: true }, null, { id: "vstem", min: 2, stackClearing: true, stem: true }, { id: "vmoveto", min: 1, stackClearing: true }, { id: "rlineto", min: 2, resetStack: true }, { id: "hlineto", min: 1, resetStack: true }, { id: "vlineto", min: 1, resetStack: true }, { id: "rrcurveto", min: 6, resetStack: true }, null, { id: "callsubr", min: 1, undefStack: true }, { id: "return", min: 0, undefStack: true }, null, null, { id: "endchar", min: 0, stackClearing: true }, null, null, null, { id: "hstemhm", min: 2, stackClearing: true, stem: true }, { id: "hintmask", min: 0, stackClearing: true }, { id: "cntrmask", min: 0, stackClearing: true }, { id: "rmoveto", min: 2, stackClearing: true }, { id: "hmoveto", min: 1, stackClearing: true }, { id: "vstemhm", min: 2, stackClearing: true, stem: true }, { id: "rcurveline", min: 8, resetStack: true }, { id: "rlinecurve", min: 8, resetStack: true }, { id: "vvcurveto", min: 4, resetStack: true }, { id: "hhcurveto", min: 4, resetStack: true }, null, { id: "callgsubr", min: 1, undefStack: true }, { id: "vhcurveto", min: 4, resetStack: true }, { id: "hvcurveto", min: 4, resetStack: true }];
    Fi = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(e3, t3) {
      e3[t3 - 2] = e3[t3 - 2] + e3[t3 - 1];
    } }, { id: "sub", min: 2, stackDelta: -1, stackFn(e3, t3) {
      e3[t3 - 2] = e3[t3 - 2] - e3[t3 - 1];
    } }, { id: "div", min: 2, stackDelta: -1, stackFn(e3, t3) {
      e3[t3 - 2] = e3[t3 - 2] / e3[t3 - 1];
    } }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(e3, t3) {
      e3[t3 - 1] = -e3[t3 - 1];
    } }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(e3, t3) {
      e3[t3 - 2] = e3[t3 - 2] * e3[t3 - 1];
    } }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: true }, { id: "flex", min: 13, resetStack: true }, { id: "hflex1", min: 9, resetStack: true }, { id: "flex1", min: 11, resetStack: true }];
    CFFParser = class {
      constructor(e3, t3, i3) {
        this.bytes = e3.getBytes();
        this.properties = t3;
        this.seacAnalysisEnabled = !!i3;
      }
      parse() {
        const e3 = this.properties, t3 = new CFF();
        this.cff = t3;
        const i3 = this.parseHeader(), a3 = this.parseIndex(i3.endPos), s3 = this.parseIndex(a3.endPos), r3 = this.parseIndex(s3.endPos), n3 = this.parseIndex(r3.endPos), o3 = this.parseDict(s3.obj.get(0)), g3 = this.createDict(CFFTopDict, o3, t3.strings);
        t3.header = i3.obj;
        t3.names = this.parseNameIndex(a3.obj);
        t3.strings = this.parseStringIndex(r3.obj);
        t3.topDict = g3;
        t3.globalSubrIndex = n3.obj;
        this.parsePrivateDict(t3.topDict);
        t3.isCIDFont = g3.hasName("ROS");
        const c3 = g3.getByName("CharStrings"), C3 = this.parseIndex(c3).obj, h2 = g3.getByName("FontMatrix");
        h2 && (e3.fontMatrix = h2);
        const l3 = g3.getByName("FontBBox");
        if (l3) {
          e3.ascent = Math.max(l3[3], l3[1]);
          e3.descent = Math.min(l3[1], l3[3]);
          e3.ascentScaled = true;
        }
        let Q3, E3;
        if (t3.isCIDFont) {
          const e4 = this.parseIndex(g3.getByName("FDArray")).obj;
          for (let i4 = 0, a4 = e4.count; i4 < a4; ++i4) {
            const a5 = e4.get(i4), s4 = this.createDict(CFFTopDict, this.parseDict(a5), t3.strings);
            this.parsePrivateDict(s4);
            t3.fdArray.push(s4);
          }
          E3 = null;
          Q3 = this.parseCharsets(g3.getByName("charset"), C3.count, t3.strings, true);
          t3.fdSelect = this.parseFDSelect(g3.getByName("FDSelect"), C3.count);
        } else {
          Q3 = this.parseCharsets(g3.getByName("charset"), C3.count, t3.strings, false);
          E3 = this.parseEncoding(g3.getByName("Encoding"), e3, t3.strings, Q3.charset);
        }
        t3.charset = Q3;
        t3.encoding = E3;
        const u3 = this.parseCharStrings({ charStrings: C3, localSubrIndex: g3.privateDict.subrsIndex, globalSubrIndex: n3.obj, fdSelect: t3.fdSelect, fdArray: t3.fdArray, privateDict: g3.privateDict });
        t3.charStrings = u3.charStrings;
        t3.seacs = u3.seacs;
        t3.widths = u3.widths;
        return t3;
      }
      parseHeader() {
        let e3 = this.bytes;
        const t3 = e3.length;
        let i3 = 0;
        for (; i3 < t3 && 1 !== e3[i3]; )
          ++i3;
        if (i3 >= t3)
          throw new FormatError("Invalid CFF header");
        if (0 !== i3) {
          info("cff data is shifted");
          e3 = e3.subarray(i3);
          this.bytes = e3;
        }
        const a3 = e3[0], s3 = e3[1], r3 = e3[2], n3 = e3[3];
        return { obj: new CFFHeader(a3, s3, r3, n3), endPos: r3 };
      }
      parseDict(e3) {
        let t3 = 0;
        function parseOperand() {
          let i4 = e3[t3++];
          if (30 === i4)
            return function parseFloatOperand() {
              let i5 = "";
              const a4 = 15, s4 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], r3 = e3.length;
              for (; t3 < r3; ) {
                const r4 = e3[t3++], n3 = r4 >> 4, o3 = 15 & r4;
                if (n3 === a4)
                  break;
                i5 += s4[n3];
                if (o3 === a4)
                  break;
                i5 += s4[o3];
              }
              return parseFloat(i5);
            }();
          if (28 === i4) {
            i4 = e3[t3++];
            i4 = (i4 << 24 | e3[t3++] << 16) >> 16;
            return i4;
          }
          if (29 === i4) {
            i4 = e3[t3++];
            i4 = i4 << 8 | e3[t3++];
            i4 = i4 << 8 | e3[t3++];
            i4 = i4 << 8 | e3[t3++];
            return i4;
          }
          if (i4 >= 32 && i4 <= 246)
            return i4 - 139;
          if (i4 >= 247 && i4 <= 250)
            return 256 * (i4 - 247) + e3[t3++] + 108;
          if (i4 >= 251 && i4 <= 254)
            return -256 * (i4 - 251) - e3[t3++] - 108;
          warn('CFFParser_parseDict: "' + i4 + '" is a reserved command.');
          return NaN;
        }
        let i3 = [];
        const a3 = [];
        t3 = 0;
        const s3 = e3.length;
        for (; t3 < s3; ) {
          let s4 = e3[t3];
          if (s4 <= 21) {
            12 === s4 && (s4 = s4 << 8 | e3[++t3]);
            a3.push([s4, i3]);
            i3 = [];
            ++t3;
          } else
            i3.push(parseOperand());
        }
        return a3;
      }
      parseIndex(e3) {
        const t3 = new CFFIndex(), i3 = this.bytes, a3 = i3[e3++] << 8 | i3[e3++], s3 = [];
        let r3, n3, o3 = e3;
        if (0 !== a3) {
          const t4 = i3[e3++], g3 = e3 + (a3 + 1) * t4 - 1;
          for (r3 = 0, n3 = a3 + 1; r3 < n3; ++r3) {
            let a4 = 0;
            for (let s4 = 0; s4 < t4; ++s4) {
              a4 <<= 8;
              a4 += i3[e3++];
            }
            s3.push(g3 + a4);
          }
          o3 = s3[a3];
        }
        for (r3 = 0, n3 = s3.length - 1; r3 < n3; ++r3) {
          const e4 = s3[r3], a4 = s3[r3 + 1];
          t3.add(i3.subarray(e4, a4));
        }
        return { obj: t3, endPos: o3 };
      }
      parseNameIndex(e3) {
        const t3 = [];
        for (let i3 = 0, a3 = e3.count; i3 < a3; ++i3) {
          const a4 = e3.get(i3);
          t3.push(bytesToString(a4));
        }
        return t3;
      }
      parseStringIndex(e3) {
        const t3 = new CFFStrings();
        for (let i3 = 0, a3 = e3.count; i3 < a3; ++i3) {
          const a4 = e3.get(i3);
          t3.add(bytesToString(a4));
        }
        return t3;
      }
      createDict(e3, t3, i3) {
        const a3 = new e3(i3);
        for (const [e4, i4] of t3)
          a3.setByKey(e4, i4);
        return a3;
      }
      parseCharString(e3, t3, i3, a3) {
        if (!t3 || e3.callDepth > 10)
          return false;
        let s3 = e3.stackSize;
        const r3 = e3.stack;
        let n3 = t3.length;
        for (let o3 = 0; o3 < n3; ) {
          const g3 = t3[o3++];
          let c3 = null;
          if (12 === g3) {
            const e4 = t3[o3++];
            if (0 === e4) {
              t3[o3 - 2] = 139;
              t3[o3 - 1] = 22;
              s3 = 0;
            } else
              c3 = Fi[e4];
          } else if (28 === g3) {
            r3[s3] = (t3[o3] << 24 | t3[o3 + 1] << 16) >> 16;
            o3 += 2;
            s3++;
          } else if (14 === g3) {
            if (s3 >= 4) {
              s3 -= 4;
              if (this.seacAnalysisEnabled) {
                e3.seac = r3.slice(s3, s3 + 4);
                return false;
              }
            }
            c3 = Di[g3];
          } else if (g3 >= 32 && g3 <= 246) {
            r3[s3] = g3 - 139;
            s3++;
          } else if (g3 >= 247 && g3 <= 254) {
            r3[s3] = g3 < 251 ? (g3 - 247 << 8) + t3[o3] + 108 : -(g3 - 251 << 8) - t3[o3] - 108;
            o3++;
            s3++;
          } else if (255 === g3) {
            r3[s3] = (t3[o3] << 24 | t3[o3 + 1] << 16 | t3[o3 + 2] << 8 | t3[o3 + 3]) / 65536;
            o3 += 4;
            s3++;
          } else if (19 === g3 || 20 === g3) {
            e3.hints += s3 >> 1;
            if (0 === e3.hints) {
              t3.copyWithin(o3 - 1, o3, -1);
              o3 -= 1;
              n3 -= 1;
              continue;
            }
            o3 += e3.hints + 7 >> 3;
            s3 %= 2;
            c3 = Di[g3];
          } else {
            if (10 === g3 || 29 === g3) {
              const t4 = 10 === g3 ? i3 : a3;
              if (!t4) {
                c3 = Di[g3];
                warn("Missing subrsIndex for " + c3.id);
                return false;
              }
              let n4 = 32768;
              t4.count < 1240 ? n4 = 107 : t4.count < 33900 && (n4 = 1131);
              const o4 = r3[--s3] + n4;
              if (o4 < 0 || o4 >= t4.count || isNaN(o4)) {
                c3 = Di[g3];
                warn("Out of bounds subrIndex for " + c3.id);
                return false;
              }
              e3.stackSize = s3;
              e3.callDepth++;
              if (!this.parseCharString(e3, t4.get(o4), i3, a3))
                return false;
              e3.callDepth--;
              s3 = e3.stackSize;
              continue;
            }
            if (11 === g3) {
              e3.stackSize = s3;
              return true;
            }
            if (0 === g3 && o3 === t3.length) {
              t3[o3 - 1] = 14;
              c3 = Di[14];
            } else {
              if (9 === g3) {
                t3.copyWithin(o3 - 1, o3, -1);
                o3 -= 1;
                n3 -= 1;
                continue;
              }
              c3 = Di[g3];
            }
          }
          if (c3) {
            if (c3.stem) {
              e3.hints += s3 >> 1;
              if (3 === g3 || 23 === g3)
                e3.hasVStems = true;
              else if (e3.hasVStems && (1 === g3 || 18 === g3)) {
                warn("CFF stem hints are in wrong order");
                t3[o3 - 1] = 1 === g3 ? 3 : 23;
              }
            }
            if ("min" in c3 && !e3.undefStack && s3 < c3.min) {
              warn("Not enough parameters for " + c3.id + "; actual: " + s3 + ", expected: " + c3.min);
              if (0 === s3) {
                t3[o3 - 1] = 14;
                return true;
              }
              return false;
            }
            if (e3.firstStackClearing && c3.stackClearing) {
              e3.firstStackClearing = false;
              s3 -= c3.min;
              s3 >= 2 && c3.stem ? s3 %= 2 : s3 > 1 && warn("Found too many parameters for stack-clearing command");
              s3 > 0 && (e3.width = r3[s3 - 1]);
            }
            if ("stackDelta" in c3) {
              "stackFn" in c3 && c3.stackFn(r3, s3);
              s3 += c3.stackDelta;
            } else if (c3.stackClearing)
              s3 = 0;
            else if (c3.resetStack) {
              s3 = 0;
              e3.undefStack = false;
            } else if (c3.undefStack) {
              s3 = 0;
              e3.undefStack = true;
              e3.firstStackClearing = false;
            }
          }
        }
        n3 < t3.length && t3.fill(14, n3);
        e3.stackSize = s3;
        return true;
      }
      parseCharStrings({ charStrings: e3, localSubrIndex: t3, globalSubrIndex: i3, fdSelect: a3, fdArray: s3, privateDict: r3 }) {
        const n3 = [], o3 = [], g3 = e3.count;
        for (let c3 = 0; c3 < g3; c3++) {
          const g4 = e3.get(c3), C3 = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false };
          let h2 = true, l3 = null, Q3 = r3;
          if (a3 && s3.length) {
            const e4 = a3.getFDIndex(c3);
            if (-1 === e4) {
              warn("Glyph index is not in fd select.");
              h2 = false;
            }
            if (e4 >= s3.length) {
              warn("Invalid fd index for glyph index.");
              h2 = false;
            }
            if (h2) {
              Q3 = s3[e4].privateDict;
              l3 = Q3.subrsIndex;
            }
          } else
            t3 && (l3 = t3);
          h2 && (h2 = this.parseCharString(C3, g4, l3, i3));
          if (null !== C3.width) {
            const e4 = Q3.getByName("nominalWidthX");
            o3[c3] = e4 + C3.width;
          } else {
            const e4 = Q3.getByName("defaultWidthX");
            o3[c3] = e4;
          }
          null !== C3.seac && (n3[c3] = C3.seac);
          h2 || e3.set(c3, new Uint8Array([14]));
        }
        return { charStrings: e3, seacs: n3, widths: o3 };
      }
      emptyPrivateDictionary(e3) {
        const t3 = this.createDict(CFFPrivateDict, [], e3.strings);
        e3.setByKey(18, [0, 0]);
        e3.privateDict = t3;
      }
      parsePrivateDict(e3) {
        if (!e3.hasName("Private")) {
          this.emptyPrivateDictionary(e3);
          return;
        }
        const t3 = e3.getByName("Private");
        if (!Array.isArray(t3) || 2 !== t3.length) {
          e3.removeByName("Private");
          return;
        }
        const i3 = t3[0], a3 = t3[1];
        if (0 === i3 || a3 >= this.bytes.length) {
          this.emptyPrivateDictionary(e3);
          return;
        }
        const s3 = a3 + i3, r3 = this.bytes.subarray(a3, s3), n3 = this.parseDict(r3), o3 = this.createDict(CFFPrivateDict, n3, e3.strings);
        e3.privateDict = o3;
        0 === o3.getByName("ExpansionFactor") && o3.setByName("ExpansionFactor", 0.06);
        if (!o3.getByName("Subrs"))
          return;
        const g3 = o3.getByName("Subrs"), c3 = a3 + g3;
        if (0 === g3 || c3 >= this.bytes.length) {
          this.emptyPrivateDictionary(e3);
          return;
        }
        const C3 = this.parseIndex(c3);
        o3.subrsIndex = C3.obj;
      }
      parseCharsets(e3, t3, i3, a3) {
        if (0 === e3)
          return new CFFCharset(true, Ni.ISO_ADOBE, li);
        if (1 === e3)
          return new CFFCharset(true, Ni.EXPERT, Bi);
        if (2 === e3)
          return new CFFCharset(true, Ni.EXPERT_SUBSET, Qi);
        const s3 = this.bytes, r3 = e3, n3 = s3[e3++], o3 = [a3 ? 0 : ".notdef"];
        let g3, c3, C3;
        t3 -= 1;
        switch (n3) {
          case 0:
            for (C3 = 0; C3 < t3; C3++) {
              g3 = s3[e3++] << 8 | s3[e3++];
              o3.push(a3 ? g3 : i3.get(g3));
            }
            break;
          case 1:
            for (; o3.length <= t3; ) {
              g3 = s3[e3++] << 8 | s3[e3++];
              c3 = s3[e3++];
              for (C3 = 0; C3 <= c3; C3++)
                o3.push(a3 ? g3++ : i3.get(g3++));
            }
            break;
          case 2:
            for (; o3.length <= t3; ) {
              g3 = s3[e3++] << 8 | s3[e3++];
              c3 = s3[e3++] << 8 | s3[e3++];
              for (C3 = 0; C3 <= c3; C3++)
                o3.push(a3 ? g3++ : i3.get(g3++));
            }
            break;
          default:
            throw new FormatError("Unknown charset format");
        }
        const h2 = e3, l3 = s3.subarray(r3, h2);
        return new CFFCharset(false, n3, o3, l3);
      }
      parseEncoding(e3, t3, i3, a3) {
        const s3 = /* @__PURE__ */ Object.create(null), r3 = this.bytes;
        let n3, o3, g3, c3 = false, C3 = null;
        if (0 === e3 || 1 === e3) {
          c3 = true;
          n3 = e3;
          const t4 = e3 ? Ei : fi;
          for (o3 = 0, g3 = a3.length; o3 < g3; o3++) {
            const e4 = t4.indexOf(a3[o3]);
            -1 !== e4 && (s3[e4] = o3);
          }
        } else {
          const t4 = e3;
          n3 = r3[e3++];
          switch (127 & n3) {
            case 0:
              const t5 = r3[e3++];
              for (o3 = 1; o3 <= t5; o3++)
                s3[r3[e3++]] = o3;
              break;
            case 1:
              const i4 = r3[e3++];
              let a4 = 1;
              for (o3 = 0; o3 < i4; o3++) {
                const t6 = r3[e3++], i5 = r3[e3++];
                for (let e4 = t6; e4 <= t6 + i5; e4++)
                  s3[e4] = a4++;
              }
              break;
            default:
              throw new FormatError(`Unknown encoding format: ${n3} in CFF`);
          }
          const g4 = e3;
          if (128 & n3) {
            r3[t4] &= 127;
            !function readSupplement() {
              const t5 = r3[e3++];
              for (o3 = 0; o3 < t5; o3++) {
                const t6 = r3[e3++], n4 = (r3[e3++] << 8) + (255 & r3[e3++]);
                s3[t6] = a3.indexOf(i3.get(n4));
              }
            }();
          }
          C3 = r3.subarray(t4, g4);
        }
        n3 &= 127;
        return new CFFEncoding(c3, n3, s3, C3);
      }
      parseFDSelect(e3, t3) {
        const i3 = this.bytes, a3 = i3[e3++], s3 = [];
        let r3;
        switch (a3) {
          case 0:
            for (r3 = 0; r3 < t3; ++r3) {
              const t4 = i3[e3++];
              s3.push(t4);
            }
            break;
          case 3:
            const n3 = i3[e3++] << 8 | i3[e3++];
            for (r3 = 0; r3 < n3; ++r3) {
              let t4 = i3[e3++] << 8 | i3[e3++];
              if (0 === r3 && 0 !== t4) {
                warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                t4 = 0;
              }
              const a4 = i3[e3++], n4 = i3[e3] << 8 | i3[e3 + 1];
              for (let e4 = t4; e4 < n4; ++e4)
                s3.push(a4);
            }
            e3 += 2;
            break;
          default:
            throw new FormatError(`parseFDSelect: Unknown format "${a3}".`);
        }
        if (s3.length !== t3)
          throw new FormatError("parseFDSelect: Invalid font data.");
        return new CFFFDSelect(a3, s3);
      }
    };
    CFF = class {
      constructor() {
        this.header = null;
        this.names = [];
        this.topDict = null;
        this.strings = new CFFStrings();
        this.globalSubrIndex = null;
        this.encoding = null;
        this.charset = null;
        this.charStrings = null;
        this.fdArray = [];
        this.fdSelect = null;
        this.isCIDFont = false;
      }
      duplicateFirstGlyph() {
        if (this.charStrings.count >= 65535) {
          warn("Not enough space in charstrings to duplicate first glyph.");
          return;
        }
        const e3 = this.charStrings.get(0);
        this.charStrings.add(e3);
        this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
      }
      hasGlyphId(e3) {
        if (e3 < 0 || e3 >= this.charStrings.count)
          return false;
        return this.charStrings.get(e3).length > 0;
      }
    };
    CFFHeader = class {
      constructor(e3, t3, i3, a3) {
        this.major = e3;
        this.minor = t3;
        this.hdrSize = i3;
        this.offSize = a3;
      }
    };
    CFFStrings = class {
      constructor() {
        this.strings = [];
      }
      get(e3) {
        return e3 >= 0 && e3 <= 390 ? wi[e3] : e3 - bi <= this.strings.length ? this.strings[e3 - bi] : wi[0];
      }
      getSID(e3) {
        let t3 = wi.indexOf(e3);
        if (-1 !== t3)
          return t3;
        t3 = this.strings.indexOf(e3);
        return -1 !== t3 ? t3 + bi : -1;
      }
      add(e3) {
        this.strings.push(e3);
      }
      get count() {
        return this.strings.length;
      }
    };
    CFFIndex = class {
      constructor() {
        this.objects = [];
        this.length = 0;
      }
      add(e3) {
        this.length += e3.length;
        this.objects.push(e3);
      }
      set(e3, t3) {
        this.length += t3.length - this.objects[e3].length;
        this.objects[e3] = t3;
      }
      get(e3) {
        return this.objects[e3];
      }
      get count() {
        return this.objects.length;
      }
    };
    CFFDict = class {
      constructor(e3, t3) {
        this.keyToNameMap = e3.keyToNameMap;
        this.nameToKeyMap = e3.nameToKeyMap;
        this.defaults = e3.defaults;
        this.types = e3.types;
        this.opcodes = e3.opcodes;
        this.order = e3.order;
        this.strings = t3;
        this.values = /* @__PURE__ */ Object.create(null);
      }
      setByKey(e3, t3) {
        if (!(e3 in this.keyToNameMap))
          return false;
        if (0 === t3.length)
          return true;
        for (const i4 of t3)
          if (isNaN(i4)) {
            warn(`Invalid CFFDict value: "${t3}" for key "${e3}".`);
            return true;
          }
        const i3 = this.types[e3];
        "num" !== i3 && "sid" !== i3 && "offset" !== i3 || (t3 = t3[0]);
        this.values[e3] = t3;
        return true;
      }
      setByName(e3, t3) {
        if (!(e3 in this.nameToKeyMap))
          throw new FormatError(`Invalid dictionary name "${e3}"`);
        this.values[this.nameToKeyMap[e3]] = t3;
      }
      hasName(e3) {
        return this.nameToKeyMap[e3] in this.values;
      }
      getByName(e3) {
        if (!(e3 in this.nameToKeyMap))
          throw new FormatError(`Invalid dictionary name ${e3}"`);
        const t3 = this.nameToKeyMap[e3];
        return t3 in this.values ? this.values[t3] : this.defaults[t3];
      }
      removeByName(e3) {
        delete this.values[this.nameToKeyMap[e3]];
      }
      static createTables(e3) {
        const t3 = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
        for (const i3 of e3) {
          const e4 = Array.isArray(i3[0]) ? (i3[0][0] << 8) + i3[0][1] : i3[0];
          t3.keyToNameMap[e4] = i3[1];
          t3.nameToKeyMap[i3[1]] = e4;
          t3.types[e4] = i3[2];
          t3.defaults[e4] = i3[3];
          t3.opcodes[e4] = Array.isArray(i3[0]) ? i3[0] : [i3[0]];
          t3.order.push(e4);
        }
        return t3;
      }
    };
    Si = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
    CFFTopDict = class _CFFTopDict extends CFFDict {
      static get tables() {
        return shadow(this, "tables", this.createTables(Si));
      }
      constructor(e3) {
        super(_CFFTopDict.tables, e3);
        this.privateDict = null;
      }
    };
    ki = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
    CFFPrivateDict = class _CFFPrivateDict extends CFFDict {
      static get tables() {
        return shadow(this, "tables", this.createTables(ki));
      }
      constructor(e3) {
        super(_CFFPrivateDict.tables, e3);
        this.subrsIndex = null;
      }
    };
    Ni = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
    CFFCharset = class {
      constructor(e3, t3, i3, a3) {
        this.predefined = e3;
        this.format = t3;
        this.charset = i3;
        this.raw = a3;
      }
    };
    CFFEncoding = class {
      constructor(e3, t3, i3, a3) {
        this.predefined = e3;
        this.format = t3;
        this.encoding = i3;
        this.raw = a3;
      }
    };
    CFFFDSelect = class {
      constructor(e3, t3) {
        this.format = e3;
        this.fdSelect = t3;
      }
      getFDIndex(e3) {
        return e3 < 0 || e3 >= this.fdSelect.length ? -1 : this.fdSelect[e3];
      }
    };
    CFFOffsetTracker = class {
      constructor() {
        this.offsets = /* @__PURE__ */ Object.create(null);
      }
      isTracking(e3) {
        return e3 in this.offsets;
      }
      track(e3, t3) {
        if (e3 in this.offsets)
          throw new FormatError(`Already tracking location of ${e3}`);
        this.offsets[e3] = t3;
      }
      offset(e3) {
        for (const t3 in this.offsets)
          this.offsets[t3] += e3;
      }
      setEntryLocation(e3, t3, i3) {
        if (!(e3 in this.offsets))
          throw new FormatError(`Not tracking location of ${e3}`);
        const a3 = i3.data, s3 = this.offsets[e3];
        for (let e4 = 0, i4 = t3.length; e4 < i4; ++e4) {
          const i5 = 5 * e4 + s3, r3 = i5 + 1, n3 = i5 + 2, o3 = i5 + 3, g3 = i5 + 4;
          if (29 !== a3[i5] || 0 !== a3[r3] || 0 !== a3[n3] || 0 !== a3[o3] || 0 !== a3[g3])
            throw new FormatError("writing to an offset that is not empty");
          const c3 = t3[e4];
          a3[i5] = 29;
          a3[r3] = c3 >> 24 & 255;
          a3[n3] = c3 >> 16 & 255;
          a3[o3] = c3 >> 8 & 255;
          a3[g3] = 255 & c3;
        }
      }
    };
    CFFCompiler = class _CFFCompiler {
      constructor(e3) {
        this.cff = e3;
      }
      compile() {
        const e3 = this.cff, t3 = { data: [], length: 0, add(e4) {
          try {
            this.data.push(...e4);
          } catch {
            this.data = this.data.concat(e4);
          }
          this.length = this.data.length;
        } }, i3 = this.compileHeader(e3.header);
        t3.add(i3);
        const a3 = this.compileNameIndex(e3.names);
        t3.add(a3);
        if (e3.isCIDFont && e3.topDict.hasName("FontMatrix")) {
          const t4 = e3.topDict.getByName("FontMatrix");
          e3.topDict.removeByName("FontMatrix");
          for (const i4 of e3.fdArray) {
            let e4 = t4.slice(0);
            i4.hasName("FontMatrix") && (e4 = Util.transform(e4, i4.getByName("FontMatrix")));
            i4.setByName("FontMatrix", e4);
          }
        }
        const s3 = e3.topDict.getByName("XUID");
        (s3 == null ? void 0 : s3.length) > 16 && e3.topDict.removeByName("XUID");
        e3.topDict.setByName("charset", 0);
        let r3 = this.compileTopDicts([e3.topDict], t3.length, e3.isCIDFont);
        t3.add(r3.output);
        const n3 = r3.trackers[0], o3 = this.compileStringIndex(e3.strings.strings);
        t3.add(o3);
        const g3 = this.compileIndex(e3.globalSubrIndex);
        t3.add(g3);
        if (e3.encoding && e3.topDict.hasName("Encoding"))
          if (e3.encoding.predefined)
            n3.setEntryLocation("Encoding", [e3.encoding.format], t3);
          else {
            const i4 = this.compileEncoding(e3.encoding);
            n3.setEntryLocation("Encoding", [t3.length], t3);
            t3.add(i4);
          }
        const c3 = this.compileCharset(e3.charset, e3.charStrings.count, e3.strings, e3.isCIDFont);
        n3.setEntryLocation("charset", [t3.length], t3);
        t3.add(c3);
        const C3 = this.compileCharStrings(e3.charStrings);
        n3.setEntryLocation("CharStrings", [t3.length], t3);
        t3.add(C3);
        if (e3.isCIDFont) {
          n3.setEntryLocation("FDSelect", [t3.length], t3);
          const i4 = this.compileFDSelect(e3.fdSelect);
          t3.add(i4);
          r3 = this.compileTopDicts(e3.fdArray, t3.length, true);
          n3.setEntryLocation("FDArray", [t3.length], t3);
          t3.add(r3.output);
          const a4 = r3.trackers;
          this.compilePrivateDicts(e3.fdArray, a4, t3);
        }
        this.compilePrivateDicts([e3.topDict], [n3], t3);
        t3.add([0]);
        return t3.data;
      }
      encodeNumber(e3) {
        return Number.isInteger(e3) ? this.encodeInteger(e3) : this.encodeFloat(e3);
      }
      static get EncodeFloatRegExp() {
        return shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
      }
      encodeFloat(e3) {
        let t3 = e3.toString();
        const i3 = _CFFCompiler.EncodeFloatRegExp.exec(t3);
        if (i3) {
          const a4 = parseFloat("1e" + ((i3[2] ? +i3[2] : 0) + i3[1].length));
          t3 = (Math.round(e3 * a4) / a4).toString();
        }
        let a3, s3, r3 = "";
        for (a3 = 0, s3 = t3.length; a3 < s3; ++a3) {
          const e4 = t3[a3];
          r3 += "e" === e4 ? "-" === t3[++a3] ? "c" : "b" : "." === e4 ? "a" : "-" === e4 ? "e" : e4;
        }
        r3 += 1 & r3.length ? "f" : "ff";
        const n3 = [30];
        for (a3 = 0, s3 = r3.length; a3 < s3; a3 += 2)
          n3.push(parseInt(r3.substring(a3, a3 + 2), 16));
        return n3;
      }
      encodeInteger(e3) {
        let t3;
        t3 = e3 >= -107 && e3 <= 107 ? [e3 + 139] : e3 >= 108 && e3 <= 1131 ? [247 + ((e3 -= 108) >> 8), 255 & e3] : e3 >= -1131 && e3 <= -108 ? [251 + ((e3 = -e3 - 108) >> 8), 255 & e3] : e3 >= -32768 && e3 <= 32767 ? [28, e3 >> 8 & 255, 255 & e3] : [29, e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
        return t3;
      }
      compileHeader(e3) {
        return [e3.major, e3.minor, 4, e3.offSize];
      }
      compileNameIndex(e3) {
        const t3 = new CFFIndex();
        for (const i3 of e3) {
          const e4 = Math.min(i3.length, 127);
          let a3 = new Array(e4);
          for (let t4 = 0; t4 < e4; t4++) {
            let e5 = i3[t4];
            (e5 < "!" || e5 > "~" || "[" === e5 || "]" === e5 || "(" === e5 || ")" === e5 || "{" === e5 || "}" === e5 || "<" === e5 || ">" === e5 || "/" === e5 || "%" === e5) && (e5 = "_");
            a3[t4] = e5;
          }
          a3 = a3.join("");
          "" === a3 && (a3 = "Bad_Font_Name");
          t3.add(stringToBytes(a3));
        }
        return this.compileIndex(t3);
      }
      compileTopDicts(e3, t3, i3) {
        const a3 = [];
        let s3 = new CFFIndex();
        for (const r3 of e3) {
          if (i3) {
            r3.removeByName("CIDFontVersion");
            r3.removeByName("CIDFontRevision");
            r3.removeByName("CIDFontType");
            r3.removeByName("CIDCount");
            r3.removeByName("UIDBase");
          }
          const e4 = new CFFOffsetTracker(), n3 = this.compileDict(r3, e4);
          a3.push(e4);
          s3.add(n3);
          e4.offset(t3);
        }
        s3 = this.compileIndex(s3, a3);
        return { trackers: a3, output: s3 };
      }
      compilePrivateDicts(e3, t3, i3) {
        for (let a3 = 0, s3 = e3.length; a3 < s3; ++a3) {
          const s4 = e3[a3], r3 = s4.privateDict;
          if (!r3 || !s4.hasName("Private"))
            throw new FormatError("There must be a private dictionary.");
          const n3 = new CFFOffsetTracker(), o3 = this.compileDict(r3, n3);
          let g3 = i3.length;
          n3.offset(g3);
          o3.length || (g3 = 0);
          t3[a3].setEntryLocation("Private", [o3.length, g3], i3);
          i3.add(o3);
          if (r3.subrsIndex && r3.hasName("Subrs")) {
            const e4 = this.compileIndex(r3.subrsIndex);
            n3.setEntryLocation("Subrs", [o3.length], i3);
            i3.add(e4);
          }
        }
      }
      compileDict(e3, t3) {
        const i3 = [];
        for (const a3 of e3.order) {
          if (!(a3 in e3.values))
            continue;
          let s3 = e3.values[a3], r3 = e3.types[a3];
          Array.isArray(r3) || (r3 = [r3]);
          Array.isArray(s3) || (s3 = [s3]);
          if (0 !== s3.length) {
            for (let n3 = 0, o3 = r3.length; n3 < o3; ++n3) {
              const o4 = r3[n3], g3 = s3[n3];
              switch (o4) {
                case "num":
                case "sid":
                  i3.push(...this.encodeNumber(g3));
                  break;
                case "offset":
                  const r4 = e3.keyToNameMap[a3];
                  t3.isTracking(r4) || t3.track(r4, i3.length);
                  i3.push(29, 0, 0, 0, 0);
                  break;
                case "array":
                case "delta":
                  i3.push(...this.encodeNumber(g3));
                  for (let e4 = 1, t4 = s3.length; e4 < t4; ++e4)
                    i3.push(...this.encodeNumber(s3[e4]));
                  break;
                default:
                  throw new FormatError(`Unknown data type of ${o4}`);
              }
            }
            i3.push(...e3.opcodes[a3]);
          }
        }
        return i3;
      }
      compileStringIndex(e3) {
        const t3 = new CFFIndex();
        for (const i3 of e3)
          t3.add(stringToBytes(i3));
        return this.compileIndex(t3);
      }
      compileCharStrings(e3) {
        const t3 = new CFFIndex();
        for (let i3 = 0; i3 < e3.count; i3++) {
          const a3 = e3.get(i3);
          0 !== a3.length ? t3.add(a3) : t3.add(new Uint8Array([139, 14]));
        }
        return this.compileIndex(t3);
      }
      compileCharset(e3, t3, i3, a3) {
        let s3;
        const r3 = t3 - 1;
        if (a3)
          s3 = new Uint8Array([2, 0, 0, r3 >> 8 & 255, 255 & r3]);
        else {
          s3 = new Uint8Array(1 + 2 * r3);
          s3[0] = 0;
          let t4 = 0;
          const a4 = e3.charset.length;
          let n3 = false;
          for (let r4 = 1; r4 < s3.length; r4 += 2) {
            let o3 = 0;
            if (t4 < a4) {
              const a5 = e3.charset[t4++];
              o3 = i3.getSID(a5);
              if (-1 === o3) {
                o3 = 0;
                if (!n3) {
                  n3 = true;
                  warn(`Couldn't find ${a5} in CFF strings`);
                }
              }
            }
            s3[r4] = o3 >> 8 & 255;
            s3[r4 + 1] = 255 & o3;
          }
        }
        return this.compileTypedArray(s3);
      }
      compileEncoding(e3) {
        return this.compileTypedArray(e3.raw);
      }
      compileFDSelect(e3) {
        const t3 = e3.format;
        let i3, a3;
        switch (t3) {
          case 0:
            i3 = new Uint8Array(1 + e3.fdSelect.length);
            i3[0] = t3;
            for (a3 = 0; a3 < e3.fdSelect.length; a3++)
              i3[a3 + 1] = e3.fdSelect[a3];
            break;
          case 3:
            const s3 = 0;
            let r3 = e3.fdSelect[0];
            const n3 = [t3, 0, 0, s3 >> 8 & 255, 255 & s3, r3];
            for (a3 = 1; a3 < e3.fdSelect.length; a3++) {
              const t4 = e3.fdSelect[a3];
              if (t4 !== r3) {
                n3.push(a3 >> 8 & 255, 255 & a3, t4);
                r3 = t4;
              }
            }
            const o3 = (n3.length - 3) / 3;
            n3[1] = o3 >> 8 & 255;
            n3[2] = 255 & o3;
            n3.push(a3 >> 8 & 255, 255 & a3);
            i3 = new Uint8Array(n3);
        }
        return this.compileTypedArray(i3);
      }
      compileTypedArray(e3) {
        return Array.from(e3);
      }
      compileIndex(e3, t3 = []) {
        const i3 = e3.objects, a3 = i3.length;
        if (0 === a3)
          return [0, 0];
        const s3 = [a3 >> 8 & 255, 255 & a3];
        let r3, n3, o3 = 1;
        for (r3 = 0; r3 < a3; ++r3)
          o3 += i3[r3].length;
        n3 = o3 < 256 ? 1 : o3 < 65536 ? 2 : o3 < 16777216 ? 3 : 4;
        s3.push(n3);
        let g3 = 1;
        for (r3 = 0; r3 < a3 + 1; r3++) {
          1 === n3 ? s3.push(255 & g3) : 2 === n3 ? s3.push(g3 >> 8 & 255, 255 & g3) : 3 === n3 ? s3.push(g3 >> 16 & 255, g3 >> 8 & 255, 255 & g3) : s3.push(g3 >>> 24 & 255, g3 >> 16 & 255, g3 >> 8 & 255, 255 & g3);
          i3[r3] && (g3 += i3[r3].length);
        }
        for (r3 = 0; r3 < a3; r3++) {
          t3[r3] && t3[r3].offset(s3.length);
          s3.push(...i3[r3]);
        }
        return s3;
      }
    };
    Ri = getLookupTableFactory(function(e3) {
      e3.A = 65;
      e3.AE = 198;
      e3.AEacute = 508;
      e3.AEmacron = 482;
      e3.AEsmall = 63462;
      e3.Aacute = 193;
      e3.Aacutesmall = 63457;
      e3.Abreve = 258;
      e3.Abreveacute = 7854;
      e3.Abrevecyrillic = 1232;
      e3.Abrevedotbelow = 7862;
      e3.Abrevegrave = 7856;
      e3.Abrevehookabove = 7858;
      e3.Abrevetilde = 7860;
      e3.Acaron = 461;
      e3.Acircle = 9398;
      e3.Acircumflex = 194;
      e3.Acircumflexacute = 7844;
      e3.Acircumflexdotbelow = 7852;
      e3.Acircumflexgrave = 7846;
      e3.Acircumflexhookabove = 7848;
      e3.Acircumflexsmall = 63458;
      e3.Acircumflextilde = 7850;
      e3.Acute = 63177;
      e3.Acutesmall = 63412;
      e3.Acyrillic = 1040;
      e3.Adblgrave = 512;
      e3.Adieresis = 196;
      e3.Adieresiscyrillic = 1234;
      e3.Adieresismacron = 478;
      e3.Adieresissmall = 63460;
      e3.Adotbelow = 7840;
      e3.Adotmacron = 480;
      e3.Agrave = 192;
      e3.Agravesmall = 63456;
      e3.Ahookabove = 7842;
      e3.Aiecyrillic = 1236;
      e3.Ainvertedbreve = 514;
      e3.Alpha = 913;
      e3.Alphatonos = 902;
      e3.Amacron = 256;
      e3.Amonospace = 65313;
      e3.Aogonek = 260;
      e3.Aring = 197;
      e3.Aringacute = 506;
      e3.Aringbelow = 7680;
      e3.Aringsmall = 63461;
      e3.Asmall = 63329;
      e3.Atilde = 195;
      e3.Atildesmall = 63459;
      e3.Aybarmenian = 1329;
      e3.B = 66;
      e3.Bcircle = 9399;
      e3.Bdotaccent = 7682;
      e3.Bdotbelow = 7684;
      e3.Becyrillic = 1041;
      e3.Benarmenian = 1330;
      e3.Beta = 914;
      e3.Bhook = 385;
      e3.Blinebelow = 7686;
      e3.Bmonospace = 65314;
      e3.Brevesmall = 63220;
      e3.Bsmall = 63330;
      e3.Btopbar = 386;
      e3.C = 67;
      e3.Caarmenian = 1342;
      e3.Cacute = 262;
      e3.Caron = 63178;
      e3.Caronsmall = 63221;
      e3.Ccaron = 268;
      e3.Ccedilla = 199;
      e3.Ccedillaacute = 7688;
      e3.Ccedillasmall = 63463;
      e3.Ccircle = 9400;
      e3.Ccircumflex = 264;
      e3.Cdot = 266;
      e3.Cdotaccent = 266;
      e3.Cedillasmall = 63416;
      e3.Chaarmenian = 1353;
      e3.Cheabkhasiancyrillic = 1212;
      e3.Checyrillic = 1063;
      e3.Chedescenderabkhasiancyrillic = 1214;
      e3.Chedescendercyrillic = 1206;
      e3.Chedieresiscyrillic = 1268;
      e3.Cheharmenian = 1347;
      e3.Chekhakassiancyrillic = 1227;
      e3.Cheverticalstrokecyrillic = 1208;
      e3.Chi = 935;
      e3.Chook = 391;
      e3.Circumflexsmall = 63222;
      e3.Cmonospace = 65315;
      e3.Coarmenian = 1361;
      e3.Csmall = 63331;
      e3.D = 68;
      e3.DZ = 497;
      e3.DZcaron = 452;
      e3.Daarmenian = 1332;
      e3.Dafrican = 393;
      e3.Dcaron = 270;
      e3.Dcedilla = 7696;
      e3.Dcircle = 9401;
      e3.Dcircumflexbelow = 7698;
      e3.Dcroat = 272;
      e3.Ddotaccent = 7690;
      e3.Ddotbelow = 7692;
      e3.Decyrillic = 1044;
      e3.Deicoptic = 1006;
      e3.Delta = 8710;
      e3.Deltagreek = 916;
      e3.Dhook = 394;
      e3.Dieresis = 63179;
      e3.DieresisAcute = 63180;
      e3.DieresisGrave = 63181;
      e3.Dieresissmall = 63400;
      e3.Digammagreek = 988;
      e3.Djecyrillic = 1026;
      e3.Dlinebelow = 7694;
      e3.Dmonospace = 65316;
      e3.Dotaccentsmall = 63223;
      e3.Dslash = 272;
      e3.Dsmall = 63332;
      e3.Dtopbar = 395;
      e3.Dz = 498;
      e3.Dzcaron = 453;
      e3.Dzeabkhasiancyrillic = 1248;
      e3.Dzecyrillic = 1029;
      e3.Dzhecyrillic = 1039;
      e3.E = 69;
      e3.Eacute = 201;
      e3.Eacutesmall = 63465;
      e3.Ebreve = 276;
      e3.Ecaron = 282;
      e3.Ecedillabreve = 7708;
      e3.Echarmenian = 1333;
      e3.Ecircle = 9402;
      e3.Ecircumflex = 202;
      e3.Ecircumflexacute = 7870;
      e3.Ecircumflexbelow = 7704;
      e3.Ecircumflexdotbelow = 7878;
      e3.Ecircumflexgrave = 7872;
      e3.Ecircumflexhookabove = 7874;
      e3.Ecircumflexsmall = 63466;
      e3.Ecircumflextilde = 7876;
      e3.Ecyrillic = 1028;
      e3.Edblgrave = 516;
      e3.Edieresis = 203;
      e3.Edieresissmall = 63467;
      e3.Edot = 278;
      e3.Edotaccent = 278;
      e3.Edotbelow = 7864;
      e3.Efcyrillic = 1060;
      e3.Egrave = 200;
      e3.Egravesmall = 63464;
      e3.Eharmenian = 1335;
      e3.Ehookabove = 7866;
      e3.Eightroman = 8551;
      e3.Einvertedbreve = 518;
      e3.Eiotifiedcyrillic = 1124;
      e3.Elcyrillic = 1051;
      e3.Elevenroman = 8554;
      e3.Emacron = 274;
      e3.Emacronacute = 7702;
      e3.Emacrongrave = 7700;
      e3.Emcyrillic = 1052;
      e3.Emonospace = 65317;
      e3.Encyrillic = 1053;
      e3.Endescendercyrillic = 1186;
      e3.Eng = 330;
      e3.Enghecyrillic = 1188;
      e3.Enhookcyrillic = 1223;
      e3.Eogonek = 280;
      e3.Eopen = 400;
      e3.Epsilon = 917;
      e3.Epsilontonos = 904;
      e3.Ercyrillic = 1056;
      e3.Ereversed = 398;
      e3.Ereversedcyrillic = 1069;
      e3.Escyrillic = 1057;
      e3.Esdescendercyrillic = 1194;
      e3.Esh = 425;
      e3.Esmall = 63333;
      e3.Eta = 919;
      e3.Etarmenian = 1336;
      e3.Etatonos = 905;
      e3.Eth = 208;
      e3.Ethsmall = 63472;
      e3.Etilde = 7868;
      e3.Etildebelow = 7706;
      e3.Euro = 8364;
      e3.Ezh = 439;
      e3.Ezhcaron = 494;
      e3.Ezhreversed = 440;
      e3.F = 70;
      e3.Fcircle = 9403;
      e3.Fdotaccent = 7710;
      e3.Feharmenian = 1366;
      e3.Feicoptic = 996;
      e3.Fhook = 401;
      e3.Fitacyrillic = 1138;
      e3.Fiveroman = 8548;
      e3.Fmonospace = 65318;
      e3.Fourroman = 8547;
      e3.Fsmall = 63334;
      e3.G = 71;
      e3.GBsquare = 13191;
      e3.Gacute = 500;
      e3.Gamma = 915;
      e3.Gammaafrican = 404;
      e3.Gangiacoptic = 1002;
      e3.Gbreve = 286;
      e3.Gcaron = 486;
      e3.Gcedilla = 290;
      e3.Gcircle = 9404;
      e3.Gcircumflex = 284;
      e3.Gcommaaccent = 290;
      e3.Gdot = 288;
      e3.Gdotaccent = 288;
      e3.Gecyrillic = 1043;
      e3.Ghadarmenian = 1346;
      e3.Ghemiddlehookcyrillic = 1172;
      e3.Ghestrokecyrillic = 1170;
      e3.Gheupturncyrillic = 1168;
      e3.Ghook = 403;
      e3.Gimarmenian = 1331;
      e3.Gjecyrillic = 1027;
      e3.Gmacron = 7712;
      e3.Gmonospace = 65319;
      e3.Grave = 63182;
      e3.Gravesmall = 63328;
      e3.Gsmall = 63335;
      e3.Gsmallhook = 667;
      e3.Gstroke = 484;
      e3.H = 72;
      e3.H18533 = 9679;
      e3.H18543 = 9642;
      e3.H18551 = 9643;
      e3.H22073 = 9633;
      e3.HPsquare = 13259;
      e3.Haabkhasiancyrillic = 1192;
      e3.Hadescendercyrillic = 1202;
      e3.Hardsigncyrillic = 1066;
      e3.Hbar = 294;
      e3.Hbrevebelow = 7722;
      e3.Hcedilla = 7720;
      e3.Hcircle = 9405;
      e3.Hcircumflex = 292;
      e3.Hdieresis = 7718;
      e3.Hdotaccent = 7714;
      e3.Hdotbelow = 7716;
      e3.Hmonospace = 65320;
      e3.Hoarmenian = 1344;
      e3.Horicoptic = 1e3;
      e3.Hsmall = 63336;
      e3.Hungarumlaut = 63183;
      e3.Hungarumlautsmall = 63224;
      e3.Hzsquare = 13200;
      e3.I = 73;
      e3.IAcyrillic = 1071;
      e3.IJ = 306;
      e3.IUcyrillic = 1070;
      e3.Iacute = 205;
      e3.Iacutesmall = 63469;
      e3.Ibreve = 300;
      e3.Icaron = 463;
      e3.Icircle = 9406;
      e3.Icircumflex = 206;
      e3.Icircumflexsmall = 63470;
      e3.Icyrillic = 1030;
      e3.Idblgrave = 520;
      e3.Idieresis = 207;
      e3.Idieresisacute = 7726;
      e3.Idieresiscyrillic = 1252;
      e3.Idieresissmall = 63471;
      e3.Idot = 304;
      e3.Idotaccent = 304;
      e3.Idotbelow = 7882;
      e3.Iebrevecyrillic = 1238;
      e3.Iecyrillic = 1045;
      e3.Ifraktur = 8465;
      e3.Igrave = 204;
      e3.Igravesmall = 63468;
      e3.Ihookabove = 7880;
      e3.Iicyrillic = 1048;
      e3.Iinvertedbreve = 522;
      e3.Iishortcyrillic = 1049;
      e3.Imacron = 298;
      e3.Imacroncyrillic = 1250;
      e3.Imonospace = 65321;
      e3.Iniarmenian = 1339;
      e3.Iocyrillic = 1025;
      e3.Iogonek = 302;
      e3.Iota = 921;
      e3.Iotaafrican = 406;
      e3.Iotadieresis = 938;
      e3.Iotatonos = 906;
      e3.Ismall = 63337;
      e3.Istroke = 407;
      e3.Itilde = 296;
      e3.Itildebelow = 7724;
      e3.Izhitsacyrillic = 1140;
      e3.Izhitsadblgravecyrillic = 1142;
      e3.J = 74;
      e3.Jaarmenian = 1345;
      e3.Jcircle = 9407;
      e3.Jcircumflex = 308;
      e3.Jecyrillic = 1032;
      e3.Jheharmenian = 1355;
      e3.Jmonospace = 65322;
      e3.Jsmall = 63338;
      e3.K = 75;
      e3.KBsquare = 13189;
      e3.KKsquare = 13261;
      e3.Kabashkircyrillic = 1184;
      e3.Kacute = 7728;
      e3.Kacyrillic = 1050;
      e3.Kadescendercyrillic = 1178;
      e3.Kahookcyrillic = 1219;
      e3.Kappa = 922;
      e3.Kastrokecyrillic = 1182;
      e3.Kaverticalstrokecyrillic = 1180;
      e3.Kcaron = 488;
      e3.Kcedilla = 310;
      e3.Kcircle = 9408;
      e3.Kcommaaccent = 310;
      e3.Kdotbelow = 7730;
      e3.Keharmenian = 1364;
      e3.Kenarmenian = 1343;
      e3.Khacyrillic = 1061;
      e3.Kheicoptic = 998;
      e3.Khook = 408;
      e3.Kjecyrillic = 1036;
      e3.Klinebelow = 7732;
      e3.Kmonospace = 65323;
      e3.Koppacyrillic = 1152;
      e3.Koppagreek = 990;
      e3.Ksicyrillic = 1134;
      e3.Ksmall = 63339;
      e3.L = 76;
      e3.LJ = 455;
      e3.LL = 63167;
      e3.Lacute = 313;
      e3.Lambda = 923;
      e3.Lcaron = 317;
      e3.Lcedilla = 315;
      e3.Lcircle = 9409;
      e3.Lcircumflexbelow = 7740;
      e3.Lcommaaccent = 315;
      e3.Ldot = 319;
      e3.Ldotaccent = 319;
      e3.Ldotbelow = 7734;
      e3.Ldotbelowmacron = 7736;
      e3.Liwnarmenian = 1340;
      e3.Lj = 456;
      e3.Ljecyrillic = 1033;
      e3.Llinebelow = 7738;
      e3.Lmonospace = 65324;
      e3.Lslash = 321;
      e3.Lslashsmall = 63225;
      e3.Lsmall = 63340;
      e3.M = 77;
      e3.MBsquare = 13190;
      e3.Macron = 63184;
      e3.Macronsmall = 63407;
      e3.Macute = 7742;
      e3.Mcircle = 9410;
      e3.Mdotaccent = 7744;
      e3.Mdotbelow = 7746;
      e3.Menarmenian = 1348;
      e3.Mmonospace = 65325;
      e3.Msmall = 63341;
      e3.Mturned = 412;
      e3.Mu = 924;
      e3.N = 78;
      e3.NJ = 458;
      e3.Nacute = 323;
      e3.Ncaron = 327;
      e3.Ncedilla = 325;
      e3.Ncircle = 9411;
      e3.Ncircumflexbelow = 7754;
      e3.Ncommaaccent = 325;
      e3.Ndotaccent = 7748;
      e3.Ndotbelow = 7750;
      e3.Nhookleft = 413;
      e3.Nineroman = 8552;
      e3.Nj = 459;
      e3.Njecyrillic = 1034;
      e3.Nlinebelow = 7752;
      e3.Nmonospace = 65326;
      e3.Nowarmenian = 1350;
      e3.Nsmall = 63342;
      e3.Ntilde = 209;
      e3.Ntildesmall = 63473;
      e3.Nu = 925;
      e3.O = 79;
      e3.OE = 338;
      e3.OEsmall = 63226;
      e3.Oacute = 211;
      e3.Oacutesmall = 63475;
      e3.Obarredcyrillic = 1256;
      e3.Obarreddieresiscyrillic = 1258;
      e3.Obreve = 334;
      e3.Ocaron = 465;
      e3.Ocenteredtilde = 415;
      e3.Ocircle = 9412;
      e3.Ocircumflex = 212;
      e3.Ocircumflexacute = 7888;
      e3.Ocircumflexdotbelow = 7896;
      e3.Ocircumflexgrave = 7890;
      e3.Ocircumflexhookabove = 7892;
      e3.Ocircumflexsmall = 63476;
      e3.Ocircumflextilde = 7894;
      e3.Ocyrillic = 1054;
      e3.Odblacute = 336;
      e3.Odblgrave = 524;
      e3.Odieresis = 214;
      e3.Odieresiscyrillic = 1254;
      e3.Odieresissmall = 63478;
      e3.Odotbelow = 7884;
      e3.Ogoneksmall = 63227;
      e3.Ograve = 210;
      e3.Ogravesmall = 63474;
      e3.Oharmenian = 1365;
      e3.Ohm = 8486;
      e3.Ohookabove = 7886;
      e3.Ohorn = 416;
      e3.Ohornacute = 7898;
      e3.Ohorndotbelow = 7906;
      e3.Ohorngrave = 7900;
      e3.Ohornhookabove = 7902;
      e3.Ohorntilde = 7904;
      e3.Ohungarumlaut = 336;
      e3.Oi = 418;
      e3.Oinvertedbreve = 526;
      e3.Omacron = 332;
      e3.Omacronacute = 7762;
      e3.Omacrongrave = 7760;
      e3.Omega = 8486;
      e3.Omegacyrillic = 1120;
      e3.Omegagreek = 937;
      e3.Omegaroundcyrillic = 1146;
      e3.Omegatitlocyrillic = 1148;
      e3.Omegatonos = 911;
      e3.Omicron = 927;
      e3.Omicrontonos = 908;
      e3.Omonospace = 65327;
      e3.Oneroman = 8544;
      e3.Oogonek = 490;
      e3.Oogonekmacron = 492;
      e3.Oopen = 390;
      e3.Oslash = 216;
      e3.Oslashacute = 510;
      e3.Oslashsmall = 63480;
      e3.Osmall = 63343;
      e3.Ostrokeacute = 510;
      e3.Otcyrillic = 1150;
      e3.Otilde = 213;
      e3.Otildeacute = 7756;
      e3.Otildedieresis = 7758;
      e3.Otildesmall = 63477;
      e3.P = 80;
      e3.Pacute = 7764;
      e3.Pcircle = 9413;
      e3.Pdotaccent = 7766;
      e3.Pecyrillic = 1055;
      e3.Peharmenian = 1354;
      e3.Pemiddlehookcyrillic = 1190;
      e3.Phi = 934;
      e3.Phook = 420;
      e3.Pi = 928;
      e3.Piwrarmenian = 1363;
      e3.Pmonospace = 65328;
      e3.Psi = 936;
      e3.Psicyrillic = 1136;
      e3.Psmall = 63344;
      e3.Q = 81;
      e3.Qcircle = 9414;
      e3.Qmonospace = 65329;
      e3.Qsmall = 63345;
      e3.R = 82;
      e3.Raarmenian = 1356;
      e3.Racute = 340;
      e3.Rcaron = 344;
      e3.Rcedilla = 342;
      e3.Rcircle = 9415;
      e3.Rcommaaccent = 342;
      e3.Rdblgrave = 528;
      e3.Rdotaccent = 7768;
      e3.Rdotbelow = 7770;
      e3.Rdotbelowmacron = 7772;
      e3.Reharmenian = 1360;
      e3.Rfraktur = 8476;
      e3.Rho = 929;
      e3.Ringsmall = 63228;
      e3.Rinvertedbreve = 530;
      e3.Rlinebelow = 7774;
      e3.Rmonospace = 65330;
      e3.Rsmall = 63346;
      e3.Rsmallinverted = 641;
      e3.Rsmallinvertedsuperior = 694;
      e3.S = 83;
      e3.SF010000 = 9484;
      e3.SF020000 = 9492;
      e3.SF030000 = 9488;
      e3.SF040000 = 9496;
      e3.SF050000 = 9532;
      e3.SF060000 = 9516;
      e3.SF070000 = 9524;
      e3.SF080000 = 9500;
      e3.SF090000 = 9508;
      e3.SF100000 = 9472;
      e3.SF110000 = 9474;
      e3.SF190000 = 9569;
      e3.SF200000 = 9570;
      e3.SF210000 = 9558;
      e3.SF220000 = 9557;
      e3.SF230000 = 9571;
      e3.SF240000 = 9553;
      e3.SF250000 = 9559;
      e3.SF260000 = 9565;
      e3.SF270000 = 9564;
      e3.SF280000 = 9563;
      e3.SF360000 = 9566;
      e3.SF370000 = 9567;
      e3.SF380000 = 9562;
      e3.SF390000 = 9556;
      e3.SF400000 = 9577;
      e3.SF410000 = 9574;
      e3.SF420000 = 9568;
      e3.SF430000 = 9552;
      e3.SF440000 = 9580;
      e3.SF450000 = 9575;
      e3.SF460000 = 9576;
      e3.SF470000 = 9572;
      e3.SF480000 = 9573;
      e3.SF490000 = 9561;
      e3.SF500000 = 9560;
      e3.SF510000 = 9554;
      e3.SF520000 = 9555;
      e3.SF530000 = 9579;
      e3.SF540000 = 9578;
      e3.Sacute = 346;
      e3.Sacutedotaccent = 7780;
      e3.Sampigreek = 992;
      e3.Scaron = 352;
      e3.Scarondotaccent = 7782;
      e3.Scaronsmall = 63229;
      e3.Scedilla = 350;
      e3.Schwa = 399;
      e3.Schwacyrillic = 1240;
      e3.Schwadieresiscyrillic = 1242;
      e3.Scircle = 9416;
      e3.Scircumflex = 348;
      e3.Scommaaccent = 536;
      e3.Sdotaccent = 7776;
      e3.Sdotbelow = 7778;
      e3.Sdotbelowdotaccent = 7784;
      e3.Seharmenian = 1357;
      e3.Sevenroman = 8550;
      e3.Shaarmenian = 1351;
      e3.Shacyrillic = 1064;
      e3.Shchacyrillic = 1065;
      e3.Sheicoptic = 994;
      e3.Shhacyrillic = 1210;
      e3.Shimacoptic = 1004;
      e3.Sigma = 931;
      e3.Sixroman = 8549;
      e3.Smonospace = 65331;
      e3.Softsigncyrillic = 1068;
      e3.Ssmall = 63347;
      e3.Stigmagreek = 986;
      e3.T = 84;
      e3.Tau = 932;
      e3.Tbar = 358;
      e3.Tcaron = 356;
      e3.Tcedilla = 354;
      e3.Tcircle = 9417;
      e3.Tcircumflexbelow = 7792;
      e3.Tcommaaccent = 354;
      e3.Tdotaccent = 7786;
      e3.Tdotbelow = 7788;
      e3.Tecyrillic = 1058;
      e3.Tedescendercyrillic = 1196;
      e3.Tenroman = 8553;
      e3.Tetsecyrillic = 1204;
      e3.Theta = 920;
      e3.Thook = 428;
      e3.Thorn = 222;
      e3.Thornsmall = 63486;
      e3.Threeroman = 8546;
      e3.Tildesmall = 63230;
      e3.Tiwnarmenian = 1359;
      e3.Tlinebelow = 7790;
      e3.Tmonospace = 65332;
      e3.Toarmenian = 1337;
      e3.Tonefive = 444;
      e3.Tonesix = 388;
      e3.Tonetwo = 423;
      e3.Tretroflexhook = 430;
      e3.Tsecyrillic = 1062;
      e3.Tshecyrillic = 1035;
      e3.Tsmall = 63348;
      e3.Twelveroman = 8555;
      e3.Tworoman = 8545;
      e3.U = 85;
      e3.Uacute = 218;
      e3.Uacutesmall = 63482;
      e3.Ubreve = 364;
      e3.Ucaron = 467;
      e3.Ucircle = 9418;
      e3.Ucircumflex = 219;
      e3.Ucircumflexbelow = 7798;
      e3.Ucircumflexsmall = 63483;
      e3.Ucyrillic = 1059;
      e3.Udblacute = 368;
      e3.Udblgrave = 532;
      e3.Udieresis = 220;
      e3.Udieresisacute = 471;
      e3.Udieresisbelow = 7794;
      e3.Udieresiscaron = 473;
      e3.Udieresiscyrillic = 1264;
      e3.Udieresisgrave = 475;
      e3.Udieresismacron = 469;
      e3.Udieresissmall = 63484;
      e3.Udotbelow = 7908;
      e3.Ugrave = 217;
      e3.Ugravesmall = 63481;
      e3.Uhookabove = 7910;
      e3.Uhorn = 431;
      e3.Uhornacute = 7912;
      e3.Uhorndotbelow = 7920;
      e3.Uhorngrave = 7914;
      e3.Uhornhookabove = 7916;
      e3.Uhorntilde = 7918;
      e3.Uhungarumlaut = 368;
      e3.Uhungarumlautcyrillic = 1266;
      e3.Uinvertedbreve = 534;
      e3.Ukcyrillic = 1144;
      e3.Umacron = 362;
      e3.Umacroncyrillic = 1262;
      e3.Umacrondieresis = 7802;
      e3.Umonospace = 65333;
      e3.Uogonek = 370;
      e3.Upsilon = 933;
      e3.Upsilon1 = 978;
      e3.Upsilonacutehooksymbolgreek = 979;
      e3.Upsilonafrican = 433;
      e3.Upsilondieresis = 939;
      e3.Upsilondieresishooksymbolgreek = 980;
      e3.Upsilonhooksymbol = 978;
      e3.Upsilontonos = 910;
      e3.Uring = 366;
      e3.Ushortcyrillic = 1038;
      e3.Usmall = 63349;
      e3.Ustraightcyrillic = 1198;
      e3.Ustraightstrokecyrillic = 1200;
      e3.Utilde = 360;
      e3.Utildeacute = 7800;
      e3.Utildebelow = 7796;
      e3.V = 86;
      e3.Vcircle = 9419;
      e3.Vdotbelow = 7806;
      e3.Vecyrillic = 1042;
      e3.Vewarmenian = 1358;
      e3.Vhook = 434;
      e3.Vmonospace = 65334;
      e3.Voarmenian = 1352;
      e3.Vsmall = 63350;
      e3.Vtilde = 7804;
      e3.W = 87;
      e3.Wacute = 7810;
      e3.Wcircle = 9420;
      e3.Wcircumflex = 372;
      e3.Wdieresis = 7812;
      e3.Wdotaccent = 7814;
      e3.Wdotbelow = 7816;
      e3.Wgrave = 7808;
      e3.Wmonospace = 65335;
      e3.Wsmall = 63351;
      e3.X = 88;
      e3.Xcircle = 9421;
      e3.Xdieresis = 7820;
      e3.Xdotaccent = 7818;
      e3.Xeharmenian = 1341;
      e3.Xi = 926;
      e3.Xmonospace = 65336;
      e3.Xsmall = 63352;
      e3.Y = 89;
      e3.Yacute = 221;
      e3.Yacutesmall = 63485;
      e3.Yatcyrillic = 1122;
      e3.Ycircle = 9422;
      e3.Ycircumflex = 374;
      e3.Ydieresis = 376;
      e3.Ydieresissmall = 63487;
      e3.Ydotaccent = 7822;
      e3.Ydotbelow = 7924;
      e3.Yericyrillic = 1067;
      e3.Yerudieresiscyrillic = 1272;
      e3.Ygrave = 7922;
      e3.Yhook = 435;
      e3.Yhookabove = 7926;
      e3.Yiarmenian = 1349;
      e3.Yicyrillic = 1031;
      e3.Yiwnarmenian = 1362;
      e3.Ymonospace = 65337;
      e3.Ysmall = 63353;
      e3.Ytilde = 7928;
      e3.Yusbigcyrillic = 1130;
      e3.Yusbigiotifiedcyrillic = 1132;
      e3.Yuslittlecyrillic = 1126;
      e3.Yuslittleiotifiedcyrillic = 1128;
      e3.Z = 90;
      e3.Zaarmenian = 1334;
      e3.Zacute = 377;
      e3.Zcaron = 381;
      e3.Zcaronsmall = 63231;
      e3.Zcircle = 9423;
      e3.Zcircumflex = 7824;
      e3.Zdot = 379;
      e3.Zdotaccent = 379;
      e3.Zdotbelow = 7826;
      e3.Zecyrillic = 1047;
      e3.Zedescendercyrillic = 1176;
      e3.Zedieresiscyrillic = 1246;
      e3.Zeta = 918;
      e3.Zhearmenian = 1338;
      e3.Zhebrevecyrillic = 1217;
      e3.Zhecyrillic = 1046;
      e3.Zhedescendercyrillic = 1174;
      e3.Zhedieresiscyrillic = 1244;
      e3.Zlinebelow = 7828;
      e3.Zmonospace = 65338;
      e3.Zsmall = 63354;
      e3.Zstroke = 437;
      e3.a = 97;
      e3.aabengali = 2438;
      e3.aacute = 225;
      e3.aadeva = 2310;
      e3.aagujarati = 2694;
      e3.aagurmukhi = 2566;
      e3.aamatragurmukhi = 2622;
      e3.aarusquare = 13059;
      e3.aavowelsignbengali = 2494;
      e3.aavowelsigndeva = 2366;
      e3.aavowelsigngujarati = 2750;
      e3.abbreviationmarkarmenian = 1375;
      e3.abbreviationsigndeva = 2416;
      e3.abengali = 2437;
      e3.abopomofo = 12570;
      e3.abreve = 259;
      e3.abreveacute = 7855;
      e3.abrevecyrillic = 1233;
      e3.abrevedotbelow = 7863;
      e3.abrevegrave = 7857;
      e3.abrevehookabove = 7859;
      e3.abrevetilde = 7861;
      e3.acaron = 462;
      e3.acircle = 9424;
      e3.acircumflex = 226;
      e3.acircumflexacute = 7845;
      e3.acircumflexdotbelow = 7853;
      e3.acircumflexgrave = 7847;
      e3.acircumflexhookabove = 7849;
      e3.acircumflextilde = 7851;
      e3.acute = 180;
      e3.acutebelowcmb = 791;
      e3.acutecmb = 769;
      e3.acutecomb = 769;
      e3.acutedeva = 2388;
      e3.acutelowmod = 719;
      e3.acutetonecmb = 833;
      e3.acyrillic = 1072;
      e3.adblgrave = 513;
      e3.addakgurmukhi = 2673;
      e3.adeva = 2309;
      e3.adieresis = 228;
      e3.adieresiscyrillic = 1235;
      e3.adieresismacron = 479;
      e3.adotbelow = 7841;
      e3.adotmacron = 481;
      e3.ae = 230;
      e3.aeacute = 509;
      e3.aekorean = 12624;
      e3.aemacron = 483;
      e3.afii00208 = 8213;
      e3.afii08941 = 8356;
      e3.afii10017 = 1040;
      e3.afii10018 = 1041;
      e3.afii10019 = 1042;
      e3.afii10020 = 1043;
      e3.afii10021 = 1044;
      e3.afii10022 = 1045;
      e3.afii10023 = 1025;
      e3.afii10024 = 1046;
      e3.afii10025 = 1047;
      e3.afii10026 = 1048;
      e3.afii10027 = 1049;
      e3.afii10028 = 1050;
      e3.afii10029 = 1051;
      e3.afii10030 = 1052;
      e3.afii10031 = 1053;
      e3.afii10032 = 1054;
      e3.afii10033 = 1055;
      e3.afii10034 = 1056;
      e3.afii10035 = 1057;
      e3.afii10036 = 1058;
      e3.afii10037 = 1059;
      e3.afii10038 = 1060;
      e3.afii10039 = 1061;
      e3.afii10040 = 1062;
      e3.afii10041 = 1063;
      e3.afii10042 = 1064;
      e3.afii10043 = 1065;
      e3.afii10044 = 1066;
      e3.afii10045 = 1067;
      e3.afii10046 = 1068;
      e3.afii10047 = 1069;
      e3.afii10048 = 1070;
      e3.afii10049 = 1071;
      e3.afii10050 = 1168;
      e3.afii10051 = 1026;
      e3.afii10052 = 1027;
      e3.afii10053 = 1028;
      e3.afii10054 = 1029;
      e3.afii10055 = 1030;
      e3.afii10056 = 1031;
      e3.afii10057 = 1032;
      e3.afii10058 = 1033;
      e3.afii10059 = 1034;
      e3.afii10060 = 1035;
      e3.afii10061 = 1036;
      e3.afii10062 = 1038;
      e3.afii10063 = 63172;
      e3.afii10064 = 63173;
      e3.afii10065 = 1072;
      e3.afii10066 = 1073;
      e3.afii10067 = 1074;
      e3.afii10068 = 1075;
      e3.afii10069 = 1076;
      e3.afii10070 = 1077;
      e3.afii10071 = 1105;
      e3.afii10072 = 1078;
      e3.afii10073 = 1079;
      e3.afii10074 = 1080;
      e3.afii10075 = 1081;
      e3.afii10076 = 1082;
      e3.afii10077 = 1083;
      e3.afii10078 = 1084;
      e3.afii10079 = 1085;
      e3.afii10080 = 1086;
      e3.afii10081 = 1087;
      e3.afii10082 = 1088;
      e3.afii10083 = 1089;
      e3.afii10084 = 1090;
      e3.afii10085 = 1091;
      e3.afii10086 = 1092;
      e3.afii10087 = 1093;
      e3.afii10088 = 1094;
      e3.afii10089 = 1095;
      e3.afii10090 = 1096;
      e3.afii10091 = 1097;
      e3.afii10092 = 1098;
      e3.afii10093 = 1099;
      e3.afii10094 = 1100;
      e3.afii10095 = 1101;
      e3.afii10096 = 1102;
      e3.afii10097 = 1103;
      e3.afii10098 = 1169;
      e3.afii10099 = 1106;
      e3.afii10100 = 1107;
      e3.afii10101 = 1108;
      e3.afii10102 = 1109;
      e3.afii10103 = 1110;
      e3.afii10104 = 1111;
      e3.afii10105 = 1112;
      e3.afii10106 = 1113;
      e3.afii10107 = 1114;
      e3.afii10108 = 1115;
      e3.afii10109 = 1116;
      e3.afii10110 = 1118;
      e3.afii10145 = 1039;
      e3.afii10146 = 1122;
      e3.afii10147 = 1138;
      e3.afii10148 = 1140;
      e3.afii10192 = 63174;
      e3.afii10193 = 1119;
      e3.afii10194 = 1123;
      e3.afii10195 = 1139;
      e3.afii10196 = 1141;
      e3.afii10831 = 63175;
      e3.afii10832 = 63176;
      e3.afii10846 = 1241;
      e3.afii299 = 8206;
      e3.afii300 = 8207;
      e3.afii301 = 8205;
      e3.afii57381 = 1642;
      e3.afii57388 = 1548;
      e3.afii57392 = 1632;
      e3.afii57393 = 1633;
      e3.afii57394 = 1634;
      e3.afii57395 = 1635;
      e3.afii57396 = 1636;
      e3.afii57397 = 1637;
      e3.afii57398 = 1638;
      e3.afii57399 = 1639;
      e3.afii57400 = 1640;
      e3.afii57401 = 1641;
      e3.afii57403 = 1563;
      e3.afii57407 = 1567;
      e3.afii57409 = 1569;
      e3.afii57410 = 1570;
      e3.afii57411 = 1571;
      e3.afii57412 = 1572;
      e3.afii57413 = 1573;
      e3.afii57414 = 1574;
      e3.afii57415 = 1575;
      e3.afii57416 = 1576;
      e3.afii57417 = 1577;
      e3.afii57418 = 1578;
      e3.afii57419 = 1579;
      e3.afii57420 = 1580;
      e3.afii57421 = 1581;
      e3.afii57422 = 1582;
      e3.afii57423 = 1583;
      e3.afii57424 = 1584;
      e3.afii57425 = 1585;
      e3.afii57426 = 1586;
      e3.afii57427 = 1587;
      e3.afii57428 = 1588;
      e3.afii57429 = 1589;
      e3.afii57430 = 1590;
      e3.afii57431 = 1591;
      e3.afii57432 = 1592;
      e3.afii57433 = 1593;
      e3.afii57434 = 1594;
      e3.afii57440 = 1600;
      e3.afii57441 = 1601;
      e3.afii57442 = 1602;
      e3.afii57443 = 1603;
      e3.afii57444 = 1604;
      e3.afii57445 = 1605;
      e3.afii57446 = 1606;
      e3.afii57448 = 1608;
      e3.afii57449 = 1609;
      e3.afii57450 = 1610;
      e3.afii57451 = 1611;
      e3.afii57452 = 1612;
      e3.afii57453 = 1613;
      e3.afii57454 = 1614;
      e3.afii57455 = 1615;
      e3.afii57456 = 1616;
      e3.afii57457 = 1617;
      e3.afii57458 = 1618;
      e3.afii57470 = 1607;
      e3.afii57505 = 1700;
      e3.afii57506 = 1662;
      e3.afii57507 = 1670;
      e3.afii57508 = 1688;
      e3.afii57509 = 1711;
      e3.afii57511 = 1657;
      e3.afii57512 = 1672;
      e3.afii57513 = 1681;
      e3.afii57514 = 1722;
      e3.afii57519 = 1746;
      e3.afii57534 = 1749;
      e3.afii57636 = 8362;
      e3.afii57645 = 1470;
      e3.afii57658 = 1475;
      e3.afii57664 = 1488;
      e3.afii57665 = 1489;
      e3.afii57666 = 1490;
      e3.afii57667 = 1491;
      e3.afii57668 = 1492;
      e3.afii57669 = 1493;
      e3.afii57670 = 1494;
      e3.afii57671 = 1495;
      e3.afii57672 = 1496;
      e3.afii57673 = 1497;
      e3.afii57674 = 1498;
      e3.afii57675 = 1499;
      e3.afii57676 = 1500;
      e3.afii57677 = 1501;
      e3.afii57678 = 1502;
      e3.afii57679 = 1503;
      e3.afii57680 = 1504;
      e3.afii57681 = 1505;
      e3.afii57682 = 1506;
      e3.afii57683 = 1507;
      e3.afii57684 = 1508;
      e3.afii57685 = 1509;
      e3.afii57686 = 1510;
      e3.afii57687 = 1511;
      e3.afii57688 = 1512;
      e3.afii57689 = 1513;
      e3.afii57690 = 1514;
      e3.afii57694 = 64298;
      e3.afii57695 = 64299;
      e3.afii57700 = 64331;
      e3.afii57705 = 64287;
      e3.afii57716 = 1520;
      e3.afii57717 = 1521;
      e3.afii57718 = 1522;
      e3.afii57723 = 64309;
      e3.afii57793 = 1460;
      e3.afii57794 = 1461;
      e3.afii57795 = 1462;
      e3.afii57796 = 1467;
      e3.afii57797 = 1464;
      e3.afii57798 = 1463;
      e3.afii57799 = 1456;
      e3.afii57800 = 1458;
      e3.afii57801 = 1457;
      e3.afii57802 = 1459;
      e3.afii57803 = 1474;
      e3.afii57804 = 1473;
      e3.afii57806 = 1465;
      e3.afii57807 = 1468;
      e3.afii57839 = 1469;
      e3.afii57841 = 1471;
      e3.afii57842 = 1472;
      e3.afii57929 = 700;
      e3.afii61248 = 8453;
      e3.afii61289 = 8467;
      e3.afii61352 = 8470;
      e3.afii61573 = 8236;
      e3.afii61574 = 8237;
      e3.afii61575 = 8238;
      e3.afii61664 = 8204;
      e3.afii63167 = 1645;
      e3.afii64937 = 701;
      e3.agrave = 224;
      e3.agujarati = 2693;
      e3.agurmukhi = 2565;
      e3.ahiragana = 12354;
      e3.ahookabove = 7843;
      e3.aibengali = 2448;
      e3.aibopomofo = 12574;
      e3.aideva = 2320;
      e3.aiecyrillic = 1237;
      e3.aigujarati = 2704;
      e3.aigurmukhi = 2576;
      e3.aimatragurmukhi = 2632;
      e3.ainarabic = 1593;
      e3.ainfinalarabic = 65226;
      e3.aininitialarabic = 65227;
      e3.ainmedialarabic = 65228;
      e3.ainvertedbreve = 515;
      e3.aivowelsignbengali = 2504;
      e3.aivowelsigndeva = 2376;
      e3.aivowelsigngujarati = 2760;
      e3.akatakana = 12450;
      e3.akatakanahalfwidth = 65393;
      e3.akorean = 12623;
      e3.alef = 1488;
      e3.alefarabic = 1575;
      e3.alefdageshhebrew = 64304;
      e3.aleffinalarabic = 65166;
      e3.alefhamzaabovearabic = 1571;
      e3.alefhamzaabovefinalarabic = 65156;
      e3.alefhamzabelowarabic = 1573;
      e3.alefhamzabelowfinalarabic = 65160;
      e3.alefhebrew = 1488;
      e3.aleflamedhebrew = 64335;
      e3.alefmaddaabovearabic = 1570;
      e3.alefmaddaabovefinalarabic = 65154;
      e3.alefmaksuraarabic = 1609;
      e3.alefmaksurafinalarabic = 65264;
      e3.alefmaksurainitialarabic = 65267;
      e3.alefmaksuramedialarabic = 65268;
      e3.alefpatahhebrew = 64302;
      e3.alefqamatshebrew = 64303;
      e3.aleph = 8501;
      e3.allequal = 8780;
      e3.alpha = 945;
      e3.alphatonos = 940;
      e3.amacron = 257;
      e3.amonospace = 65345;
      e3.ampersand = 38;
      e3.ampersandmonospace = 65286;
      e3.ampersandsmall = 63270;
      e3.amsquare = 13250;
      e3.anbopomofo = 12578;
      e3.angbopomofo = 12580;
      e3.angbracketleft = 12296;
      e3.angbracketright = 12297;
      e3.angkhankhuthai = 3674;
      e3.angle = 8736;
      e3.anglebracketleft = 12296;
      e3.anglebracketleftvertical = 65087;
      e3.anglebracketright = 12297;
      e3.anglebracketrightvertical = 65088;
      e3.angleleft = 9001;
      e3.angleright = 9002;
      e3.angstrom = 8491;
      e3.anoteleia = 903;
      e3.anudattadeva = 2386;
      e3.anusvarabengali = 2434;
      e3.anusvaradeva = 2306;
      e3.anusvaragujarati = 2690;
      e3.aogonek = 261;
      e3.apaatosquare = 13056;
      e3.aparen = 9372;
      e3.apostrophearmenian = 1370;
      e3.apostrophemod = 700;
      e3.apple = 63743;
      e3.approaches = 8784;
      e3.approxequal = 8776;
      e3.approxequalorimage = 8786;
      e3.approximatelyequal = 8773;
      e3.araeaekorean = 12686;
      e3.araeakorean = 12685;
      e3.arc = 8978;
      e3.arighthalfring = 7834;
      e3.aring = 229;
      e3.aringacute = 507;
      e3.aringbelow = 7681;
      e3.arrowboth = 8596;
      e3.arrowdashdown = 8675;
      e3.arrowdashleft = 8672;
      e3.arrowdashright = 8674;
      e3.arrowdashup = 8673;
      e3.arrowdblboth = 8660;
      e3.arrowdbldown = 8659;
      e3.arrowdblleft = 8656;
      e3.arrowdblright = 8658;
      e3.arrowdblup = 8657;
      e3.arrowdown = 8595;
      e3.arrowdownleft = 8601;
      e3.arrowdownright = 8600;
      e3.arrowdownwhite = 8681;
      e3.arrowheaddownmod = 709;
      e3.arrowheadleftmod = 706;
      e3.arrowheadrightmod = 707;
      e3.arrowheadupmod = 708;
      e3.arrowhorizex = 63719;
      e3.arrowleft = 8592;
      e3.arrowleftdbl = 8656;
      e3.arrowleftdblstroke = 8653;
      e3.arrowleftoverright = 8646;
      e3.arrowleftwhite = 8678;
      e3.arrowright = 8594;
      e3.arrowrightdblstroke = 8655;
      e3.arrowrightheavy = 10142;
      e3.arrowrightoverleft = 8644;
      e3.arrowrightwhite = 8680;
      e3.arrowtableft = 8676;
      e3.arrowtabright = 8677;
      e3.arrowup = 8593;
      e3.arrowupdn = 8597;
      e3.arrowupdnbse = 8616;
      e3.arrowupdownbase = 8616;
      e3.arrowupleft = 8598;
      e3.arrowupleftofdown = 8645;
      e3.arrowupright = 8599;
      e3.arrowupwhite = 8679;
      e3.arrowvertex = 63718;
      e3.asciicircum = 94;
      e3.asciicircummonospace = 65342;
      e3.asciitilde = 126;
      e3.asciitildemonospace = 65374;
      e3.ascript = 593;
      e3.ascriptturned = 594;
      e3.asmallhiragana = 12353;
      e3.asmallkatakana = 12449;
      e3.asmallkatakanahalfwidth = 65383;
      e3.asterisk = 42;
      e3.asteriskaltonearabic = 1645;
      e3.asteriskarabic = 1645;
      e3.asteriskmath = 8727;
      e3.asteriskmonospace = 65290;
      e3.asterisksmall = 65121;
      e3.asterism = 8258;
      e3.asuperior = 63209;
      e3.asymptoticallyequal = 8771;
      e3.at = 64;
      e3.atilde = 227;
      e3.atmonospace = 65312;
      e3.atsmall = 65131;
      e3.aturned = 592;
      e3.aubengali = 2452;
      e3.aubopomofo = 12576;
      e3.audeva = 2324;
      e3.augujarati = 2708;
      e3.augurmukhi = 2580;
      e3.aulengthmarkbengali = 2519;
      e3.aumatragurmukhi = 2636;
      e3.auvowelsignbengali = 2508;
      e3.auvowelsigndeva = 2380;
      e3.auvowelsigngujarati = 2764;
      e3.avagrahadeva = 2365;
      e3.aybarmenian = 1377;
      e3.ayin = 1506;
      e3.ayinaltonehebrew = 64288;
      e3.ayinhebrew = 1506;
      e3.b = 98;
      e3.babengali = 2476;
      e3.backslash = 92;
      e3.backslashmonospace = 65340;
      e3.badeva = 2348;
      e3.bagujarati = 2732;
      e3.bagurmukhi = 2604;
      e3.bahiragana = 12400;
      e3.bahtthai = 3647;
      e3.bakatakana = 12496;
      e3.bar = 124;
      e3.barmonospace = 65372;
      e3.bbopomofo = 12549;
      e3.bcircle = 9425;
      e3.bdotaccent = 7683;
      e3.bdotbelow = 7685;
      e3.beamedsixteenthnotes = 9836;
      e3.because = 8757;
      e3.becyrillic = 1073;
      e3.beharabic = 1576;
      e3.behfinalarabic = 65168;
      e3.behinitialarabic = 65169;
      e3.behiragana = 12409;
      e3.behmedialarabic = 65170;
      e3.behmeeminitialarabic = 64671;
      e3.behmeemisolatedarabic = 64520;
      e3.behnoonfinalarabic = 64621;
      e3.bekatakana = 12505;
      e3.benarmenian = 1378;
      e3.bet = 1489;
      e3.beta = 946;
      e3.betasymbolgreek = 976;
      e3.betdagesh = 64305;
      e3.betdageshhebrew = 64305;
      e3.bethebrew = 1489;
      e3.betrafehebrew = 64332;
      e3.bhabengali = 2477;
      e3.bhadeva = 2349;
      e3.bhagujarati = 2733;
      e3.bhagurmukhi = 2605;
      e3.bhook = 595;
      e3.bihiragana = 12403;
      e3.bikatakana = 12499;
      e3.bilabialclick = 664;
      e3.bindigurmukhi = 2562;
      e3.birusquare = 13105;
      e3.blackcircle = 9679;
      e3.blackdiamond = 9670;
      e3.blackdownpointingtriangle = 9660;
      e3.blackleftpointingpointer = 9668;
      e3.blackleftpointingtriangle = 9664;
      e3.blacklenticularbracketleft = 12304;
      e3.blacklenticularbracketleftvertical = 65083;
      e3.blacklenticularbracketright = 12305;
      e3.blacklenticularbracketrightvertical = 65084;
      e3.blacklowerlefttriangle = 9699;
      e3.blacklowerrighttriangle = 9698;
      e3.blackrectangle = 9644;
      e3.blackrightpointingpointer = 9658;
      e3.blackrightpointingtriangle = 9654;
      e3.blacksmallsquare = 9642;
      e3.blacksmilingface = 9787;
      e3.blacksquare = 9632;
      e3.blackstar = 9733;
      e3.blackupperlefttriangle = 9700;
      e3.blackupperrighttriangle = 9701;
      e3.blackuppointingsmalltriangle = 9652;
      e3.blackuppointingtriangle = 9650;
      e3.blank = 9251;
      e3.blinebelow = 7687;
      e3.block = 9608;
      e3.bmonospace = 65346;
      e3.bobaimaithai = 3610;
      e3.bohiragana = 12412;
      e3.bokatakana = 12508;
      e3.bparen = 9373;
      e3.bqsquare = 13251;
      e3.braceex = 63732;
      e3.braceleft = 123;
      e3.braceleftbt = 63731;
      e3.braceleftmid = 63730;
      e3.braceleftmonospace = 65371;
      e3.braceleftsmall = 65115;
      e3.bracelefttp = 63729;
      e3.braceleftvertical = 65079;
      e3.braceright = 125;
      e3.bracerightbt = 63742;
      e3.bracerightmid = 63741;
      e3.bracerightmonospace = 65373;
      e3.bracerightsmall = 65116;
      e3.bracerighttp = 63740;
      e3.bracerightvertical = 65080;
      e3.bracketleft = 91;
      e3.bracketleftbt = 63728;
      e3.bracketleftex = 63727;
      e3.bracketleftmonospace = 65339;
      e3.bracketlefttp = 63726;
      e3.bracketright = 93;
      e3.bracketrightbt = 63739;
      e3.bracketrightex = 63738;
      e3.bracketrightmonospace = 65341;
      e3.bracketrighttp = 63737;
      e3.breve = 728;
      e3.brevebelowcmb = 814;
      e3.brevecmb = 774;
      e3.breveinvertedbelowcmb = 815;
      e3.breveinvertedcmb = 785;
      e3.breveinverteddoublecmb = 865;
      e3.bridgebelowcmb = 810;
      e3.bridgeinvertedbelowcmb = 826;
      e3.brokenbar = 166;
      e3.bstroke = 384;
      e3.bsuperior = 63210;
      e3.btopbar = 387;
      e3.buhiragana = 12406;
      e3.bukatakana = 12502;
      e3.bullet = 8226;
      e3.bulletinverse = 9688;
      e3.bulletoperator = 8729;
      e3.bullseye = 9678;
      e3.c = 99;
      e3.caarmenian = 1390;
      e3.cabengali = 2458;
      e3.cacute = 263;
      e3.cadeva = 2330;
      e3.cagujarati = 2714;
      e3.cagurmukhi = 2586;
      e3.calsquare = 13192;
      e3.candrabindubengali = 2433;
      e3.candrabinducmb = 784;
      e3.candrabindudeva = 2305;
      e3.candrabindugujarati = 2689;
      e3.capslock = 8682;
      e3.careof = 8453;
      e3.caron = 711;
      e3.caronbelowcmb = 812;
      e3.caroncmb = 780;
      e3.carriagereturn = 8629;
      e3.cbopomofo = 12568;
      e3.ccaron = 269;
      e3.ccedilla = 231;
      e3.ccedillaacute = 7689;
      e3.ccircle = 9426;
      e3.ccircumflex = 265;
      e3.ccurl = 597;
      e3.cdot = 267;
      e3.cdotaccent = 267;
      e3.cdsquare = 13253;
      e3.cedilla = 184;
      e3.cedillacmb = 807;
      e3.cent = 162;
      e3.centigrade = 8451;
      e3.centinferior = 63199;
      e3.centmonospace = 65504;
      e3.centoldstyle = 63394;
      e3.centsuperior = 63200;
      e3.chaarmenian = 1401;
      e3.chabengali = 2459;
      e3.chadeva = 2331;
      e3.chagujarati = 2715;
      e3.chagurmukhi = 2587;
      e3.chbopomofo = 12564;
      e3.cheabkhasiancyrillic = 1213;
      e3.checkmark = 10003;
      e3.checyrillic = 1095;
      e3.chedescenderabkhasiancyrillic = 1215;
      e3.chedescendercyrillic = 1207;
      e3.chedieresiscyrillic = 1269;
      e3.cheharmenian = 1395;
      e3.chekhakassiancyrillic = 1228;
      e3.cheverticalstrokecyrillic = 1209;
      e3.chi = 967;
      e3.chieuchacirclekorean = 12919;
      e3.chieuchaparenkorean = 12823;
      e3.chieuchcirclekorean = 12905;
      e3.chieuchkorean = 12618;
      e3.chieuchparenkorean = 12809;
      e3.chochangthai = 3594;
      e3.chochanthai = 3592;
      e3.chochingthai = 3593;
      e3.chochoethai = 3596;
      e3.chook = 392;
      e3.cieucacirclekorean = 12918;
      e3.cieucaparenkorean = 12822;
      e3.cieuccirclekorean = 12904;
      e3.cieuckorean = 12616;
      e3.cieucparenkorean = 12808;
      e3.cieucuparenkorean = 12828;
      e3.circle = 9675;
      e3.circlecopyrt = 169;
      e3.circlemultiply = 8855;
      e3.circleot = 8857;
      e3.circleplus = 8853;
      e3.circlepostalmark = 12342;
      e3.circlewithlefthalfblack = 9680;
      e3.circlewithrighthalfblack = 9681;
      e3.circumflex = 710;
      e3.circumflexbelowcmb = 813;
      e3.circumflexcmb = 770;
      e3.clear = 8999;
      e3.clickalveolar = 450;
      e3.clickdental = 448;
      e3.clicklateral = 449;
      e3.clickretroflex = 451;
      e3.club = 9827;
      e3.clubsuitblack = 9827;
      e3.clubsuitwhite = 9831;
      e3.cmcubedsquare = 13220;
      e3.cmonospace = 65347;
      e3.cmsquaredsquare = 13216;
      e3.coarmenian = 1409;
      e3.colon = 58;
      e3.colonmonetary = 8353;
      e3.colonmonospace = 65306;
      e3.colonsign = 8353;
      e3.colonsmall = 65109;
      e3.colontriangularhalfmod = 721;
      e3.colontriangularmod = 720;
      e3.comma = 44;
      e3.commaabovecmb = 787;
      e3.commaaboverightcmb = 789;
      e3.commaaccent = 63171;
      e3.commaarabic = 1548;
      e3.commaarmenian = 1373;
      e3.commainferior = 63201;
      e3.commamonospace = 65292;
      e3.commareversedabovecmb = 788;
      e3.commareversedmod = 701;
      e3.commasmall = 65104;
      e3.commasuperior = 63202;
      e3.commaturnedabovecmb = 786;
      e3.commaturnedmod = 699;
      e3.compass = 9788;
      e3.congruent = 8773;
      e3.contourintegral = 8750;
      e3.control = 8963;
      e3.controlACK = 6;
      e3.controlBEL = 7;
      e3.controlBS = 8;
      e3.controlCAN = 24;
      e3.controlCR = 13;
      e3.controlDC1 = 17;
      e3.controlDC2 = 18;
      e3.controlDC3 = 19;
      e3.controlDC4 = 20;
      e3.controlDEL = 127;
      e3.controlDLE = 16;
      e3.controlEM = 25;
      e3.controlENQ = 5;
      e3.controlEOT = 4;
      e3.controlESC = 27;
      e3.controlETB = 23;
      e3.controlETX = 3;
      e3.controlFF = 12;
      e3.controlFS = 28;
      e3.controlGS = 29;
      e3.controlHT = 9;
      e3.controlLF = 10;
      e3.controlNAK = 21;
      e3.controlNULL = 0;
      e3.controlRS = 30;
      e3.controlSI = 15;
      e3.controlSO = 14;
      e3.controlSOT = 2;
      e3.controlSTX = 1;
      e3.controlSUB = 26;
      e3.controlSYN = 22;
      e3.controlUS = 31;
      e3.controlVT = 11;
      e3.copyright = 169;
      e3.copyrightsans = 63721;
      e3.copyrightserif = 63193;
      e3.cornerbracketleft = 12300;
      e3.cornerbracketlefthalfwidth = 65378;
      e3.cornerbracketleftvertical = 65089;
      e3.cornerbracketright = 12301;
      e3.cornerbracketrighthalfwidth = 65379;
      e3.cornerbracketrightvertical = 65090;
      e3.corporationsquare = 13183;
      e3.cosquare = 13255;
      e3.coverkgsquare = 13254;
      e3.cparen = 9374;
      e3.cruzeiro = 8354;
      e3.cstretched = 663;
      e3.curlyand = 8911;
      e3.curlyor = 8910;
      e3.currency = 164;
      e3.cyrBreve = 63185;
      e3.cyrFlex = 63186;
      e3.cyrbreve = 63188;
      e3.cyrflex = 63189;
      e3.d = 100;
      e3.daarmenian = 1380;
      e3.dabengali = 2470;
      e3.dadarabic = 1590;
      e3.dadeva = 2342;
      e3.dadfinalarabic = 65214;
      e3.dadinitialarabic = 65215;
      e3.dadmedialarabic = 65216;
      e3.dagesh = 1468;
      e3.dageshhebrew = 1468;
      e3.dagger = 8224;
      e3.daggerdbl = 8225;
      e3.dagujarati = 2726;
      e3.dagurmukhi = 2598;
      e3.dahiragana = 12384;
      e3.dakatakana = 12480;
      e3.dalarabic = 1583;
      e3.dalet = 1491;
      e3.daletdagesh = 64307;
      e3.daletdageshhebrew = 64307;
      e3.dalethebrew = 1491;
      e3.dalfinalarabic = 65194;
      e3.dammaarabic = 1615;
      e3.dammalowarabic = 1615;
      e3.dammatanaltonearabic = 1612;
      e3.dammatanarabic = 1612;
      e3.danda = 2404;
      e3.dargahebrew = 1447;
      e3.dargalefthebrew = 1447;
      e3.dasiapneumatacyrilliccmb = 1157;
      e3.dblGrave = 63187;
      e3.dblanglebracketleft = 12298;
      e3.dblanglebracketleftvertical = 65085;
      e3.dblanglebracketright = 12299;
      e3.dblanglebracketrightvertical = 65086;
      e3.dblarchinvertedbelowcmb = 811;
      e3.dblarrowleft = 8660;
      e3.dblarrowright = 8658;
      e3.dbldanda = 2405;
      e3.dblgrave = 63190;
      e3.dblgravecmb = 783;
      e3.dblintegral = 8748;
      e3.dbllowline = 8215;
      e3.dbllowlinecmb = 819;
      e3.dbloverlinecmb = 831;
      e3.dblprimemod = 698;
      e3.dblverticalbar = 8214;
      e3.dblverticallineabovecmb = 782;
      e3.dbopomofo = 12553;
      e3.dbsquare = 13256;
      e3.dcaron = 271;
      e3.dcedilla = 7697;
      e3.dcircle = 9427;
      e3.dcircumflexbelow = 7699;
      e3.dcroat = 273;
      e3.ddabengali = 2465;
      e3.ddadeva = 2337;
      e3.ddagujarati = 2721;
      e3.ddagurmukhi = 2593;
      e3.ddalarabic = 1672;
      e3.ddalfinalarabic = 64393;
      e3.dddhadeva = 2396;
      e3.ddhabengali = 2466;
      e3.ddhadeva = 2338;
      e3.ddhagujarati = 2722;
      e3.ddhagurmukhi = 2594;
      e3.ddotaccent = 7691;
      e3.ddotbelow = 7693;
      e3.decimalseparatorarabic = 1643;
      e3.decimalseparatorpersian = 1643;
      e3.decyrillic = 1076;
      e3.degree = 176;
      e3.dehihebrew = 1453;
      e3.dehiragana = 12391;
      e3.deicoptic = 1007;
      e3.dekatakana = 12487;
      e3.deleteleft = 9003;
      e3.deleteright = 8998;
      e3.delta = 948;
      e3.deltaturned = 397;
      e3.denominatorminusonenumeratorbengali = 2552;
      e3.dezh = 676;
      e3.dhabengali = 2471;
      e3.dhadeva = 2343;
      e3.dhagujarati = 2727;
      e3.dhagurmukhi = 2599;
      e3.dhook = 599;
      e3.dialytikatonos = 901;
      e3.dialytikatonoscmb = 836;
      e3.diamond = 9830;
      e3.diamondsuitwhite = 9826;
      e3.dieresis = 168;
      e3.dieresisacute = 63191;
      e3.dieresisbelowcmb = 804;
      e3.dieresiscmb = 776;
      e3.dieresisgrave = 63192;
      e3.dieresistonos = 901;
      e3.dihiragana = 12386;
      e3.dikatakana = 12482;
      e3.dittomark = 12291;
      e3.divide = 247;
      e3.divides = 8739;
      e3.divisionslash = 8725;
      e3.djecyrillic = 1106;
      e3.dkshade = 9619;
      e3.dlinebelow = 7695;
      e3.dlsquare = 13207;
      e3.dmacron = 273;
      e3.dmonospace = 65348;
      e3.dnblock = 9604;
      e3.dochadathai = 3598;
      e3.dodekthai = 3604;
      e3.dohiragana = 12393;
      e3.dokatakana = 12489;
      e3.dollar = 36;
      e3.dollarinferior = 63203;
      e3.dollarmonospace = 65284;
      e3.dollaroldstyle = 63268;
      e3.dollarsmall = 65129;
      e3.dollarsuperior = 63204;
      e3.dong = 8363;
      e3.dorusquare = 13094;
      e3.dotaccent = 729;
      e3.dotaccentcmb = 775;
      e3.dotbelowcmb = 803;
      e3.dotbelowcomb = 803;
      e3.dotkatakana = 12539;
      e3.dotlessi = 305;
      e3.dotlessj = 63166;
      e3.dotlessjstrokehook = 644;
      e3.dotmath = 8901;
      e3.dottedcircle = 9676;
      e3.doubleyodpatah = 64287;
      e3.doubleyodpatahhebrew = 64287;
      e3.downtackbelowcmb = 798;
      e3.downtackmod = 725;
      e3.dparen = 9375;
      e3.dsuperior = 63211;
      e3.dtail = 598;
      e3.dtopbar = 396;
      e3.duhiragana = 12389;
      e3.dukatakana = 12485;
      e3.dz = 499;
      e3.dzaltone = 675;
      e3.dzcaron = 454;
      e3.dzcurl = 677;
      e3.dzeabkhasiancyrillic = 1249;
      e3.dzecyrillic = 1109;
      e3.dzhecyrillic = 1119;
      e3.e = 101;
      e3.eacute = 233;
      e3.earth = 9793;
      e3.ebengali = 2447;
      e3.ebopomofo = 12572;
      e3.ebreve = 277;
      e3.ecandradeva = 2317;
      e3.ecandragujarati = 2701;
      e3.ecandravowelsigndeva = 2373;
      e3.ecandravowelsigngujarati = 2757;
      e3.ecaron = 283;
      e3.ecedillabreve = 7709;
      e3.echarmenian = 1381;
      e3.echyiwnarmenian = 1415;
      e3.ecircle = 9428;
      e3.ecircumflex = 234;
      e3.ecircumflexacute = 7871;
      e3.ecircumflexbelow = 7705;
      e3.ecircumflexdotbelow = 7879;
      e3.ecircumflexgrave = 7873;
      e3.ecircumflexhookabove = 7875;
      e3.ecircumflextilde = 7877;
      e3.ecyrillic = 1108;
      e3.edblgrave = 517;
      e3.edeva = 2319;
      e3.edieresis = 235;
      e3.edot = 279;
      e3.edotaccent = 279;
      e3.edotbelow = 7865;
      e3.eegurmukhi = 2575;
      e3.eematragurmukhi = 2631;
      e3.efcyrillic = 1092;
      e3.egrave = 232;
      e3.egujarati = 2703;
      e3.eharmenian = 1383;
      e3.ehbopomofo = 12573;
      e3.ehiragana = 12360;
      e3.ehookabove = 7867;
      e3.eibopomofo = 12575;
      e3.eight = 56;
      e3.eightarabic = 1640;
      e3.eightbengali = 2542;
      e3.eightcircle = 9319;
      e3.eightcircleinversesansserif = 10129;
      e3.eightdeva = 2414;
      e3.eighteencircle = 9329;
      e3.eighteenparen = 9349;
      e3.eighteenperiod = 9369;
      e3.eightgujarati = 2798;
      e3.eightgurmukhi = 2670;
      e3.eighthackarabic = 1640;
      e3.eighthangzhou = 12328;
      e3.eighthnotebeamed = 9835;
      e3.eightideographicparen = 12839;
      e3.eightinferior = 8328;
      e3.eightmonospace = 65304;
      e3.eightoldstyle = 63288;
      e3.eightparen = 9339;
      e3.eightperiod = 9359;
      e3.eightpersian = 1784;
      e3.eightroman = 8567;
      e3.eightsuperior = 8312;
      e3.eightthai = 3672;
      e3.einvertedbreve = 519;
      e3.eiotifiedcyrillic = 1125;
      e3.ekatakana = 12456;
      e3.ekatakanahalfwidth = 65396;
      e3.ekonkargurmukhi = 2676;
      e3.ekorean = 12628;
      e3.elcyrillic = 1083;
      e3.element = 8712;
      e3.elevencircle = 9322;
      e3.elevenparen = 9342;
      e3.elevenperiod = 9362;
      e3.elevenroman = 8570;
      e3.ellipsis = 8230;
      e3.ellipsisvertical = 8942;
      e3.emacron = 275;
      e3.emacronacute = 7703;
      e3.emacrongrave = 7701;
      e3.emcyrillic = 1084;
      e3.emdash = 8212;
      e3.emdashvertical = 65073;
      e3.emonospace = 65349;
      e3.emphasismarkarmenian = 1371;
      e3.emptyset = 8709;
      e3.enbopomofo = 12579;
      e3.encyrillic = 1085;
      e3.endash = 8211;
      e3.endashvertical = 65074;
      e3.endescendercyrillic = 1187;
      e3.eng = 331;
      e3.engbopomofo = 12581;
      e3.enghecyrillic = 1189;
      e3.enhookcyrillic = 1224;
      e3.enspace = 8194;
      e3.eogonek = 281;
      e3.eokorean = 12627;
      e3.eopen = 603;
      e3.eopenclosed = 666;
      e3.eopenreversed = 604;
      e3.eopenreversedclosed = 606;
      e3.eopenreversedhook = 605;
      e3.eparen = 9376;
      e3.epsilon = 949;
      e3.epsilontonos = 941;
      e3.equal = 61;
      e3.equalmonospace = 65309;
      e3.equalsmall = 65126;
      e3.equalsuperior = 8316;
      e3.equivalence = 8801;
      e3.erbopomofo = 12582;
      e3.ercyrillic = 1088;
      e3.ereversed = 600;
      e3.ereversedcyrillic = 1101;
      e3.escyrillic = 1089;
      e3.esdescendercyrillic = 1195;
      e3.esh = 643;
      e3.eshcurl = 646;
      e3.eshortdeva = 2318;
      e3.eshortvowelsigndeva = 2374;
      e3.eshreversedloop = 426;
      e3.eshsquatreversed = 645;
      e3.esmallhiragana = 12359;
      e3.esmallkatakana = 12455;
      e3.esmallkatakanahalfwidth = 65386;
      e3.estimated = 8494;
      e3.esuperior = 63212;
      e3.eta = 951;
      e3.etarmenian = 1384;
      e3.etatonos = 942;
      e3.eth = 240;
      e3.etilde = 7869;
      e3.etildebelow = 7707;
      e3.etnahtafoukhhebrew = 1425;
      e3.etnahtafoukhlefthebrew = 1425;
      e3.etnahtahebrew = 1425;
      e3.etnahtalefthebrew = 1425;
      e3.eturned = 477;
      e3.eukorean = 12641;
      e3.euro = 8364;
      e3.evowelsignbengali = 2503;
      e3.evowelsigndeva = 2375;
      e3.evowelsigngujarati = 2759;
      e3.exclam = 33;
      e3.exclamarmenian = 1372;
      e3.exclamdbl = 8252;
      e3.exclamdown = 161;
      e3.exclamdownsmall = 63393;
      e3.exclammonospace = 65281;
      e3.exclamsmall = 63265;
      e3.existential = 8707;
      e3.ezh = 658;
      e3.ezhcaron = 495;
      e3.ezhcurl = 659;
      e3.ezhreversed = 441;
      e3.ezhtail = 442;
      e3.f = 102;
      e3.fadeva = 2398;
      e3.fagurmukhi = 2654;
      e3.fahrenheit = 8457;
      e3.fathaarabic = 1614;
      e3.fathalowarabic = 1614;
      e3.fathatanarabic = 1611;
      e3.fbopomofo = 12552;
      e3.fcircle = 9429;
      e3.fdotaccent = 7711;
      e3.feharabic = 1601;
      e3.feharmenian = 1414;
      e3.fehfinalarabic = 65234;
      e3.fehinitialarabic = 65235;
      e3.fehmedialarabic = 65236;
      e3.feicoptic = 997;
      e3.female = 9792;
      e3.ff = 64256;
      e3.f_f = 64256;
      e3.ffi = 64259;
      e3.f_f_i = 64259;
      e3.ffl = 64260;
      e3.f_f_l = 64260;
      e3.fi = 64257;
      e3.f_i = 64257;
      e3.fifteencircle = 9326;
      e3.fifteenparen = 9346;
      e3.fifteenperiod = 9366;
      e3.figuredash = 8210;
      e3.filledbox = 9632;
      e3.filledrect = 9644;
      e3.finalkaf = 1498;
      e3.finalkafdagesh = 64314;
      e3.finalkafdageshhebrew = 64314;
      e3.finalkafhebrew = 1498;
      e3.finalmem = 1501;
      e3.finalmemhebrew = 1501;
      e3.finalnun = 1503;
      e3.finalnunhebrew = 1503;
      e3.finalpe = 1507;
      e3.finalpehebrew = 1507;
      e3.finaltsadi = 1509;
      e3.finaltsadihebrew = 1509;
      e3.firsttonechinese = 713;
      e3.fisheye = 9673;
      e3.fitacyrillic = 1139;
      e3.five = 53;
      e3.fivearabic = 1637;
      e3.fivebengali = 2539;
      e3.fivecircle = 9316;
      e3.fivecircleinversesansserif = 10126;
      e3.fivedeva = 2411;
      e3.fiveeighths = 8541;
      e3.fivegujarati = 2795;
      e3.fivegurmukhi = 2667;
      e3.fivehackarabic = 1637;
      e3.fivehangzhou = 12325;
      e3.fiveideographicparen = 12836;
      e3.fiveinferior = 8325;
      e3.fivemonospace = 65301;
      e3.fiveoldstyle = 63285;
      e3.fiveparen = 9336;
      e3.fiveperiod = 9356;
      e3.fivepersian = 1781;
      e3.fiveroman = 8564;
      e3.fivesuperior = 8309;
      e3.fivethai = 3669;
      e3.fl = 64258;
      e3.f_l = 64258;
      e3.florin = 402;
      e3.fmonospace = 65350;
      e3.fmsquare = 13209;
      e3.fofanthai = 3615;
      e3.fofathai = 3613;
      e3.fongmanthai = 3663;
      e3.forall = 8704;
      e3.four = 52;
      e3.fourarabic = 1636;
      e3.fourbengali = 2538;
      e3.fourcircle = 9315;
      e3.fourcircleinversesansserif = 10125;
      e3.fourdeva = 2410;
      e3.fourgujarati = 2794;
      e3.fourgurmukhi = 2666;
      e3.fourhackarabic = 1636;
      e3.fourhangzhou = 12324;
      e3.fourideographicparen = 12835;
      e3.fourinferior = 8324;
      e3.fourmonospace = 65300;
      e3.fournumeratorbengali = 2551;
      e3.fouroldstyle = 63284;
      e3.fourparen = 9335;
      e3.fourperiod = 9355;
      e3.fourpersian = 1780;
      e3.fourroman = 8563;
      e3.foursuperior = 8308;
      e3.fourteencircle = 9325;
      e3.fourteenparen = 9345;
      e3.fourteenperiod = 9365;
      e3.fourthai = 3668;
      e3.fourthtonechinese = 715;
      e3.fparen = 9377;
      e3.fraction = 8260;
      e3.franc = 8355;
      e3.g = 103;
      e3.gabengali = 2455;
      e3.gacute = 501;
      e3.gadeva = 2327;
      e3.gafarabic = 1711;
      e3.gaffinalarabic = 64403;
      e3.gafinitialarabic = 64404;
      e3.gafmedialarabic = 64405;
      e3.gagujarati = 2711;
      e3.gagurmukhi = 2583;
      e3.gahiragana = 12364;
      e3.gakatakana = 12460;
      e3.gamma = 947;
      e3.gammalatinsmall = 611;
      e3.gammasuperior = 736;
      e3.gangiacoptic = 1003;
      e3.gbopomofo = 12557;
      e3.gbreve = 287;
      e3.gcaron = 487;
      e3.gcedilla = 291;
      e3.gcircle = 9430;
      e3.gcircumflex = 285;
      e3.gcommaaccent = 291;
      e3.gdot = 289;
      e3.gdotaccent = 289;
      e3.gecyrillic = 1075;
      e3.gehiragana = 12370;
      e3.gekatakana = 12466;
      e3.geometricallyequal = 8785;
      e3.gereshaccenthebrew = 1436;
      e3.gereshhebrew = 1523;
      e3.gereshmuqdamhebrew = 1437;
      e3.germandbls = 223;
      e3.gershayimaccenthebrew = 1438;
      e3.gershayimhebrew = 1524;
      e3.getamark = 12307;
      e3.ghabengali = 2456;
      e3.ghadarmenian = 1394;
      e3.ghadeva = 2328;
      e3.ghagujarati = 2712;
      e3.ghagurmukhi = 2584;
      e3.ghainarabic = 1594;
      e3.ghainfinalarabic = 65230;
      e3.ghaininitialarabic = 65231;
      e3.ghainmedialarabic = 65232;
      e3.ghemiddlehookcyrillic = 1173;
      e3.ghestrokecyrillic = 1171;
      e3.gheupturncyrillic = 1169;
      e3.ghhadeva = 2394;
      e3.ghhagurmukhi = 2650;
      e3.ghook = 608;
      e3.ghzsquare = 13203;
      e3.gihiragana = 12366;
      e3.gikatakana = 12462;
      e3.gimarmenian = 1379;
      e3.gimel = 1490;
      e3.gimeldagesh = 64306;
      e3.gimeldageshhebrew = 64306;
      e3.gimelhebrew = 1490;
      e3.gjecyrillic = 1107;
      e3.glottalinvertedstroke = 446;
      e3.glottalstop = 660;
      e3.glottalstopinverted = 662;
      e3.glottalstopmod = 704;
      e3.glottalstopreversed = 661;
      e3.glottalstopreversedmod = 705;
      e3.glottalstopreversedsuperior = 740;
      e3.glottalstopstroke = 673;
      e3.glottalstopstrokereversed = 674;
      e3.gmacron = 7713;
      e3.gmonospace = 65351;
      e3.gohiragana = 12372;
      e3.gokatakana = 12468;
      e3.gparen = 9378;
      e3.gpasquare = 13228;
      e3.gradient = 8711;
      e3.grave = 96;
      e3.gravebelowcmb = 790;
      e3.gravecmb = 768;
      e3.gravecomb = 768;
      e3.gravedeva = 2387;
      e3.gravelowmod = 718;
      e3.gravemonospace = 65344;
      e3.gravetonecmb = 832;
      e3.greater = 62;
      e3.greaterequal = 8805;
      e3.greaterequalorless = 8923;
      e3.greatermonospace = 65310;
      e3.greaterorequivalent = 8819;
      e3.greaterorless = 8823;
      e3.greateroverequal = 8807;
      e3.greatersmall = 65125;
      e3.gscript = 609;
      e3.gstroke = 485;
      e3.guhiragana = 12368;
      e3.guillemotleft = 171;
      e3.guillemotright = 187;
      e3.guilsinglleft = 8249;
      e3.guilsinglright = 8250;
      e3.gukatakana = 12464;
      e3.guramusquare = 13080;
      e3.gysquare = 13257;
      e3.h = 104;
      e3.haabkhasiancyrillic = 1193;
      e3.haaltonearabic = 1729;
      e3.habengali = 2489;
      e3.hadescendercyrillic = 1203;
      e3.hadeva = 2361;
      e3.hagujarati = 2745;
      e3.hagurmukhi = 2617;
      e3.haharabic = 1581;
      e3.hahfinalarabic = 65186;
      e3.hahinitialarabic = 65187;
      e3.hahiragana = 12399;
      e3.hahmedialarabic = 65188;
      e3.haitusquare = 13098;
      e3.hakatakana = 12495;
      e3.hakatakanahalfwidth = 65418;
      e3.halantgurmukhi = 2637;
      e3.hamzaarabic = 1569;
      e3.hamzalowarabic = 1569;
      e3.hangulfiller = 12644;
      e3.hardsigncyrillic = 1098;
      e3.harpoonleftbarbup = 8636;
      e3.harpoonrightbarbup = 8640;
      e3.hasquare = 13258;
      e3.hatafpatah = 1458;
      e3.hatafpatah16 = 1458;
      e3.hatafpatah23 = 1458;
      e3.hatafpatah2f = 1458;
      e3.hatafpatahhebrew = 1458;
      e3.hatafpatahnarrowhebrew = 1458;
      e3.hatafpatahquarterhebrew = 1458;
      e3.hatafpatahwidehebrew = 1458;
      e3.hatafqamats = 1459;
      e3.hatafqamats1b = 1459;
      e3.hatafqamats28 = 1459;
      e3.hatafqamats34 = 1459;
      e3.hatafqamatshebrew = 1459;
      e3.hatafqamatsnarrowhebrew = 1459;
      e3.hatafqamatsquarterhebrew = 1459;
      e3.hatafqamatswidehebrew = 1459;
      e3.hatafsegol = 1457;
      e3.hatafsegol17 = 1457;
      e3.hatafsegol24 = 1457;
      e3.hatafsegol30 = 1457;
      e3.hatafsegolhebrew = 1457;
      e3.hatafsegolnarrowhebrew = 1457;
      e3.hatafsegolquarterhebrew = 1457;
      e3.hatafsegolwidehebrew = 1457;
      e3.hbar = 295;
      e3.hbopomofo = 12559;
      e3.hbrevebelow = 7723;
      e3.hcedilla = 7721;
      e3.hcircle = 9431;
      e3.hcircumflex = 293;
      e3.hdieresis = 7719;
      e3.hdotaccent = 7715;
      e3.hdotbelow = 7717;
      e3.he = 1492;
      e3.heart = 9829;
      e3.heartsuitblack = 9829;
      e3.heartsuitwhite = 9825;
      e3.hedagesh = 64308;
      e3.hedageshhebrew = 64308;
      e3.hehaltonearabic = 1729;
      e3.heharabic = 1607;
      e3.hehebrew = 1492;
      e3.hehfinalaltonearabic = 64423;
      e3.hehfinalalttwoarabic = 65258;
      e3.hehfinalarabic = 65258;
      e3.hehhamzaabovefinalarabic = 64421;
      e3.hehhamzaaboveisolatedarabic = 64420;
      e3.hehinitialaltonearabic = 64424;
      e3.hehinitialarabic = 65259;
      e3.hehiragana = 12408;
      e3.hehmedialaltonearabic = 64425;
      e3.hehmedialarabic = 65260;
      e3.heiseierasquare = 13179;
      e3.hekatakana = 12504;
      e3.hekatakanahalfwidth = 65421;
      e3.hekutaarusquare = 13110;
      e3.henghook = 615;
      e3.herutusquare = 13113;
      e3.het = 1495;
      e3.hethebrew = 1495;
      e3.hhook = 614;
      e3.hhooksuperior = 689;
      e3.hieuhacirclekorean = 12923;
      e3.hieuhaparenkorean = 12827;
      e3.hieuhcirclekorean = 12909;
      e3.hieuhkorean = 12622;
      e3.hieuhparenkorean = 12813;
      e3.hihiragana = 12402;
      e3.hikatakana = 12498;
      e3.hikatakanahalfwidth = 65419;
      e3.hiriq = 1460;
      e3.hiriq14 = 1460;
      e3.hiriq21 = 1460;
      e3.hiriq2d = 1460;
      e3.hiriqhebrew = 1460;
      e3.hiriqnarrowhebrew = 1460;
      e3.hiriqquarterhebrew = 1460;
      e3.hiriqwidehebrew = 1460;
      e3.hlinebelow = 7830;
      e3.hmonospace = 65352;
      e3.hoarmenian = 1392;
      e3.hohipthai = 3627;
      e3.hohiragana = 12411;
      e3.hokatakana = 12507;
      e3.hokatakanahalfwidth = 65422;
      e3.holam = 1465;
      e3.holam19 = 1465;
      e3.holam26 = 1465;
      e3.holam32 = 1465;
      e3.holamhebrew = 1465;
      e3.holamnarrowhebrew = 1465;
      e3.holamquarterhebrew = 1465;
      e3.holamwidehebrew = 1465;
      e3.honokhukthai = 3630;
      e3.hookabovecomb = 777;
      e3.hookcmb = 777;
      e3.hookpalatalizedbelowcmb = 801;
      e3.hookretroflexbelowcmb = 802;
      e3.hoonsquare = 13122;
      e3.horicoptic = 1001;
      e3.horizontalbar = 8213;
      e3.horncmb = 795;
      e3.hotsprings = 9832;
      e3.house = 8962;
      e3.hparen = 9379;
      e3.hsuperior = 688;
      e3.hturned = 613;
      e3.huhiragana = 12405;
      e3.huiitosquare = 13107;
      e3.hukatakana = 12501;
      e3.hukatakanahalfwidth = 65420;
      e3.hungarumlaut = 733;
      e3.hungarumlautcmb = 779;
      e3.hv = 405;
      e3.hyphen = 45;
      e3.hypheninferior = 63205;
      e3.hyphenmonospace = 65293;
      e3.hyphensmall = 65123;
      e3.hyphensuperior = 63206;
      e3.hyphentwo = 8208;
      e3.i = 105;
      e3.iacute = 237;
      e3.iacyrillic = 1103;
      e3.ibengali = 2439;
      e3.ibopomofo = 12583;
      e3.ibreve = 301;
      e3.icaron = 464;
      e3.icircle = 9432;
      e3.icircumflex = 238;
      e3.icyrillic = 1110;
      e3.idblgrave = 521;
      e3.ideographearthcircle = 12943;
      e3.ideographfirecircle = 12939;
      e3.ideographicallianceparen = 12863;
      e3.ideographiccallparen = 12858;
      e3.ideographiccentrecircle = 12965;
      e3.ideographicclose = 12294;
      e3.ideographiccomma = 12289;
      e3.ideographiccommaleft = 65380;
      e3.ideographiccongratulationparen = 12855;
      e3.ideographiccorrectcircle = 12963;
      e3.ideographicearthparen = 12847;
      e3.ideographicenterpriseparen = 12861;
      e3.ideographicexcellentcircle = 12957;
      e3.ideographicfestivalparen = 12864;
      e3.ideographicfinancialcircle = 12950;
      e3.ideographicfinancialparen = 12854;
      e3.ideographicfireparen = 12843;
      e3.ideographichaveparen = 12850;
      e3.ideographichighcircle = 12964;
      e3.ideographiciterationmark = 12293;
      e3.ideographiclaborcircle = 12952;
      e3.ideographiclaborparen = 12856;
      e3.ideographicleftcircle = 12967;
      e3.ideographiclowcircle = 12966;
      e3.ideographicmedicinecircle = 12969;
      e3.ideographicmetalparen = 12846;
      e3.ideographicmoonparen = 12842;
      e3.ideographicnameparen = 12852;
      e3.ideographicperiod = 12290;
      e3.ideographicprintcircle = 12958;
      e3.ideographicreachparen = 12867;
      e3.ideographicrepresentparen = 12857;
      e3.ideographicresourceparen = 12862;
      e3.ideographicrightcircle = 12968;
      e3.ideographicsecretcircle = 12953;
      e3.ideographicselfparen = 12866;
      e3.ideographicsocietyparen = 12851;
      e3.ideographicspace = 12288;
      e3.ideographicspecialparen = 12853;
      e3.ideographicstockparen = 12849;
      e3.ideographicstudyparen = 12859;
      e3.ideographicsunparen = 12848;
      e3.ideographicsuperviseparen = 12860;
      e3.ideographicwaterparen = 12844;
      e3.ideographicwoodparen = 12845;
      e3.ideographiczero = 12295;
      e3.ideographmetalcircle = 12942;
      e3.ideographmooncircle = 12938;
      e3.ideographnamecircle = 12948;
      e3.ideographsuncircle = 12944;
      e3.ideographwatercircle = 12940;
      e3.ideographwoodcircle = 12941;
      e3.ideva = 2311;
      e3.idieresis = 239;
      e3.idieresisacute = 7727;
      e3.idieresiscyrillic = 1253;
      e3.idotbelow = 7883;
      e3.iebrevecyrillic = 1239;
      e3.iecyrillic = 1077;
      e3.ieungacirclekorean = 12917;
      e3.ieungaparenkorean = 12821;
      e3.ieungcirclekorean = 12903;
      e3.ieungkorean = 12615;
      e3.ieungparenkorean = 12807;
      e3.igrave = 236;
      e3.igujarati = 2695;
      e3.igurmukhi = 2567;
      e3.ihiragana = 12356;
      e3.ihookabove = 7881;
      e3.iibengali = 2440;
      e3.iicyrillic = 1080;
      e3.iideva = 2312;
      e3.iigujarati = 2696;
      e3.iigurmukhi = 2568;
      e3.iimatragurmukhi = 2624;
      e3.iinvertedbreve = 523;
      e3.iishortcyrillic = 1081;
      e3.iivowelsignbengali = 2496;
      e3.iivowelsigndeva = 2368;
      e3.iivowelsigngujarati = 2752;
      e3.ij = 307;
      e3.ikatakana = 12452;
      e3.ikatakanahalfwidth = 65394;
      e3.ikorean = 12643;
      e3.ilde = 732;
      e3.iluyhebrew = 1452;
      e3.imacron = 299;
      e3.imacroncyrillic = 1251;
      e3.imageorapproximatelyequal = 8787;
      e3.imatragurmukhi = 2623;
      e3.imonospace = 65353;
      e3.increment = 8710;
      e3.infinity = 8734;
      e3.iniarmenian = 1387;
      e3.integral = 8747;
      e3.integralbottom = 8993;
      e3.integralbt = 8993;
      e3.integralex = 63733;
      e3.integraltop = 8992;
      e3.integraltp = 8992;
      e3.intersection = 8745;
      e3.intisquare = 13061;
      e3.invbullet = 9688;
      e3.invcircle = 9689;
      e3.invsmileface = 9787;
      e3.iocyrillic = 1105;
      e3.iogonek = 303;
      e3.iota = 953;
      e3.iotadieresis = 970;
      e3.iotadieresistonos = 912;
      e3.iotalatin = 617;
      e3.iotatonos = 943;
      e3.iparen = 9380;
      e3.irigurmukhi = 2674;
      e3.ismallhiragana = 12355;
      e3.ismallkatakana = 12451;
      e3.ismallkatakanahalfwidth = 65384;
      e3.issharbengali = 2554;
      e3.istroke = 616;
      e3.isuperior = 63213;
      e3.iterationhiragana = 12445;
      e3.iterationkatakana = 12541;
      e3.itilde = 297;
      e3.itildebelow = 7725;
      e3.iubopomofo = 12585;
      e3.iucyrillic = 1102;
      e3.ivowelsignbengali = 2495;
      e3.ivowelsigndeva = 2367;
      e3.ivowelsigngujarati = 2751;
      e3.izhitsacyrillic = 1141;
      e3.izhitsadblgravecyrillic = 1143;
      e3.j = 106;
      e3.jaarmenian = 1393;
      e3.jabengali = 2460;
      e3.jadeva = 2332;
      e3.jagujarati = 2716;
      e3.jagurmukhi = 2588;
      e3.jbopomofo = 12560;
      e3.jcaron = 496;
      e3.jcircle = 9433;
      e3.jcircumflex = 309;
      e3.jcrossedtail = 669;
      e3.jdotlessstroke = 607;
      e3.jecyrillic = 1112;
      e3.jeemarabic = 1580;
      e3.jeemfinalarabic = 65182;
      e3.jeeminitialarabic = 65183;
      e3.jeemmedialarabic = 65184;
      e3.jeharabic = 1688;
      e3.jehfinalarabic = 64395;
      e3.jhabengali = 2461;
      e3.jhadeva = 2333;
      e3.jhagujarati = 2717;
      e3.jhagurmukhi = 2589;
      e3.jheharmenian = 1403;
      e3.jis = 12292;
      e3.jmonospace = 65354;
      e3.jparen = 9381;
      e3.jsuperior = 690;
      e3.k = 107;
      e3.kabashkircyrillic = 1185;
      e3.kabengali = 2453;
      e3.kacute = 7729;
      e3.kacyrillic = 1082;
      e3.kadescendercyrillic = 1179;
      e3.kadeva = 2325;
      e3.kaf = 1499;
      e3.kafarabic = 1603;
      e3.kafdagesh = 64315;
      e3.kafdageshhebrew = 64315;
      e3.kaffinalarabic = 65242;
      e3.kafhebrew = 1499;
      e3.kafinitialarabic = 65243;
      e3.kafmedialarabic = 65244;
      e3.kafrafehebrew = 64333;
      e3.kagujarati = 2709;
      e3.kagurmukhi = 2581;
      e3.kahiragana = 12363;
      e3.kahookcyrillic = 1220;
      e3.kakatakana = 12459;
      e3.kakatakanahalfwidth = 65398;
      e3.kappa = 954;
      e3.kappasymbolgreek = 1008;
      e3.kapyeounmieumkorean = 12657;
      e3.kapyeounphieuphkorean = 12676;
      e3.kapyeounpieupkorean = 12664;
      e3.kapyeounssangpieupkorean = 12665;
      e3.karoriisquare = 13069;
      e3.kashidaautoarabic = 1600;
      e3.kashidaautonosidebearingarabic = 1600;
      e3.kasmallkatakana = 12533;
      e3.kasquare = 13188;
      e3.kasraarabic = 1616;
      e3.kasratanarabic = 1613;
      e3.kastrokecyrillic = 1183;
      e3.katahiraprolongmarkhalfwidth = 65392;
      e3.kaverticalstrokecyrillic = 1181;
      e3.kbopomofo = 12558;
      e3.kcalsquare = 13193;
      e3.kcaron = 489;
      e3.kcedilla = 311;
      e3.kcircle = 9434;
      e3.kcommaaccent = 311;
      e3.kdotbelow = 7731;
      e3.keharmenian = 1412;
      e3.kehiragana = 12369;
      e3.kekatakana = 12465;
      e3.kekatakanahalfwidth = 65401;
      e3.kenarmenian = 1391;
      e3.kesmallkatakana = 12534;
      e3.kgreenlandic = 312;
      e3.khabengali = 2454;
      e3.khacyrillic = 1093;
      e3.khadeva = 2326;
      e3.khagujarati = 2710;
      e3.khagurmukhi = 2582;
      e3.khaharabic = 1582;
      e3.khahfinalarabic = 65190;
      e3.khahinitialarabic = 65191;
      e3.khahmedialarabic = 65192;
      e3.kheicoptic = 999;
      e3.khhadeva = 2393;
      e3.khhagurmukhi = 2649;
      e3.khieukhacirclekorean = 12920;
      e3.khieukhaparenkorean = 12824;
      e3.khieukhcirclekorean = 12906;
      e3.khieukhkorean = 12619;
      e3.khieukhparenkorean = 12810;
      e3.khokhaithai = 3586;
      e3.khokhonthai = 3589;
      e3.khokhuatthai = 3587;
      e3.khokhwaithai = 3588;
      e3.khomutthai = 3675;
      e3.khook = 409;
      e3.khorakhangthai = 3590;
      e3.khzsquare = 13201;
      e3.kihiragana = 12365;
      e3.kikatakana = 12461;
      e3.kikatakanahalfwidth = 65399;
      e3.kiroguramusquare = 13077;
      e3.kiromeetorusquare = 13078;
      e3.kirosquare = 13076;
      e3.kiyeokacirclekorean = 12910;
      e3.kiyeokaparenkorean = 12814;
      e3.kiyeokcirclekorean = 12896;
      e3.kiyeokkorean = 12593;
      e3.kiyeokparenkorean = 12800;
      e3.kiyeoksioskorean = 12595;
      e3.kjecyrillic = 1116;
      e3.klinebelow = 7733;
      e3.klsquare = 13208;
      e3.kmcubedsquare = 13222;
      e3.kmonospace = 65355;
      e3.kmsquaredsquare = 13218;
      e3.kohiragana = 12371;
      e3.kohmsquare = 13248;
      e3.kokaithai = 3585;
      e3.kokatakana = 12467;
      e3.kokatakanahalfwidth = 65402;
      e3.kooposquare = 13086;
      e3.koppacyrillic = 1153;
      e3.koreanstandardsymbol = 12927;
      e3.koroniscmb = 835;
      e3.kparen = 9382;
      e3.kpasquare = 13226;
      e3.ksicyrillic = 1135;
      e3.ktsquare = 13263;
      e3.kturned = 670;
      e3.kuhiragana = 12367;
      e3.kukatakana = 12463;
      e3.kukatakanahalfwidth = 65400;
      e3.kvsquare = 13240;
      e3.kwsquare = 13246;
      e3.l = 108;
      e3.labengali = 2482;
      e3.lacute = 314;
      e3.ladeva = 2354;
      e3.lagujarati = 2738;
      e3.lagurmukhi = 2610;
      e3.lakkhangyaothai = 3653;
      e3.lamaleffinalarabic = 65276;
      e3.lamalefhamzaabovefinalarabic = 65272;
      e3.lamalefhamzaaboveisolatedarabic = 65271;
      e3.lamalefhamzabelowfinalarabic = 65274;
      e3.lamalefhamzabelowisolatedarabic = 65273;
      e3.lamalefisolatedarabic = 65275;
      e3.lamalefmaddaabovefinalarabic = 65270;
      e3.lamalefmaddaaboveisolatedarabic = 65269;
      e3.lamarabic = 1604;
      e3.lambda = 955;
      e3.lambdastroke = 411;
      e3.lamed = 1500;
      e3.lameddagesh = 64316;
      e3.lameddageshhebrew = 64316;
      e3.lamedhebrew = 1500;
      e3.lamfinalarabic = 65246;
      e3.lamhahinitialarabic = 64714;
      e3.laminitialarabic = 65247;
      e3.lamjeeminitialarabic = 64713;
      e3.lamkhahinitialarabic = 64715;
      e3.lamlamhehisolatedarabic = 65010;
      e3.lammedialarabic = 65248;
      e3.lammeemhahinitialarabic = 64904;
      e3.lammeeminitialarabic = 64716;
      e3.largecircle = 9711;
      e3.lbar = 410;
      e3.lbelt = 620;
      e3.lbopomofo = 12556;
      e3.lcaron = 318;
      e3.lcedilla = 316;
      e3.lcircle = 9435;
      e3.lcircumflexbelow = 7741;
      e3.lcommaaccent = 316;
      e3.ldot = 320;
      e3.ldotaccent = 320;
      e3.ldotbelow = 7735;
      e3.ldotbelowmacron = 7737;
      e3.leftangleabovecmb = 794;
      e3.lefttackbelowcmb = 792;
      e3.less = 60;
      e3.lessequal = 8804;
      e3.lessequalorgreater = 8922;
      e3.lessmonospace = 65308;
      e3.lessorequivalent = 8818;
      e3.lessorgreater = 8822;
      e3.lessoverequal = 8806;
      e3.lesssmall = 65124;
      e3.lezh = 622;
      e3.lfblock = 9612;
      e3.lhookretroflex = 621;
      e3.lira = 8356;
      e3.liwnarmenian = 1388;
      e3.lj = 457;
      e3.ljecyrillic = 1113;
      e3.ll = 63168;
      e3.lladeva = 2355;
      e3.llagujarati = 2739;
      e3.llinebelow = 7739;
      e3.llladeva = 2356;
      e3.llvocalicbengali = 2529;
      e3.llvocalicdeva = 2401;
      e3.llvocalicvowelsignbengali = 2531;
      e3.llvocalicvowelsigndeva = 2403;
      e3.lmiddletilde = 619;
      e3.lmonospace = 65356;
      e3.lmsquare = 13264;
      e3.lochulathai = 3628;
      e3.logicaland = 8743;
      e3.logicalnot = 172;
      e3.logicalnotreversed = 8976;
      e3.logicalor = 8744;
      e3.lolingthai = 3621;
      e3.longs = 383;
      e3.lowlinecenterline = 65102;
      e3.lowlinecmb = 818;
      e3.lowlinedashed = 65101;
      e3.lozenge = 9674;
      e3.lparen = 9383;
      e3.lslash = 322;
      e3.lsquare = 8467;
      e3.lsuperior = 63214;
      e3.ltshade = 9617;
      e3.luthai = 3622;
      e3.lvocalicbengali = 2444;
      e3.lvocalicdeva = 2316;
      e3.lvocalicvowelsignbengali = 2530;
      e3.lvocalicvowelsigndeva = 2402;
      e3.lxsquare = 13267;
      e3.m = 109;
      e3.mabengali = 2478;
      e3.macron = 175;
      e3.macronbelowcmb = 817;
      e3.macroncmb = 772;
      e3.macronlowmod = 717;
      e3.macronmonospace = 65507;
      e3.macute = 7743;
      e3.madeva = 2350;
      e3.magujarati = 2734;
      e3.magurmukhi = 2606;
      e3.mahapakhhebrew = 1444;
      e3.mahapakhlefthebrew = 1444;
      e3.mahiragana = 12414;
      e3.maichattawalowleftthai = 63637;
      e3.maichattawalowrightthai = 63636;
      e3.maichattawathai = 3659;
      e3.maichattawaupperleftthai = 63635;
      e3.maieklowleftthai = 63628;
      e3.maieklowrightthai = 63627;
      e3.maiekthai = 3656;
      e3.maiekupperleftthai = 63626;
      e3.maihanakatleftthai = 63620;
      e3.maihanakatthai = 3633;
      e3.maitaikhuleftthai = 63625;
      e3.maitaikhuthai = 3655;
      e3.maitholowleftthai = 63631;
      e3.maitholowrightthai = 63630;
      e3.maithothai = 3657;
      e3.maithoupperleftthai = 63629;
      e3.maitrilowleftthai = 63634;
      e3.maitrilowrightthai = 63633;
      e3.maitrithai = 3658;
      e3.maitriupperleftthai = 63632;
      e3.maiyamokthai = 3654;
      e3.makatakana = 12510;
      e3.makatakanahalfwidth = 65423;
      e3.male = 9794;
      e3.mansyonsquare = 13127;
      e3.maqafhebrew = 1470;
      e3.mars = 9794;
      e3.masoracirclehebrew = 1455;
      e3.masquare = 13187;
      e3.mbopomofo = 12551;
      e3.mbsquare = 13268;
      e3.mcircle = 9436;
      e3.mcubedsquare = 13221;
      e3.mdotaccent = 7745;
      e3.mdotbelow = 7747;
      e3.meemarabic = 1605;
      e3.meemfinalarabic = 65250;
      e3.meeminitialarabic = 65251;
      e3.meemmedialarabic = 65252;
      e3.meemmeeminitialarabic = 64721;
      e3.meemmeemisolatedarabic = 64584;
      e3.meetorusquare = 13133;
      e3.mehiragana = 12417;
      e3.meizierasquare = 13182;
      e3.mekatakana = 12513;
      e3.mekatakanahalfwidth = 65426;
      e3.mem = 1502;
      e3.memdagesh = 64318;
      e3.memdageshhebrew = 64318;
      e3.memhebrew = 1502;
      e3.menarmenian = 1396;
      e3.merkhahebrew = 1445;
      e3.merkhakefulahebrew = 1446;
      e3.merkhakefulalefthebrew = 1446;
      e3.merkhalefthebrew = 1445;
      e3.mhook = 625;
      e3.mhzsquare = 13202;
      e3.middledotkatakanahalfwidth = 65381;
      e3.middot = 183;
      e3.mieumacirclekorean = 12914;
      e3.mieumaparenkorean = 12818;
      e3.mieumcirclekorean = 12900;
      e3.mieumkorean = 12609;
      e3.mieumpansioskorean = 12656;
      e3.mieumparenkorean = 12804;
      e3.mieumpieupkorean = 12654;
      e3.mieumsioskorean = 12655;
      e3.mihiragana = 12415;
      e3.mikatakana = 12511;
      e3.mikatakanahalfwidth = 65424;
      e3.minus = 8722;
      e3.minusbelowcmb = 800;
      e3.minuscircle = 8854;
      e3.minusmod = 727;
      e3.minusplus = 8723;
      e3.minute = 8242;
      e3.miribaarusquare = 13130;
      e3.mirisquare = 13129;
      e3.mlonglegturned = 624;
      e3.mlsquare = 13206;
      e3.mmcubedsquare = 13219;
      e3.mmonospace = 65357;
      e3.mmsquaredsquare = 13215;
      e3.mohiragana = 12418;
      e3.mohmsquare = 13249;
      e3.mokatakana = 12514;
      e3.mokatakanahalfwidth = 65427;
      e3.molsquare = 13270;
      e3.momathai = 3617;
      e3.moverssquare = 13223;
      e3.moverssquaredsquare = 13224;
      e3.mparen = 9384;
      e3.mpasquare = 13227;
      e3.mssquare = 13235;
      e3.msuperior = 63215;
      e3.mturned = 623;
      e3.mu = 181;
      e3.mu1 = 181;
      e3.muasquare = 13186;
      e3.muchgreater = 8811;
      e3.muchless = 8810;
      e3.mufsquare = 13196;
      e3.mugreek = 956;
      e3.mugsquare = 13197;
      e3.muhiragana = 12416;
      e3.mukatakana = 12512;
      e3.mukatakanahalfwidth = 65425;
      e3.mulsquare = 13205;
      e3.multiply = 215;
      e3.mumsquare = 13211;
      e3.munahhebrew = 1443;
      e3.munahlefthebrew = 1443;
      e3.musicalnote = 9834;
      e3.musicalnotedbl = 9835;
      e3.musicflatsign = 9837;
      e3.musicsharpsign = 9839;
      e3.mussquare = 13234;
      e3.muvsquare = 13238;
      e3.muwsquare = 13244;
      e3.mvmegasquare = 13241;
      e3.mvsquare = 13239;
      e3.mwmegasquare = 13247;
      e3.mwsquare = 13245;
      e3.n = 110;
      e3.nabengali = 2472;
      e3.nabla = 8711;
      e3.nacute = 324;
      e3.nadeva = 2344;
      e3.nagujarati = 2728;
      e3.nagurmukhi = 2600;
      e3.nahiragana = 12394;
      e3.nakatakana = 12490;
      e3.nakatakanahalfwidth = 65413;
      e3.napostrophe = 329;
      e3.nasquare = 13185;
      e3.nbopomofo = 12555;
      e3.nbspace = 160;
      e3.ncaron = 328;
      e3.ncedilla = 326;
      e3.ncircle = 9437;
      e3.ncircumflexbelow = 7755;
      e3.ncommaaccent = 326;
      e3.ndotaccent = 7749;
      e3.ndotbelow = 7751;
      e3.nehiragana = 12397;
      e3.nekatakana = 12493;
      e3.nekatakanahalfwidth = 65416;
      e3.newsheqelsign = 8362;
      e3.nfsquare = 13195;
      e3.ngabengali = 2457;
      e3.ngadeva = 2329;
      e3.ngagujarati = 2713;
      e3.ngagurmukhi = 2585;
      e3.ngonguthai = 3591;
      e3.nhiragana = 12435;
      e3.nhookleft = 626;
      e3.nhookretroflex = 627;
      e3.nieunacirclekorean = 12911;
      e3.nieunaparenkorean = 12815;
      e3.nieuncieuckorean = 12597;
      e3.nieuncirclekorean = 12897;
      e3.nieunhieuhkorean = 12598;
      e3.nieunkorean = 12596;
      e3.nieunpansioskorean = 12648;
      e3.nieunparenkorean = 12801;
      e3.nieunsioskorean = 12647;
      e3.nieuntikeutkorean = 12646;
      e3.nihiragana = 12395;
      e3.nikatakana = 12491;
      e3.nikatakanahalfwidth = 65414;
      e3.nikhahitleftthai = 63641;
      e3.nikhahitthai = 3661;
      e3.nine = 57;
      e3.ninearabic = 1641;
      e3.ninebengali = 2543;
      e3.ninecircle = 9320;
      e3.ninecircleinversesansserif = 10130;
      e3.ninedeva = 2415;
      e3.ninegujarati = 2799;
      e3.ninegurmukhi = 2671;
      e3.ninehackarabic = 1641;
      e3.ninehangzhou = 12329;
      e3.nineideographicparen = 12840;
      e3.nineinferior = 8329;
      e3.ninemonospace = 65305;
      e3.nineoldstyle = 63289;
      e3.nineparen = 9340;
      e3.nineperiod = 9360;
      e3.ninepersian = 1785;
      e3.nineroman = 8568;
      e3.ninesuperior = 8313;
      e3.nineteencircle = 9330;
      e3.nineteenparen = 9350;
      e3.nineteenperiod = 9370;
      e3.ninethai = 3673;
      e3.nj = 460;
      e3.njecyrillic = 1114;
      e3.nkatakana = 12531;
      e3.nkatakanahalfwidth = 65437;
      e3.nlegrightlong = 414;
      e3.nlinebelow = 7753;
      e3.nmonospace = 65358;
      e3.nmsquare = 13210;
      e3.nnabengali = 2467;
      e3.nnadeva = 2339;
      e3.nnagujarati = 2723;
      e3.nnagurmukhi = 2595;
      e3.nnnadeva = 2345;
      e3.nohiragana = 12398;
      e3.nokatakana = 12494;
      e3.nokatakanahalfwidth = 65417;
      e3.nonbreakingspace = 160;
      e3.nonenthai = 3603;
      e3.nonuthai = 3609;
      e3.noonarabic = 1606;
      e3.noonfinalarabic = 65254;
      e3.noonghunnaarabic = 1722;
      e3.noonghunnafinalarabic = 64415;
      e3.nooninitialarabic = 65255;
      e3.noonjeeminitialarabic = 64722;
      e3.noonjeemisolatedarabic = 64587;
      e3.noonmedialarabic = 65256;
      e3.noonmeeminitialarabic = 64725;
      e3.noonmeemisolatedarabic = 64590;
      e3.noonnoonfinalarabic = 64653;
      e3.notcontains = 8716;
      e3.notelement = 8713;
      e3.notelementof = 8713;
      e3.notequal = 8800;
      e3.notgreater = 8815;
      e3.notgreaternorequal = 8817;
      e3.notgreaternorless = 8825;
      e3.notidentical = 8802;
      e3.notless = 8814;
      e3.notlessnorequal = 8816;
      e3.notparallel = 8742;
      e3.notprecedes = 8832;
      e3.notsubset = 8836;
      e3.notsucceeds = 8833;
      e3.notsuperset = 8837;
      e3.nowarmenian = 1398;
      e3.nparen = 9385;
      e3.nssquare = 13233;
      e3.nsuperior = 8319;
      e3.ntilde = 241;
      e3.nu = 957;
      e3.nuhiragana = 12396;
      e3.nukatakana = 12492;
      e3.nukatakanahalfwidth = 65415;
      e3.nuktabengali = 2492;
      e3.nuktadeva = 2364;
      e3.nuktagujarati = 2748;
      e3.nuktagurmukhi = 2620;
      e3.numbersign = 35;
      e3.numbersignmonospace = 65283;
      e3.numbersignsmall = 65119;
      e3.numeralsigngreek = 884;
      e3.numeralsignlowergreek = 885;
      e3.numero = 8470;
      e3.nun = 1504;
      e3.nundagesh = 64320;
      e3.nundageshhebrew = 64320;
      e3.nunhebrew = 1504;
      e3.nvsquare = 13237;
      e3.nwsquare = 13243;
      e3.nyabengali = 2462;
      e3.nyadeva = 2334;
      e3.nyagujarati = 2718;
      e3.nyagurmukhi = 2590;
      e3.o = 111;
      e3.oacute = 243;
      e3.oangthai = 3629;
      e3.obarred = 629;
      e3.obarredcyrillic = 1257;
      e3.obarreddieresiscyrillic = 1259;
      e3.obengali = 2451;
      e3.obopomofo = 12571;
      e3.obreve = 335;
      e3.ocandradeva = 2321;
      e3.ocandragujarati = 2705;
      e3.ocandravowelsigndeva = 2377;
      e3.ocandravowelsigngujarati = 2761;
      e3.ocaron = 466;
      e3.ocircle = 9438;
      e3.ocircumflex = 244;
      e3.ocircumflexacute = 7889;
      e3.ocircumflexdotbelow = 7897;
      e3.ocircumflexgrave = 7891;
      e3.ocircumflexhookabove = 7893;
      e3.ocircumflextilde = 7895;
      e3.ocyrillic = 1086;
      e3.odblacute = 337;
      e3.odblgrave = 525;
      e3.odeva = 2323;
      e3.odieresis = 246;
      e3.odieresiscyrillic = 1255;
      e3.odotbelow = 7885;
      e3.oe = 339;
      e3.oekorean = 12634;
      e3.ogonek = 731;
      e3.ogonekcmb = 808;
      e3.ograve = 242;
      e3.ogujarati = 2707;
      e3.oharmenian = 1413;
      e3.ohiragana = 12362;
      e3.ohookabove = 7887;
      e3.ohorn = 417;
      e3.ohornacute = 7899;
      e3.ohorndotbelow = 7907;
      e3.ohorngrave = 7901;
      e3.ohornhookabove = 7903;
      e3.ohorntilde = 7905;
      e3.ohungarumlaut = 337;
      e3.oi = 419;
      e3.oinvertedbreve = 527;
      e3.okatakana = 12458;
      e3.okatakanahalfwidth = 65397;
      e3.okorean = 12631;
      e3.olehebrew = 1451;
      e3.omacron = 333;
      e3.omacronacute = 7763;
      e3.omacrongrave = 7761;
      e3.omdeva = 2384;
      e3.omega = 969;
      e3.omega1 = 982;
      e3.omegacyrillic = 1121;
      e3.omegalatinclosed = 631;
      e3.omegaroundcyrillic = 1147;
      e3.omegatitlocyrillic = 1149;
      e3.omegatonos = 974;
      e3.omgujarati = 2768;
      e3.omicron = 959;
      e3.omicrontonos = 972;
      e3.omonospace = 65359;
      e3.one = 49;
      e3.onearabic = 1633;
      e3.onebengali = 2535;
      e3.onecircle = 9312;
      e3.onecircleinversesansserif = 10122;
      e3.onedeva = 2407;
      e3.onedotenleader = 8228;
      e3.oneeighth = 8539;
      e3.onefitted = 63196;
      e3.onegujarati = 2791;
      e3.onegurmukhi = 2663;
      e3.onehackarabic = 1633;
      e3.onehalf = 189;
      e3.onehangzhou = 12321;
      e3.oneideographicparen = 12832;
      e3.oneinferior = 8321;
      e3.onemonospace = 65297;
      e3.onenumeratorbengali = 2548;
      e3.oneoldstyle = 63281;
      e3.oneparen = 9332;
      e3.oneperiod = 9352;
      e3.onepersian = 1777;
      e3.onequarter = 188;
      e3.oneroman = 8560;
      e3.onesuperior = 185;
      e3.onethai = 3665;
      e3.onethird = 8531;
      e3.oogonek = 491;
      e3.oogonekmacron = 493;
      e3.oogurmukhi = 2579;
      e3.oomatragurmukhi = 2635;
      e3.oopen = 596;
      e3.oparen = 9386;
      e3.openbullet = 9702;
      e3.option = 8997;
      e3.ordfeminine = 170;
      e3.ordmasculine = 186;
      e3.orthogonal = 8735;
      e3.oshortdeva = 2322;
      e3.oshortvowelsigndeva = 2378;
      e3.oslash = 248;
      e3.oslashacute = 511;
      e3.osmallhiragana = 12361;
      e3.osmallkatakana = 12457;
      e3.osmallkatakanahalfwidth = 65387;
      e3.ostrokeacute = 511;
      e3.osuperior = 63216;
      e3.otcyrillic = 1151;
      e3.otilde = 245;
      e3.otildeacute = 7757;
      e3.otildedieresis = 7759;
      e3.oubopomofo = 12577;
      e3.overline = 8254;
      e3.overlinecenterline = 65098;
      e3.overlinecmb = 773;
      e3.overlinedashed = 65097;
      e3.overlinedblwavy = 65100;
      e3.overlinewavy = 65099;
      e3.overscore = 175;
      e3.ovowelsignbengali = 2507;
      e3.ovowelsigndeva = 2379;
      e3.ovowelsigngujarati = 2763;
      e3.p = 112;
      e3.paampssquare = 13184;
      e3.paasentosquare = 13099;
      e3.pabengali = 2474;
      e3.pacute = 7765;
      e3.padeva = 2346;
      e3.pagedown = 8671;
      e3.pageup = 8670;
      e3.pagujarati = 2730;
      e3.pagurmukhi = 2602;
      e3.pahiragana = 12401;
      e3.paiyannoithai = 3631;
      e3.pakatakana = 12497;
      e3.palatalizationcyrilliccmb = 1156;
      e3.palochkacyrillic = 1216;
      e3.pansioskorean = 12671;
      e3.paragraph = 182;
      e3.parallel = 8741;
      e3.parenleft = 40;
      e3.parenleftaltonearabic = 64830;
      e3.parenleftbt = 63725;
      e3.parenleftex = 63724;
      e3.parenleftinferior = 8333;
      e3.parenleftmonospace = 65288;
      e3.parenleftsmall = 65113;
      e3.parenleftsuperior = 8317;
      e3.parenlefttp = 63723;
      e3.parenleftvertical = 65077;
      e3.parenright = 41;
      e3.parenrightaltonearabic = 64831;
      e3.parenrightbt = 63736;
      e3.parenrightex = 63735;
      e3.parenrightinferior = 8334;
      e3.parenrightmonospace = 65289;
      e3.parenrightsmall = 65114;
      e3.parenrightsuperior = 8318;
      e3.parenrighttp = 63734;
      e3.parenrightvertical = 65078;
      e3.partialdiff = 8706;
      e3.paseqhebrew = 1472;
      e3.pashtahebrew = 1433;
      e3.pasquare = 13225;
      e3.patah = 1463;
      e3.patah11 = 1463;
      e3.patah1d = 1463;
      e3.patah2a = 1463;
      e3.patahhebrew = 1463;
      e3.patahnarrowhebrew = 1463;
      e3.patahquarterhebrew = 1463;
      e3.patahwidehebrew = 1463;
      e3.pazerhebrew = 1441;
      e3.pbopomofo = 12550;
      e3.pcircle = 9439;
      e3.pdotaccent = 7767;
      e3.pe = 1508;
      e3.pecyrillic = 1087;
      e3.pedagesh = 64324;
      e3.pedageshhebrew = 64324;
      e3.peezisquare = 13115;
      e3.pefinaldageshhebrew = 64323;
      e3.peharabic = 1662;
      e3.peharmenian = 1402;
      e3.pehebrew = 1508;
      e3.pehfinalarabic = 64343;
      e3.pehinitialarabic = 64344;
      e3.pehiragana = 12410;
      e3.pehmedialarabic = 64345;
      e3.pekatakana = 12506;
      e3.pemiddlehookcyrillic = 1191;
      e3.perafehebrew = 64334;
      e3.percent = 37;
      e3.percentarabic = 1642;
      e3.percentmonospace = 65285;
      e3.percentsmall = 65130;
      e3.period = 46;
      e3.periodarmenian = 1417;
      e3.periodcentered = 183;
      e3.periodhalfwidth = 65377;
      e3.periodinferior = 63207;
      e3.periodmonospace = 65294;
      e3.periodsmall = 65106;
      e3.periodsuperior = 63208;
      e3.perispomenigreekcmb = 834;
      e3.perpendicular = 8869;
      e3.perthousand = 8240;
      e3.peseta = 8359;
      e3.pfsquare = 13194;
      e3.phabengali = 2475;
      e3.phadeva = 2347;
      e3.phagujarati = 2731;
      e3.phagurmukhi = 2603;
      e3.phi = 966;
      e3.phi1 = 981;
      e3.phieuphacirclekorean = 12922;
      e3.phieuphaparenkorean = 12826;
      e3.phieuphcirclekorean = 12908;
      e3.phieuphkorean = 12621;
      e3.phieuphparenkorean = 12812;
      e3.philatin = 632;
      e3.phinthuthai = 3642;
      e3.phisymbolgreek = 981;
      e3.phook = 421;
      e3.phophanthai = 3614;
      e3.phophungthai = 3612;
      e3.phosamphaothai = 3616;
      e3.pi = 960;
      e3.pieupacirclekorean = 12915;
      e3.pieupaparenkorean = 12819;
      e3.pieupcieuckorean = 12662;
      e3.pieupcirclekorean = 12901;
      e3.pieupkiyeokkorean = 12658;
      e3.pieupkorean = 12610;
      e3.pieupparenkorean = 12805;
      e3.pieupsioskiyeokkorean = 12660;
      e3.pieupsioskorean = 12612;
      e3.pieupsiostikeutkorean = 12661;
      e3.pieupthieuthkorean = 12663;
      e3.pieuptikeutkorean = 12659;
      e3.pihiragana = 12404;
      e3.pikatakana = 12500;
      e3.pisymbolgreek = 982;
      e3.piwrarmenian = 1411;
      e3.planckover2pi = 8463;
      e3.planckover2pi1 = 8463;
      e3.plus = 43;
      e3.plusbelowcmb = 799;
      e3.pluscircle = 8853;
      e3.plusminus = 177;
      e3.plusmod = 726;
      e3.plusmonospace = 65291;
      e3.plussmall = 65122;
      e3.plussuperior = 8314;
      e3.pmonospace = 65360;
      e3.pmsquare = 13272;
      e3.pohiragana = 12413;
      e3.pointingindexdownwhite = 9759;
      e3.pointingindexleftwhite = 9756;
      e3.pointingindexrightwhite = 9758;
      e3.pointingindexupwhite = 9757;
      e3.pokatakana = 12509;
      e3.poplathai = 3611;
      e3.postalmark = 12306;
      e3.postalmarkface = 12320;
      e3.pparen = 9387;
      e3.precedes = 8826;
      e3.prescription = 8478;
      e3.primemod = 697;
      e3.primereversed = 8245;
      e3.product = 8719;
      e3.projective = 8965;
      e3.prolongedkana = 12540;
      e3.propellor = 8984;
      e3.propersubset = 8834;
      e3.propersuperset = 8835;
      e3.proportion = 8759;
      e3.proportional = 8733;
      e3.psi = 968;
      e3.psicyrillic = 1137;
      e3.psilipneumatacyrilliccmb = 1158;
      e3.pssquare = 13232;
      e3.puhiragana = 12407;
      e3.pukatakana = 12503;
      e3.pvsquare = 13236;
      e3.pwsquare = 13242;
      e3.q = 113;
      e3.qadeva = 2392;
      e3.qadmahebrew = 1448;
      e3.qafarabic = 1602;
      e3.qaffinalarabic = 65238;
      e3.qafinitialarabic = 65239;
      e3.qafmedialarabic = 65240;
      e3.qamats = 1464;
      e3.qamats10 = 1464;
      e3.qamats1a = 1464;
      e3.qamats1c = 1464;
      e3.qamats27 = 1464;
      e3.qamats29 = 1464;
      e3.qamats33 = 1464;
      e3.qamatsde = 1464;
      e3.qamatshebrew = 1464;
      e3.qamatsnarrowhebrew = 1464;
      e3.qamatsqatanhebrew = 1464;
      e3.qamatsqatannarrowhebrew = 1464;
      e3.qamatsqatanquarterhebrew = 1464;
      e3.qamatsqatanwidehebrew = 1464;
      e3.qamatsquarterhebrew = 1464;
      e3.qamatswidehebrew = 1464;
      e3.qarneyparahebrew = 1439;
      e3.qbopomofo = 12561;
      e3.qcircle = 9440;
      e3.qhook = 672;
      e3.qmonospace = 65361;
      e3.qof = 1511;
      e3.qofdagesh = 64327;
      e3.qofdageshhebrew = 64327;
      e3.qofhebrew = 1511;
      e3.qparen = 9388;
      e3.quarternote = 9833;
      e3.qubuts = 1467;
      e3.qubuts18 = 1467;
      e3.qubuts25 = 1467;
      e3.qubuts31 = 1467;
      e3.qubutshebrew = 1467;
      e3.qubutsnarrowhebrew = 1467;
      e3.qubutsquarterhebrew = 1467;
      e3.qubutswidehebrew = 1467;
      e3.question = 63;
      e3.questionarabic = 1567;
      e3.questionarmenian = 1374;
      e3.questiondown = 191;
      e3.questiondownsmall = 63423;
      e3.questiongreek = 894;
      e3.questionmonospace = 65311;
      e3.questionsmall = 63295;
      e3.quotedbl = 34;
      e3.quotedblbase = 8222;
      e3.quotedblleft = 8220;
      e3.quotedblmonospace = 65282;
      e3.quotedblprime = 12318;
      e3.quotedblprimereversed = 12317;
      e3.quotedblright = 8221;
      e3.quoteleft = 8216;
      e3.quoteleftreversed = 8219;
      e3.quotereversed = 8219;
      e3.quoteright = 8217;
      e3.quoterightn = 329;
      e3.quotesinglbase = 8218;
      e3.quotesingle = 39;
      e3.quotesinglemonospace = 65287;
      e3.r = 114;
      e3.raarmenian = 1404;
      e3.rabengali = 2480;
      e3.racute = 341;
      e3.radeva = 2352;
      e3.radical = 8730;
      e3.radicalex = 63717;
      e3.radoverssquare = 13230;
      e3.radoverssquaredsquare = 13231;
      e3.radsquare = 13229;
      e3.rafe = 1471;
      e3.rafehebrew = 1471;
      e3.ragujarati = 2736;
      e3.ragurmukhi = 2608;
      e3.rahiragana = 12425;
      e3.rakatakana = 12521;
      e3.rakatakanahalfwidth = 65431;
      e3.ralowerdiagonalbengali = 2545;
      e3.ramiddlediagonalbengali = 2544;
      e3.ramshorn = 612;
      e3.ratio = 8758;
      e3.rbopomofo = 12566;
      e3.rcaron = 345;
      e3.rcedilla = 343;
      e3.rcircle = 9441;
      e3.rcommaaccent = 343;
      e3.rdblgrave = 529;
      e3.rdotaccent = 7769;
      e3.rdotbelow = 7771;
      e3.rdotbelowmacron = 7773;
      e3.referencemark = 8251;
      e3.reflexsubset = 8838;
      e3.reflexsuperset = 8839;
      e3.registered = 174;
      e3.registersans = 63720;
      e3.registerserif = 63194;
      e3.reharabic = 1585;
      e3.reharmenian = 1408;
      e3.rehfinalarabic = 65198;
      e3.rehiragana = 12428;
      e3.rekatakana = 12524;
      e3.rekatakanahalfwidth = 65434;
      e3.resh = 1512;
      e3.reshdageshhebrew = 64328;
      e3.reshhebrew = 1512;
      e3.reversedtilde = 8765;
      e3.reviahebrew = 1431;
      e3.reviamugrashhebrew = 1431;
      e3.revlogicalnot = 8976;
      e3.rfishhook = 638;
      e3.rfishhookreversed = 639;
      e3.rhabengali = 2525;
      e3.rhadeva = 2397;
      e3.rho = 961;
      e3.rhook = 637;
      e3.rhookturned = 635;
      e3.rhookturnedsuperior = 693;
      e3.rhosymbolgreek = 1009;
      e3.rhotichookmod = 734;
      e3.rieulacirclekorean = 12913;
      e3.rieulaparenkorean = 12817;
      e3.rieulcirclekorean = 12899;
      e3.rieulhieuhkorean = 12608;
      e3.rieulkiyeokkorean = 12602;
      e3.rieulkiyeoksioskorean = 12649;
      e3.rieulkorean = 12601;
      e3.rieulmieumkorean = 12603;
      e3.rieulpansioskorean = 12652;
      e3.rieulparenkorean = 12803;
      e3.rieulphieuphkorean = 12607;
      e3.rieulpieupkorean = 12604;
      e3.rieulpieupsioskorean = 12651;
      e3.rieulsioskorean = 12605;
      e3.rieulthieuthkorean = 12606;
      e3.rieultikeutkorean = 12650;
      e3.rieulyeorinhieuhkorean = 12653;
      e3.rightangle = 8735;
      e3.righttackbelowcmb = 793;
      e3.righttriangle = 8895;
      e3.rihiragana = 12426;
      e3.rikatakana = 12522;
      e3.rikatakanahalfwidth = 65432;
      e3.ring = 730;
      e3.ringbelowcmb = 805;
      e3.ringcmb = 778;
      e3.ringhalfleft = 703;
      e3.ringhalfleftarmenian = 1369;
      e3.ringhalfleftbelowcmb = 796;
      e3.ringhalfleftcentered = 723;
      e3.ringhalfright = 702;
      e3.ringhalfrightbelowcmb = 825;
      e3.ringhalfrightcentered = 722;
      e3.rinvertedbreve = 531;
      e3.rittorusquare = 13137;
      e3.rlinebelow = 7775;
      e3.rlongleg = 636;
      e3.rlonglegturned = 634;
      e3.rmonospace = 65362;
      e3.rohiragana = 12429;
      e3.rokatakana = 12525;
      e3.rokatakanahalfwidth = 65435;
      e3.roruathai = 3619;
      e3.rparen = 9389;
      e3.rrabengali = 2524;
      e3.rradeva = 2353;
      e3.rragurmukhi = 2652;
      e3.rreharabic = 1681;
      e3.rrehfinalarabic = 64397;
      e3.rrvocalicbengali = 2528;
      e3.rrvocalicdeva = 2400;
      e3.rrvocalicgujarati = 2784;
      e3.rrvocalicvowelsignbengali = 2500;
      e3.rrvocalicvowelsigndeva = 2372;
      e3.rrvocalicvowelsigngujarati = 2756;
      e3.rsuperior = 63217;
      e3.rtblock = 9616;
      e3.rturned = 633;
      e3.rturnedsuperior = 692;
      e3.ruhiragana = 12427;
      e3.rukatakana = 12523;
      e3.rukatakanahalfwidth = 65433;
      e3.rupeemarkbengali = 2546;
      e3.rupeesignbengali = 2547;
      e3.rupiah = 63197;
      e3.ruthai = 3620;
      e3.rvocalicbengali = 2443;
      e3.rvocalicdeva = 2315;
      e3.rvocalicgujarati = 2699;
      e3.rvocalicvowelsignbengali = 2499;
      e3.rvocalicvowelsigndeva = 2371;
      e3.rvocalicvowelsigngujarati = 2755;
      e3.s = 115;
      e3.sabengali = 2488;
      e3.sacute = 347;
      e3.sacutedotaccent = 7781;
      e3.sadarabic = 1589;
      e3.sadeva = 2360;
      e3.sadfinalarabic = 65210;
      e3.sadinitialarabic = 65211;
      e3.sadmedialarabic = 65212;
      e3.sagujarati = 2744;
      e3.sagurmukhi = 2616;
      e3.sahiragana = 12373;
      e3.sakatakana = 12469;
      e3.sakatakanahalfwidth = 65403;
      e3.sallallahoualayhewasallamarabic = 65018;
      e3.samekh = 1505;
      e3.samekhdagesh = 64321;
      e3.samekhdageshhebrew = 64321;
      e3.samekhhebrew = 1505;
      e3.saraaathai = 3634;
      e3.saraaethai = 3649;
      e3.saraaimaimalaithai = 3652;
      e3.saraaimaimuanthai = 3651;
      e3.saraamthai = 3635;
      e3.saraathai = 3632;
      e3.saraethai = 3648;
      e3.saraiileftthai = 63622;
      e3.saraiithai = 3637;
      e3.saraileftthai = 63621;
      e3.saraithai = 3636;
      e3.saraothai = 3650;
      e3.saraueeleftthai = 63624;
      e3.saraueethai = 3639;
      e3.saraueleftthai = 63623;
      e3.sarauethai = 3638;
      e3.sarauthai = 3640;
      e3.sarauuthai = 3641;
      e3.sbopomofo = 12569;
      e3.scaron = 353;
      e3.scarondotaccent = 7783;
      e3.scedilla = 351;
      e3.schwa = 601;
      e3.schwacyrillic = 1241;
      e3.schwadieresiscyrillic = 1243;
      e3.schwahook = 602;
      e3.scircle = 9442;
      e3.scircumflex = 349;
      e3.scommaaccent = 537;
      e3.sdotaccent = 7777;
      e3.sdotbelow = 7779;
      e3.sdotbelowdotaccent = 7785;
      e3.seagullbelowcmb = 828;
      e3.second = 8243;
      e3.secondtonechinese = 714;
      e3.section = 167;
      e3.seenarabic = 1587;
      e3.seenfinalarabic = 65202;
      e3.seeninitialarabic = 65203;
      e3.seenmedialarabic = 65204;
      e3.segol = 1462;
      e3.segol13 = 1462;
      e3.segol1f = 1462;
      e3.segol2c = 1462;
      e3.segolhebrew = 1462;
      e3.segolnarrowhebrew = 1462;
      e3.segolquarterhebrew = 1462;
      e3.segoltahebrew = 1426;
      e3.segolwidehebrew = 1462;
      e3.seharmenian = 1405;
      e3.sehiragana = 12379;
      e3.sekatakana = 12475;
      e3.sekatakanahalfwidth = 65406;
      e3.semicolon = 59;
      e3.semicolonarabic = 1563;
      e3.semicolonmonospace = 65307;
      e3.semicolonsmall = 65108;
      e3.semivoicedmarkkana = 12444;
      e3.semivoicedmarkkanahalfwidth = 65439;
      e3.sentisquare = 13090;
      e3.sentosquare = 13091;
      e3.seven = 55;
      e3.sevenarabic = 1639;
      e3.sevenbengali = 2541;
      e3.sevencircle = 9318;
      e3.sevencircleinversesansserif = 10128;
      e3.sevendeva = 2413;
      e3.seveneighths = 8542;
      e3.sevengujarati = 2797;
      e3.sevengurmukhi = 2669;
      e3.sevenhackarabic = 1639;
      e3.sevenhangzhou = 12327;
      e3.sevenideographicparen = 12838;
      e3.seveninferior = 8327;
      e3.sevenmonospace = 65303;
      e3.sevenoldstyle = 63287;
      e3.sevenparen = 9338;
      e3.sevenperiod = 9358;
      e3.sevenpersian = 1783;
      e3.sevenroman = 8566;
      e3.sevensuperior = 8311;
      e3.seventeencircle = 9328;
      e3.seventeenparen = 9348;
      e3.seventeenperiod = 9368;
      e3.seventhai = 3671;
      e3.sfthyphen = 173;
      e3.shaarmenian = 1399;
      e3.shabengali = 2486;
      e3.shacyrillic = 1096;
      e3.shaddaarabic = 1617;
      e3.shaddadammaarabic = 64609;
      e3.shaddadammatanarabic = 64606;
      e3.shaddafathaarabic = 64608;
      e3.shaddakasraarabic = 64610;
      e3.shaddakasratanarabic = 64607;
      e3.shade = 9618;
      e3.shadedark = 9619;
      e3.shadelight = 9617;
      e3.shademedium = 9618;
      e3.shadeva = 2358;
      e3.shagujarati = 2742;
      e3.shagurmukhi = 2614;
      e3.shalshelethebrew = 1427;
      e3.shbopomofo = 12565;
      e3.shchacyrillic = 1097;
      e3.sheenarabic = 1588;
      e3.sheenfinalarabic = 65206;
      e3.sheeninitialarabic = 65207;
      e3.sheenmedialarabic = 65208;
      e3.sheicoptic = 995;
      e3.sheqel = 8362;
      e3.sheqelhebrew = 8362;
      e3.sheva = 1456;
      e3.sheva115 = 1456;
      e3.sheva15 = 1456;
      e3.sheva22 = 1456;
      e3.sheva2e = 1456;
      e3.shevahebrew = 1456;
      e3.shevanarrowhebrew = 1456;
      e3.shevaquarterhebrew = 1456;
      e3.shevawidehebrew = 1456;
      e3.shhacyrillic = 1211;
      e3.shimacoptic = 1005;
      e3.shin = 1513;
      e3.shindagesh = 64329;
      e3.shindageshhebrew = 64329;
      e3.shindageshshindot = 64300;
      e3.shindageshshindothebrew = 64300;
      e3.shindageshsindot = 64301;
      e3.shindageshsindothebrew = 64301;
      e3.shindothebrew = 1473;
      e3.shinhebrew = 1513;
      e3.shinshindot = 64298;
      e3.shinshindothebrew = 64298;
      e3.shinsindot = 64299;
      e3.shinsindothebrew = 64299;
      e3.shook = 642;
      e3.sigma = 963;
      e3.sigma1 = 962;
      e3.sigmafinal = 962;
      e3.sigmalunatesymbolgreek = 1010;
      e3.sihiragana = 12375;
      e3.sikatakana = 12471;
      e3.sikatakanahalfwidth = 65404;
      e3.siluqhebrew = 1469;
      e3.siluqlefthebrew = 1469;
      e3.similar = 8764;
      e3.sindothebrew = 1474;
      e3.siosacirclekorean = 12916;
      e3.siosaparenkorean = 12820;
      e3.sioscieuckorean = 12670;
      e3.sioscirclekorean = 12902;
      e3.sioskiyeokkorean = 12666;
      e3.sioskorean = 12613;
      e3.siosnieunkorean = 12667;
      e3.siosparenkorean = 12806;
      e3.siospieupkorean = 12669;
      e3.siostikeutkorean = 12668;
      e3.six = 54;
      e3.sixarabic = 1638;
      e3.sixbengali = 2540;
      e3.sixcircle = 9317;
      e3.sixcircleinversesansserif = 10127;
      e3.sixdeva = 2412;
      e3.sixgujarati = 2796;
      e3.sixgurmukhi = 2668;
      e3.sixhackarabic = 1638;
      e3.sixhangzhou = 12326;
      e3.sixideographicparen = 12837;
      e3.sixinferior = 8326;
      e3.sixmonospace = 65302;
      e3.sixoldstyle = 63286;
      e3.sixparen = 9337;
      e3.sixperiod = 9357;
      e3.sixpersian = 1782;
      e3.sixroman = 8565;
      e3.sixsuperior = 8310;
      e3.sixteencircle = 9327;
      e3.sixteencurrencydenominatorbengali = 2553;
      e3.sixteenparen = 9347;
      e3.sixteenperiod = 9367;
      e3.sixthai = 3670;
      e3.slash = 47;
      e3.slashmonospace = 65295;
      e3.slong = 383;
      e3.slongdotaccent = 7835;
      e3.smileface = 9786;
      e3.smonospace = 65363;
      e3.sofpasuqhebrew = 1475;
      e3.softhyphen = 173;
      e3.softsigncyrillic = 1100;
      e3.sohiragana = 12381;
      e3.sokatakana = 12477;
      e3.sokatakanahalfwidth = 65407;
      e3.soliduslongoverlaycmb = 824;
      e3.solidusshortoverlaycmb = 823;
      e3.sorusithai = 3625;
      e3.sosalathai = 3624;
      e3.sosothai = 3595;
      e3.sosuathai = 3626;
      e3.space = 32;
      e3.spacehackarabic = 32;
      e3.spade = 9824;
      e3.spadesuitblack = 9824;
      e3.spadesuitwhite = 9828;
      e3.sparen = 9390;
      e3.squarebelowcmb = 827;
      e3.squarecc = 13252;
      e3.squarecm = 13213;
      e3.squarediagonalcrosshatchfill = 9641;
      e3.squarehorizontalfill = 9636;
      e3.squarekg = 13199;
      e3.squarekm = 13214;
      e3.squarekmcapital = 13262;
      e3.squareln = 13265;
      e3.squarelog = 13266;
      e3.squaremg = 13198;
      e3.squaremil = 13269;
      e3.squaremm = 13212;
      e3.squaremsquared = 13217;
      e3.squareorthogonalcrosshatchfill = 9638;
      e3.squareupperlefttolowerrightfill = 9639;
      e3.squareupperrighttolowerleftfill = 9640;
      e3.squareverticalfill = 9637;
      e3.squarewhitewithsmallblack = 9635;
      e3.srsquare = 13275;
      e3.ssabengali = 2487;
      e3.ssadeva = 2359;
      e3.ssagujarati = 2743;
      e3.ssangcieuckorean = 12617;
      e3.ssanghieuhkorean = 12677;
      e3.ssangieungkorean = 12672;
      e3.ssangkiyeokkorean = 12594;
      e3.ssangnieunkorean = 12645;
      e3.ssangpieupkorean = 12611;
      e3.ssangsioskorean = 12614;
      e3.ssangtikeutkorean = 12600;
      e3.ssuperior = 63218;
      e3.sterling = 163;
      e3.sterlingmonospace = 65505;
      e3.strokelongoverlaycmb = 822;
      e3.strokeshortoverlaycmb = 821;
      e3.subset = 8834;
      e3.subsetnotequal = 8842;
      e3.subsetorequal = 8838;
      e3.succeeds = 8827;
      e3.suchthat = 8715;
      e3.suhiragana = 12377;
      e3.sukatakana = 12473;
      e3.sukatakanahalfwidth = 65405;
      e3.sukunarabic = 1618;
      e3.summation = 8721;
      e3.sun = 9788;
      e3.superset = 8835;
      e3.supersetnotequal = 8843;
      e3.supersetorequal = 8839;
      e3.svsquare = 13276;
      e3.syouwaerasquare = 13180;
      e3.t = 116;
      e3.tabengali = 2468;
      e3.tackdown = 8868;
      e3.tackleft = 8867;
      e3.tadeva = 2340;
      e3.tagujarati = 2724;
      e3.tagurmukhi = 2596;
      e3.taharabic = 1591;
      e3.tahfinalarabic = 65218;
      e3.tahinitialarabic = 65219;
      e3.tahiragana = 12383;
      e3.tahmedialarabic = 65220;
      e3.taisyouerasquare = 13181;
      e3.takatakana = 12479;
      e3.takatakanahalfwidth = 65408;
      e3.tatweelarabic = 1600;
      e3.tau = 964;
      e3.tav = 1514;
      e3.tavdages = 64330;
      e3.tavdagesh = 64330;
      e3.tavdageshhebrew = 64330;
      e3.tavhebrew = 1514;
      e3.tbar = 359;
      e3.tbopomofo = 12554;
      e3.tcaron = 357;
      e3.tccurl = 680;
      e3.tcedilla = 355;
      e3.tcheharabic = 1670;
      e3.tchehfinalarabic = 64379;
      e3.tchehinitialarabic = 64380;
      e3.tchehmedialarabic = 64381;
      e3.tcircle = 9443;
      e3.tcircumflexbelow = 7793;
      e3.tcommaaccent = 355;
      e3.tdieresis = 7831;
      e3.tdotaccent = 7787;
      e3.tdotbelow = 7789;
      e3.tecyrillic = 1090;
      e3.tedescendercyrillic = 1197;
      e3.teharabic = 1578;
      e3.tehfinalarabic = 65174;
      e3.tehhahinitialarabic = 64674;
      e3.tehhahisolatedarabic = 64524;
      e3.tehinitialarabic = 65175;
      e3.tehiragana = 12390;
      e3.tehjeeminitialarabic = 64673;
      e3.tehjeemisolatedarabic = 64523;
      e3.tehmarbutaarabic = 1577;
      e3.tehmarbutafinalarabic = 65172;
      e3.tehmedialarabic = 65176;
      e3.tehmeeminitialarabic = 64676;
      e3.tehmeemisolatedarabic = 64526;
      e3.tehnoonfinalarabic = 64627;
      e3.tekatakana = 12486;
      e3.tekatakanahalfwidth = 65411;
      e3.telephone = 8481;
      e3.telephoneblack = 9742;
      e3.telishagedolahebrew = 1440;
      e3.telishaqetanahebrew = 1449;
      e3.tencircle = 9321;
      e3.tenideographicparen = 12841;
      e3.tenparen = 9341;
      e3.tenperiod = 9361;
      e3.tenroman = 8569;
      e3.tesh = 679;
      e3.tet = 1496;
      e3.tetdagesh = 64312;
      e3.tetdageshhebrew = 64312;
      e3.tethebrew = 1496;
      e3.tetsecyrillic = 1205;
      e3.tevirhebrew = 1435;
      e3.tevirlefthebrew = 1435;
      e3.thabengali = 2469;
      e3.thadeva = 2341;
      e3.thagujarati = 2725;
      e3.thagurmukhi = 2597;
      e3.thalarabic = 1584;
      e3.thalfinalarabic = 65196;
      e3.thanthakhatlowleftthai = 63640;
      e3.thanthakhatlowrightthai = 63639;
      e3.thanthakhatthai = 3660;
      e3.thanthakhatupperleftthai = 63638;
      e3.theharabic = 1579;
      e3.thehfinalarabic = 65178;
      e3.thehinitialarabic = 65179;
      e3.thehmedialarabic = 65180;
      e3.thereexists = 8707;
      e3.therefore = 8756;
      e3.theta = 952;
      e3.theta1 = 977;
      e3.thetasymbolgreek = 977;
      e3.thieuthacirclekorean = 12921;
      e3.thieuthaparenkorean = 12825;
      e3.thieuthcirclekorean = 12907;
      e3.thieuthkorean = 12620;
      e3.thieuthparenkorean = 12811;
      e3.thirteencircle = 9324;
      e3.thirteenparen = 9344;
      e3.thirteenperiod = 9364;
      e3.thonangmonthothai = 3601;
      e3.thook = 429;
      e3.thophuthaothai = 3602;
      e3.thorn = 254;
      e3.thothahanthai = 3607;
      e3.thothanthai = 3600;
      e3.thothongthai = 3608;
      e3.thothungthai = 3606;
      e3.thousandcyrillic = 1154;
      e3.thousandsseparatorarabic = 1644;
      e3.thousandsseparatorpersian = 1644;
      e3.three = 51;
      e3.threearabic = 1635;
      e3.threebengali = 2537;
      e3.threecircle = 9314;
      e3.threecircleinversesansserif = 10124;
      e3.threedeva = 2409;
      e3.threeeighths = 8540;
      e3.threegujarati = 2793;
      e3.threegurmukhi = 2665;
      e3.threehackarabic = 1635;
      e3.threehangzhou = 12323;
      e3.threeideographicparen = 12834;
      e3.threeinferior = 8323;
      e3.threemonospace = 65299;
      e3.threenumeratorbengali = 2550;
      e3.threeoldstyle = 63283;
      e3.threeparen = 9334;
      e3.threeperiod = 9354;
      e3.threepersian = 1779;
      e3.threequarters = 190;
      e3.threequartersemdash = 63198;
      e3.threeroman = 8562;
      e3.threesuperior = 179;
      e3.threethai = 3667;
      e3.thzsquare = 13204;
      e3.tihiragana = 12385;
      e3.tikatakana = 12481;
      e3.tikatakanahalfwidth = 65409;
      e3.tikeutacirclekorean = 12912;
      e3.tikeutaparenkorean = 12816;
      e3.tikeutcirclekorean = 12898;
      e3.tikeutkorean = 12599;
      e3.tikeutparenkorean = 12802;
      e3.tilde = 732;
      e3.tildebelowcmb = 816;
      e3.tildecmb = 771;
      e3.tildecomb = 771;
      e3.tildedoublecmb = 864;
      e3.tildeoperator = 8764;
      e3.tildeoverlaycmb = 820;
      e3.tildeverticalcmb = 830;
      e3.timescircle = 8855;
      e3.tipehahebrew = 1430;
      e3.tipehalefthebrew = 1430;
      e3.tippigurmukhi = 2672;
      e3.titlocyrilliccmb = 1155;
      e3.tiwnarmenian = 1407;
      e3.tlinebelow = 7791;
      e3.tmonospace = 65364;
      e3.toarmenian = 1385;
      e3.tohiragana = 12392;
      e3.tokatakana = 12488;
      e3.tokatakanahalfwidth = 65412;
      e3.tonebarextrahighmod = 741;
      e3.tonebarextralowmod = 745;
      e3.tonebarhighmod = 742;
      e3.tonebarlowmod = 744;
      e3.tonebarmidmod = 743;
      e3.tonefive = 445;
      e3.tonesix = 389;
      e3.tonetwo = 424;
      e3.tonos = 900;
      e3.tonsquare = 13095;
      e3.topatakthai = 3599;
      e3.tortoiseshellbracketleft = 12308;
      e3.tortoiseshellbracketleftsmall = 65117;
      e3.tortoiseshellbracketleftvertical = 65081;
      e3.tortoiseshellbracketright = 12309;
      e3.tortoiseshellbracketrightsmall = 65118;
      e3.tortoiseshellbracketrightvertical = 65082;
      e3.totaothai = 3605;
      e3.tpalatalhook = 427;
      e3.tparen = 9391;
      e3.trademark = 8482;
      e3.trademarksans = 63722;
      e3.trademarkserif = 63195;
      e3.tretroflexhook = 648;
      e3.triagdn = 9660;
      e3.triaglf = 9668;
      e3.triagrt = 9658;
      e3.triagup = 9650;
      e3.ts = 678;
      e3.tsadi = 1510;
      e3.tsadidagesh = 64326;
      e3.tsadidageshhebrew = 64326;
      e3.tsadihebrew = 1510;
      e3.tsecyrillic = 1094;
      e3.tsere = 1461;
      e3.tsere12 = 1461;
      e3.tsere1e = 1461;
      e3.tsere2b = 1461;
      e3.tserehebrew = 1461;
      e3.tserenarrowhebrew = 1461;
      e3.tserequarterhebrew = 1461;
      e3.tserewidehebrew = 1461;
      e3.tshecyrillic = 1115;
      e3.tsuperior = 63219;
      e3.ttabengali = 2463;
      e3.ttadeva = 2335;
      e3.ttagujarati = 2719;
      e3.ttagurmukhi = 2591;
      e3.tteharabic = 1657;
      e3.ttehfinalarabic = 64359;
      e3.ttehinitialarabic = 64360;
      e3.ttehmedialarabic = 64361;
      e3.tthabengali = 2464;
      e3.tthadeva = 2336;
      e3.tthagujarati = 2720;
      e3.tthagurmukhi = 2592;
      e3.tturned = 647;
      e3.tuhiragana = 12388;
      e3.tukatakana = 12484;
      e3.tukatakanahalfwidth = 65410;
      e3.tusmallhiragana = 12387;
      e3.tusmallkatakana = 12483;
      e3.tusmallkatakanahalfwidth = 65391;
      e3.twelvecircle = 9323;
      e3.twelveparen = 9343;
      e3.twelveperiod = 9363;
      e3.twelveroman = 8571;
      e3.twentycircle = 9331;
      e3.twentyhangzhou = 21316;
      e3.twentyparen = 9351;
      e3.twentyperiod = 9371;
      e3.two = 50;
      e3.twoarabic = 1634;
      e3.twobengali = 2536;
      e3.twocircle = 9313;
      e3.twocircleinversesansserif = 10123;
      e3.twodeva = 2408;
      e3.twodotenleader = 8229;
      e3.twodotleader = 8229;
      e3.twodotleadervertical = 65072;
      e3.twogujarati = 2792;
      e3.twogurmukhi = 2664;
      e3.twohackarabic = 1634;
      e3.twohangzhou = 12322;
      e3.twoideographicparen = 12833;
      e3.twoinferior = 8322;
      e3.twomonospace = 65298;
      e3.twonumeratorbengali = 2549;
      e3.twooldstyle = 63282;
      e3.twoparen = 9333;
      e3.twoperiod = 9353;
      e3.twopersian = 1778;
      e3.tworoman = 8561;
      e3.twostroke = 443;
      e3.twosuperior = 178;
      e3.twothai = 3666;
      e3.twothirds = 8532;
      e3.u = 117;
      e3.uacute = 250;
      e3.ubar = 649;
      e3.ubengali = 2441;
      e3.ubopomofo = 12584;
      e3.ubreve = 365;
      e3.ucaron = 468;
      e3.ucircle = 9444;
      e3.ucircumflex = 251;
      e3.ucircumflexbelow = 7799;
      e3.ucyrillic = 1091;
      e3.udattadeva = 2385;
      e3.udblacute = 369;
      e3.udblgrave = 533;
      e3.udeva = 2313;
      e3.udieresis = 252;
      e3.udieresisacute = 472;
      e3.udieresisbelow = 7795;
      e3.udieresiscaron = 474;
      e3.udieresiscyrillic = 1265;
      e3.udieresisgrave = 476;
      e3.udieresismacron = 470;
      e3.udotbelow = 7909;
      e3.ugrave = 249;
      e3.ugujarati = 2697;
      e3.ugurmukhi = 2569;
      e3.uhiragana = 12358;
      e3.uhookabove = 7911;
      e3.uhorn = 432;
      e3.uhornacute = 7913;
      e3.uhorndotbelow = 7921;
      e3.uhorngrave = 7915;
      e3.uhornhookabove = 7917;
      e3.uhorntilde = 7919;
      e3.uhungarumlaut = 369;
      e3.uhungarumlautcyrillic = 1267;
      e3.uinvertedbreve = 535;
      e3.ukatakana = 12454;
      e3.ukatakanahalfwidth = 65395;
      e3.ukcyrillic = 1145;
      e3.ukorean = 12636;
      e3.umacron = 363;
      e3.umacroncyrillic = 1263;
      e3.umacrondieresis = 7803;
      e3.umatragurmukhi = 2625;
      e3.umonospace = 65365;
      e3.underscore = 95;
      e3.underscoredbl = 8215;
      e3.underscoremonospace = 65343;
      e3.underscorevertical = 65075;
      e3.underscorewavy = 65103;
      e3.union = 8746;
      e3.universal = 8704;
      e3.uogonek = 371;
      e3.uparen = 9392;
      e3.upblock = 9600;
      e3.upperdothebrew = 1476;
      e3.upsilon = 965;
      e3.upsilondieresis = 971;
      e3.upsilondieresistonos = 944;
      e3.upsilonlatin = 650;
      e3.upsilontonos = 973;
      e3.uptackbelowcmb = 797;
      e3.uptackmod = 724;
      e3.uragurmukhi = 2675;
      e3.uring = 367;
      e3.ushortcyrillic = 1118;
      e3.usmallhiragana = 12357;
      e3.usmallkatakana = 12453;
      e3.usmallkatakanahalfwidth = 65385;
      e3.ustraightcyrillic = 1199;
      e3.ustraightstrokecyrillic = 1201;
      e3.utilde = 361;
      e3.utildeacute = 7801;
      e3.utildebelow = 7797;
      e3.uubengali = 2442;
      e3.uudeva = 2314;
      e3.uugujarati = 2698;
      e3.uugurmukhi = 2570;
      e3.uumatragurmukhi = 2626;
      e3.uuvowelsignbengali = 2498;
      e3.uuvowelsigndeva = 2370;
      e3.uuvowelsigngujarati = 2754;
      e3.uvowelsignbengali = 2497;
      e3.uvowelsigndeva = 2369;
      e3.uvowelsigngujarati = 2753;
      e3.v = 118;
      e3.vadeva = 2357;
      e3.vagujarati = 2741;
      e3.vagurmukhi = 2613;
      e3.vakatakana = 12535;
      e3.vav = 1493;
      e3.vavdagesh = 64309;
      e3.vavdagesh65 = 64309;
      e3.vavdageshhebrew = 64309;
      e3.vavhebrew = 1493;
      e3.vavholam = 64331;
      e3.vavholamhebrew = 64331;
      e3.vavvavhebrew = 1520;
      e3.vavyodhebrew = 1521;
      e3.vcircle = 9445;
      e3.vdotbelow = 7807;
      e3.vecyrillic = 1074;
      e3.veharabic = 1700;
      e3.vehfinalarabic = 64363;
      e3.vehinitialarabic = 64364;
      e3.vehmedialarabic = 64365;
      e3.vekatakana = 12537;
      e3.venus = 9792;
      e3.verticalbar = 124;
      e3.verticallineabovecmb = 781;
      e3.verticallinebelowcmb = 809;
      e3.verticallinelowmod = 716;
      e3.verticallinemod = 712;
      e3.vewarmenian = 1406;
      e3.vhook = 651;
      e3.vikatakana = 12536;
      e3.viramabengali = 2509;
      e3.viramadeva = 2381;
      e3.viramagujarati = 2765;
      e3.visargabengali = 2435;
      e3.visargadeva = 2307;
      e3.visargagujarati = 2691;
      e3.vmonospace = 65366;
      e3.voarmenian = 1400;
      e3.voicediterationhiragana = 12446;
      e3.voicediterationkatakana = 12542;
      e3.voicedmarkkana = 12443;
      e3.voicedmarkkanahalfwidth = 65438;
      e3.vokatakana = 12538;
      e3.vparen = 9393;
      e3.vtilde = 7805;
      e3.vturned = 652;
      e3.vuhiragana = 12436;
      e3.vukatakana = 12532;
      e3.w = 119;
      e3.wacute = 7811;
      e3.waekorean = 12633;
      e3.wahiragana = 12431;
      e3.wakatakana = 12527;
      e3.wakatakanahalfwidth = 65436;
      e3.wakorean = 12632;
      e3.wasmallhiragana = 12430;
      e3.wasmallkatakana = 12526;
      e3.wattosquare = 13143;
      e3.wavedash = 12316;
      e3.wavyunderscorevertical = 65076;
      e3.wawarabic = 1608;
      e3.wawfinalarabic = 65262;
      e3.wawhamzaabovearabic = 1572;
      e3.wawhamzaabovefinalarabic = 65158;
      e3.wbsquare = 13277;
      e3.wcircle = 9446;
      e3.wcircumflex = 373;
      e3.wdieresis = 7813;
      e3.wdotaccent = 7815;
      e3.wdotbelow = 7817;
      e3.wehiragana = 12433;
      e3.weierstrass = 8472;
      e3.wekatakana = 12529;
      e3.wekorean = 12638;
      e3.weokorean = 12637;
      e3.wgrave = 7809;
      e3.whitebullet = 9702;
      e3.whitecircle = 9675;
      e3.whitecircleinverse = 9689;
      e3.whitecornerbracketleft = 12302;
      e3.whitecornerbracketleftvertical = 65091;
      e3.whitecornerbracketright = 12303;
      e3.whitecornerbracketrightvertical = 65092;
      e3.whitediamond = 9671;
      e3.whitediamondcontainingblacksmalldiamond = 9672;
      e3.whitedownpointingsmalltriangle = 9663;
      e3.whitedownpointingtriangle = 9661;
      e3.whiteleftpointingsmalltriangle = 9667;
      e3.whiteleftpointingtriangle = 9665;
      e3.whitelenticularbracketleft = 12310;
      e3.whitelenticularbracketright = 12311;
      e3.whiterightpointingsmalltriangle = 9657;
      e3.whiterightpointingtriangle = 9655;
      e3.whitesmallsquare = 9643;
      e3.whitesmilingface = 9786;
      e3.whitesquare = 9633;
      e3.whitestar = 9734;
      e3.whitetelephone = 9743;
      e3.whitetortoiseshellbracketleft = 12312;
      e3.whitetortoiseshellbracketright = 12313;
      e3.whiteuppointingsmalltriangle = 9653;
      e3.whiteuppointingtriangle = 9651;
      e3.wihiragana = 12432;
      e3.wikatakana = 12528;
      e3.wikorean = 12639;
      e3.wmonospace = 65367;
      e3.wohiragana = 12434;
      e3.wokatakana = 12530;
      e3.wokatakanahalfwidth = 65382;
      e3.won = 8361;
      e3.wonmonospace = 65510;
      e3.wowaenthai = 3623;
      e3.wparen = 9394;
      e3.wring = 7832;
      e3.wsuperior = 695;
      e3.wturned = 653;
      e3.wynn = 447;
      e3.x = 120;
      e3.xabovecmb = 829;
      e3.xbopomofo = 12562;
      e3.xcircle = 9447;
      e3.xdieresis = 7821;
      e3.xdotaccent = 7819;
      e3.xeharmenian = 1389;
      e3.xi = 958;
      e3.xmonospace = 65368;
      e3.xparen = 9395;
      e3.xsuperior = 739;
      e3.y = 121;
      e3.yaadosquare = 13134;
      e3.yabengali = 2479;
      e3.yacute = 253;
      e3.yadeva = 2351;
      e3.yaekorean = 12626;
      e3.yagujarati = 2735;
      e3.yagurmukhi = 2607;
      e3.yahiragana = 12420;
      e3.yakatakana = 12516;
      e3.yakatakanahalfwidth = 65428;
      e3.yakorean = 12625;
      e3.yamakkanthai = 3662;
      e3.yasmallhiragana = 12419;
      e3.yasmallkatakana = 12515;
      e3.yasmallkatakanahalfwidth = 65388;
      e3.yatcyrillic = 1123;
      e3.ycircle = 9448;
      e3.ycircumflex = 375;
      e3.ydieresis = 255;
      e3.ydotaccent = 7823;
      e3.ydotbelow = 7925;
      e3.yeharabic = 1610;
      e3.yehbarreearabic = 1746;
      e3.yehbarreefinalarabic = 64431;
      e3.yehfinalarabic = 65266;
      e3.yehhamzaabovearabic = 1574;
      e3.yehhamzaabovefinalarabic = 65162;
      e3.yehhamzaaboveinitialarabic = 65163;
      e3.yehhamzaabovemedialarabic = 65164;
      e3.yehinitialarabic = 65267;
      e3.yehmedialarabic = 65268;
      e3.yehmeeminitialarabic = 64733;
      e3.yehmeemisolatedarabic = 64600;
      e3.yehnoonfinalarabic = 64660;
      e3.yehthreedotsbelowarabic = 1745;
      e3.yekorean = 12630;
      e3.yen = 165;
      e3.yenmonospace = 65509;
      e3.yeokorean = 12629;
      e3.yeorinhieuhkorean = 12678;
      e3.yerahbenyomohebrew = 1450;
      e3.yerahbenyomolefthebrew = 1450;
      e3.yericyrillic = 1099;
      e3.yerudieresiscyrillic = 1273;
      e3.yesieungkorean = 12673;
      e3.yesieungpansioskorean = 12675;
      e3.yesieungsioskorean = 12674;
      e3.yetivhebrew = 1434;
      e3.ygrave = 7923;
      e3.yhook = 436;
      e3.yhookabove = 7927;
      e3.yiarmenian = 1397;
      e3.yicyrillic = 1111;
      e3.yikorean = 12642;
      e3.yinyang = 9775;
      e3.yiwnarmenian = 1410;
      e3.ymonospace = 65369;
      e3.yod = 1497;
      e3.yoddagesh = 64313;
      e3.yoddageshhebrew = 64313;
      e3.yodhebrew = 1497;
      e3.yodyodhebrew = 1522;
      e3.yodyodpatahhebrew = 64287;
      e3.yohiragana = 12424;
      e3.yoikorean = 12681;
      e3.yokatakana = 12520;
      e3.yokatakanahalfwidth = 65430;
      e3.yokorean = 12635;
      e3.yosmallhiragana = 12423;
      e3.yosmallkatakana = 12519;
      e3.yosmallkatakanahalfwidth = 65390;
      e3.yotgreek = 1011;
      e3.yoyaekorean = 12680;
      e3.yoyakorean = 12679;
      e3.yoyakthai = 3618;
      e3.yoyingthai = 3597;
      e3.yparen = 9396;
      e3.ypogegrammeni = 890;
      e3.ypogegrammenigreekcmb = 837;
      e3.yr = 422;
      e3.yring = 7833;
      e3.ysuperior = 696;
      e3.ytilde = 7929;
      e3.yturned = 654;
      e3.yuhiragana = 12422;
      e3.yuikorean = 12684;
      e3.yukatakana = 12518;
      e3.yukatakanahalfwidth = 65429;
      e3.yukorean = 12640;
      e3.yusbigcyrillic = 1131;
      e3.yusbigiotifiedcyrillic = 1133;
      e3.yuslittlecyrillic = 1127;
      e3.yuslittleiotifiedcyrillic = 1129;
      e3.yusmallhiragana = 12421;
      e3.yusmallkatakana = 12517;
      e3.yusmallkatakanahalfwidth = 65389;
      e3.yuyekorean = 12683;
      e3.yuyeokorean = 12682;
      e3.yyabengali = 2527;
      e3.yyadeva = 2399;
      e3.z = 122;
      e3.zaarmenian = 1382;
      e3.zacute = 378;
      e3.zadeva = 2395;
      e3.zagurmukhi = 2651;
      e3.zaharabic = 1592;
      e3.zahfinalarabic = 65222;
      e3.zahinitialarabic = 65223;
      e3.zahiragana = 12374;
      e3.zahmedialarabic = 65224;
      e3.zainarabic = 1586;
      e3.zainfinalarabic = 65200;
      e3.zakatakana = 12470;
      e3.zaqefgadolhebrew = 1429;
      e3.zaqefqatanhebrew = 1428;
      e3.zarqahebrew = 1432;
      e3.zayin = 1494;
      e3.zayindagesh = 64310;
      e3.zayindageshhebrew = 64310;
      e3.zayinhebrew = 1494;
      e3.zbopomofo = 12567;
      e3.zcaron = 382;
      e3.zcircle = 9449;
      e3.zcircumflex = 7825;
      e3.zcurl = 657;
      e3.zdot = 380;
      e3.zdotaccent = 380;
      e3.zdotbelow = 7827;
      e3.zecyrillic = 1079;
      e3.zedescendercyrillic = 1177;
      e3.zedieresiscyrillic = 1247;
      e3.zehiragana = 12380;
      e3.zekatakana = 12476;
      e3.zero = 48;
      e3.zeroarabic = 1632;
      e3.zerobengali = 2534;
      e3.zerodeva = 2406;
      e3.zerogujarati = 2790;
      e3.zerogurmukhi = 2662;
      e3.zerohackarabic = 1632;
      e3.zeroinferior = 8320;
      e3.zeromonospace = 65296;
      e3.zerooldstyle = 63280;
      e3.zeropersian = 1776;
      e3.zerosuperior = 8304;
      e3.zerothai = 3664;
      e3.zerowidthjoiner = 65279;
      e3.zerowidthnonjoiner = 8204;
      e3.zerowidthspace = 8203;
      e3.zeta = 950;
      e3.zhbopomofo = 12563;
      e3.zhearmenian = 1386;
      e3.zhebrevecyrillic = 1218;
      e3.zhecyrillic = 1078;
      e3.zhedescendercyrillic = 1175;
      e3.zhedieresiscyrillic = 1245;
      e3.zihiragana = 12376;
      e3.zikatakana = 12472;
      e3.zinorhebrew = 1454;
      e3.zlinebelow = 7829;
      e3.zmonospace = 65370;
      e3.zohiragana = 12382;
      e3.zokatakana = 12478;
      e3.zparen = 9397;
      e3.zretroflexhook = 656;
      e3.zstroke = 438;
      e3.zuhiragana = 12378;
      e3.zukatakana = 12474;
      e3[".notdef"] = 0;
      e3.angbracketleftbig = 9001;
      e3.angbracketleftBig = 9001;
      e3.angbracketleftbigg = 9001;
      e3.angbracketleftBigg = 9001;
      e3.angbracketrightBig = 9002;
      e3.angbracketrightbig = 9002;
      e3.angbracketrightBigg = 9002;
      e3.angbracketrightbigg = 9002;
      e3.arrowhookleft = 8618;
      e3.arrowhookright = 8617;
      e3.arrowlefttophalf = 8636;
      e3.arrowleftbothalf = 8637;
      e3.arrownortheast = 8599;
      e3.arrownorthwest = 8598;
      e3.arrowrighttophalf = 8640;
      e3.arrowrightbothalf = 8641;
      e3.arrowsoutheast = 8600;
      e3.arrowsouthwest = 8601;
      e3.backslashbig = 8726;
      e3.backslashBig = 8726;
      e3.backslashBigg = 8726;
      e3.backslashbigg = 8726;
      e3.bardbl = 8214;
      e3.bracehtipdownleft = 65079;
      e3.bracehtipdownright = 65079;
      e3.bracehtipupleft = 65080;
      e3.bracehtipupright = 65080;
      e3.braceleftBig = 123;
      e3.braceleftbig = 123;
      e3.braceleftbigg = 123;
      e3.braceleftBigg = 123;
      e3.bracerightBig = 125;
      e3.bracerightbig = 125;
      e3.bracerightbigg = 125;
      e3.bracerightBigg = 125;
      e3.bracketleftbig = 91;
      e3.bracketleftBig = 91;
      e3.bracketleftbigg = 91;
      e3.bracketleftBigg = 91;
      e3.bracketrightBig = 93;
      e3.bracketrightbig = 93;
      e3.bracketrightbigg = 93;
      e3.bracketrightBigg = 93;
      e3.ceilingleftbig = 8968;
      e3.ceilingleftBig = 8968;
      e3.ceilingleftBigg = 8968;
      e3.ceilingleftbigg = 8968;
      e3.ceilingrightbig = 8969;
      e3.ceilingrightBig = 8969;
      e3.ceilingrightbigg = 8969;
      e3.ceilingrightBigg = 8969;
      e3.circledotdisplay = 8857;
      e3.circledottext = 8857;
      e3.circlemultiplydisplay = 8855;
      e3.circlemultiplytext = 8855;
      e3.circleplusdisplay = 8853;
      e3.circleplustext = 8853;
      e3.contintegraldisplay = 8750;
      e3.contintegraltext = 8750;
      e3.coproductdisplay = 8720;
      e3.coproducttext = 8720;
      e3.floorleftBig = 8970;
      e3.floorleftbig = 8970;
      e3.floorleftbigg = 8970;
      e3.floorleftBigg = 8970;
      e3.floorrightbig = 8971;
      e3.floorrightBig = 8971;
      e3.floorrightBigg = 8971;
      e3.floorrightbigg = 8971;
      e3.hatwide = 770;
      e3.hatwider = 770;
      e3.hatwidest = 770;
      e3.intercal = 7488;
      e3.integraldisplay = 8747;
      e3.integraltext = 8747;
      e3.intersectiondisplay = 8898;
      e3.intersectiontext = 8898;
      e3.logicalanddisplay = 8743;
      e3.logicalandtext = 8743;
      e3.logicalordisplay = 8744;
      e3.logicalortext = 8744;
      e3.parenleftBig = 40;
      e3.parenleftbig = 40;
      e3.parenleftBigg = 40;
      e3.parenleftbigg = 40;
      e3.parenrightBig = 41;
      e3.parenrightbig = 41;
      e3.parenrightBigg = 41;
      e3.parenrightbigg = 41;
      e3.prime = 8242;
      e3.productdisplay = 8719;
      e3.producttext = 8719;
      e3.radicalbig = 8730;
      e3.radicalBig = 8730;
      e3.radicalBigg = 8730;
      e3.radicalbigg = 8730;
      e3.radicalbt = 8730;
      e3.radicaltp = 8730;
      e3.radicalvertex = 8730;
      e3.slashbig = 47;
      e3.slashBig = 47;
      e3.slashBigg = 47;
      e3.slashbigg = 47;
      e3.summationdisplay = 8721;
      e3.summationtext = 8721;
      e3.tildewide = 732;
      e3.tildewider = 732;
      e3.tildewidest = 732;
      e3.uniondisplay = 8899;
      e3.unionmultidisplay = 8846;
      e3.unionmultitext = 8846;
      e3.unionsqdisplay = 8852;
      e3.unionsqtext = 8852;
      e3.uniontext = 8899;
      e3.vextenddouble = 8741;
      e3.vextendsingle = 8739;
    });
    Gi = getLookupTableFactory(function(e3) {
      e3.space = 32;
      e3.a1 = 9985;
      e3.a2 = 9986;
      e3.a202 = 9987;
      e3.a3 = 9988;
      e3.a4 = 9742;
      e3.a5 = 9990;
      e3.a119 = 9991;
      e3.a118 = 9992;
      e3.a117 = 9993;
      e3.a11 = 9755;
      e3.a12 = 9758;
      e3.a13 = 9996;
      e3.a14 = 9997;
      e3.a15 = 9998;
      e3.a16 = 9999;
      e3.a105 = 1e4;
      e3.a17 = 10001;
      e3.a18 = 10002;
      e3.a19 = 10003;
      e3.a20 = 10004;
      e3.a21 = 10005;
      e3.a22 = 10006;
      e3.a23 = 10007;
      e3.a24 = 10008;
      e3.a25 = 10009;
      e3.a26 = 10010;
      e3.a27 = 10011;
      e3.a28 = 10012;
      e3.a6 = 10013;
      e3.a7 = 10014;
      e3.a8 = 10015;
      e3.a9 = 10016;
      e3.a10 = 10017;
      e3.a29 = 10018;
      e3.a30 = 10019;
      e3.a31 = 10020;
      e3.a32 = 10021;
      e3.a33 = 10022;
      e3.a34 = 10023;
      e3.a35 = 9733;
      e3.a36 = 10025;
      e3.a37 = 10026;
      e3.a38 = 10027;
      e3.a39 = 10028;
      e3.a40 = 10029;
      e3.a41 = 10030;
      e3.a42 = 10031;
      e3.a43 = 10032;
      e3.a44 = 10033;
      e3.a45 = 10034;
      e3.a46 = 10035;
      e3.a47 = 10036;
      e3.a48 = 10037;
      e3.a49 = 10038;
      e3.a50 = 10039;
      e3.a51 = 10040;
      e3.a52 = 10041;
      e3.a53 = 10042;
      e3.a54 = 10043;
      e3.a55 = 10044;
      e3.a56 = 10045;
      e3.a57 = 10046;
      e3.a58 = 10047;
      e3.a59 = 10048;
      e3.a60 = 10049;
      e3.a61 = 10050;
      e3.a62 = 10051;
      e3.a63 = 10052;
      e3.a64 = 10053;
      e3.a65 = 10054;
      e3.a66 = 10055;
      e3.a67 = 10056;
      e3.a68 = 10057;
      e3.a69 = 10058;
      e3.a70 = 10059;
      e3.a71 = 9679;
      e3.a72 = 10061;
      e3.a73 = 9632;
      e3.a74 = 10063;
      e3.a203 = 10064;
      e3.a75 = 10065;
      e3.a204 = 10066;
      e3.a76 = 9650;
      e3.a77 = 9660;
      e3.a78 = 9670;
      e3.a79 = 10070;
      e3.a81 = 9687;
      e3.a82 = 10072;
      e3.a83 = 10073;
      e3.a84 = 10074;
      e3.a97 = 10075;
      e3.a98 = 10076;
      e3.a99 = 10077;
      e3.a100 = 10078;
      e3.a101 = 10081;
      e3.a102 = 10082;
      e3.a103 = 10083;
      e3.a104 = 10084;
      e3.a106 = 10085;
      e3.a107 = 10086;
      e3.a108 = 10087;
      e3.a112 = 9827;
      e3.a111 = 9830;
      e3.a110 = 9829;
      e3.a109 = 9824;
      e3.a120 = 9312;
      e3.a121 = 9313;
      e3.a122 = 9314;
      e3.a123 = 9315;
      e3.a124 = 9316;
      e3.a125 = 9317;
      e3.a126 = 9318;
      e3.a127 = 9319;
      e3.a128 = 9320;
      e3.a129 = 9321;
      e3.a130 = 10102;
      e3.a131 = 10103;
      e3.a132 = 10104;
      e3.a133 = 10105;
      e3.a134 = 10106;
      e3.a135 = 10107;
      e3.a136 = 10108;
      e3.a137 = 10109;
      e3.a138 = 10110;
      e3.a139 = 10111;
      e3.a140 = 10112;
      e3.a141 = 10113;
      e3.a142 = 10114;
      e3.a143 = 10115;
      e3.a144 = 10116;
      e3.a145 = 10117;
      e3.a146 = 10118;
      e3.a147 = 10119;
      e3.a148 = 10120;
      e3.a149 = 10121;
      e3.a150 = 10122;
      e3.a151 = 10123;
      e3.a152 = 10124;
      e3.a153 = 10125;
      e3.a154 = 10126;
      e3.a155 = 10127;
      e3.a156 = 10128;
      e3.a157 = 10129;
      e3.a158 = 10130;
      e3.a159 = 10131;
      e3.a160 = 10132;
      e3.a161 = 8594;
      e3.a163 = 8596;
      e3.a164 = 8597;
      e3.a196 = 10136;
      e3.a165 = 10137;
      e3.a192 = 10138;
      e3.a166 = 10139;
      e3.a167 = 10140;
      e3.a168 = 10141;
      e3.a169 = 10142;
      e3.a170 = 10143;
      e3.a171 = 10144;
      e3.a172 = 10145;
      e3.a173 = 10146;
      e3.a162 = 10147;
      e3.a174 = 10148;
      e3.a175 = 10149;
      e3.a176 = 10150;
      e3.a177 = 10151;
      e3.a178 = 10152;
      e3.a179 = 10153;
      e3.a193 = 10154;
      e3.a180 = 10155;
      e3.a199 = 10156;
      e3.a181 = 10157;
      e3.a200 = 10158;
      e3.a182 = 10159;
      e3.a201 = 10161;
      e3.a183 = 10162;
      e3.a184 = 10163;
      e3.a197 = 10164;
      e3.a185 = 10165;
      e3.a194 = 10166;
      e3.a198 = 10167;
      e3.a186 = 10168;
      e3.a195 = 10169;
      e3.a187 = 10170;
      e3.a188 = 10171;
      e3.a189 = 10172;
      e3.a190 = 10173;
      e3.a191 = 10174;
      e3.a89 = 10088;
      e3.a90 = 10089;
      e3.a93 = 10090;
      e3.a94 = 10091;
      e3.a91 = 10092;
      e3.a92 = 10093;
      e3.a205 = 10094;
      e3.a85 = 10095;
      e3.a206 = 10096;
      e3.a86 = 10097;
      e3.a87 = 10098;
      e3.a88 = 10099;
      e3.a95 = 10100;
      e3.a96 = 10101;
      e3[".notdef"] = 0;
    });
    xi = getLookupTableFactory(function(e3) {
      e3[63721] = 169;
      e3[63193] = 169;
      e3[63720] = 174;
      e3[63194] = 174;
      e3[63722] = 8482;
      e3[63195] = 8482;
      e3[63729] = 9127;
      e3[63730] = 9128;
      e3[63731] = 9129;
      e3[63740] = 9131;
      e3[63741] = 9132;
      e3[63742] = 9133;
      e3[63726] = 9121;
      e3[63727] = 9122;
      e3[63728] = 9123;
      e3[63737] = 9124;
      e3[63738] = 9125;
      e3[63739] = 9126;
      e3[63723] = 9115;
      e3[63724] = 9116;
      e3[63725] = 9117;
      e3[63734] = 9118;
      e3[63735] = 9119;
      e3[63736] = 9120;
    });
    Mi = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
    Hi = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
    Ji = /* @__PURE__ */ new Map();
    Yi = true;
    vi = 1;
    Ki = 2;
    Ti = 4;
    qi = 32;
    Oi = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
    Pi = getLookupTableFactory(function(e3) {
      e3["Times-Roman"] = "Times-Roman";
      e3.Helvetica = "Helvetica";
      e3.Courier = "Courier";
      e3.Symbol = "Symbol";
      e3["Times-Bold"] = "Times-Bold";
      e3["Helvetica-Bold"] = "Helvetica-Bold";
      e3["Courier-Bold"] = "Courier-Bold";
      e3.ZapfDingbats = "ZapfDingbats";
      e3["Times-Italic"] = "Times-Italic";
      e3["Helvetica-Oblique"] = "Helvetica-Oblique";
      e3["Courier-Oblique"] = "Courier-Oblique";
      e3["Times-BoldItalic"] = "Times-BoldItalic";
      e3["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
      e3["Courier-BoldOblique"] = "Courier-BoldOblique";
      e3.ArialNarrow = "Helvetica";
      e3["ArialNarrow-Bold"] = "Helvetica-Bold";
      e3["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
      e3["ArialNarrow-Italic"] = "Helvetica-Oblique";
      e3.ArialBlack = "Helvetica";
      e3["ArialBlack-Bold"] = "Helvetica-Bold";
      e3["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
      e3["ArialBlack-Italic"] = "Helvetica-Oblique";
      e3["Arial-Black"] = "Helvetica";
      e3["Arial-Black-Bold"] = "Helvetica-Bold";
      e3["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
      e3["Arial-Black-Italic"] = "Helvetica-Oblique";
      e3.Arial = "Helvetica";
      e3["Arial-Bold"] = "Helvetica-Bold";
      e3["Arial-BoldItalic"] = "Helvetica-BoldOblique";
      e3["Arial-Italic"] = "Helvetica-Oblique";
      e3.ArialMT = "Helvetica";
      e3["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
      e3["Arial-BoldMT"] = "Helvetica-Bold";
      e3["Arial-ItalicMT"] = "Helvetica-Oblique";
      e3["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
      e3["Arial-BoldMT-Bold"] = "Helvetica-Bold";
      e3["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
      e3.ArialUnicodeMS = "Helvetica";
      e3["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
      e3["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
      e3["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
      e3["Courier-BoldItalic"] = "Courier-BoldOblique";
      e3["Courier-Italic"] = "Courier-Oblique";
      e3.CourierNew = "Courier";
      e3["CourierNew-Bold"] = "Courier-Bold";
      e3["CourierNew-BoldItalic"] = "Courier-BoldOblique";
      e3["CourierNew-Italic"] = "Courier-Oblique";
      e3["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
      e3["CourierNewPS-BoldMT"] = "Courier-Bold";
      e3["CourierNewPS-ItalicMT"] = "Courier-Oblique";
      e3.CourierNewPSMT = "Courier";
      e3["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
      e3["Helvetica-Italic"] = "Helvetica-Oblique";
      e3["Symbol-Bold"] = "Symbol";
      e3["Symbol-BoldItalic"] = "Symbol";
      e3["Symbol-Italic"] = "Symbol";
      e3.TimesNewRoman = "Times-Roman";
      e3["TimesNewRoman-Bold"] = "Times-Bold";
      e3["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
      e3["TimesNewRoman-Italic"] = "Times-Italic";
      e3.TimesNewRomanPS = "Times-Roman";
      e3["TimesNewRomanPS-Bold"] = "Times-Bold";
      e3["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
      e3["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
      e3["TimesNewRomanPS-BoldMT"] = "Times-Bold";
      e3["TimesNewRomanPS-Italic"] = "Times-Italic";
      e3["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
      e3.TimesNewRomanPSMT = "Times-Roman";
      e3["TimesNewRomanPSMT-Bold"] = "Times-Bold";
      e3["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
      e3["TimesNewRomanPSMT-Italic"] = "Times-Italic";
    });
    Wi = getLookupTableFactory(function(e3) {
      e3.Courier = "FoxitFixed.pfb";
      e3["Courier-Bold"] = "FoxitFixedBold.pfb";
      e3["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
      e3["Courier-Oblique"] = "FoxitFixedItalic.pfb";
      e3.Helvetica = "LiberationSans-Regular.ttf";
      e3["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
      e3["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
      e3["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
      e3["Times-Roman"] = "FoxitSerif.pfb";
      e3["Times-Bold"] = "FoxitSerifBold.pfb";
      e3["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
      e3["Times-Italic"] = "FoxitSerifItalic.pfb";
      e3.Symbol = "FoxitSymbol.pfb";
      e3.ZapfDingbats = "FoxitDingbats.pfb";
      e3["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
      e3["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
      e3["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
      e3["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
    });
    ji = getLookupTableFactory(function(e3) {
      e3.Calibri = "Helvetica";
      e3["Calibri-Bold"] = "Helvetica-Bold";
      e3["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
      e3["Calibri-Italic"] = "Helvetica-Oblique";
      e3.CenturyGothic = "Helvetica";
      e3["CenturyGothic-Bold"] = "Helvetica-Bold";
      e3["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
      e3["CenturyGothic-Italic"] = "Helvetica-Oblique";
      e3.ComicSansMS = "Comic Sans MS";
      e3["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
      e3["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
      e3["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
      e3.Impact = "Helvetica";
      e3["ItcSymbol-Bold"] = "Helvetica-Bold";
      e3["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
      e3["ItcSymbol-Book"] = "Helvetica";
      e3["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
      e3["ItcSymbol-Medium"] = "Helvetica";
      e3["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
      e3.LucidaConsole = "Courier";
      e3["LucidaConsole-Bold"] = "Courier-Bold";
      e3["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
      e3["LucidaConsole-Italic"] = "Courier-Oblique";
      e3["LucidaSans-Demi"] = "Helvetica-Bold";
      e3["MS-Gothic"] = "MS Gothic";
      e3["MS-Gothic-Bold"] = "MS Gothic-Bold";
      e3["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
      e3["MS-Gothic-Italic"] = "MS Gothic-Italic";
      e3["MS-Mincho"] = "MS Mincho";
      e3["MS-Mincho-Bold"] = "MS Mincho-Bold";
      e3["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
      e3["MS-Mincho-Italic"] = "MS Mincho-Italic";
      e3["MS-PGothic"] = "MS PGothic";
      e3["MS-PGothic-Bold"] = "MS PGothic-Bold";
      e3["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
      e3["MS-PGothic-Italic"] = "MS PGothic-Italic";
      e3["MS-PMincho"] = "MS PMincho";
      e3["MS-PMincho-Bold"] = "MS PMincho-Bold";
      e3["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
      e3["MS-PMincho-Italic"] = "MS PMincho-Italic";
      e3.NuptialScript = "Times-Italic";
      e3.SegoeUISymbol = "Helvetica";
    });
    Xi = getLookupTableFactory(function(e3) {
      e3["Adobe Jenson"] = true;
      e3["Adobe Text"] = true;
      e3.Albertus = true;
      e3.Aldus = true;
      e3.Alexandria = true;
      e3.Algerian = true;
      e3["American Typewriter"] = true;
      e3.Antiqua = true;
      e3.Apex = true;
      e3.Arno = true;
      e3.Aster = true;
      e3.Aurora = true;
      e3.Baskerville = true;
      e3.Bell = true;
      e3.Bembo = true;
      e3["Bembo Schoolbook"] = true;
      e3.Benguiat = true;
      e3["Berkeley Old Style"] = true;
      e3["Bernhard Modern"] = true;
      e3["Berthold City"] = true;
      e3.Bodoni = true;
      e3["Bauer Bodoni"] = true;
      e3["Book Antiqua"] = true;
      e3.Bookman = true;
      e3["Bordeaux Roman"] = true;
      e3["Californian FB"] = true;
      e3.Calisto = true;
      e3.Calvert = true;
      e3.Capitals = true;
      e3.Cambria = true;
      e3.Cartier = true;
      e3.Caslon = true;
      e3.Catull = true;
      e3.Centaur = true;
      e3["Century Old Style"] = true;
      e3["Century Schoolbook"] = true;
      e3.Chaparral = true;
      e3["Charis SIL"] = true;
      e3.Cheltenham = true;
      e3["Cholla Slab"] = true;
      e3.Clarendon = true;
      e3.Clearface = true;
      e3.Cochin = true;
      e3.Colonna = true;
      e3["Computer Modern"] = true;
      e3["Concrete Roman"] = true;
      e3.Constantia = true;
      e3["Cooper Black"] = true;
      e3.Corona = true;
      e3.Ecotype = true;
      e3.Egyptienne = true;
      e3.Elephant = true;
      e3.Excelsior = true;
      e3.Fairfield = true;
      e3["FF Scala"] = true;
      e3.Folkard = true;
      e3.Footlight = true;
      e3.FreeSerif = true;
      e3["Friz Quadrata"] = true;
      e3.Garamond = true;
      e3.Gentium = true;
      e3.Georgia = true;
      e3.Gloucester = true;
      e3["Goudy Old Style"] = true;
      e3["Goudy Schoolbook"] = true;
      e3["Goudy Pro Font"] = true;
      e3.Granjon = true;
      e3["Guardian Egyptian"] = true;
      e3.Heather = true;
      e3.Hercules = true;
      e3["High Tower Text"] = true;
      e3.Hiroshige = true;
      e3["Hoefler Text"] = true;
      e3["Humana Serif"] = true;
      e3.Imprint = true;
      e3["Ionic No. 5"] = true;
      e3.Janson = true;
      e3.Joanna = true;
      e3.Korinna = true;
      e3.Lexicon = true;
      e3.LiberationSerif = true;
      e3["Liberation Serif"] = true;
      e3["Linux Libertine"] = true;
      e3.Literaturnaya = true;
      e3.Lucida = true;
      e3["Lucida Bright"] = true;
      e3.Melior = true;
      e3.Memphis = true;
      e3.Miller = true;
      e3.Minion = true;
      e3.Modern = true;
      e3["Mona Lisa"] = true;
      e3["Mrs Eaves"] = true;
      e3["MS Serif"] = true;
      e3["Museo Slab"] = true;
      e3["New York"] = true;
      e3["Nimbus Roman"] = true;
      e3["NPS Rawlinson Roadway"] = true;
      e3.NuptialScript = true;
      e3.Palatino = true;
      e3.Perpetua = true;
      e3.Plantin = true;
      e3["Plantin Schoolbook"] = true;
      e3.Playbill = true;
      e3["Poor Richard"] = true;
      e3["Rawlinson Roadway"] = true;
      e3.Renault = true;
      e3.Requiem = true;
      e3.Rockwell = true;
      e3.Roman = true;
      e3["Rotis Serif"] = true;
      e3.Sabon = true;
      e3.Scala = true;
      e3.Seagull = true;
      e3.Sistina = true;
      e3.Souvenir = true;
      e3.STIX = true;
      e3["Stone Informal"] = true;
      e3["Stone Serif"] = true;
      e3.Sylfaen = true;
      e3.Times = true;
      e3.Trajan = true;
      e3["Trinité"] = true;
      e3["Trump Mediaeval"] = true;
      e3.Utopia = true;
      e3["Vale Type"] = true;
      e3["Bitstream Vera"] = true;
      e3["Vera Serif"] = true;
      e3.Versailles = true;
      e3.Wanted = true;
      e3.Weiss = true;
      e3["Wide Latin"] = true;
      e3.Windsor = true;
      e3.XITS = true;
    });
    Zi = getLookupTableFactory(function(e3) {
      e3.Dingbats = true;
      e3.Symbol = true;
      e3.ZapfDingbats = true;
      e3.Wingdings = true;
      e3["Wingdings-Bold"] = true;
      e3["Wingdings-Regular"] = true;
    });
    Vi = getLookupTableFactory(function(e3) {
      e3[2] = 10;
      e3[3] = 32;
      e3[4] = 33;
      e3[5] = 34;
      e3[6] = 35;
      e3[7] = 36;
      e3[8] = 37;
      e3[9] = 38;
      e3[10] = 39;
      e3[11] = 40;
      e3[12] = 41;
      e3[13] = 42;
      e3[14] = 43;
      e3[15] = 44;
      e3[16] = 45;
      e3[17] = 46;
      e3[18] = 47;
      e3[19] = 48;
      e3[20] = 49;
      e3[21] = 50;
      e3[22] = 51;
      e3[23] = 52;
      e3[24] = 53;
      e3[25] = 54;
      e3[26] = 55;
      e3[27] = 56;
      e3[28] = 57;
      e3[29] = 58;
      e3[30] = 894;
      e3[31] = 60;
      e3[32] = 61;
      e3[33] = 62;
      e3[34] = 63;
      e3[35] = 64;
      e3[36] = 65;
      e3[37] = 66;
      e3[38] = 67;
      e3[39] = 68;
      e3[40] = 69;
      e3[41] = 70;
      e3[42] = 71;
      e3[43] = 72;
      e3[44] = 73;
      e3[45] = 74;
      e3[46] = 75;
      e3[47] = 76;
      e3[48] = 77;
      e3[49] = 78;
      e3[50] = 79;
      e3[51] = 80;
      e3[52] = 81;
      e3[53] = 82;
      e3[54] = 83;
      e3[55] = 84;
      e3[56] = 85;
      e3[57] = 86;
      e3[58] = 87;
      e3[59] = 88;
      e3[60] = 89;
      e3[61] = 90;
      e3[62] = 91;
      e3[63] = 92;
      e3[64] = 93;
      e3[65] = 94;
      e3[66] = 95;
      e3[67] = 96;
      e3[68] = 97;
      e3[69] = 98;
      e3[70] = 99;
      e3[71] = 100;
      e3[72] = 101;
      e3[73] = 102;
      e3[74] = 103;
      e3[75] = 104;
      e3[76] = 105;
      e3[77] = 106;
      e3[78] = 107;
      e3[79] = 108;
      e3[80] = 109;
      e3[81] = 110;
      e3[82] = 111;
      e3[83] = 112;
      e3[84] = 113;
      e3[85] = 114;
      e3[86] = 115;
      e3[87] = 116;
      e3[88] = 117;
      e3[89] = 118;
      e3[90] = 119;
      e3[91] = 120;
      e3[92] = 121;
      e3[93] = 122;
      e3[94] = 123;
      e3[95] = 124;
      e3[96] = 125;
      e3[97] = 126;
      e3[98] = 196;
      e3[99] = 197;
      e3[100] = 199;
      e3[101] = 201;
      e3[102] = 209;
      e3[103] = 214;
      e3[104] = 220;
      e3[105] = 225;
      e3[106] = 224;
      e3[107] = 226;
      e3[108] = 228;
      e3[109] = 227;
      e3[110] = 229;
      e3[111] = 231;
      e3[112] = 233;
      e3[113] = 232;
      e3[114] = 234;
      e3[115] = 235;
      e3[116] = 237;
      e3[117] = 236;
      e3[118] = 238;
      e3[119] = 239;
      e3[120] = 241;
      e3[121] = 243;
      e3[122] = 242;
      e3[123] = 244;
      e3[124] = 246;
      e3[125] = 245;
      e3[126] = 250;
      e3[127] = 249;
      e3[128] = 251;
      e3[129] = 252;
      e3[130] = 8224;
      e3[131] = 176;
      e3[132] = 162;
      e3[133] = 163;
      e3[134] = 167;
      e3[135] = 8226;
      e3[136] = 182;
      e3[137] = 223;
      e3[138] = 174;
      e3[139] = 169;
      e3[140] = 8482;
      e3[141] = 180;
      e3[142] = 168;
      e3[143] = 8800;
      e3[144] = 198;
      e3[145] = 216;
      e3[146] = 8734;
      e3[147] = 177;
      e3[148] = 8804;
      e3[149] = 8805;
      e3[150] = 165;
      e3[151] = 181;
      e3[152] = 8706;
      e3[153] = 8721;
      e3[154] = 8719;
      e3[156] = 8747;
      e3[157] = 170;
      e3[158] = 186;
      e3[159] = 8486;
      e3[160] = 230;
      e3[161] = 248;
      e3[162] = 191;
      e3[163] = 161;
      e3[164] = 172;
      e3[165] = 8730;
      e3[166] = 402;
      e3[167] = 8776;
      e3[168] = 8710;
      e3[169] = 171;
      e3[170] = 187;
      e3[171] = 8230;
      e3[179] = 8220;
      e3[180] = 8221;
      e3[181] = 8216;
      e3[182] = 8217;
      e3[200] = 193;
      e3[203] = 205;
      e3[207] = 211;
      e3[210] = 218;
      e3[223] = 711;
      e3[224] = 321;
      e3[225] = 322;
      e3[226] = 352;
      e3[227] = 353;
      e3[228] = 381;
      e3[229] = 382;
      e3[233] = 221;
      e3[234] = 253;
      e3[252] = 263;
      e3[253] = 268;
      e3[254] = 269;
      e3[258] = 258;
      e3[260] = 260;
      e3[261] = 261;
      e3[265] = 280;
      e3[266] = 281;
      e3[267] = 282;
      e3[268] = 283;
      e3[269] = 313;
      e3[275] = 323;
      e3[276] = 324;
      e3[278] = 328;
      e3[283] = 344;
      e3[284] = 345;
      e3[285] = 346;
      e3[286] = 347;
      e3[292] = 367;
      e3[295] = 377;
      e3[296] = 378;
      e3[298] = 380;
      e3[305] = 963;
      e3[306] = 964;
      e3[307] = 966;
      e3[308] = 8215;
      e3[309] = 8252;
      e3[310] = 8319;
      e3[311] = 8359;
      e3[312] = 8592;
      e3[313] = 8593;
      e3[337] = 9552;
      e3[493] = 1039;
      e3[494] = 1040;
      e3[672] = 1488;
      e3[673] = 1489;
      e3[674] = 1490;
      e3[675] = 1491;
      e3[676] = 1492;
      e3[677] = 1493;
      e3[678] = 1494;
      e3[679] = 1495;
      e3[680] = 1496;
      e3[681] = 1497;
      e3[682] = 1498;
      e3[683] = 1499;
      e3[684] = 1500;
      e3[685] = 1501;
      e3[686] = 1502;
      e3[687] = 1503;
      e3[688] = 1504;
      e3[689] = 1505;
      e3[690] = 1506;
      e3[691] = 1507;
      e3[692] = 1508;
      e3[693] = 1509;
      e3[694] = 1510;
      e3[695] = 1511;
      e3[696] = 1512;
      e3[697] = 1513;
      e3[698] = 1514;
      e3[705] = 1524;
      e3[706] = 8362;
      e3[710] = 64288;
      e3[711] = 64298;
      e3[759] = 1617;
      e3[761] = 1776;
      e3[763] = 1778;
      e3[775] = 1652;
      e3[777] = 1764;
      e3[778] = 1780;
      e3[779] = 1781;
      e3[780] = 1782;
      e3[782] = 771;
      e3[783] = 64726;
      e3[786] = 8363;
      e3[788] = 8532;
      e3[790] = 768;
      e3[791] = 769;
      e3[792] = 768;
      e3[795] = 803;
      e3[797] = 64336;
      e3[798] = 64337;
      e3[799] = 64342;
      e3[800] = 64343;
      e3[801] = 64344;
      e3[802] = 64345;
      e3[803] = 64362;
      e3[804] = 64363;
      e3[805] = 64364;
      e3[2424] = 7821;
      e3[2425] = 7822;
      e3[2426] = 7823;
      e3[2427] = 7824;
      e3[2428] = 7825;
      e3[2429] = 7826;
      e3[2430] = 7827;
      e3[2433] = 7682;
      e3[2678] = 8045;
      e3[2679] = 8046;
      e3[2830] = 1552;
      e3[2838] = 686;
      e3[2840] = 751;
      e3[2842] = 753;
      e3[2843] = 754;
      e3[2844] = 755;
      e3[2846] = 757;
      e3[2856] = 767;
      e3[2857] = 848;
      e3[2858] = 849;
      e3[2862] = 853;
      e3[2863] = 854;
      e3[2864] = 855;
      e3[2865] = 861;
      e3[2866] = 862;
      e3[2906] = 7460;
      e3[2908] = 7462;
      e3[2909] = 7463;
      e3[2910] = 7464;
      e3[2912] = 7466;
      e3[2913] = 7467;
      e3[2914] = 7468;
      e3[2916] = 7470;
      e3[2917] = 7471;
      e3[2918] = 7472;
      e3[2920] = 7474;
      e3[2921] = 7475;
      e3[2922] = 7476;
      e3[2924] = 7478;
      e3[2925] = 7479;
      e3[2926] = 7480;
      e3[2928] = 7482;
      e3[2929] = 7483;
      e3[2930] = 7484;
      e3[2932] = 7486;
      e3[2933] = 7487;
      e3[2934] = 7488;
      e3[2936] = 7490;
      e3[2937] = 7491;
      e3[2938] = 7492;
      e3[2940] = 7494;
      e3[2941] = 7495;
      e3[2942] = 7496;
      e3[2944] = 7498;
      e3[2946] = 7500;
      e3[2948] = 7502;
      e3[2950] = 7504;
      e3[2951] = 7505;
      e3[2952] = 7506;
      e3[2954] = 7508;
      e3[2955] = 7509;
      e3[2956] = 7510;
      e3[2958] = 7512;
      e3[2959] = 7513;
      e3[2960] = 7514;
      e3[2962] = 7516;
      e3[2963] = 7517;
      e3[2964] = 7518;
      e3[2966] = 7520;
      e3[2967] = 7521;
      e3[2968] = 7522;
      e3[2970] = 7524;
      e3[2971] = 7525;
      e3[2972] = 7526;
      e3[2974] = 7528;
      e3[2975] = 7529;
      e3[2976] = 7530;
      e3[2978] = 1537;
      e3[2979] = 1538;
      e3[2980] = 1539;
      e3[2982] = 1549;
      e3[2983] = 1551;
      e3[2984] = 1552;
      e3[2986] = 1554;
      e3[2987] = 1555;
      e3[2988] = 1556;
      e3[2990] = 1623;
      e3[2991] = 1624;
      e3[2995] = 1775;
      e3[2999] = 1791;
      e3[3002] = 64290;
      e3[3003] = 64291;
      e3[3004] = 64292;
      e3[3006] = 64294;
      e3[3007] = 64295;
      e3[3008] = 64296;
      e3[3011] = 1900;
      e3[3014] = 8223;
      e3[3015] = 8244;
      e3[3017] = 7532;
      e3[3018] = 7533;
      e3[3019] = 7534;
      e3[3075] = 7590;
      e3[3076] = 7591;
      e3[3079] = 7594;
      e3[3080] = 7595;
      e3[3083] = 7598;
      e3[3084] = 7599;
      e3[3087] = 7602;
      e3[3088] = 7603;
      e3[3091] = 7606;
      e3[3092] = 7607;
      e3[3095] = 7610;
      e3[3096] = 7611;
      e3[3099] = 7614;
      e3[3100] = 7615;
      e3[3103] = 7618;
      e3[3104] = 7619;
      e3[3107] = 8337;
      e3[3108] = 8338;
      e3[3116] = 1884;
      e3[3119] = 1885;
      e3[3120] = 1885;
      e3[3123] = 1886;
      e3[3124] = 1886;
      e3[3127] = 1887;
      e3[3128] = 1887;
      e3[3131] = 1888;
      e3[3132] = 1888;
      e3[3135] = 1889;
      e3[3136] = 1889;
      e3[3139] = 1890;
      e3[3140] = 1890;
      e3[3143] = 1891;
      e3[3144] = 1891;
      e3[3147] = 1892;
      e3[3148] = 1892;
      e3[3153] = 580;
      e3[3154] = 581;
      e3[3157] = 584;
      e3[3158] = 585;
      e3[3161] = 588;
      e3[3162] = 589;
      e3[3165] = 891;
      e3[3166] = 892;
      e3[3169] = 1274;
      e3[3170] = 1275;
      e3[3173] = 1278;
      e3[3174] = 1279;
      e3[3181] = 7622;
      e3[3182] = 7623;
      e3[3282] = 11799;
      e3[3316] = 578;
      e3[3379] = 42785;
      e3[3393] = 1159;
      e3[3416] = 8377;
    });
    zi = getLookupTableFactory(function(e3) {
      e3[227] = 322;
      e3[264] = 261;
      e3[291] = 346;
    });
    _i2 = getLookupTableFactory(function(e3) {
      e3[1] = 32;
      e3[4] = 65;
      e3[5] = 192;
      e3[6] = 193;
      e3[9] = 196;
      e3[17] = 66;
      e3[18] = 67;
      e3[21] = 268;
      e3[24] = 68;
      e3[28] = 69;
      e3[29] = 200;
      e3[30] = 201;
      e3[32] = 282;
      e3[38] = 70;
      e3[39] = 71;
      e3[44] = 72;
      e3[47] = 73;
      e3[48] = 204;
      e3[49] = 205;
      e3[58] = 74;
      e3[60] = 75;
      e3[62] = 76;
      e3[68] = 77;
      e3[69] = 78;
      e3[75] = 79;
      e3[76] = 210;
      e3[80] = 214;
      e3[87] = 80;
      e3[89] = 81;
      e3[90] = 82;
      e3[92] = 344;
      e3[94] = 83;
      e3[97] = 352;
      e3[100] = 84;
      e3[104] = 85;
      e3[109] = 220;
      e3[115] = 86;
      e3[116] = 87;
      e3[121] = 88;
      e3[122] = 89;
      e3[124] = 221;
      e3[127] = 90;
      e3[129] = 381;
      e3[258] = 97;
      e3[259] = 224;
      e3[260] = 225;
      e3[263] = 228;
      e3[268] = 261;
      e3[271] = 98;
      e3[272] = 99;
      e3[273] = 263;
      e3[275] = 269;
      e3[282] = 100;
      e3[286] = 101;
      e3[287] = 232;
      e3[288] = 233;
      e3[290] = 283;
      e3[295] = 281;
      e3[296] = 102;
      e3[336] = 103;
      e3[346] = 104;
      e3[349] = 105;
      e3[350] = 236;
      e3[351] = 237;
      e3[361] = 106;
      e3[364] = 107;
      e3[367] = 108;
      e3[371] = 322;
      e3[373] = 109;
      e3[374] = 110;
      e3[381] = 111;
      e3[382] = 242;
      e3[383] = 243;
      e3[386] = 246;
      e3[393] = 112;
      e3[395] = 113;
      e3[396] = 114;
      e3[398] = 345;
      e3[400] = 115;
      e3[401] = 347;
      e3[403] = 353;
      e3[410] = 116;
      e3[437] = 117;
      e3[442] = 252;
      e3[448] = 118;
      e3[449] = 119;
      e3[454] = 120;
      e3[455] = 121;
      e3[457] = 253;
      e3[460] = 122;
      e3[462] = 382;
      e3[463] = 380;
      e3[853] = 44;
      e3[855] = 58;
      e3[856] = 46;
      e3[876] = 47;
      e3[878] = 45;
      e3[882] = 45;
      e3[894] = 40;
      e3[895] = 41;
      e3[896] = 91;
      e3[897] = 93;
      e3[923] = 64;
      e3[1004] = 48;
      e3[1005] = 49;
      e3[1006] = 50;
      e3[1007] = 51;
      e3[1008] = 52;
      e3[1009] = 53;
      e3[1010] = 54;
      e3[1011] = 55;
      e3[1012] = 56;
      e3[1013] = 57;
      e3[1081] = 37;
      e3[1085] = 43;
      e3[1086] = 45;
    });
    ToUnicodeMap = class {
      constructor(e3 = []) {
        this._map = e3;
      }
      get length() {
        return this._map.length;
      }
      forEach(e3) {
        for (const t3 in this._map)
          e3(t3, this._map[t3].charCodeAt(0));
      }
      has(e3) {
        return void 0 !== this._map[e3];
      }
      get(e3) {
        return this._map[e3];
      }
      charCodeOf(e3) {
        const t3 = this._map;
        if (t3.length <= 65536)
          return t3.indexOf(e3);
        for (const i3 in t3)
          if (t3[i3] === e3)
            return 0 | i3;
        return -1;
      }
      amend(e3) {
        for (const t3 in e3)
          this._map[t3] = e3[t3];
      }
    };
    IdentityToUnicodeMap = class {
      constructor(e3, t3) {
        this.firstChar = e3;
        this.lastChar = t3;
      }
      get length() {
        return this.lastChar + 1 - this.firstChar;
      }
      forEach(e3) {
        for (let t3 = this.firstChar, i3 = this.lastChar; t3 <= i3; t3++)
          e3(t3, t3);
      }
      has(e3) {
        return this.firstChar <= e3 && e3 <= this.lastChar;
      }
      get(e3) {
        if (this.firstChar <= e3 && e3 <= this.lastChar)
          return String.fromCharCode(e3);
      }
      charCodeOf(e3) {
        return Number.isInteger(e3) && e3 >= this.firstChar && e3 <= this.lastChar ? e3 : -1;
      }
      amend(e3) {
        unreachable("Should not call amend()");
      }
    };
    CFFFont = class {
      constructor(e3, t3) {
        this.properties = t3;
        const i3 = new CFFParser(e3, t3, Yi);
        this.cff = i3.parse();
        this.cff.duplicateFirstGlyph();
        const a3 = new CFFCompiler(this.cff);
        this.seacs = this.cff.seacs;
        try {
          this.data = a3.compile();
        } catch {
          warn("Failed to compile font " + t3.loadedName);
          this.data = e3;
        }
        this._createBuiltInEncoding();
      }
      get numGlyphs() {
        return this.cff.charStrings.count;
      }
      getCharset() {
        return this.cff.charset.charset;
      }
      getGlyphMapping() {
        const e3 = this.cff, t3 = this.properties, { cidToGidMap: i3, cMap: a3 } = t3, s3 = e3.charset.charset;
        let r3, n3;
        if (t3.composite) {
          let t4, o4;
          if ((i3 == null ? void 0 : i3.length) > 0) {
            t4 = /* @__PURE__ */ Object.create(null);
            for (let e4 = 0, a4 = i3.length; e4 < a4; e4++) {
              const a5 = i3[e4];
              void 0 !== a5 && (t4[a5] = e4);
            }
          }
          r3 = /* @__PURE__ */ Object.create(null);
          if (e3.isCIDFont)
            for (n3 = 0; n3 < s3.length; n3++) {
              const e4 = s3[n3];
              o4 = a3.charCodeOf(e4);
              void 0 !== (t4 == null ? void 0 : t4[o4]) && (o4 = t4[o4]);
              r3[o4] = n3;
            }
          else
            for (n3 = 0; n3 < e3.charStrings.count; n3++) {
              o4 = a3.charCodeOf(n3);
              r3[o4] = n3;
            }
          return r3;
        }
        let o3 = e3.encoding ? e3.encoding.encoding : null;
        t3.isInternalFont && (o3 = t3.defaultEncoding);
        r3 = type1FontGlyphMapping(t3, o3, s3);
        return r3;
      }
      hasGlyphId(e3) {
        return this.cff.hasGlyphId(e3);
      }
      _createBuiltInEncoding() {
        const { charset: e3, encoding: t3 } = this.cff;
        if (!e3 || !t3)
          return;
        const i3 = e3.charset, a3 = t3.encoding, s3 = [];
        for (const e4 in a3) {
          const t4 = a3[e4];
          if (t4 >= 0) {
            const a4 = i3[t4];
            a4 && (s3[e4] = a4);
          }
        }
        s3.length > 0 && (this.properties.builtInEncoding = s3);
      }
    };
    $i = [];
    Commands = class {
      constructor() {
        __publicField(this, "cmds", []);
      }
      add(e3, t3) {
        if (t3)
          if (isNumberArray(t3, null))
            this.cmds.push(e3, ...t3);
          else {
            warn(`Commands.add - "${e3}" has at least one non-number arg: "${t3}".`);
            const i3 = t3.map((e4) => "number" == typeof e4 ? e4 : 0);
            this.cmds.push(e3, ...i3);
          }
        else
          this.cmds.push(e3);
      }
    };
    CompiledFont = class _CompiledFont {
      constructor(e3) {
        this.constructor === _CompiledFont && unreachable("Cannot initialize CompiledFont.");
        this.fontMatrix = e3;
        this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
        this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
      }
      getPathJs(e3) {
        var _a3;
        const { charCode: t3, glyphId: i3 } = lookupCmap(this.cmap, e3);
        let a3, s3 = this.compiledGlyphs[i3];
        if (!s3) {
          try {
            s3 = this.compileGlyph(this.glyphs[i3], i3);
          } catch (e4) {
            s3 = $i;
            a3 = e4;
          }
          this.compiledGlyphs[i3] = s3;
        }
        (_a3 = this.compiledCharCodeToGlyphId)[t3] ?? (_a3[t3] = i3);
        if (a3)
          throw a3;
        return s3;
      }
      compileGlyph(e3, t3) {
        if (!e3 || 0 === e3.length || 14 === e3[0])
          return $i;
        let i3 = this.fontMatrix;
        if (this.isCFFCIDFont) {
          const e4 = this.fdSelect.getFDIndex(t3);
          if (e4 >= 0 && e4 < this.fdArray.length) {
            i3 = this.fdArray[e4].getByName("FontMatrix") || a2;
          } else
            warn("Invalid fd index for glyph index.");
        }
        const s3 = new Commands();
        s3.add(Qt);
        s3.add(ut, i3.slice());
        s3.add(Et);
        this.compileGlyphImpl(e3, s3, t3);
        s3.add(Bt);
        return s3.cmds;
      }
      compileGlyphImpl() {
        unreachable("Children classes should implement this.");
      }
      hasBuiltPath(e3) {
        const { charCode: t3, glyphId: i3 } = lookupCmap(this.cmap, e3);
        return void 0 !== this.compiledGlyphs[i3] && void 0 !== this.compiledCharCodeToGlyphId[t3];
      }
    };
    TrueTypeCompiled = class extends CompiledFont {
      constructor(e3, t3, i3) {
        super(i3 || [488e-6, 0, 0, 488e-6, 0, 0]);
        this.glyphs = e3;
        this.cmap = t3;
      }
      compileGlyphImpl(e3, t3) {
        compileGlyf(e3, t3, this);
      }
    };
    Type2Compiled = class extends CompiledFont {
      constructor(e3, t3, i3, a3) {
        super(i3 || [1e-3, 0, 0, 1e-3, 0, 0]);
        this.glyphs = e3.glyphs;
        this.gsubrs = e3.gsubrs || [];
        this.subrs = e3.subrs || [];
        this.cmap = t3;
        this.glyphNameMap = a3 || Ri();
        this.gsubrsBias = getSubroutineBias(this.gsubrs);
        this.subrsBias = getSubroutineBias(this.subrs);
        this.isCFFCIDFont = e3.isCFFCIDFont;
        this.fdSelect = e3.fdSelect;
        this.fdArray = e3.fdArray;
      }
      compileGlyphImpl(e3, t3, i3) {
        compileCharString(e3, t3, this, i3);
      }
    };
    FontRendererFactory = class {
      static create(e3, t3) {
        const i3 = new Uint8Array(e3.data);
        let a3, s3, r3, n3, o3, g3;
        const c3 = getUint16(i3, 4);
        for (let e4 = 0, C3 = 12; e4 < c3; e4++, C3 += 16) {
          const e5 = bytesToString(i3.subarray(C3, C3 + 4)), c4 = getUint32(i3, C3 + 8), h2 = getUint32(i3, C3 + 12);
          switch (e5) {
            case "cmap":
              a3 = parseCmap(i3, c4);
              break;
            case "glyf":
              s3 = i3.subarray(c4, c4 + h2);
              break;
            case "loca":
              r3 = i3.subarray(c4, c4 + h2);
              break;
            case "head":
              g3 = getUint16(i3, c4 + 18);
              o3 = getUint16(i3, c4 + 50);
              break;
            case "CFF ":
              n3 = parseCff(i3, c4, c4 + h2, t3);
          }
        }
        if (s3) {
          const t4 = g3 ? [1 / g3, 0, 0, 1 / g3, 0, 0] : e3.fontMatrix;
          return new TrueTypeCompiled(function parseGlyfTable(e4, t5, i4) {
            let a4, s4;
            if (i4) {
              a4 = 4;
              s4 = getUint32;
            } else {
              a4 = 2;
              s4 = (e5, t6) => 2 * getUint16(e5, t6);
            }
            const r4 = [];
            let n4 = s4(t5, 0);
            for (let i5 = a4; i5 < t5.length; i5 += a4) {
              const a5 = s4(t5, i5);
              r4.push(e4.subarray(n4, a5));
              n4 = a5;
            }
            return r4;
          }(s3, r3, o3), a3, t4);
        }
        return new Type2Compiled(n3, a3, e3.fontMatrix, e3.glyphNameMap);
      }
    };
    Aa = getLookupTableFactory(function(e3) {
      e3.Courier = 600;
      e3["Courier-Bold"] = 600;
      e3["Courier-BoldOblique"] = 600;
      e3["Courier-Oblique"] = 600;
      e3.Helvetica = getLookupTableFactory(function(e4) {
        e4.space = 278;
        e4.exclam = 278;
        e4.quotedbl = 355;
        e4.numbersign = 556;
        e4.dollar = 556;
        e4.percent = 889;
        e4.ampersand = 667;
        e4.quoteright = 222;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asterisk = 389;
        e4.plus = 584;
        e4.comma = 278;
        e4.hyphen = 333;
        e4.period = 278;
        e4.slash = 278;
        e4.zero = 556;
        e4.one = 556;
        e4.two = 556;
        e4.three = 556;
        e4.four = 556;
        e4.five = 556;
        e4.six = 556;
        e4.seven = 556;
        e4.eight = 556;
        e4.nine = 556;
        e4.colon = 278;
        e4.semicolon = 278;
        e4.less = 584;
        e4.equal = 584;
        e4.greater = 584;
        e4.question = 556;
        e4.at = 1015;
        e4.A = 667;
        e4.B = 667;
        e4.C = 722;
        e4.D = 722;
        e4.E = 667;
        e4.F = 611;
        e4.G = 778;
        e4.H = 722;
        e4.I = 278;
        e4.J = 500;
        e4.K = 667;
        e4.L = 556;
        e4.M = 833;
        e4.N = 722;
        e4.O = 778;
        e4.P = 667;
        e4.Q = 778;
        e4.R = 722;
        e4.S = 667;
        e4.T = 611;
        e4.U = 722;
        e4.V = 667;
        e4.W = 944;
        e4.X = 667;
        e4.Y = 667;
        e4.Z = 611;
        e4.bracketleft = 278;
        e4.backslash = 278;
        e4.bracketright = 278;
        e4.asciicircum = 469;
        e4.underscore = 556;
        e4.quoteleft = 222;
        e4.a = 556;
        e4.b = 556;
        e4.c = 500;
        e4.d = 556;
        e4.e = 556;
        e4.f = 278;
        e4.g = 556;
        e4.h = 556;
        e4.i = 222;
        e4.j = 222;
        e4.k = 500;
        e4.l = 222;
        e4.m = 833;
        e4.n = 556;
        e4.o = 556;
        e4.p = 556;
        e4.q = 556;
        e4.r = 333;
        e4.s = 500;
        e4.t = 278;
        e4.u = 556;
        e4.v = 500;
        e4.w = 722;
        e4.x = 500;
        e4.y = 500;
        e4.z = 500;
        e4.braceleft = 334;
        e4.bar = 260;
        e4.braceright = 334;
        e4.asciitilde = 584;
        e4.exclamdown = 333;
        e4.cent = 556;
        e4.sterling = 556;
        e4.fraction = 167;
        e4.yen = 556;
        e4.florin = 556;
        e4.section = 556;
        e4.currency = 556;
        e4.quotesingle = 191;
        e4.quotedblleft = 333;
        e4.guillemotleft = 556;
        e4.guilsinglleft = 333;
        e4.guilsinglright = 333;
        e4.fi = 500;
        e4.fl = 500;
        e4.endash = 556;
        e4.dagger = 556;
        e4.daggerdbl = 556;
        e4.periodcentered = 278;
        e4.paragraph = 537;
        e4.bullet = 350;
        e4.quotesinglbase = 222;
        e4.quotedblbase = 333;
        e4.quotedblright = 333;
        e4.guillemotright = 556;
        e4.ellipsis = 1e3;
        e4.perthousand = 1e3;
        e4.questiondown = 611;
        e4.grave = 333;
        e4.acute = 333;
        e4.circumflex = 333;
        e4.tilde = 333;
        e4.macron = 333;
        e4.breve = 333;
        e4.dotaccent = 333;
        e4.dieresis = 333;
        e4.ring = 333;
        e4.cedilla = 333;
        e4.hungarumlaut = 333;
        e4.ogonek = 333;
        e4.caron = 333;
        e4.emdash = 1e3;
        e4.AE = 1e3;
        e4.ordfeminine = 370;
        e4.Lslash = 556;
        e4.Oslash = 778;
        e4.OE = 1e3;
        e4.ordmasculine = 365;
        e4.ae = 889;
        e4.dotlessi = 278;
        e4.lslash = 222;
        e4.oslash = 611;
        e4.oe = 944;
        e4.germandbls = 611;
        e4.Idieresis = 278;
        e4.eacute = 556;
        e4.abreve = 556;
        e4.uhungarumlaut = 556;
        e4.ecaron = 556;
        e4.Ydieresis = 667;
        e4.divide = 584;
        e4.Yacute = 667;
        e4.Acircumflex = 667;
        e4.aacute = 556;
        e4.Ucircumflex = 722;
        e4.yacute = 500;
        e4.scommaaccent = 500;
        e4.ecircumflex = 556;
        e4.Uring = 722;
        e4.Udieresis = 722;
        e4.aogonek = 556;
        e4.Uacute = 722;
        e4.uogonek = 556;
        e4.Edieresis = 667;
        e4.Dcroat = 722;
        e4.commaaccent = 250;
        e4.copyright = 737;
        e4.Emacron = 667;
        e4.ccaron = 500;
        e4.aring = 556;
        e4.Ncommaaccent = 722;
        e4.lacute = 222;
        e4.agrave = 556;
        e4.Tcommaaccent = 611;
        e4.Cacute = 722;
        e4.atilde = 556;
        e4.Edotaccent = 667;
        e4.scaron = 500;
        e4.scedilla = 500;
        e4.iacute = 278;
        e4.lozenge = 471;
        e4.Rcaron = 722;
        e4.Gcommaaccent = 778;
        e4.ucircumflex = 556;
        e4.acircumflex = 556;
        e4.Amacron = 667;
        e4.rcaron = 333;
        e4.ccedilla = 500;
        e4.Zdotaccent = 611;
        e4.Thorn = 667;
        e4.Omacron = 778;
        e4.Racute = 722;
        e4.Sacute = 667;
        e4.dcaron = 643;
        e4.Umacron = 722;
        e4.uring = 556;
        e4.threesuperior = 333;
        e4.Ograve = 778;
        e4.Agrave = 667;
        e4.Abreve = 667;
        e4.multiply = 584;
        e4.uacute = 556;
        e4.Tcaron = 611;
        e4.partialdiff = 476;
        e4.ydieresis = 500;
        e4.Nacute = 722;
        e4.icircumflex = 278;
        e4.Ecircumflex = 667;
        e4.adieresis = 556;
        e4.edieresis = 556;
        e4.cacute = 500;
        e4.nacute = 556;
        e4.umacron = 556;
        e4.Ncaron = 722;
        e4.Iacute = 278;
        e4.plusminus = 584;
        e4.brokenbar = 260;
        e4.registered = 737;
        e4.Gbreve = 778;
        e4.Idotaccent = 278;
        e4.summation = 600;
        e4.Egrave = 667;
        e4.racute = 333;
        e4.omacron = 556;
        e4.Zacute = 611;
        e4.Zcaron = 611;
        e4.greaterequal = 549;
        e4.Eth = 722;
        e4.Ccedilla = 722;
        e4.lcommaaccent = 222;
        e4.tcaron = 317;
        e4.eogonek = 556;
        e4.Uogonek = 722;
        e4.Aacute = 667;
        e4.Adieresis = 667;
        e4.egrave = 556;
        e4.zacute = 500;
        e4.iogonek = 222;
        e4.Oacute = 778;
        e4.oacute = 556;
        e4.amacron = 556;
        e4.sacute = 500;
        e4.idieresis = 278;
        e4.Ocircumflex = 778;
        e4.Ugrave = 722;
        e4.Delta = 612;
        e4.thorn = 556;
        e4.twosuperior = 333;
        e4.Odieresis = 778;
        e4.mu = 556;
        e4.igrave = 278;
        e4.ohungarumlaut = 556;
        e4.Eogonek = 667;
        e4.dcroat = 556;
        e4.threequarters = 834;
        e4.Scedilla = 667;
        e4.lcaron = 299;
        e4.Kcommaaccent = 667;
        e4.Lacute = 556;
        e4.trademark = 1e3;
        e4.edotaccent = 556;
        e4.Igrave = 278;
        e4.Imacron = 278;
        e4.Lcaron = 556;
        e4.onehalf = 834;
        e4.lessequal = 549;
        e4.ocircumflex = 556;
        e4.ntilde = 556;
        e4.Uhungarumlaut = 722;
        e4.Eacute = 667;
        e4.emacron = 556;
        e4.gbreve = 556;
        e4.onequarter = 834;
        e4.Scaron = 667;
        e4.Scommaaccent = 667;
        e4.Ohungarumlaut = 778;
        e4.degree = 400;
        e4.ograve = 556;
        e4.Ccaron = 722;
        e4.ugrave = 556;
        e4.radical = 453;
        e4.Dcaron = 722;
        e4.rcommaaccent = 333;
        e4.Ntilde = 722;
        e4.otilde = 556;
        e4.Rcommaaccent = 722;
        e4.Lcommaaccent = 556;
        e4.Atilde = 667;
        e4.Aogonek = 667;
        e4.Aring = 667;
        e4.Otilde = 778;
        e4.zdotaccent = 500;
        e4.Ecaron = 667;
        e4.Iogonek = 278;
        e4.kcommaaccent = 500;
        e4.minus = 584;
        e4.Icircumflex = 278;
        e4.ncaron = 556;
        e4.tcommaaccent = 278;
        e4.logicalnot = 584;
        e4.odieresis = 556;
        e4.udieresis = 556;
        e4.notequal = 549;
        e4.gcommaaccent = 556;
        e4.eth = 556;
        e4.zcaron = 500;
        e4.ncommaaccent = 556;
        e4.onesuperior = 333;
        e4.imacron = 278;
        e4.Euro = 556;
      });
      e3["Helvetica-Bold"] = getLookupTableFactory(function(e4) {
        e4.space = 278;
        e4.exclam = 333;
        e4.quotedbl = 474;
        e4.numbersign = 556;
        e4.dollar = 556;
        e4.percent = 889;
        e4.ampersand = 722;
        e4.quoteright = 278;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asterisk = 389;
        e4.plus = 584;
        e4.comma = 278;
        e4.hyphen = 333;
        e4.period = 278;
        e4.slash = 278;
        e4.zero = 556;
        e4.one = 556;
        e4.two = 556;
        e4.three = 556;
        e4.four = 556;
        e4.five = 556;
        e4.six = 556;
        e4.seven = 556;
        e4.eight = 556;
        e4.nine = 556;
        e4.colon = 333;
        e4.semicolon = 333;
        e4.less = 584;
        e4.equal = 584;
        e4.greater = 584;
        e4.question = 611;
        e4.at = 975;
        e4.A = 722;
        e4.B = 722;
        e4.C = 722;
        e4.D = 722;
        e4.E = 667;
        e4.F = 611;
        e4.G = 778;
        e4.H = 722;
        e4.I = 278;
        e4.J = 556;
        e4.K = 722;
        e4.L = 611;
        e4.M = 833;
        e4.N = 722;
        e4.O = 778;
        e4.P = 667;
        e4.Q = 778;
        e4.R = 722;
        e4.S = 667;
        e4.T = 611;
        e4.U = 722;
        e4.V = 667;
        e4.W = 944;
        e4.X = 667;
        e4.Y = 667;
        e4.Z = 611;
        e4.bracketleft = 333;
        e4.backslash = 278;
        e4.bracketright = 333;
        e4.asciicircum = 584;
        e4.underscore = 556;
        e4.quoteleft = 278;
        e4.a = 556;
        e4.b = 611;
        e4.c = 556;
        e4.d = 611;
        e4.e = 556;
        e4.f = 333;
        e4.g = 611;
        e4.h = 611;
        e4.i = 278;
        e4.j = 278;
        e4.k = 556;
        e4.l = 278;
        e4.m = 889;
        e4.n = 611;
        e4.o = 611;
        e4.p = 611;
        e4.q = 611;
        e4.r = 389;
        e4.s = 556;
        e4.t = 333;
        e4.u = 611;
        e4.v = 556;
        e4.w = 778;
        e4.x = 556;
        e4.y = 556;
        e4.z = 500;
        e4.braceleft = 389;
        e4.bar = 280;
        e4.braceright = 389;
        e4.asciitilde = 584;
        e4.exclamdown = 333;
        e4.cent = 556;
        e4.sterling = 556;
        e4.fraction = 167;
        e4.yen = 556;
        e4.florin = 556;
        e4.section = 556;
        e4.currency = 556;
        e4.quotesingle = 238;
        e4.quotedblleft = 500;
        e4.guillemotleft = 556;
        e4.guilsinglleft = 333;
        e4.guilsinglright = 333;
        e4.fi = 611;
        e4.fl = 611;
        e4.endash = 556;
        e4.dagger = 556;
        e4.daggerdbl = 556;
        e4.periodcentered = 278;
        e4.paragraph = 556;
        e4.bullet = 350;
        e4.quotesinglbase = 278;
        e4.quotedblbase = 500;
        e4.quotedblright = 500;
        e4.guillemotright = 556;
        e4.ellipsis = 1e3;
        e4.perthousand = 1e3;
        e4.questiondown = 611;
        e4.grave = 333;
        e4.acute = 333;
        e4.circumflex = 333;
        e4.tilde = 333;
        e4.macron = 333;
        e4.breve = 333;
        e4.dotaccent = 333;
        e4.dieresis = 333;
        e4.ring = 333;
        e4.cedilla = 333;
        e4.hungarumlaut = 333;
        e4.ogonek = 333;
        e4.caron = 333;
        e4.emdash = 1e3;
        e4.AE = 1e3;
        e4.ordfeminine = 370;
        e4.Lslash = 611;
        e4.Oslash = 778;
        e4.OE = 1e3;
        e4.ordmasculine = 365;
        e4.ae = 889;
        e4.dotlessi = 278;
        e4.lslash = 278;
        e4.oslash = 611;
        e4.oe = 944;
        e4.germandbls = 611;
        e4.Idieresis = 278;
        e4.eacute = 556;
        e4.abreve = 556;
        e4.uhungarumlaut = 611;
        e4.ecaron = 556;
        e4.Ydieresis = 667;
        e4.divide = 584;
        e4.Yacute = 667;
        e4.Acircumflex = 722;
        e4.aacute = 556;
        e4.Ucircumflex = 722;
        e4.yacute = 556;
        e4.scommaaccent = 556;
        e4.ecircumflex = 556;
        e4.Uring = 722;
        e4.Udieresis = 722;
        e4.aogonek = 556;
        e4.Uacute = 722;
        e4.uogonek = 611;
        e4.Edieresis = 667;
        e4.Dcroat = 722;
        e4.commaaccent = 250;
        e4.copyright = 737;
        e4.Emacron = 667;
        e4.ccaron = 556;
        e4.aring = 556;
        e4.Ncommaaccent = 722;
        e4.lacute = 278;
        e4.agrave = 556;
        e4.Tcommaaccent = 611;
        e4.Cacute = 722;
        e4.atilde = 556;
        e4.Edotaccent = 667;
        e4.scaron = 556;
        e4.scedilla = 556;
        e4.iacute = 278;
        e4.lozenge = 494;
        e4.Rcaron = 722;
        e4.Gcommaaccent = 778;
        e4.ucircumflex = 611;
        e4.acircumflex = 556;
        e4.Amacron = 722;
        e4.rcaron = 389;
        e4.ccedilla = 556;
        e4.Zdotaccent = 611;
        e4.Thorn = 667;
        e4.Omacron = 778;
        e4.Racute = 722;
        e4.Sacute = 667;
        e4.dcaron = 743;
        e4.Umacron = 722;
        e4.uring = 611;
        e4.threesuperior = 333;
        e4.Ograve = 778;
        e4.Agrave = 722;
        e4.Abreve = 722;
        e4.multiply = 584;
        e4.uacute = 611;
        e4.Tcaron = 611;
        e4.partialdiff = 494;
        e4.ydieresis = 556;
        e4.Nacute = 722;
        e4.icircumflex = 278;
        e4.Ecircumflex = 667;
        e4.adieresis = 556;
        e4.edieresis = 556;
        e4.cacute = 556;
        e4.nacute = 611;
        e4.umacron = 611;
        e4.Ncaron = 722;
        e4.Iacute = 278;
        e4.plusminus = 584;
        e4.brokenbar = 280;
        e4.registered = 737;
        e4.Gbreve = 778;
        e4.Idotaccent = 278;
        e4.summation = 600;
        e4.Egrave = 667;
        e4.racute = 389;
        e4.omacron = 611;
        e4.Zacute = 611;
        e4.Zcaron = 611;
        e4.greaterequal = 549;
        e4.Eth = 722;
        e4.Ccedilla = 722;
        e4.lcommaaccent = 278;
        e4.tcaron = 389;
        e4.eogonek = 556;
        e4.Uogonek = 722;
        e4.Aacute = 722;
        e4.Adieresis = 722;
        e4.egrave = 556;
        e4.zacute = 500;
        e4.iogonek = 278;
        e4.Oacute = 778;
        e4.oacute = 611;
        e4.amacron = 556;
        e4.sacute = 556;
        e4.idieresis = 278;
        e4.Ocircumflex = 778;
        e4.Ugrave = 722;
        e4.Delta = 612;
        e4.thorn = 611;
        e4.twosuperior = 333;
        e4.Odieresis = 778;
        e4.mu = 611;
        e4.igrave = 278;
        e4.ohungarumlaut = 611;
        e4.Eogonek = 667;
        e4.dcroat = 611;
        e4.threequarters = 834;
        e4.Scedilla = 667;
        e4.lcaron = 400;
        e4.Kcommaaccent = 722;
        e4.Lacute = 611;
        e4.trademark = 1e3;
        e4.edotaccent = 556;
        e4.Igrave = 278;
        e4.Imacron = 278;
        e4.Lcaron = 611;
        e4.onehalf = 834;
        e4.lessequal = 549;
        e4.ocircumflex = 611;
        e4.ntilde = 611;
        e4.Uhungarumlaut = 722;
        e4.Eacute = 667;
        e4.emacron = 556;
        e4.gbreve = 611;
        e4.onequarter = 834;
        e4.Scaron = 667;
        e4.Scommaaccent = 667;
        e4.Ohungarumlaut = 778;
        e4.degree = 400;
        e4.ograve = 611;
        e4.Ccaron = 722;
        e4.ugrave = 611;
        e4.radical = 549;
        e4.Dcaron = 722;
        e4.rcommaaccent = 389;
        e4.Ntilde = 722;
        e4.otilde = 611;
        e4.Rcommaaccent = 722;
        e4.Lcommaaccent = 611;
        e4.Atilde = 722;
        e4.Aogonek = 722;
        e4.Aring = 722;
        e4.Otilde = 778;
        e4.zdotaccent = 500;
        e4.Ecaron = 667;
        e4.Iogonek = 278;
        e4.kcommaaccent = 556;
        e4.minus = 584;
        e4.Icircumflex = 278;
        e4.ncaron = 611;
        e4.tcommaaccent = 333;
        e4.logicalnot = 584;
        e4.odieresis = 611;
        e4.udieresis = 611;
        e4.notequal = 549;
        e4.gcommaaccent = 611;
        e4.eth = 611;
        e4.zcaron = 500;
        e4.ncommaaccent = 611;
        e4.onesuperior = 333;
        e4.imacron = 278;
        e4.Euro = 556;
      });
      e3["Helvetica-BoldOblique"] = getLookupTableFactory(function(e4) {
        e4.space = 278;
        e4.exclam = 333;
        e4.quotedbl = 474;
        e4.numbersign = 556;
        e4.dollar = 556;
        e4.percent = 889;
        e4.ampersand = 722;
        e4.quoteright = 278;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asterisk = 389;
        e4.plus = 584;
        e4.comma = 278;
        e4.hyphen = 333;
        e4.period = 278;
        e4.slash = 278;
        e4.zero = 556;
        e4.one = 556;
        e4.two = 556;
        e4.three = 556;
        e4.four = 556;
        e4.five = 556;
        e4.six = 556;
        e4.seven = 556;
        e4.eight = 556;
        e4.nine = 556;
        e4.colon = 333;
        e4.semicolon = 333;
        e4.less = 584;
        e4.equal = 584;
        e4.greater = 584;
        e4.question = 611;
        e4.at = 975;
        e4.A = 722;
        e4.B = 722;
        e4.C = 722;
        e4.D = 722;
        e4.E = 667;
        e4.F = 611;
        e4.G = 778;
        e4.H = 722;
        e4.I = 278;
        e4.J = 556;
        e4.K = 722;
        e4.L = 611;
        e4.M = 833;
        e4.N = 722;
        e4.O = 778;
        e4.P = 667;
        e4.Q = 778;
        e4.R = 722;
        e4.S = 667;
        e4.T = 611;
        e4.U = 722;
        e4.V = 667;
        e4.W = 944;
        e4.X = 667;
        e4.Y = 667;
        e4.Z = 611;
        e4.bracketleft = 333;
        e4.backslash = 278;
        e4.bracketright = 333;
        e4.asciicircum = 584;
        e4.underscore = 556;
        e4.quoteleft = 278;
        e4.a = 556;
        e4.b = 611;
        e4.c = 556;
        e4.d = 611;
        e4.e = 556;
        e4.f = 333;
        e4.g = 611;
        e4.h = 611;
        e4.i = 278;
        e4.j = 278;
        e4.k = 556;
        e4.l = 278;
        e4.m = 889;
        e4.n = 611;
        e4.o = 611;
        e4.p = 611;
        e4.q = 611;
        e4.r = 389;
        e4.s = 556;
        e4.t = 333;
        e4.u = 611;
        e4.v = 556;
        e4.w = 778;
        e4.x = 556;
        e4.y = 556;
        e4.z = 500;
        e4.braceleft = 389;
        e4.bar = 280;
        e4.braceright = 389;
        e4.asciitilde = 584;
        e4.exclamdown = 333;
        e4.cent = 556;
        e4.sterling = 556;
        e4.fraction = 167;
        e4.yen = 556;
        e4.florin = 556;
        e4.section = 556;
        e4.currency = 556;
        e4.quotesingle = 238;
        e4.quotedblleft = 500;
        e4.guillemotleft = 556;
        e4.guilsinglleft = 333;
        e4.guilsinglright = 333;
        e4.fi = 611;
        e4.fl = 611;
        e4.endash = 556;
        e4.dagger = 556;
        e4.daggerdbl = 556;
        e4.periodcentered = 278;
        e4.paragraph = 556;
        e4.bullet = 350;
        e4.quotesinglbase = 278;
        e4.quotedblbase = 500;
        e4.quotedblright = 500;
        e4.guillemotright = 556;
        e4.ellipsis = 1e3;
        e4.perthousand = 1e3;
        e4.questiondown = 611;
        e4.grave = 333;
        e4.acute = 333;
        e4.circumflex = 333;
        e4.tilde = 333;
        e4.macron = 333;
        e4.breve = 333;
        e4.dotaccent = 333;
        e4.dieresis = 333;
        e4.ring = 333;
        e4.cedilla = 333;
        e4.hungarumlaut = 333;
        e4.ogonek = 333;
        e4.caron = 333;
        e4.emdash = 1e3;
        e4.AE = 1e3;
        e4.ordfeminine = 370;
        e4.Lslash = 611;
        e4.Oslash = 778;
        e4.OE = 1e3;
        e4.ordmasculine = 365;
        e4.ae = 889;
        e4.dotlessi = 278;
        e4.lslash = 278;
        e4.oslash = 611;
        e4.oe = 944;
        e4.germandbls = 611;
        e4.Idieresis = 278;
        e4.eacute = 556;
        e4.abreve = 556;
        e4.uhungarumlaut = 611;
        e4.ecaron = 556;
        e4.Ydieresis = 667;
        e4.divide = 584;
        e4.Yacute = 667;
        e4.Acircumflex = 722;
        e4.aacute = 556;
        e4.Ucircumflex = 722;
        e4.yacute = 556;
        e4.scommaaccent = 556;
        e4.ecircumflex = 556;
        e4.Uring = 722;
        e4.Udieresis = 722;
        e4.aogonek = 556;
        e4.Uacute = 722;
        e4.uogonek = 611;
        e4.Edieresis = 667;
        e4.Dcroat = 722;
        e4.commaaccent = 250;
        e4.copyright = 737;
        e4.Emacron = 667;
        e4.ccaron = 556;
        e4.aring = 556;
        e4.Ncommaaccent = 722;
        e4.lacute = 278;
        e4.agrave = 556;
        e4.Tcommaaccent = 611;
        e4.Cacute = 722;
        e4.atilde = 556;
        e4.Edotaccent = 667;
        e4.scaron = 556;
        e4.scedilla = 556;
        e4.iacute = 278;
        e4.lozenge = 494;
        e4.Rcaron = 722;
        e4.Gcommaaccent = 778;
        e4.ucircumflex = 611;
        e4.acircumflex = 556;
        e4.Amacron = 722;
        e4.rcaron = 389;
        e4.ccedilla = 556;
        e4.Zdotaccent = 611;
        e4.Thorn = 667;
        e4.Omacron = 778;
        e4.Racute = 722;
        e4.Sacute = 667;
        e4.dcaron = 743;
        e4.Umacron = 722;
        e4.uring = 611;
        e4.threesuperior = 333;
        e4.Ograve = 778;
        e4.Agrave = 722;
        e4.Abreve = 722;
        e4.multiply = 584;
        e4.uacute = 611;
        e4.Tcaron = 611;
        e4.partialdiff = 494;
        e4.ydieresis = 556;
        e4.Nacute = 722;
        e4.icircumflex = 278;
        e4.Ecircumflex = 667;
        e4.adieresis = 556;
        e4.edieresis = 556;
        e4.cacute = 556;
        e4.nacute = 611;
        e4.umacron = 611;
        e4.Ncaron = 722;
        e4.Iacute = 278;
        e4.plusminus = 584;
        e4.brokenbar = 280;
        e4.registered = 737;
        e4.Gbreve = 778;
        e4.Idotaccent = 278;
        e4.summation = 600;
        e4.Egrave = 667;
        e4.racute = 389;
        e4.omacron = 611;
        e4.Zacute = 611;
        e4.Zcaron = 611;
        e4.greaterequal = 549;
        e4.Eth = 722;
        e4.Ccedilla = 722;
        e4.lcommaaccent = 278;
        e4.tcaron = 389;
        e4.eogonek = 556;
        e4.Uogonek = 722;
        e4.Aacute = 722;
        e4.Adieresis = 722;
        e4.egrave = 556;
        e4.zacute = 500;
        e4.iogonek = 278;
        e4.Oacute = 778;
        e4.oacute = 611;
        e4.amacron = 556;
        e4.sacute = 556;
        e4.idieresis = 278;
        e4.Ocircumflex = 778;
        e4.Ugrave = 722;
        e4.Delta = 612;
        e4.thorn = 611;
        e4.twosuperior = 333;
        e4.Odieresis = 778;
        e4.mu = 611;
        e4.igrave = 278;
        e4.ohungarumlaut = 611;
        e4.Eogonek = 667;
        e4.dcroat = 611;
        e4.threequarters = 834;
        e4.Scedilla = 667;
        e4.lcaron = 400;
        e4.Kcommaaccent = 722;
        e4.Lacute = 611;
        e4.trademark = 1e3;
        e4.edotaccent = 556;
        e4.Igrave = 278;
        e4.Imacron = 278;
        e4.Lcaron = 611;
        e4.onehalf = 834;
        e4.lessequal = 549;
        e4.ocircumflex = 611;
        e4.ntilde = 611;
        e4.Uhungarumlaut = 722;
        e4.Eacute = 667;
        e4.emacron = 556;
        e4.gbreve = 611;
        e4.onequarter = 834;
        e4.Scaron = 667;
        e4.Scommaaccent = 667;
        e4.Ohungarumlaut = 778;
        e4.degree = 400;
        e4.ograve = 611;
        e4.Ccaron = 722;
        e4.ugrave = 611;
        e4.radical = 549;
        e4.Dcaron = 722;
        e4.rcommaaccent = 389;
        e4.Ntilde = 722;
        e4.otilde = 611;
        e4.Rcommaaccent = 722;
        e4.Lcommaaccent = 611;
        e4.Atilde = 722;
        e4.Aogonek = 722;
        e4.Aring = 722;
        e4.Otilde = 778;
        e4.zdotaccent = 500;
        e4.Ecaron = 667;
        e4.Iogonek = 278;
        e4.kcommaaccent = 556;
        e4.minus = 584;
        e4.Icircumflex = 278;
        e4.ncaron = 611;
        e4.tcommaaccent = 333;
        e4.logicalnot = 584;
        e4.odieresis = 611;
        e4.udieresis = 611;
        e4.notequal = 549;
        e4.gcommaaccent = 611;
        e4.eth = 611;
        e4.zcaron = 500;
        e4.ncommaaccent = 611;
        e4.onesuperior = 333;
        e4.imacron = 278;
        e4.Euro = 556;
      });
      e3["Helvetica-Oblique"] = getLookupTableFactory(function(e4) {
        e4.space = 278;
        e4.exclam = 278;
        e4.quotedbl = 355;
        e4.numbersign = 556;
        e4.dollar = 556;
        e4.percent = 889;
        e4.ampersand = 667;
        e4.quoteright = 222;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asterisk = 389;
        e4.plus = 584;
        e4.comma = 278;
        e4.hyphen = 333;
        e4.period = 278;
        e4.slash = 278;
        e4.zero = 556;
        e4.one = 556;
        e4.two = 556;
        e4.three = 556;
        e4.four = 556;
        e4.five = 556;
        e4.six = 556;
        e4.seven = 556;
        e4.eight = 556;
        e4.nine = 556;
        e4.colon = 278;
        e4.semicolon = 278;
        e4.less = 584;
        e4.equal = 584;
        e4.greater = 584;
        e4.question = 556;
        e4.at = 1015;
        e4.A = 667;
        e4.B = 667;
        e4.C = 722;
        e4.D = 722;
        e4.E = 667;
        e4.F = 611;
        e4.G = 778;
        e4.H = 722;
        e4.I = 278;
        e4.J = 500;
        e4.K = 667;
        e4.L = 556;
        e4.M = 833;
        e4.N = 722;
        e4.O = 778;
        e4.P = 667;
        e4.Q = 778;
        e4.R = 722;
        e4.S = 667;
        e4.T = 611;
        e4.U = 722;
        e4.V = 667;
        e4.W = 944;
        e4.X = 667;
        e4.Y = 667;
        e4.Z = 611;
        e4.bracketleft = 278;
        e4.backslash = 278;
        e4.bracketright = 278;
        e4.asciicircum = 469;
        e4.underscore = 556;
        e4.quoteleft = 222;
        e4.a = 556;
        e4.b = 556;
        e4.c = 500;
        e4.d = 556;
        e4.e = 556;
        e4.f = 278;
        e4.g = 556;
        e4.h = 556;
        e4.i = 222;
        e4.j = 222;
        e4.k = 500;
        e4.l = 222;
        e4.m = 833;
        e4.n = 556;
        e4.o = 556;
        e4.p = 556;
        e4.q = 556;
        e4.r = 333;
        e4.s = 500;
        e4.t = 278;
        e4.u = 556;
        e4.v = 500;
        e4.w = 722;
        e4.x = 500;
        e4.y = 500;
        e4.z = 500;
        e4.braceleft = 334;
        e4.bar = 260;
        e4.braceright = 334;
        e4.asciitilde = 584;
        e4.exclamdown = 333;
        e4.cent = 556;
        e4.sterling = 556;
        e4.fraction = 167;
        e4.yen = 556;
        e4.florin = 556;
        e4.section = 556;
        e4.currency = 556;
        e4.quotesingle = 191;
        e4.quotedblleft = 333;
        e4.guillemotleft = 556;
        e4.guilsinglleft = 333;
        e4.guilsinglright = 333;
        e4.fi = 500;
        e4.fl = 500;
        e4.endash = 556;
        e4.dagger = 556;
        e4.daggerdbl = 556;
        e4.periodcentered = 278;
        e4.paragraph = 537;
        e4.bullet = 350;
        e4.quotesinglbase = 222;
        e4.quotedblbase = 333;
        e4.quotedblright = 333;
        e4.guillemotright = 556;
        e4.ellipsis = 1e3;
        e4.perthousand = 1e3;
        e4.questiondown = 611;
        e4.grave = 333;
        e4.acute = 333;
        e4.circumflex = 333;
        e4.tilde = 333;
        e4.macron = 333;
        e4.breve = 333;
        e4.dotaccent = 333;
        e4.dieresis = 333;
        e4.ring = 333;
        e4.cedilla = 333;
        e4.hungarumlaut = 333;
        e4.ogonek = 333;
        e4.caron = 333;
        e4.emdash = 1e3;
        e4.AE = 1e3;
        e4.ordfeminine = 370;
        e4.Lslash = 556;
        e4.Oslash = 778;
        e4.OE = 1e3;
        e4.ordmasculine = 365;
        e4.ae = 889;
        e4.dotlessi = 278;
        e4.lslash = 222;
        e4.oslash = 611;
        e4.oe = 944;
        e4.germandbls = 611;
        e4.Idieresis = 278;
        e4.eacute = 556;
        e4.abreve = 556;
        e4.uhungarumlaut = 556;
        e4.ecaron = 556;
        e4.Ydieresis = 667;
        e4.divide = 584;
        e4.Yacute = 667;
        e4.Acircumflex = 667;
        e4.aacute = 556;
        e4.Ucircumflex = 722;
        e4.yacute = 500;
        e4.scommaaccent = 500;
        e4.ecircumflex = 556;
        e4.Uring = 722;
        e4.Udieresis = 722;
        e4.aogonek = 556;
        e4.Uacute = 722;
        e4.uogonek = 556;
        e4.Edieresis = 667;
        e4.Dcroat = 722;
        e4.commaaccent = 250;
        e4.copyright = 737;
        e4.Emacron = 667;
        e4.ccaron = 500;
        e4.aring = 556;
        e4.Ncommaaccent = 722;
        e4.lacute = 222;
        e4.agrave = 556;
        e4.Tcommaaccent = 611;
        e4.Cacute = 722;
        e4.atilde = 556;
        e4.Edotaccent = 667;
        e4.scaron = 500;
        e4.scedilla = 500;
        e4.iacute = 278;
        e4.lozenge = 471;
        e4.Rcaron = 722;
        e4.Gcommaaccent = 778;
        e4.ucircumflex = 556;
        e4.acircumflex = 556;
        e4.Amacron = 667;
        e4.rcaron = 333;
        e4.ccedilla = 500;
        e4.Zdotaccent = 611;
        e4.Thorn = 667;
        e4.Omacron = 778;
        e4.Racute = 722;
        e4.Sacute = 667;
        e4.dcaron = 643;
        e4.Umacron = 722;
        e4.uring = 556;
        e4.threesuperior = 333;
        e4.Ograve = 778;
        e4.Agrave = 667;
        e4.Abreve = 667;
        e4.multiply = 584;
        e4.uacute = 556;
        e4.Tcaron = 611;
        e4.partialdiff = 476;
        e4.ydieresis = 500;
        e4.Nacute = 722;
        e4.icircumflex = 278;
        e4.Ecircumflex = 667;
        e4.adieresis = 556;
        e4.edieresis = 556;
        e4.cacute = 500;
        e4.nacute = 556;
        e4.umacron = 556;
        e4.Ncaron = 722;
        e4.Iacute = 278;
        e4.plusminus = 584;
        e4.brokenbar = 260;
        e4.registered = 737;
        e4.Gbreve = 778;
        e4.Idotaccent = 278;
        e4.summation = 600;
        e4.Egrave = 667;
        e4.racute = 333;
        e4.omacron = 556;
        e4.Zacute = 611;
        e4.Zcaron = 611;
        e4.greaterequal = 549;
        e4.Eth = 722;
        e4.Ccedilla = 722;
        e4.lcommaaccent = 222;
        e4.tcaron = 317;
        e4.eogonek = 556;
        e4.Uogonek = 722;
        e4.Aacute = 667;
        e4.Adieresis = 667;
        e4.egrave = 556;
        e4.zacute = 500;
        e4.iogonek = 222;
        e4.Oacute = 778;
        e4.oacute = 556;
        e4.amacron = 556;
        e4.sacute = 500;
        e4.idieresis = 278;
        e4.Ocircumflex = 778;
        e4.Ugrave = 722;
        e4.Delta = 612;
        e4.thorn = 556;
        e4.twosuperior = 333;
        e4.Odieresis = 778;
        e4.mu = 556;
        e4.igrave = 278;
        e4.ohungarumlaut = 556;
        e4.Eogonek = 667;
        e4.dcroat = 556;
        e4.threequarters = 834;
        e4.Scedilla = 667;
        e4.lcaron = 299;
        e4.Kcommaaccent = 667;
        e4.Lacute = 556;
        e4.trademark = 1e3;
        e4.edotaccent = 556;
        e4.Igrave = 278;
        e4.Imacron = 278;
        e4.Lcaron = 556;
        e4.onehalf = 834;
        e4.lessequal = 549;
        e4.ocircumflex = 556;
        e4.ntilde = 556;
        e4.Uhungarumlaut = 722;
        e4.Eacute = 667;
        e4.emacron = 556;
        e4.gbreve = 556;
        e4.onequarter = 834;
        e4.Scaron = 667;
        e4.Scommaaccent = 667;
        e4.Ohungarumlaut = 778;
        e4.degree = 400;
        e4.ograve = 556;
        e4.Ccaron = 722;
        e4.ugrave = 556;
        e4.radical = 453;
        e4.Dcaron = 722;
        e4.rcommaaccent = 333;
        e4.Ntilde = 722;
        e4.otilde = 556;
        e4.Rcommaaccent = 722;
        e4.Lcommaaccent = 556;
        e4.Atilde = 667;
        e4.Aogonek = 667;
        e4.Aring = 667;
        e4.Otilde = 778;
        e4.zdotaccent = 500;
        e4.Ecaron = 667;
        e4.Iogonek = 278;
        e4.kcommaaccent = 500;
        e4.minus = 584;
        e4.Icircumflex = 278;
        e4.ncaron = 556;
        e4.tcommaaccent = 278;
        e4.logicalnot = 584;
        e4.odieresis = 556;
        e4.udieresis = 556;
        e4.notequal = 549;
        e4.gcommaaccent = 556;
        e4.eth = 556;
        e4.zcaron = 500;
        e4.ncommaaccent = 556;
        e4.onesuperior = 333;
        e4.imacron = 278;
        e4.Euro = 556;
      });
      e3.Symbol = getLookupTableFactory(function(e4) {
        e4.space = 250;
        e4.exclam = 333;
        e4.universal = 713;
        e4.numbersign = 500;
        e4.existential = 549;
        e4.percent = 833;
        e4.ampersand = 778;
        e4.suchthat = 439;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asteriskmath = 500;
        e4.plus = 549;
        e4.comma = 250;
        e4.minus = 549;
        e4.period = 250;
        e4.slash = 278;
        e4.zero = 500;
        e4.one = 500;
        e4.two = 500;
        e4.three = 500;
        e4.four = 500;
        e4.five = 500;
        e4.six = 500;
        e4.seven = 500;
        e4.eight = 500;
        e4.nine = 500;
        e4.colon = 278;
        e4.semicolon = 278;
        e4.less = 549;
        e4.equal = 549;
        e4.greater = 549;
        e4.question = 444;
        e4.congruent = 549;
        e4.Alpha = 722;
        e4.Beta = 667;
        e4.Chi = 722;
        e4.Delta = 612;
        e4.Epsilon = 611;
        e4.Phi = 763;
        e4.Gamma = 603;
        e4.Eta = 722;
        e4.Iota = 333;
        e4.theta1 = 631;
        e4.Kappa = 722;
        e4.Lambda = 686;
        e4.Mu = 889;
        e4.Nu = 722;
        e4.Omicron = 722;
        e4.Pi = 768;
        e4.Theta = 741;
        e4.Rho = 556;
        e4.Sigma = 592;
        e4.Tau = 611;
        e4.Upsilon = 690;
        e4.sigma1 = 439;
        e4.Omega = 768;
        e4.Xi = 645;
        e4.Psi = 795;
        e4.Zeta = 611;
        e4.bracketleft = 333;
        e4.therefore = 863;
        e4.bracketright = 333;
        e4.perpendicular = 658;
        e4.underscore = 500;
        e4.radicalex = 500;
        e4.alpha = 631;
        e4.beta = 549;
        e4.chi = 549;
        e4.delta = 494;
        e4.epsilon = 439;
        e4.phi = 521;
        e4.gamma = 411;
        e4.eta = 603;
        e4.iota = 329;
        e4.phi1 = 603;
        e4.kappa = 549;
        e4.lambda = 549;
        e4.mu = 576;
        e4.nu = 521;
        e4.omicron = 549;
        e4.pi = 549;
        e4.theta = 521;
        e4.rho = 549;
        e4.sigma = 603;
        e4.tau = 439;
        e4.upsilon = 576;
        e4.omega1 = 713;
        e4.omega = 686;
        e4.xi = 493;
        e4.psi = 686;
        e4.zeta = 494;
        e4.braceleft = 480;
        e4.bar = 200;
        e4.braceright = 480;
        e4.similar = 549;
        e4.Euro = 750;
        e4.Upsilon1 = 620;
        e4.minute = 247;
        e4.lessequal = 549;
        e4.fraction = 167;
        e4.infinity = 713;
        e4.florin = 500;
        e4.club = 753;
        e4.diamond = 753;
        e4.heart = 753;
        e4.spade = 753;
        e4.arrowboth = 1042;
        e4.arrowleft = 987;
        e4.arrowup = 603;
        e4.arrowright = 987;
        e4.arrowdown = 603;
        e4.degree = 400;
        e4.plusminus = 549;
        e4.second = 411;
        e4.greaterequal = 549;
        e4.multiply = 549;
        e4.proportional = 713;
        e4.partialdiff = 494;
        e4.bullet = 460;
        e4.divide = 549;
        e4.notequal = 549;
        e4.equivalence = 549;
        e4.approxequal = 549;
        e4.ellipsis = 1e3;
        e4.arrowvertex = 603;
        e4.arrowhorizex = 1e3;
        e4.carriagereturn = 658;
        e4.aleph = 823;
        e4.Ifraktur = 686;
        e4.Rfraktur = 795;
        e4.weierstrass = 987;
        e4.circlemultiply = 768;
        e4.circleplus = 768;
        e4.emptyset = 823;
        e4.intersection = 768;
        e4.union = 768;
        e4.propersuperset = 713;
        e4.reflexsuperset = 713;
        e4.notsubset = 713;
        e4.propersubset = 713;
        e4.reflexsubset = 713;
        e4.element = 713;
        e4.notelement = 713;
        e4.angle = 768;
        e4.gradient = 713;
        e4.registerserif = 790;
        e4.copyrightserif = 790;
        e4.trademarkserif = 890;
        e4.product = 823;
        e4.radical = 549;
        e4.dotmath = 250;
        e4.logicalnot = 713;
        e4.logicaland = 603;
        e4.logicalor = 603;
        e4.arrowdblboth = 1042;
        e4.arrowdblleft = 987;
        e4.arrowdblup = 603;
        e4.arrowdblright = 987;
        e4.arrowdbldown = 603;
        e4.lozenge = 494;
        e4.angleleft = 329;
        e4.registersans = 790;
        e4.copyrightsans = 790;
        e4.trademarksans = 786;
        e4.summation = 713;
        e4.parenlefttp = 384;
        e4.parenleftex = 384;
        e4.parenleftbt = 384;
        e4.bracketlefttp = 384;
        e4.bracketleftex = 384;
        e4.bracketleftbt = 384;
        e4.bracelefttp = 494;
        e4.braceleftmid = 494;
        e4.braceleftbt = 494;
        e4.braceex = 494;
        e4.angleright = 329;
        e4.integral = 274;
        e4.integraltp = 686;
        e4.integralex = 686;
        e4.integralbt = 686;
        e4.parenrighttp = 384;
        e4.parenrightex = 384;
        e4.parenrightbt = 384;
        e4.bracketrighttp = 384;
        e4.bracketrightex = 384;
        e4.bracketrightbt = 384;
        e4.bracerighttp = 494;
        e4.bracerightmid = 494;
        e4.bracerightbt = 494;
        e4.apple = 790;
      });
      e3["Times-Roman"] = getLookupTableFactory(function(e4) {
        e4.space = 250;
        e4.exclam = 333;
        e4.quotedbl = 408;
        e4.numbersign = 500;
        e4.dollar = 500;
        e4.percent = 833;
        e4.ampersand = 778;
        e4.quoteright = 333;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asterisk = 500;
        e4.plus = 564;
        e4.comma = 250;
        e4.hyphen = 333;
        e4.period = 250;
        e4.slash = 278;
        e4.zero = 500;
        e4.one = 500;
        e4.two = 500;
        e4.three = 500;
        e4.four = 500;
        e4.five = 500;
        e4.six = 500;
        e4.seven = 500;
        e4.eight = 500;
        e4.nine = 500;
        e4.colon = 278;
        e4.semicolon = 278;
        e4.less = 564;
        e4.equal = 564;
        e4.greater = 564;
        e4.question = 444;
        e4.at = 921;
        e4.A = 722;
        e4.B = 667;
        e4.C = 667;
        e4.D = 722;
        e4.E = 611;
        e4.F = 556;
        e4.G = 722;
        e4.H = 722;
        e4.I = 333;
        e4.J = 389;
        e4.K = 722;
        e4.L = 611;
        e4.M = 889;
        e4.N = 722;
        e4.O = 722;
        e4.P = 556;
        e4.Q = 722;
        e4.R = 667;
        e4.S = 556;
        e4.T = 611;
        e4.U = 722;
        e4.V = 722;
        e4.W = 944;
        e4.X = 722;
        e4.Y = 722;
        e4.Z = 611;
        e4.bracketleft = 333;
        e4.backslash = 278;
        e4.bracketright = 333;
        e4.asciicircum = 469;
        e4.underscore = 500;
        e4.quoteleft = 333;
        e4.a = 444;
        e4.b = 500;
        e4.c = 444;
        e4.d = 500;
        e4.e = 444;
        e4.f = 333;
        e4.g = 500;
        e4.h = 500;
        e4.i = 278;
        e4.j = 278;
        e4.k = 500;
        e4.l = 278;
        e4.m = 778;
        e4.n = 500;
        e4.o = 500;
        e4.p = 500;
        e4.q = 500;
        e4.r = 333;
        e4.s = 389;
        e4.t = 278;
        e4.u = 500;
        e4.v = 500;
        e4.w = 722;
        e4.x = 500;
        e4.y = 500;
        e4.z = 444;
        e4.braceleft = 480;
        e4.bar = 200;
        e4.braceright = 480;
        e4.asciitilde = 541;
        e4.exclamdown = 333;
        e4.cent = 500;
        e4.sterling = 500;
        e4.fraction = 167;
        e4.yen = 500;
        e4.florin = 500;
        e4.section = 500;
        e4.currency = 500;
        e4.quotesingle = 180;
        e4.quotedblleft = 444;
        e4.guillemotleft = 500;
        e4.guilsinglleft = 333;
        e4.guilsinglright = 333;
        e4.fi = 556;
        e4.fl = 556;
        e4.endash = 500;
        e4.dagger = 500;
        e4.daggerdbl = 500;
        e4.periodcentered = 250;
        e4.paragraph = 453;
        e4.bullet = 350;
        e4.quotesinglbase = 333;
        e4.quotedblbase = 444;
        e4.quotedblright = 444;
        e4.guillemotright = 500;
        e4.ellipsis = 1e3;
        e4.perthousand = 1e3;
        e4.questiondown = 444;
        e4.grave = 333;
        e4.acute = 333;
        e4.circumflex = 333;
        e4.tilde = 333;
        e4.macron = 333;
        e4.breve = 333;
        e4.dotaccent = 333;
        e4.dieresis = 333;
        e4.ring = 333;
        e4.cedilla = 333;
        e4.hungarumlaut = 333;
        e4.ogonek = 333;
        e4.caron = 333;
        e4.emdash = 1e3;
        e4.AE = 889;
        e4.ordfeminine = 276;
        e4.Lslash = 611;
        e4.Oslash = 722;
        e4.OE = 889;
        e4.ordmasculine = 310;
        e4.ae = 667;
        e4.dotlessi = 278;
        e4.lslash = 278;
        e4.oslash = 500;
        e4.oe = 722;
        e4.germandbls = 500;
        e4.Idieresis = 333;
        e4.eacute = 444;
        e4.abreve = 444;
        e4.uhungarumlaut = 500;
        e4.ecaron = 444;
        e4.Ydieresis = 722;
        e4.divide = 564;
        e4.Yacute = 722;
        e4.Acircumflex = 722;
        e4.aacute = 444;
        e4.Ucircumflex = 722;
        e4.yacute = 500;
        e4.scommaaccent = 389;
        e4.ecircumflex = 444;
        e4.Uring = 722;
        e4.Udieresis = 722;
        e4.aogonek = 444;
        e4.Uacute = 722;
        e4.uogonek = 500;
        e4.Edieresis = 611;
        e4.Dcroat = 722;
        e4.commaaccent = 250;
        e4.copyright = 760;
        e4.Emacron = 611;
        e4.ccaron = 444;
        e4.aring = 444;
        e4.Ncommaaccent = 722;
        e4.lacute = 278;
        e4.agrave = 444;
        e4.Tcommaaccent = 611;
        e4.Cacute = 667;
        e4.atilde = 444;
        e4.Edotaccent = 611;
        e4.scaron = 389;
        e4.scedilla = 389;
        e4.iacute = 278;
        e4.lozenge = 471;
        e4.Rcaron = 667;
        e4.Gcommaaccent = 722;
        e4.ucircumflex = 500;
        e4.acircumflex = 444;
        e4.Amacron = 722;
        e4.rcaron = 333;
        e4.ccedilla = 444;
        e4.Zdotaccent = 611;
        e4.Thorn = 556;
        e4.Omacron = 722;
        e4.Racute = 667;
        e4.Sacute = 556;
        e4.dcaron = 588;
        e4.Umacron = 722;
        e4.uring = 500;
        e4.threesuperior = 300;
        e4.Ograve = 722;
        e4.Agrave = 722;
        e4.Abreve = 722;
        e4.multiply = 564;
        e4.uacute = 500;
        e4.Tcaron = 611;
        e4.partialdiff = 476;
        e4.ydieresis = 500;
        e4.Nacute = 722;
        e4.icircumflex = 278;
        e4.Ecircumflex = 611;
        e4.adieresis = 444;
        e4.edieresis = 444;
        e4.cacute = 444;
        e4.nacute = 500;
        e4.umacron = 500;
        e4.Ncaron = 722;
        e4.Iacute = 333;
        e4.plusminus = 564;
        e4.brokenbar = 200;
        e4.registered = 760;
        e4.Gbreve = 722;
        e4.Idotaccent = 333;
        e4.summation = 600;
        e4.Egrave = 611;
        e4.racute = 333;
        e4.omacron = 500;
        e4.Zacute = 611;
        e4.Zcaron = 611;
        e4.greaterequal = 549;
        e4.Eth = 722;
        e4.Ccedilla = 667;
        e4.lcommaaccent = 278;
        e4.tcaron = 326;
        e4.eogonek = 444;
        e4.Uogonek = 722;
        e4.Aacute = 722;
        e4.Adieresis = 722;
        e4.egrave = 444;
        e4.zacute = 444;
        e4.iogonek = 278;
        e4.Oacute = 722;
        e4.oacute = 500;
        e4.amacron = 444;
        e4.sacute = 389;
        e4.idieresis = 278;
        e4.Ocircumflex = 722;
        e4.Ugrave = 722;
        e4.Delta = 612;
        e4.thorn = 500;
        e4.twosuperior = 300;
        e4.Odieresis = 722;
        e4.mu = 500;
        e4.igrave = 278;
        e4.ohungarumlaut = 500;
        e4.Eogonek = 611;
        e4.dcroat = 500;
        e4.threequarters = 750;
        e4.Scedilla = 556;
        e4.lcaron = 344;
        e4.Kcommaaccent = 722;
        e4.Lacute = 611;
        e4.trademark = 980;
        e4.edotaccent = 444;
        e4.Igrave = 333;
        e4.Imacron = 333;
        e4.Lcaron = 611;
        e4.onehalf = 750;
        e4.lessequal = 549;
        e4.ocircumflex = 500;
        e4.ntilde = 500;
        e4.Uhungarumlaut = 722;
        e4.Eacute = 611;
        e4.emacron = 444;
        e4.gbreve = 500;
        e4.onequarter = 750;
        e4.Scaron = 556;
        e4.Scommaaccent = 556;
        e4.Ohungarumlaut = 722;
        e4.degree = 400;
        e4.ograve = 500;
        e4.Ccaron = 667;
        e4.ugrave = 500;
        e4.radical = 453;
        e4.Dcaron = 722;
        e4.rcommaaccent = 333;
        e4.Ntilde = 722;
        e4.otilde = 500;
        e4.Rcommaaccent = 667;
        e4.Lcommaaccent = 611;
        e4.Atilde = 722;
        e4.Aogonek = 722;
        e4.Aring = 722;
        e4.Otilde = 722;
        e4.zdotaccent = 444;
        e4.Ecaron = 611;
        e4.Iogonek = 333;
        e4.kcommaaccent = 500;
        e4.minus = 564;
        e4.Icircumflex = 333;
        e4.ncaron = 500;
        e4.tcommaaccent = 278;
        e4.logicalnot = 564;
        e4.odieresis = 500;
        e4.udieresis = 500;
        e4.notequal = 549;
        e4.gcommaaccent = 500;
        e4.eth = 500;
        e4.zcaron = 444;
        e4.ncommaaccent = 500;
        e4.onesuperior = 300;
        e4.imacron = 278;
        e4.Euro = 500;
      });
      e3["Times-Bold"] = getLookupTableFactory(function(e4) {
        e4.space = 250;
        e4.exclam = 333;
        e4.quotedbl = 555;
        e4.numbersign = 500;
        e4.dollar = 500;
        e4.percent = 1e3;
        e4.ampersand = 833;
        e4.quoteright = 333;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asterisk = 500;
        e4.plus = 570;
        e4.comma = 250;
        e4.hyphen = 333;
        e4.period = 250;
        e4.slash = 278;
        e4.zero = 500;
        e4.one = 500;
        e4.two = 500;
        e4.three = 500;
        e4.four = 500;
        e4.five = 500;
        e4.six = 500;
        e4.seven = 500;
        e4.eight = 500;
        e4.nine = 500;
        e4.colon = 333;
        e4.semicolon = 333;
        e4.less = 570;
        e4.equal = 570;
        e4.greater = 570;
        e4.question = 500;
        e4.at = 930;
        e4.A = 722;
        e4.B = 667;
        e4.C = 722;
        e4.D = 722;
        e4.E = 667;
        e4.F = 611;
        e4.G = 778;
        e4.H = 778;
        e4.I = 389;
        e4.J = 500;
        e4.K = 778;
        e4.L = 667;
        e4.M = 944;
        e4.N = 722;
        e4.O = 778;
        e4.P = 611;
        e4.Q = 778;
        e4.R = 722;
        e4.S = 556;
        e4.T = 667;
        e4.U = 722;
        e4.V = 722;
        e4.W = 1e3;
        e4.X = 722;
        e4.Y = 722;
        e4.Z = 667;
        e4.bracketleft = 333;
        e4.backslash = 278;
        e4.bracketright = 333;
        e4.asciicircum = 581;
        e4.underscore = 500;
        e4.quoteleft = 333;
        e4.a = 500;
        e4.b = 556;
        e4.c = 444;
        e4.d = 556;
        e4.e = 444;
        e4.f = 333;
        e4.g = 500;
        e4.h = 556;
        e4.i = 278;
        e4.j = 333;
        e4.k = 556;
        e4.l = 278;
        e4.m = 833;
        e4.n = 556;
        e4.o = 500;
        e4.p = 556;
        e4.q = 556;
        e4.r = 444;
        e4.s = 389;
        e4.t = 333;
        e4.u = 556;
        e4.v = 500;
        e4.w = 722;
        e4.x = 500;
        e4.y = 500;
        e4.z = 444;
        e4.braceleft = 394;
        e4.bar = 220;
        e4.braceright = 394;
        e4.asciitilde = 520;
        e4.exclamdown = 333;
        e4.cent = 500;
        e4.sterling = 500;
        e4.fraction = 167;
        e4.yen = 500;
        e4.florin = 500;
        e4.section = 500;
        e4.currency = 500;
        e4.quotesingle = 278;
        e4.quotedblleft = 500;
        e4.guillemotleft = 500;
        e4.guilsinglleft = 333;
        e4.guilsinglright = 333;
        e4.fi = 556;
        e4.fl = 556;
        e4.endash = 500;
        e4.dagger = 500;
        e4.daggerdbl = 500;
        e4.periodcentered = 250;
        e4.paragraph = 540;
        e4.bullet = 350;
        e4.quotesinglbase = 333;
        e4.quotedblbase = 500;
        e4.quotedblright = 500;
        e4.guillemotright = 500;
        e4.ellipsis = 1e3;
        e4.perthousand = 1e3;
        e4.questiondown = 500;
        e4.grave = 333;
        e4.acute = 333;
        e4.circumflex = 333;
        e4.tilde = 333;
        e4.macron = 333;
        e4.breve = 333;
        e4.dotaccent = 333;
        e4.dieresis = 333;
        e4.ring = 333;
        e4.cedilla = 333;
        e4.hungarumlaut = 333;
        e4.ogonek = 333;
        e4.caron = 333;
        e4.emdash = 1e3;
        e4.AE = 1e3;
        e4.ordfeminine = 300;
        e4.Lslash = 667;
        e4.Oslash = 778;
        e4.OE = 1e3;
        e4.ordmasculine = 330;
        e4.ae = 722;
        e4.dotlessi = 278;
        e4.lslash = 278;
        e4.oslash = 500;
        e4.oe = 722;
        e4.germandbls = 556;
        e4.Idieresis = 389;
        e4.eacute = 444;
        e4.abreve = 500;
        e4.uhungarumlaut = 556;
        e4.ecaron = 444;
        e4.Ydieresis = 722;
        e4.divide = 570;
        e4.Yacute = 722;
        e4.Acircumflex = 722;
        e4.aacute = 500;
        e4.Ucircumflex = 722;
        e4.yacute = 500;
        e4.scommaaccent = 389;
        e4.ecircumflex = 444;
        e4.Uring = 722;
        e4.Udieresis = 722;
        e4.aogonek = 500;
        e4.Uacute = 722;
        e4.uogonek = 556;
        e4.Edieresis = 667;
        e4.Dcroat = 722;
        e4.commaaccent = 250;
        e4.copyright = 747;
        e4.Emacron = 667;
        e4.ccaron = 444;
        e4.aring = 500;
        e4.Ncommaaccent = 722;
        e4.lacute = 278;
        e4.agrave = 500;
        e4.Tcommaaccent = 667;
        e4.Cacute = 722;
        e4.atilde = 500;
        e4.Edotaccent = 667;
        e4.scaron = 389;
        e4.scedilla = 389;
        e4.iacute = 278;
        e4.lozenge = 494;
        e4.Rcaron = 722;
        e4.Gcommaaccent = 778;
        e4.ucircumflex = 556;
        e4.acircumflex = 500;
        e4.Amacron = 722;
        e4.rcaron = 444;
        e4.ccedilla = 444;
        e4.Zdotaccent = 667;
        e4.Thorn = 611;
        e4.Omacron = 778;
        e4.Racute = 722;
        e4.Sacute = 556;
        e4.dcaron = 672;
        e4.Umacron = 722;
        e4.uring = 556;
        e4.threesuperior = 300;
        e4.Ograve = 778;
        e4.Agrave = 722;
        e4.Abreve = 722;
        e4.multiply = 570;
        e4.uacute = 556;
        e4.Tcaron = 667;
        e4.partialdiff = 494;
        e4.ydieresis = 500;
        e4.Nacute = 722;
        e4.icircumflex = 278;
        e4.Ecircumflex = 667;
        e4.adieresis = 500;
        e4.edieresis = 444;
        e4.cacute = 444;
        e4.nacute = 556;
        e4.umacron = 556;
        e4.Ncaron = 722;
        e4.Iacute = 389;
        e4.plusminus = 570;
        e4.brokenbar = 220;
        e4.registered = 747;
        e4.Gbreve = 778;
        e4.Idotaccent = 389;
        e4.summation = 600;
        e4.Egrave = 667;
        e4.racute = 444;
        e4.omacron = 500;
        e4.Zacute = 667;
        e4.Zcaron = 667;
        e4.greaterequal = 549;
        e4.Eth = 722;
        e4.Ccedilla = 722;
        e4.lcommaaccent = 278;
        e4.tcaron = 416;
        e4.eogonek = 444;
        e4.Uogonek = 722;
        e4.Aacute = 722;
        e4.Adieresis = 722;
        e4.egrave = 444;
        e4.zacute = 444;
        e4.iogonek = 278;
        e4.Oacute = 778;
        e4.oacute = 500;
        e4.amacron = 500;
        e4.sacute = 389;
        e4.idieresis = 278;
        e4.Ocircumflex = 778;
        e4.Ugrave = 722;
        e4.Delta = 612;
        e4.thorn = 556;
        e4.twosuperior = 300;
        e4.Odieresis = 778;
        e4.mu = 556;
        e4.igrave = 278;
        e4.ohungarumlaut = 500;
        e4.Eogonek = 667;
        e4.dcroat = 556;
        e4.threequarters = 750;
        e4.Scedilla = 556;
        e4.lcaron = 394;
        e4.Kcommaaccent = 778;
        e4.Lacute = 667;
        e4.trademark = 1e3;
        e4.edotaccent = 444;
        e4.Igrave = 389;
        e4.Imacron = 389;
        e4.Lcaron = 667;
        e4.onehalf = 750;
        e4.lessequal = 549;
        e4.ocircumflex = 500;
        e4.ntilde = 556;
        e4.Uhungarumlaut = 722;
        e4.Eacute = 667;
        e4.emacron = 444;
        e4.gbreve = 500;
        e4.onequarter = 750;
        e4.Scaron = 556;
        e4.Scommaaccent = 556;
        e4.Ohungarumlaut = 778;
        e4.degree = 400;
        e4.ograve = 500;
        e4.Ccaron = 722;
        e4.ugrave = 556;
        e4.radical = 549;
        e4.Dcaron = 722;
        e4.rcommaaccent = 444;
        e4.Ntilde = 722;
        e4.otilde = 500;
        e4.Rcommaaccent = 722;
        e4.Lcommaaccent = 667;
        e4.Atilde = 722;
        e4.Aogonek = 722;
        e4.Aring = 722;
        e4.Otilde = 778;
        e4.zdotaccent = 444;
        e4.Ecaron = 667;
        e4.Iogonek = 389;
        e4.kcommaaccent = 556;
        e4.minus = 570;
        e4.Icircumflex = 389;
        e4.ncaron = 556;
        e4.tcommaaccent = 333;
        e4.logicalnot = 570;
        e4.odieresis = 500;
        e4.udieresis = 556;
        e4.notequal = 549;
        e4.gcommaaccent = 500;
        e4.eth = 500;
        e4.zcaron = 444;
        e4.ncommaaccent = 556;
        e4.onesuperior = 300;
        e4.imacron = 278;
        e4.Euro = 500;
      });
      e3["Times-BoldItalic"] = getLookupTableFactory(function(e4) {
        e4.space = 250;
        e4.exclam = 389;
        e4.quotedbl = 555;
        e4.numbersign = 500;
        e4.dollar = 500;
        e4.percent = 833;
        e4.ampersand = 778;
        e4.quoteright = 333;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asterisk = 500;
        e4.plus = 570;
        e4.comma = 250;
        e4.hyphen = 333;
        e4.period = 250;
        e4.slash = 278;
        e4.zero = 500;
        e4.one = 500;
        e4.two = 500;
        e4.three = 500;
        e4.four = 500;
        e4.five = 500;
        e4.six = 500;
        e4.seven = 500;
        e4.eight = 500;
        e4.nine = 500;
        e4.colon = 333;
        e4.semicolon = 333;
        e4.less = 570;
        e4.equal = 570;
        e4.greater = 570;
        e4.question = 500;
        e4.at = 832;
        e4.A = 667;
        e4.B = 667;
        e4.C = 667;
        e4.D = 722;
        e4.E = 667;
        e4.F = 667;
        e4.G = 722;
        e4.H = 778;
        e4.I = 389;
        e4.J = 500;
        e4.K = 667;
        e4.L = 611;
        e4.M = 889;
        e4.N = 722;
        e4.O = 722;
        e4.P = 611;
        e4.Q = 722;
        e4.R = 667;
        e4.S = 556;
        e4.T = 611;
        e4.U = 722;
        e4.V = 667;
        e4.W = 889;
        e4.X = 667;
        e4.Y = 611;
        e4.Z = 611;
        e4.bracketleft = 333;
        e4.backslash = 278;
        e4.bracketright = 333;
        e4.asciicircum = 570;
        e4.underscore = 500;
        e4.quoteleft = 333;
        e4.a = 500;
        e4.b = 500;
        e4.c = 444;
        e4.d = 500;
        e4.e = 444;
        e4.f = 333;
        e4.g = 500;
        e4.h = 556;
        e4.i = 278;
        e4.j = 278;
        e4.k = 500;
        e4.l = 278;
        e4.m = 778;
        e4.n = 556;
        e4.o = 500;
        e4.p = 500;
        e4.q = 500;
        e4.r = 389;
        e4.s = 389;
        e4.t = 278;
        e4.u = 556;
        e4.v = 444;
        e4.w = 667;
        e4.x = 500;
        e4.y = 444;
        e4.z = 389;
        e4.braceleft = 348;
        e4.bar = 220;
        e4.braceright = 348;
        e4.asciitilde = 570;
        e4.exclamdown = 389;
        e4.cent = 500;
        e4.sterling = 500;
        e4.fraction = 167;
        e4.yen = 500;
        e4.florin = 500;
        e4.section = 500;
        e4.currency = 500;
        e4.quotesingle = 278;
        e4.quotedblleft = 500;
        e4.guillemotleft = 500;
        e4.guilsinglleft = 333;
        e4.guilsinglright = 333;
        e4.fi = 556;
        e4.fl = 556;
        e4.endash = 500;
        e4.dagger = 500;
        e4.daggerdbl = 500;
        e4.periodcentered = 250;
        e4.paragraph = 500;
        e4.bullet = 350;
        e4.quotesinglbase = 333;
        e4.quotedblbase = 500;
        e4.quotedblright = 500;
        e4.guillemotright = 500;
        e4.ellipsis = 1e3;
        e4.perthousand = 1e3;
        e4.questiondown = 500;
        e4.grave = 333;
        e4.acute = 333;
        e4.circumflex = 333;
        e4.tilde = 333;
        e4.macron = 333;
        e4.breve = 333;
        e4.dotaccent = 333;
        e4.dieresis = 333;
        e4.ring = 333;
        e4.cedilla = 333;
        e4.hungarumlaut = 333;
        e4.ogonek = 333;
        e4.caron = 333;
        e4.emdash = 1e3;
        e4.AE = 944;
        e4.ordfeminine = 266;
        e4.Lslash = 611;
        e4.Oslash = 722;
        e4.OE = 944;
        e4.ordmasculine = 300;
        e4.ae = 722;
        e4.dotlessi = 278;
        e4.lslash = 278;
        e4.oslash = 500;
        e4.oe = 722;
        e4.germandbls = 500;
        e4.Idieresis = 389;
        e4.eacute = 444;
        e4.abreve = 500;
        e4.uhungarumlaut = 556;
        e4.ecaron = 444;
        e4.Ydieresis = 611;
        e4.divide = 570;
        e4.Yacute = 611;
        e4.Acircumflex = 667;
        e4.aacute = 500;
        e4.Ucircumflex = 722;
        e4.yacute = 444;
        e4.scommaaccent = 389;
        e4.ecircumflex = 444;
        e4.Uring = 722;
        e4.Udieresis = 722;
        e4.aogonek = 500;
        e4.Uacute = 722;
        e4.uogonek = 556;
        e4.Edieresis = 667;
        e4.Dcroat = 722;
        e4.commaaccent = 250;
        e4.copyright = 747;
        e4.Emacron = 667;
        e4.ccaron = 444;
        e4.aring = 500;
        e4.Ncommaaccent = 722;
        e4.lacute = 278;
        e4.agrave = 500;
        e4.Tcommaaccent = 611;
        e4.Cacute = 667;
        e4.atilde = 500;
        e4.Edotaccent = 667;
        e4.scaron = 389;
        e4.scedilla = 389;
        e4.iacute = 278;
        e4.lozenge = 494;
        e4.Rcaron = 667;
        e4.Gcommaaccent = 722;
        e4.ucircumflex = 556;
        e4.acircumflex = 500;
        e4.Amacron = 667;
        e4.rcaron = 389;
        e4.ccedilla = 444;
        e4.Zdotaccent = 611;
        e4.Thorn = 611;
        e4.Omacron = 722;
        e4.Racute = 667;
        e4.Sacute = 556;
        e4.dcaron = 608;
        e4.Umacron = 722;
        e4.uring = 556;
        e4.threesuperior = 300;
        e4.Ograve = 722;
        e4.Agrave = 667;
        e4.Abreve = 667;
        e4.multiply = 570;
        e4.uacute = 556;
        e4.Tcaron = 611;
        e4.partialdiff = 494;
        e4.ydieresis = 444;
        e4.Nacute = 722;
        e4.icircumflex = 278;
        e4.Ecircumflex = 667;
        e4.adieresis = 500;
        e4.edieresis = 444;
        e4.cacute = 444;
        e4.nacute = 556;
        e4.umacron = 556;
        e4.Ncaron = 722;
        e4.Iacute = 389;
        e4.plusminus = 570;
        e4.brokenbar = 220;
        e4.registered = 747;
        e4.Gbreve = 722;
        e4.Idotaccent = 389;
        e4.summation = 600;
        e4.Egrave = 667;
        e4.racute = 389;
        e4.omacron = 500;
        e4.Zacute = 611;
        e4.Zcaron = 611;
        e4.greaterequal = 549;
        e4.Eth = 722;
        e4.Ccedilla = 667;
        e4.lcommaaccent = 278;
        e4.tcaron = 366;
        e4.eogonek = 444;
        e4.Uogonek = 722;
        e4.Aacute = 667;
        e4.Adieresis = 667;
        e4.egrave = 444;
        e4.zacute = 389;
        e4.iogonek = 278;
        e4.Oacute = 722;
        e4.oacute = 500;
        e4.amacron = 500;
        e4.sacute = 389;
        e4.idieresis = 278;
        e4.Ocircumflex = 722;
        e4.Ugrave = 722;
        e4.Delta = 612;
        e4.thorn = 500;
        e4.twosuperior = 300;
        e4.Odieresis = 722;
        e4.mu = 576;
        e4.igrave = 278;
        e4.ohungarumlaut = 500;
        e4.Eogonek = 667;
        e4.dcroat = 500;
        e4.threequarters = 750;
        e4.Scedilla = 556;
        e4.lcaron = 382;
        e4.Kcommaaccent = 667;
        e4.Lacute = 611;
        e4.trademark = 1e3;
        e4.edotaccent = 444;
        e4.Igrave = 389;
        e4.Imacron = 389;
        e4.Lcaron = 611;
        e4.onehalf = 750;
        e4.lessequal = 549;
        e4.ocircumflex = 500;
        e4.ntilde = 556;
        e4.Uhungarumlaut = 722;
        e4.Eacute = 667;
        e4.emacron = 444;
        e4.gbreve = 500;
        e4.onequarter = 750;
        e4.Scaron = 556;
        e4.Scommaaccent = 556;
        e4.Ohungarumlaut = 722;
        e4.degree = 400;
        e4.ograve = 500;
        e4.Ccaron = 667;
        e4.ugrave = 556;
        e4.radical = 549;
        e4.Dcaron = 722;
        e4.rcommaaccent = 389;
        e4.Ntilde = 722;
        e4.otilde = 500;
        e4.Rcommaaccent = 667;
        e4.Lcommaaccent = 611;
        e4.Atilde = 667;
        e4.Aogonek = 667;
        e4.Aring = 667;
        e4.Otilde = 722;
        e4.zdotaccent = 389;
        e4.Ecaron = 667;
        e4.Iogonek = 389;
        e4.kcommaaccent = 500;
        e4.minus = 606;
        e4.Icircumflex = 389;
        e4.ncaron = 556;
        e4.tcommaaccent = 278;
        e4.logicalnot = 606;
        e4.odieresis = 500;
        e4.udieresis = 556;
        e4.notequal = 549;
        e4.gcommaaccent = 500;
        e4.eth = 500;
        e4.zcaron = 389;
        e4.ncommaaccent = 556;
        e4.onesuperior = 300;
        e4.imacron = 278;
        e4.Euro = 500;
      });
      e3["Times-Italic"] = getLookupTableFactory(function(e4) {
        e4.space = 250;
        e4.exclam = 333;
        e4.quotedbl = 420;
        e4.numbersign = 500;
        e4.dollar = 500;
        e4.percent = 833;
        e4.ampersand = 778;
        e4.quoteright = 333;
        e4.parenleft = 333;
        e4.parenright = 333;
        e4.asterisk = 500;
        e4.plus = 675;
        e4.comma = 250;
        e4.hyphen = 333;
        e4.period = 250;
        e4.slash = 278;
        e4.zero = 500;
        e4.one = 500;
        e4.two = 500;
        e4.three = 500;
        e4.four = 500;
        e4.five = 500;
        e4.six = 500;
        e4.seven = 500;
        e4.eight = 500;
        e4.nine = 500;
        e4.colon = 333;
        e4.semicolon = 333;
        e4.less = 675;
        e4.equal = 675;
        e4.greater = 675;
        e4.question = 500;
        e4.at = 920;
        e4.A = 611;
        e4.B = 611;
        e4.C = 667;
        e4.D = 722;
        e4.E = 611;
        e4.F = 611;
        e4.G = 722;
        e4.H = 722;
        e4.I = 333;
        e4.J = 444;
        e4.K = 667;
        e4.L = 556;
        e4.M = 833;
        e4.N = 667;
        e4.O = 722;
        e4.P = 611;
        e4.Q = 722;
        e4.R = 611;
        e4.S = 500;
        e4.T = 556;
        e4.U = 722;
        e4.V = 611;
        e4.W = 833;
        e4.X = 611;
        e4.Y = 556;
        e4.Z = 556;
        e4.bracketleft = 389;
        e4.backslash = 278;
        e4.bracketright = 389;
        e4.asciicircum = 422;
        e4.underscore = 500;
        e4.quoteleft = 333;
        e4.a = 500;
        e4.b = 500;
        e4.c = 444;
        e4.d = 500;
        e4.e = 444;
        e4.f = 278;
        e4.g = 500;
        e4.h = 500;
        e4.i = 278;
        e4.j = 278;
        e4.k = 444;
        e4.l = 278;
        e4.m = 722;
        e4.n = 500;
        e4.o = 500;
        e4.p = 500;
        e4.q = 500;
        e4.r = 389;
        e4.s = 389;
        e4.t = 278;
        e4.u = 500;
        e4.v = 444;
        e4.w = 667;
        e4.x = 444;
        e4.y = 444;
        e4.z = 389;
        e4.braceleft = 400;
        e4.bar = 275;
        e4.braceright = 400;
        e4.asciitilde = 541;
        e4.exclamdown = 389;
        e4.cent = 500;
        e4.sterling = 500;
        e4.fraction = 167;
        e4.yen = 500;
        e4.florin = 500;
        e4.section = 500;
        e4.currency = 500;
        e4.quotesingle = 214;
        e4.quotedblleft = 556;
        e4.guillemotleft = 500;
        e4.guilsinglleft = 333;
        e4.guilsinglright = 333;
        e4.fi = 500;
        e4.fl = 500;
        e4.endash = 500;
        e4.dagger = 500;
        e4.daggerdbl = 500;
        e4.periodcentered = 250;
        e4.paragraph = 523;
        e4.bullet = 350;
        e4.quotesinglbase = 333;
        e4.quotedblbase = 556;
        e4.quotedblright = 556;
        e4.guillemotright = 500;
        e4.ellipsis = 889;
        e4.perthousand = 1e3;
        e4.questiondown = 500;
        e4.grave = 333;
        e4.acute = 333;
        e4.circumflex = 333;
        e4.tilde = 333;
        e4.macron = 333;
        e4.breve = 333;
        e4.dotaccent = 333;
        e4.dieresis = 333;
        e4.ring = 333;
        e4.cedilla = 333;
        e4.hungarumlaut = 333;
        e4.ogonek = 333;
        e4.caron = 333;
        e4.emdash = 889;
        e4.AE = 889;
        e4.ordfeminine = 276;
        e4.Lslash = 556;
        e4.Oslash = 722;
        e4.OE = 944;
        e4.ordmasculine = 310;
        e4.ae = 667;
        e4.dotlessi = 278;
        e4.lslash = 278;
        e4.oslash = 500;
        e4.oe = 667;
        e4.germandbls = 500;
        e4.Idieresis = 333;
        e4.eacute = 444;
        e4.abreve = 500;
        e4.uhungarumlaut = 500;
        e4.ecaron = 444;
        e4.Ydieresis = 556;
        e4.divide = 675;
        e4.Yacute = 556;
        e4.Acircumflex = 611;
        e4.aacute = 500;
        e4.Ucircumflex = 722;
        e4.yacute = 444;
        e4.scommaaccent = 389;
        e4.ecircumflex = 444;
        e4.Uring = 722;
        e4.Udieresis = 722;
        e4.aogonek = 500;
        e4.Uacute = 722;
        e4.uogonek = 500;
        e4.Edieresis = 611;
        e4.Dcroat = 722;
        e4.commaaccent = 250;
        e4.copyright = 760;
        e4.Emacron = 611;
        e4.ccaron = 444;
        e4.aring = 500;
        e4.Ncommaaccent = 667;
        e4.lacute = 278;
        e4.agrave = 500;
        e4.Tcommaaccent = 556;
        e4.Cacute = 667;
        e4.atilde = 500;
        e4.Edotaccent = 611;
        e4.scaron = 389;
        e4.scedilla = 389;
        e4.iacute = 278;
        e4.lozenge = 471;
        e4.Rcaron = 611;
        e4.Gcommaaccent = 722;
        e4.ucircumflex = 500;
        e4.acircumflex = 500;
        e4.Amacron = 611;
        e4.rcaron = 389;
        e4.ccedilla = 444;
        e4.Zdotaccent = 556;
        e4.Thorn = 611;
        e4.Omacron = 722;
        e4.Racute = 611;
        e4.Sacute = 500;
        e4.dcaron = 544;
        e4.Umacron = 722;
        e4.uring = 500;
        e4.threesuperior = 300;
        e4.Ograve = 722;
        e4.Agrave = 611;
        e4.Abreve = 611;
        e4.multiply = 675;
        e4.uacute = 500;
        e4.Tcaron = 556;
        e4.partialdiff = 476;
        e4.ydieresis = 444;
        e4.Nacute = 667;
        e4.icircumflex = 278;
        e4.Ecircumflex = 611;
        e4.adieresis = 500;
        e4.edieresis = 444;
        e4.cacute = 444;
        e4.nacute = 500;
        e4.umacron = 500;
        e4.Ncaron = 667;
        e4.Iacute = 333;
        e4.plusminus = 675;
        e4.brokenbar = 275;
        e4.registered = 760;
        e4.Gbreve = 722;
        e4.Idotaccent = 333;
        e4.summation = 600;
        e4.Egrave = 611;
        e4.racute = 389;
        e4.omacron = 500;
        e4.Zacute = 556;
        e4.Zcaron = 556;
        e4.greaterequal = 549;
        e4.Eth = 722;
        e4.Ccedilla = 667;
        e4.lcommaaccent = 278;
        e4.tcaron = 300;
        e4.eogonek = 444;
        e4.Uogonek = 722;
        e4.Aacute = 611;
        e4.Adieresis = 611;
        e4.egrave = 444;
        e4.zacute = 389;
        e4.iogonek = 278;
        e4.Oacute = 722;
        e4.oacute = 500;
        e4.amacron = 500;
        e4.sacute = 389;
        e4.idieresis = 278;
        e4.Ocircumflex = 722;
        e4.Ugrave = 722;
        e4.Delta = 612;
        e4.thorn = 500;
        e4.twosuperior = 300;
        e4.Odieresis = 722;
        e4.mu = 500;
        e4.igrave = 278;
        e4.ohungarumlaut = 500;
        e4.Eogonek = 611;
        e4.dcroat = 500;
        e4.threequarters = 750;
        e4.Scedilla = 500;
        e4.lcaron = 300;
        e4.Kcommaaccent = 667;
        e4.Lacute = 556;
        e4.trademark = 980;
        e4.edotaccent = 444;
        e4.Igrave = 333;
        e4.Imacron = 333;
        e4.Lcaron = 611;
        e4.onehalf = 750;
        e4.lessequal = 549;
        e4.ocircumflex = 500;
        e4.ntilde = 500;
        e4.Uhungarumlaut = 722;
        e4.Eacute = 611;
        e4.emacron = 444;
        e4.gbreve = 500;
        e4.onequarter = 750;
        e4.Scaron = 500;
        e4.Scommaaccent = 500;
        e4.Ohungarumlaut = 722;
        e4.degree = 400;
        e4.ograve = 500;
        e4.Ccaron = 667;
        e4.ugrave = 500;
        e4.radical = 453;
        e4.Dcaron = 722;
        e4.rcommaaccent = 389;
        e4.Ntilde = 667;
        e4.otilde = 500;
        e4.Rcommaaccent = 611;
        e4.Lcommaaccent = 556;
        e4.Atilde = 611;
        e4.Aogonek = 611;
        e4.Aring = 611;
        e4.Otilde = 722;
        e4.zdotaccent = 389;
        e4.Ecaron = 611;
        e4.Iogonek = 333;
        e4.kcommaaccent = 444;
        e4.minus = 675;
        e4.Icircumflex = 333;
        e4.ncaron = 500;
        e4.tcommaaccent = 278;
        e4.logicalnot = 675;
        e4.odieresis = 500;
        e4.udieresis = 500;
        e4.notequal = 549;
        e4.gcommaaccent = 500;
        e4.eth = 500;
        e4.zcaron = 389;
        e4.ncommaaccent = 500;
        e4.onesuperior = 300;
        e4.imacron = 278;
        e4.Euro = 500;
      });
      e3.ZapfDingbats = getLookupTableFactory(function(e4) {
        e4.space = 278;
        e4.a1 = 974;
        e4.a2 = 961;
        e4.a202 = 974;
        e4.a3 = 980;
        e4.a4 = 719;
        e4.a5 = 789;
        e4.a119 = 790;
        e4.a118 = 791;
        e4.a117 = 690;
        e4.a11 = 960;
        e4.a12 = 939;
        e4.a13 = 549;
        e4.a14 = 855;
        e4.a15 = 911;
        e4.a16 = 933;
        e4.a105 = 911;
        e4.a17 = 945;
        e4.a18 = 974;
        e4.a19 = 755;
        e4.a20 = 846;
        e4.a21 = 762;
        e4.a22 = 761;
        e4.a23 = 571;
        e4.a24 = 677;
        e4.a25 = 763;
        e4.a26 = 760;
        e4.a27 = 759;
        e4.a28 = 754;
        e4.a6 = 494;
        e4.a7 = 552;
        e4.a8 = 537;
        e4.a9 = 577;
        e4.a10 = 692;
        e4.a29 = 786;
        e4.a30 = 788;
        e4.a31 = 788;
        e4.a32 = 790;
        e4.a33 = 793;
        e4.a34 = 794;
        e4.a35 = 816;
        e4.a36 = 823;
        e4.a37 = 789;
        e4.a38 = 841;
        e4.a39 = 823;
        e4.a40 = 833;
        e4.a41 = 816;
        e4.a42 = 831;
        e4.a43 = 923;
        e4.a44 = 744;
        e4.a45 = 723;
        e4.a46 = 749;
        e4.a47 = 790;
        e4.a48 = 792;
        e4.a49 = 695;
        e4.a50 = 776;
        e4.a51 = 768;
        e4.a52 = 792;
        e4.a53 = 759;
        e4.a54 = 707;
        e4.a55 = 708;
        e4.a56 = 682;
        e4.a57 = 701;
        e4.a58 = 826;
        e4.a59 = 815;
        e4.a60 = 789;
        e4.a61 = 789;
        e4.a62 = 707;
        e4.a63 = 687;
        e4.a64 = 696;
        e4.a65 = 689;
        e4.a66 = 786;
        e4.a67 = 787;
        e4.a68 = 713;
        e4.a69 = 791;
        e4.a70 = 785;
        e4.a71 = 791;
        e4.a72 = 873;
        e4.a73 = 761;
        e4.a74 = 762;
        e4.a203 = 762;
        e4.a75 = 759;
        e4.a204 = 759;
        e4.a76 = 892;
        e4.a77 = 892;
        e4.a78 = 788;
        e4.a79 = 784;
        e4.a81 = 438;
        e4.a82 = 138;
        e4.a83 = 277;
        e4.a84 = 415;
        e4.a97 = 392;
        e4.a98 = 392;
        e4.a99 = 668;
        e4.a100 = 668;
        e4.a89 = 390;
        e4.a90 = 390;
        e4.a93 = 317;
        e4.a94 = 317;
        e4.a91 = 276;
        e4.a92 = 276;
        e4.a205 = 509;
        e4.a85 = 509;
        e4.a206 = 410;
        e4.a86 = 410;
        e4.a87 = 234;
        e4.a88 = 234;
        e4.a95 = 334;
        e4.a96 = 334;
        e4.a101 = 732;
        e4.a102 = 544;
        e4.a103 = 544;
        e4.a104 = 910;
        e4.a106 = 667;
        e4.a107 = 760;
        e4.a108 = 760;
        e4.a112 = 776;
        e4.a111 = 595;
        e4.a110 = 694;
        e4.a109 = 626;
        e4.a120 = 788;
        e4.a121 = 788;
        e4.a122 = 788;
        e4.a123 = 788;
        e4.a124 = 788;
        e4.a125 = 788;
        e4.a126 = 788;
        e4.a127 = 788;
        e4.a128 = 788;
        e4.a129 = 788;
        e4.a130 = 788;
        e4.a131 = 788;
        e4.a132 = 788;
        e4.a133 = 788;
        e4.a134 = 788;
        e4.a135 = 788;
        e4.a136 = 788;
        e4.a137 = 788;
        e4.a138 = 788;
        e4.a139 = 788;
        e4.a140 = 788;
        e4.a141 = 788;
        e4.a142 = 788;
        e4.a143 = 788;
        e4.a144 = 788;
        e4.a145 = 788;
        e4.a146 = 788;
        e4.a147 = 788;
        e4.a148 = 788;
        e4.a149 = 788;
        e4.a150 = 788;
        e4.a151 = 788;
        e4.a152 = 788;
        e4.a153 = 788;
        e4.a154 = 788;
        e4.a155 = 788;
        e4.a156 = 788;
        e4.a157 = 788;
        e4.a158 = 788;
        e4.a159 = 788;
        e4.a160 = 894;
        e4.a161 = 838;
        e4.a163 = 1016;
        e4.a164 = 458;
        e4.a196 = 748;
        e4.a165 = 924;
        e4.a192 = 748;
        e4.a166 = 918;
        e4.a167 = 927;
        e4.a168 = 928;
        e4.a169 = 928;
        e4.a170 = 834;
        e4.a171 = 873;
        e4.a172 = 828;
        e4.a173 = 924;
        e4.a162 = 924;
        e4.a174 = 917;
        e4.a175 = 930;
        e4.a176 = 931;
        e4.a177 = 463;
        e4.a178 = 883;
        e4.a179 = 836;
        e4.a193 = 836;
        e4.a180 = 867;
        e4.a199 = 867;
        e4.a181 = 696;
        e4.a200 = 696;
        e4.a182 = 874;
        e4.a201 = 874;
        e4.a183 = 760;
        e4.a184 = 946;
        e4.a197 = 771;
        e4.a185 = 865;
        e4.a194 = 771;
        e4.a198 = 888;
        e4.a186 = 967;
        e4.a195 = 888;
        e4.a187 = 831;
        e4.a188 = 873;
        e4.a189 = 927;
        e4.a190 = 970;
        e4.a191 = 918;
      });
    });
    ea = getLookupTableFactory(function(e3) {
      e3.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 };
      e3["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 };
      e3["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 };
      e3["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 };
      e3.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 };
      e3["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 };
      e3["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 };
      e3["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 };
      e3["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 };
      e3["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 };
      e3["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 };
      e3["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 };
      e3.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
      e3.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
    });
    GlyfTable = class {
      constructor({ glyfTable: e3, isGlyphLocationsLong: t3, locaTable: i3, numGlyphs: a3 }) {
        this.glyphs = [];
        const s3 = new DataView(i3.buffer, i3.byteOffset, i3.byteLength), r3 = new DataView(e3.buffer, e3.byteOffset, e3.byteLength), n3 = t3 ? 4 : 2;
        let o3 = t3 ? s3.getUint32(0) : 2 * s3.getUint16(0), g3 = 0;
        for (let e4 = 0; e4 < a3; e4++) {
          g3 += n3;
          const e5 = t3 ? s3.getUint32(g3) : 2 * s3.getUint16(g3);
          if (e5 === o3) {
            this.glyphs.push(new Glyph({}));
            continue;
          }
          const i4 = Glyph.parse(o3, r3);
          this.glyphs.push(i4);
          o3 = e5;
        }
      }
      getSize() {
        return this.glyphs.reduce((e3, t3) => e3 + (t3.getSize() + 3 & -4), 0);
      }
      write() {
        const e3 = this.getSize(), t3 = new DataView(new ArrayBuffer(e3)), i3 = e3 > 131070, a3 = i3 ? 4 : 2, s3 = new DataView(new ArrayBuffer((this.glyphs.length + 1) * a3));
        i3 ? s3.setUint32(0, 0) : s3.setUint16(0, 0);
        let r3 = 0, n3 = 0;
        for (const e4 of this.glyphs) {
          r3 += e4.write(r3, t3);
          r3 = r3 + 3 & -4;
          n3 += a3;
          i3 ? s3.setUint32(n3, r3) : s3.setUint16(n3, r3 >> 1);
        }
        return { isLocationLong: i3, loca: new Uint8Array(s3.buffer), glyf: new Uint8Array(t3.buffer) };
      }
      scale(e3) {
        for (let t3 = 0, i3 = this.glyphs.length; t3 < i3; t3++)
          this.glyphs[t3].scale(e3[t3]);
      }
    };
    Glyph = class _Glyph {
      constructor({ header: e3 = null, simple: t3 = null, composites: i3 = null }) {
        this.header = e3;
        this.simple = t3;
        this.composites = i3;
      }
      static parse(e3, t3) {
        const [i3, a3] = GlyphHeader.parse(e3, t3);
        e3 += i3;
        if (a3.numberOfContours < 0) {
          const i4 = [];
          for (; ; ) {
            const [a4, s4] = CompositeGlyph.parse(e3, t3);
            e3 += a4;
            i4.push(s4);
            if (!(32 & s4.flags))
              break;
          }
          return new _Glyph({ header: a3, composites: i4 });
        }
        const s3 = SimpleGlyph.parse(e3, t3, a3.numberOfContours);
        return new _Glyph({ header: a3, simple: s3 });
      }
      getSize() {
        if (!this.header)
          return 0;
        const e3 = this.simple ? this.simple.getSize() : this.composites.reduce((e4, t3) => e4 + t3.getSize(), 0);
        return this.header.getSize() + e3;
      }
      write(e3, t3) {
        if (!this.header)
          return 0;
        const i3 = e3;
        e3 += this.header.write(e3, t3);
        if (this.simple)
          e3 += this.simple.write(e3, t3);
        else
          for (const i4 of this.composites)
            e3 += i4.write(e3, t3);
        return e3 - i3;
      }
      scale(e3) {
        if (!this.header)
          return;
        const t3 = (this.header.xMin + this.header.xMax) / 2;
        this.header.scale(t3, e3);
        if (this.simple)
          this.simple.scale(t3, e3);
        else
          for (const i3 of this.composites)
            i3.scale(t3, e3);
      }
    };
    GlyphHeader = class _GlyphHeader {
      constructor({ numberOfContours: e3, xMin: t3, yMin: i3, xMax: a3, yMax: s3 }) {
        this.numberOfContours = e3;
        this.xMin = t3;
        this.yMin = i3;
        this.xMax = a3;
        this.yMax = s3;
      }
      static parse(e3, t3) {
        return [10, new _GlyphHeader({ numberOfContours: t3.getInt16(e3), xMin: t3.getInt16(e3 + 2), yMin: t3.getInt16(e3 + 4), xMax: t3.getInt16(e3 + 6), yMax: t3.getInt16(e3 + 8) })];
      }
      getSize() {
        return 10;
      }
      write(e3, t3) {
        t3.setInt16(e3, this.numberOfContours);
        t3.setInt16(e3 + 2, this.xMin);
        t3.setInt16(e3 + 4, this.yMin);
        t3.setInt16(e3 + 6, this.xMax);
        t3.setInt16(e3 + 8, this.yMax);
        return 10;
      }
      scale(e3, t3) {
        this.xMin = Math.round(e3 + (this.xMin - e3) * t3);
        this.xMax = Math.round(e3 + (this.xMax - e3) * t3);
      }
    };
    Contour = class {
      constructor({ flags: e3, xCoordinates: t3, yCoordinates: i3 }) {
        this.xCoordinates = t3;
        this.yCoordinates = i3;
        this.flags = e3;
      }
    };
    SimpleGlyph = class _SimpleGlyph {
      constructor({ contours: e3, instructions: t3 }) {
        this.contours = e3;
        this.instructions = t3;
      }
      static parse(e3, t3, i3) {
        const a3 = [];
        for (let s4 = 0; s4 < i3; s4++) {
          const i4 = t3.getUint16(e3);
          e3 += 2;
          a3.push(i4);
        }
        const s3 = a3[i3 - 1] + 1, r3 = t3.getUint16(e3);
        e3 += 2;
        const n3 = new Uint8Array(t3).slice(e3, e3 + r3);
        e3 += r3;
        const o3 = [];
        for (let i4 = 0; i4 < s3; e3++, i4++) {
          let a4 = t3.getUint8(e3);
          o3.push(a4);
          if (8 & a4) {
            const s4 = t3.getUint8(++e3);
            a4 ^= 8;
            for (let e4 = 0; e4 < s4; e4++)
              o3.push(a4);
            i4 += s4;
          }
        }
        const g3 = [];
        let c3 = [], C3 = [], h2 = [];
        const l3 = [];
        let Q3 = 0, E3 = 0;
        for (let i4 = 0; i4 < s3; i4++) {
          const s4 = o3[i4];
          if (2 & s4) {
            const i5 = t3.getUint8(e3++);
            E3 += 16 & s4 ? i5 : -i5;
            c3.push(E3);
          } else if (16 & s4)
            c3.push(E3);
          else {
            E3 += t3.getInt16(e3);
            e3 += 2;
            c3.push(E3);
          }
          if (a3[Q3] === i4) {
            Q3++;
            g3.push(c3);
            c3 = [];
          }
        }
        E3 = 0;
        Q3 = 0;
        for (let i4 = 0; i4 < s3; i4++) {
          const s4 = o3[i4];
          if (4 & s4) {
            const i5 = t3.getUint8(e3++);
            E3 += 32 & s4 ? i5 : -i5;
            C3.push(E3);
          } else if (32 & s4)
            C3.push(E3);
          else {
            E3 += t3.getInt16(e3);
            e3 += 2;
            C3.push(E3);
          }
          h2.push(1 & s4 | 64 & s4);
          if (a3[Q3] === i4) {
            c3 = g3[Q3];
            Q3++;
            l3.push(new Contour({ flags: h2, xCoordinates: c3, yCoordinates: C3 }));
            C3 = [];
            h2 = [];
          }
        }
        return new _SimpleGlyph({ contours: l3, instructions: n3 });
      }
      getSize() {
        let e3 = 2 * this.contours.length + 2 + this.instructions.length, t3 = 0, i3 = 0;
        for (const a3 of this.contours) {
          e3 += a3.flags.length;
          for (let s3 = 0, r3 = a3.xCoordinates.length; s3 < r3; s3++) {
            const r4 = a3.xCoordinates[s3], n3 = a3.yCoordinates[s3];
            let o3 = Math.abs(r4 - t3);
            o3 > 255 ? e3 += 2 : o3 > 0 && (e3 += 1);
            t3 = r4;
            o3 = Math.abs(n3 - i3);
            o3 > 255 ? e3 += 2 : o3 > 0 && (e3 += 1);
            i3 = n3;
          }
        }
        return e3;
      }
      write(e3, t3) {
        const i3 = e3, a3 = [], s3 = [], r3 = [];
        let n3 = 0, o3 = 0;
        for (const i4 of this.contours) {
          for (let e4 = 0, t4 = i4.xCoordinates.length; e4 < t4; e4++) {
            let t5 = i4.flags[e4];
            const g3 = i4.xCoordinates[e4];
            let c3 = g3 - n3;
            if (0 === c3) {
              t5 |= 16;
              a3.push(0);
            } else {
              const e5 = Math.abs(c3);
              if (e5 <= 255) {
                t5 |= c3 >= 0 ? 18 : 2;
                a3.push(e5);
              } else
                a3.push(c3);
            }
            n3 = g3;
            const C3 = i4.yCoordinates[e4];
            c3 = C3 - o3;
            if (0 === c3) {
              t5 |= 32;
              s3.push(0);
            } else {
              const e5 = Math.abs(c3);
              if (e5 <= 255) {
                t5 |= c3 >= 0 ? 36 : 4;
                s3.push(e5);
              } else
                s3.push(c3);
            }
            o3 = C3;
            r3.push(t5);
          }
          t3.setUint16(e3, a3.length - 1);
          e3 += 2;
        }
        t3.setUint16(e3, this.instructions.length);
        e3 += 2;
        if (this.instructions.length) {
          new Uint8Array(t3.buffer, 0, t3.buffer.byteLength).set(this.instructions, e3);
          e3 += this.instructions.length;
        }
        for (const i4 of r3)
          t3.setUint8(e3++, i4);
        for (let i4 = 0, s4 = a3.length; i4 < s4; i4++) {
          const s5 = a3[i4], n4 = r3[i4];
          if (2 & n4)
            t3.setUint8(e3++, s5);
          else if (!(16 & n4)) {
            t3.setInt16(e3, s5);
            e3 += 2;
          }
        }
        for (let i4 = 0, a4 = s3.length; i4 < a4; i4++) {
          const a5 = s3[i4], n4 = r3[i4];
          if (4 & n4)
            t3.setUint8(e3++, a5);
          else if (!(32 & n4)) {
            t3.setInt16(e3, a5);
            e3 += 2;
          }
        }
        return e3 - i3;
      }
      scale(e3, t3) {
        for (const i3 of this.contours)
          if (0 !== i3.xCoordinates.length)
            for (let a3 = 0, s3 = i3.xCoordinates.length; a3 < s3; a3++)
              i3.xCoordinates[a3] = Math.round(e3 + (i3.xCoordinates[a3] - e3) * t3);
      }
    };
    CompositeGlyph = class _CompositeGlyph {
      constructor({ flags: e3, glyphIndex: t3, argument1: i3, argument2: a3, transf: s3, instructions: r3 }) {
        this.flags = e3;
        this.glyphIndex = t3;
        this.argument1 = i3;
        this.argument2 = a3;
        this.transf = s3;
        this.instructions = r3;
      }
      static parse(e3, t3) {
        const i3 = e3, a3 = [];
        let s3 = t3.getUint16(e3);
        const r3 = t3.getUint16(e3 + 2);
        e3 += 4;
        let n3, o3;
        if (1 & s3) {
          if (2 & s3) {
            n3 = t3.getInt16(e3);
            o3 = t3.getInt16(e3 + 2);
          } else {
            n3 = t3.getUint16(e3);
            o3 = t3.getUint16(e3 + 2);
          }
          e3 += 4;
          s3 ^= 1;
        } else {
          if (2 & s3) {
            n3 = t3.getInt8(e3);
            o3 = t3.getInt8(e3 + 1);
          } else {
            n3 = t3.getUint8(e3);
            o3 = t3.getUint8(e3 + 1);
          }
          e3 += 2;
        }
        if (8 & s3) {
          a3.push(t3.getUint16(e3));
          e3 += 2;
        } else if (64 & s3) {
          a3.push(t3.getUint16(e3), t3.getUint16(e3 + 2));
          e3 += 4;
        } else if (128 & s3) {
          a3.push(t3.getUint16(e3), t3.getUint16(e3 + 2), t3.getUint16(e3 + 4), t3.getUint16(e3 + 6));
          e3 += 8;
        }
        let g3 = null;
        if (256 & s3) {
          const i4 = t3.getUint16(e3);
          e3 += 2;
          g3 = new Uint8Array(t3).slice(e3, e3 + i4);
          e3 += i4;
        }
        return [e3 - i3, new _CompositeGlyph({ flags: s3, glyphIndex: r3, argument1: n3, argument2: o3, transf: a3, instructions: g3 })];
      }
      getSize() {
        let e3 = 4 + 2 * this.transf.length;
        256 & this.flags && (e3 += 2 + this.instructions.length);
        e3 += 2;
        2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e3 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e3 += 2);
        return e3;
      }
      write(e3, t3) {
        const i3 = e3;
        2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);
        t3.setUint16(e3, this.flags);
        t3.setUint16(e3 + 2, this.glyphIndex);
        e3 += 4;
        if (1 & this.flags) {
          if (2 & this.flags) {
            t3.setInt16(e3, this.argument1);
            t3.setInt16(e3 + 2, this.argument2);
          } else {
            t3.setUint16(e3, this.argument1);
            t3.setUint16(e3 + 2, this.argument2);
          }
          e3 += 4;
        } else {
          t3.setUint8(e3, this.argument1);
          t3.setUint8(e3 + 1, this.argument2);
          e3 += 2;
        }
        if (256 & this.flags) {
          t3.setUint16(e3, this.instructions.length);
          e3 += 2;
          if (this.instructions.length) {
            new Uint8Array(t3.buffer, 0, t3.buffer.byteLength).set(this.instructions, e3);
            e3 += this.instructions.length;
          }
        }
        return e3 - i3;
      }
      scale(e3, t3) {
      }
    };
    OpenTypeFileBuilder = class _OpenTypeFileBuilder {
      constructor(e3) {
        this.sfnt = e3;
        this.tables = /* @__PURE__ */ Object.create(null);
      }
      static getSearchParams(e3, t3) {
        let i3 = 1, a3 = 0;
        for (; (i3 ^ e3) > i3; ) {
          i3 <<= 1;
          a3++;
        }
        const s3 = i3 * t3;
        return { range: s3, entry: a3, rangeShift: t3 * e3 - s3 };
      }
      toArray() {
        let e3 = this.sfnt;
        const t3 = this.tables, i3 = Object.keys(t3);
        i3.sort();
        const a3 = i3.length;
        let s3, r3, n3, o3, g3, c3 = 12 + 16 * a3;
        const C3 = [c3];
        for (s3 = 0; s3 < a3; s3++) {
          o3 = t3[i3[s3]];
          c3 += (o3.length + 3 & -4) >>> 0;
          C3.push(c3);
        }
        const h2 = new Uint8Array(c3);
        for (s3 = 0; s3 < a3; s3++) {
          o3 = t3[i3[s3]];
          writeData(h2, C3[s3], o3);
        }
        "true" === e3 && (e3 = string32(65536));
        h2[0] = 255 & e3.charCodeAt(0);
        h2[1] = 255 & e3.charCodeAt(1);
        h2[2] = 255 & e3.charCodeAt(2);
        h2[3] = 255 & e3.charCodeAt(3);
        writeInt16(h2, 4, a3);
        const l3 = _OpenTypeFileBuilder.getSearchParams(a3, 16);
        writeInt16(h2, 6, l3.range);
        writeInt16(h2, 8, l3.entry);
        writeInt16(h2, 10, l3.rangeShift);
        c3 = 12;
        for (s3 = 0; s3 < a3; s3++) {
          g3 = i3[s3];
          h2[c3] = 255 & g3.charCodeAt(0);
          h2[c3 + 1] = 255 & g3.charCodeAt(1);
          h2[c3 + 2] = 255 & g3.charCodeAt(2);
          h2[c3 + 3] = 255 & g3.charCodeAt(3);
          let e4 = 0;
          for (r3 = C3[s3], n3 = C3[s3 + 1]; r3 < n3; r3 += 4) {
            e4 = e4 + readUint32(h2, r3) >>> 0;
          }
          writeInt32(h2, c3 + 4, e4);
          writeInt32(h2, c3 + 8, C3[s3]);
          writeInt32(h2, c3 + 12, t3[g3].length);
          c3 += 16;
        }
        return h2;
      }
      addTable(e3, t3) {
        if (e3 in this.tables)
          throw new Error("Table " + e3 + " already exists");
        this.tables[e3] = t3;
      }
    };
    ta = [4];
    ia = [5];
    aa = [6];
    sa = [7];
    ra = [8];
    na = [12, 35];
    oa = [14];
    ga = [21];
    Ia = [22];
    ca = [30];
    Ca = [31];
    Type1CharString = class {
      constructor() {
        this.width = 0;
        this.lsb = 0;
        this.flexing = false;
        this.output = [];
        this.stack = [];
      }
      convert(e3, t3, i3) {
        const a3 = e3.length;
        let s3, r3, n3, o3 = false;
        for (let g3 = 0; g3 < a3; g3++) {
          let a4 = e3[g3];
          if (a4 < 32) {
            12 === a4 && (a4 = (a4 << 8) + e3[++g3]);
            switch (a4) {
              case 1:
              case 3:
              case 9:
              case 3072:
              case 3073:
              case 3074:
              case 3105:
                this.stack = [];
                break;
              case 4:
                if (this.flexing) {
                  if (this.stack.length < 1) {
                    o3 = true;
                    break;
                  }
                  const e5 = this.stack.pop();
                  this.stack.push(0, e5);
                  break;
                }
                o3 = this.executeCommand(1, ta);
                break;
              case 5:
                o3 = this.executeCommand(2, ia);
                break;
              case 6:
                o3 = this.executeCommand(1, aa);
                break;
              case 7:
                o3 = this.executeCommand(1, sa);
                break;
              case 8:
                o3 = this.executeCommand(6, ra);
                break;
              case 10:
                if (this.stack.length < 1) {
                  o3 = true;
                  break;
                }
                n3 = this.stack.pop();
                if (!t3[n3]) {
                  o3 = true;
                  break;
                }
                o3 = this.convert(t3[n3], t3, i3);
                break;
              case 11:
                return o3;
              case 13:
                if (this.stack.length < 2) {
                  o3 = true;
                  break;
                }
                s3 = this.stack.pop();
                r3 = this.stack.pop();
                this.lsb = r3;
                this.width = s3;
                this.stack.push(s3, r3);
                o3 = this.executeCommand(2, Ia);
                break;
              case 14:
                this.output.push(oa[0]);
                break;
              case 21:
                if (this.flexing)
                  break;
                o3 = this.executeCommand(2, ga);
                break;
              case 22:
                if (this.flexing) {
                  this.stack.push(0);
                  break;
                }
                o3 = this.executeCommand(1, Ia);
                break;
              case 30:
                o3 = this.executeCommand(4, ca);
                break;
              case 31:
                o3 = this.executeCommand(4, Ca);
                break;
              case 3078:
                if (i3) {
                  const e5 = this.stack.at(-5);
                  this.seac = this.stack.splice(-4, 4);
                  this.seac[0] += this.lsb - e5;
                  o3 = this.executeCommand(0, oa);
                } else
                  o3 = this.executeCommand(4, oa);
                break;
              case 3079:
                if (this.stack.length < 4) {
                  o3 = true;
                  break;
                }
                this.stack.pop();
                s3 = this.stack.pop();
                const e4 = this.stack.pop();
                r3 = this.stack.pop();
                this.lsb = r3;
                this.width = s3;
                this.stack.push(s3, r3, e4);
                o3 = this.executeCommand(3, ga);
                break;
              case 3084:
                if (this.stack.length < 2) {
                  o3 = true;
                  break;
                }
                const g4 = this.stack.pop(), c3 = this.stack.pop();
                this.stack.push(c3 / g4);
                break;
              case 3088:
                if (this.stack.length < 2) {
                  o3 = true;
                  break;
                }
                n3 = this.stack.pop();
                const C3 = this.stack.pop();
                if (0 === n3 && 3 === C3) {
                  const e5 = this.stack.splice(-17, 17);
                  this.stack.push(e5[2] + e5[0], e5[3] + e5[1], e5[4], e5[5], e5[6], e5[7], e5[8], e5[9], e5[10], e5[11], e5[12], e5[13], e5[14]);
                  o3 = this.executeCommand(13, na, true);
                  this.flexing = false;
                  this.stack.push(e5[15], e5[16]);
                } else
                  1 === n3 && 0 === C3 && (this.flexing = true);
                break;
              case 3089:
                break;
              default:
                warn('Unknown type 1 charstring command of "' + a4 + '"');
            }
            if (o3)
              break;
          } else {
            a4 <= 246 ? a4 -= 139 : a4 = a4 <= 250 ? 256 * (a4 - 247) + e3[++g3] + 108 : a4 <= 254 ? -256 * (a4 - 251) - e3[++g3] - 108 : (255 & e3[++g3]) << 24 | (255 & e3[++g3]) << 16 | (255 & e3[++g3]) << 8 | (255 & e3[++g3]) << 0;
            this.stack.push(a4);
          }
        }
        return o3;
      }
      executeCommand(e3, t3, i3) {
        const a3 = this.stack.length;
        if (e3 > a3)
          return true;
        const s3 = a3 - e3;
        for (let e4 = s3; e4 < a3; e4++) {
          let t4 = this.stack[e4];
          if (Number.isInteger(t4))
            this.output.push(28, t4 >> 8 & 255, 255 & t4);
          else {
            t4 = 65536 * t4 | 0;
            this.output.push(255, t4 >> 24 & 255, t4 >> 16 & 255, t4 >> 8 & 255, 255 & t4);
          }
        }
        this.output.push(...t3);
        i3 ? this.stack.splice(s3, e3) : this.stack.length = 0;
        return false;
      }
    };
    Type1Parser = class {
      constructor(e3, t3, i3) {
        if (t3) {
          const t4 = e3.getBytes(), i4 = !((isHexDigit(t4[0]) || isWhiteSpace(t4[0])) && isHexDigit(t4[1]) && isHexDigit(t4[2]) && isHexDigit(t4[3]) && isHexDigit(t4[4]) && isHexDigit(t4[5]) && isHexDigit(t4[6]) && isHexDigit(t4[7]));
          e3 = new Stream(i4 ? decrypt(t4, 55665, 4) : function decryptAscii(e4, t5, i5) {
            let a3 = 0 | t5;
            const s3 = e4.length, r3 = new Uint8Array(s3 >>> 1);
            let n3, o3;
            for (n3 = 0, o3 = 0; n3 < s3; n3++) {
              const t6 = e4[n3];
              if (!isHexDigit(t6))
                continue;
              n3++;
              let i6;
              for (; n3 < s3 && !isHexDigit(i6 = e4[n3]); )
                n3++;
              if (n3 < s3) {
                const e5 = parseInt(String.fromCharCode(t6, i6), 16);
                r3[o3++] = e5 ^ a3 >> 8;
                a3 = 52845 * (e5 + a3) + 22719 & 65535;
              }
            }
            return r3.slice(i5, o3);
          }(t4, 55665, 4));
        }
        this.seacAnalysisEnabled = !!i3;
        this.stream = e3;
        this.nextChar();
      }
      readNumberArray() {
        this.getToken();
        const e3 = [];
        for (; ; ) {
          const t3 = this.getToken();
          if (null === t3 || "]" === t3 || "}" === t3)
            break;
          e3.push(parseFloat(t3 || 0));
        }
        return e3;
      }
      readNumber() {
        const e3 = this.getToken();
        return parseFloat(e3 || 0);
      }
      readInt() {
        const e3 = this.getToken();
        return 0 | parseInt(e3 || 0, 10);
      }
      readBoolean() {
        return "true" === this.getToken() ? 1 : 0;
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      prevChar() {
        this.stream.skip(-2);
        return this.currentChar = this.stream.getByte();
      }
      getToken() {
        let e3 = false, t3 = this.currentChar;
        for (; ; ) {
          if (-1 === t3)
            return null;
          if (e3)
            10 !== t3 && 13 !== t3 || (e3 = false);
          else if (37 === t3)
            e3 = true;
          else if (!isWhiteSpace(t3))
            break;
          t3 = this.nextChar();
        }
        if (isSpecial(t3)) {
          this.nextChar();
          return String.fromCharCode(t3);
        }
        let i3 = "";
        do {
          i3 += String.fromCharCode(t3);
          t3 = this.nextChar();
        } while (t3 >= 0 && !isWhiteSpace(t3) && !isSpecial(t3));
        return i3;
      }
      readCharStrings(e3, t3) {
        return -1 === t3 ? e3 : decrypt(e3, 4330, t3);
      }
      extractFontProgram(e3) {
        const t3 = this.stream, i3 = [], a3 = [], s3 = /* @__PURE__ */ Object.create(null);
        s3.lenIV = 4;
        const r3 = { subrs: [], charstrings: [], properties: { privateData: s3 } };
        let n3, o3, g3, c3;
        for (; null !== (n3 = this.getToken()); )
          if ("/" === n3) {
            n3 = this.getToken();
            switch (n3) {
              case "CharStrings":
                this.getToken();
                this.getToken();
                this.getToken();
                this.getToken();
                for (; ; ) {
                  n3 = this.getToken();
                  if (null === n3 || "end" === n3)
                    break;
                  if ("/" !== n3)
                    continue;
                  const e5 = this.getToken();
                  o3 = this.readInt();
                  this.getToken();
                  g3 = o3 > 0 ? t3.getBytes(o3) : new Uint8Array(0);
                  c3 = r3.properties.privateData.lenIV;
                  const i4 = this.readCharStrings(g3, c3);
                  this.nextChar();
                  n3 = this.getToken();
                  "noaccess" === n3 ? this.getToken() : "/" === n3 && this.prevChar();
                  a3.push({ glyph: e5, encoded: i4 });
                }
                break;
              case "Subrs":
                this.readInt();
                this.getToken();
                for (; "dup" === this.getToken(); ) {
                  const e5 = this.readInt();
                  o3 = this.readInt();
                  this.getToken();
                  g3 = o3 > 0 ? t3.getBytes(o3) : new Uint8Array(0);
                  c3 = r3.properties.privateData.lenIV;
                  const a4 = this.readCharStrings(g3, c3);
                  this.nextChar();
                  n3 = this.getToken();
                  "noaccess" === n3 && this.getToken();
                  i3[e5] = a4;
                }
                break;
              case "BlueValues":
              case "OtherBlues":
              case "FamilyBlues":
              case "FamilyOtherBlues":
                const e4 = this.readNumberArray();
                e4.length > 0 && e4.length, 0;
                break;
              case "StemSnapH":
              case "StemSnapV":
                r3.properties.privateData[n3] = this.readNumberArray();
                break;
              case "StdHW":
              case "StdVW":
                r3.properties.privateData[n3] = this.readNumberArray()[0];
                break;
              case "BlueShift":
              case "lenIV":
              case "BlueFuzz":
              case "BlueScale":
              case "LanguageGroup":
                r3.properties.privateData[n3] = this.readNumber();
                break;
              case "ExpansionFactor":
                r3.properties.privateData[n3] = this.readNumber() || 0.06;
                break;
              case "ForceBold":
                r3.properties.privateData[n3] = this.readBoolean();
            }
          }
        for (const { encoded: t4, glyph: s4 } of a3) {
          const a4 = new Type1CharString(), n4 = a4.convert(t4, i3, this.seacAnalysisEnabled);
          let o4 = a4.output;
          n4 && (o4 = [14]);
          const g4 = { glyphName: s4, charstring: o4, width: a4.width, lsb: a4.lsb, seac: a4.seac };
          ".notdef" === s4 ? r3.charstrings.unshift(g4) : r3.charstrings.push(g4);
          if (e3.builtInEncoding) {
            const t5 = e3.builtInEncoding.indexOf(s4);
            t5 > -1 && void 0 === e3.widths[t5] && t5 >= e3.firstChar && t5 <= e3.lastChar && (e3.widths[t5] = a4.width);
          }
        }
        return r3;
      }
      extractFontHeader(e3) {
        let t3;
        for (; null !== (t3 = this.getToken()); )
          if ("/" === t3) {
            t3 = this.getToken();
            switch (t3) {
              case "FontMatrix":
                const i3 = this.readNumberArray();
                e3.fontMatrix = i3;
                break;
              case "Encoding":
                const a3 = this.getToken();
                let s3;
                if (/^\d+$/.test(a3)) {
                  s3 = [];
                  const e4 = 0 | parseInt(a3, 10);
                  this.getToken();
                  for (let i4 = 0; i4 < e4; i4++) {
                    t3 = this.getToken();
                    for (; "dup" !== t3 && "def" !== t3; ) {
                      t3 = this.getToken();
                      if (null === t3)
                        return;
                    }
                    if ("def" === t3)
                      break;
                    const e5 = this.readInt();
                    this.getToken();
                    const i5 = this.getToken();
                    s3[e5] = i5;
                    this.getToken();
                  }
                } else
                  s3 = getEncoding(a3);
                e3.builtInEncoding = s3;
                break;
              case "FontBBox":
                const r3 = this.readNumberArray();
                e3.ascent = Math.max(r3[3], r3[1]);
                e3.descent = Math.min(r3[1], r3[3]);
                e3.ascentScaled = true;
            }
          }
      }
    };
    Type1Font = class {
      constructor(e3, t3, i3) {
        let a3 = i3.length1, s3 = i3.length2, r3 = t3.peekBytes(6);
        const n3 = 128 === r3[0] && 1 === r3[1];
        if (n3) {
          t3.skip(6);
          a3 = r3[5] << 24 | r3[4] << 16 | r3[3] << 8 | r3[2];
        }
        const o3 = function getHeaderBlock(e4, t4) {
          const i4 = [101, 101, 120, 101, 99], a4 = e4.pos;
          let s4, r4, n4, o4;
          try {
            s4 = e4.getBytes(t4);
            r4 = s4.length;
          } catch {
          }
          if (r4 === t4) {
            n4 = findBlock(s4, i4, t4 - 2 * i4.length);
            if (n4.found && n4.length === t4)
              return { stream: new Stream(s4), length: t4 };
          }
          warn('Invalid "Length1" property in Type1 font -- trying to recover.');
          e4.pos = a4;
          for (; ; ) {
            n4 = findBlock(e4.peekBytes(2048), i4, 0);
            if (0 === n4.length)
              break;
            e4.pos += n4.length;
            if (n4.found) {
              o4 = e4.pos - a4;
              break;
            }
          }
          e4.pos = a4;
          if (o4)
            return { stream: new Stream(e4.getBytes(o4)), length: o4 };
          warn('Unable to recover "Length1" property in Type1 font -- using as is.');
          return { stream: new Stream(e4.getBytes(t4)), length: t4 };
        }(t3, a3);
        new Type1Parser(o3.stream, false, Yi).extractFontHeader(i3);
        if (n3) {
          r3 = t3.getBytes(6);
          s3 = r3[5] << 24 | r3[4] << 16 | r3[3] << 8 | r3[2];
        }
        const g3 = function getEexecBlock(e4, t4) {
          const i4 = e4.getBytes();
          if (0 === i4.length)
            throw new FormatError("getEexecBlock - no font program found.");
          return { stream: new Stream(i4), length: i4.length };
        }(t3), c3 = new Type1Parser(g3.stream, true, Yi).extractFontProgram(i3);
        for (const e4 in c3.properties)
          i3[e4] = c3.properties[e4];
        const C3 = c3.charstrings, h2 = this.getType2Charstrings(C3), l3 = this.getType2Subrs(c3.subrs);
        this.charstrings = C3;
        this.data = this.wrap(e3, h2, this.charstrings, l3, i3);
        this.seacs = this.getSeacs(c3.charstrings);
      }
      get numGlyphs() {
        return this.charstrings.length + 1;
      }
      getCharset() {
        const e3 = [".notdef"];
        for (const { glyphName: t3 } of this.charstrings)
          e3.push(t3);
        return e3;
      }
      getGlyphMapping(e3) {
        const t3 = this.charstrings;
        if (e3.composite) {
          const i4 = /* @__PURE__ */ Object.create(null);
          for (let a4 = 0, s4 = t3.length; a4 < s4; a4++) {
            i4[e3.cMap.charCodeOf(a4)] = a4 + 1;
          }
          return i4;
        }
        const i3 = [".notdef"];
        let a3, s3;
        for (s3 = 0; s3 < t3.length; s3++)
          i3.push(t3[s3].glyphName);
        const r3 = e3.builtInEncoding;
        if (r3) {
          a3 = /* @__PURE__ */ Object.create(null);
          for (const e4 in r3) {
            s3 = i3.indexOf(r3[e4]);
            s3 >= 0 && (a3[e4] = s3);
          }
        }
        return type1FontGlyphMapping(e3, a3, i3);
      }
      hasGlyphId(e3) {
        if (e3 < 0 || e3 >= this.numGlyphs)
          return false;
        if (0 === e3)
          return true;
        return this.charstrings[e3 - 1].charstring.length > 0;
      }
      getSeacs(e3) {
        const t3 = [];
        for (let i3 = 0, a3 = e3.length; i3 < a3; i3++) {
          const a4 = e3[i3];
          a4.seac && (t3[i3 + 1] = a4.seac);
        }
        return t3;
      }
      getType2Charstrings(e3) {
        const t3 = [];
        for (const i3 of e3)
          t3.push(i3.charstring);
        return t3;
      }
      getType2Subrs(e3) {
        let t3 = 0;
        const i3 = e3.length;
        t3 = i3 < 1133 ? 107 : i3 < 33769 ? 1131 : 32768;
        const a3 = [];
        let s3;
        for (s3 = 0; s3 < t3; s3++)
          a3.push([11]);
        for (s3 = 0; s3 < i3; s3++)
          a3.push(e3[s3]);
        return a3;
      }
      wrap(e3, t3, i3, a3, s3) {
        const r3 = new CFF();
        r3.header = new CFFHeader(1, 0, 4, 4);
        r3.names = [e3];
        const n3 = new CFFTopDict();
        n3.setByName("version", 391);
        n3.setByName("Notice", 392);
        n3.setByName("FullName", 393);
        n3.setByName("FamilyName", 394);
        n3.setByName("Weight", 395);
        n3.setByName("Encoding", null);
        n3.setByName("FontMatrix", s3.fontMatrix);
        n3.setByName("FontBBox", s3.bbox);
        n3.setByName("charset", null);
        n3.setByName("CharStrings", null);
        n3.setByName("Private", null);
        r3.topDict = n3;
        const o3 = new CFFStrings();
        o3.add("Version 0.11");
        o3.add("See original notice");
        o3.add(e3);
        o3.add(e3);
        o3.add("Medium");
        r3.strings = o3;
        r3.globalSubrIndex = new CFFIndex();
        const g3 = t3.length, c3 = [".notdef"];
        let C3, h2;
        for (C3 = 0; C3 < g3; C3++) {
          const e4 = i3[C3].glyphName;
          -1 === wi.indexOf(e4) && o3.add(e4);
          c3.push(e4);
        }
        r3.charset = new CFFCharset(false, 0, c3);
        const l3 = new CFFIndex();
        l3.add([139, 14]);
        for (C3 = 0; C3 < g3; C3++)
          l3.add(t3[C3]);
        r3.charStrings = l3;
        const Q3 = new CFFPrivateDict();
        Q3.setByName("Subrs", null);
        const E3 = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
        for (C3 = 0, h2 = E3.length; C3 < h2; C3++) {
          const e4 = E3[C3];
          if (!(e4 in s3.privateData))
            continue;
          const t4 = s3.privateData[e4];
          if (Array.isArray(t4))
            for (let e5 = t4.length - 1; e5 > 0; e5--)
              t4[e5] -= t4[e5 - 1];
          Q3.setByName(e4, t4);
        }
        r3.topDict.privateDict = Q3;
        const u3 = new CFFIndex();
        for (C3 = 0, h2 = a3.length; C3 < h2; C3++)
          u3.add(a3[C3]);
        Q3.subrsIndex = u3;
        return new CFFCompiler(r3).compile();
      }
    };
    ha = [[57344, 63743], [1048576, 1114109]];
    la = 1e3;
    Ba = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"];
    Qa = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
    fonts_Glyph = class {
      constructor(e3, t3, i3, a3, s3, r3, n3, o3, g3) {
        this.originalCharCode = e3;
        this.fontChar = t3;
        this.unicode = i3;
        this.accent = a3;
        this.width = s3;
        this.vmetric = r3;
        this.operatorListId = n3;
        this.isSpace = o3;
        this.isInFont = g3;
      }
      get category() {
        return shadow(this, "category", function getCharUnicodeCategory(e3) {
          const t3 = Ji.get(e3);
          if (t3)
            return t3;
          const i3 = e3.match(Hi), a3 = { isWhitespace: !!(i3 == null ? void 0 : i3[1]), isZeroWidthDiacritic: !!(i3 == null ? void 0 : i3[2]), isInvisibleFormatMark: !!(i3 == null ? void 0 : i3[3]) };
          Ji.set(e3, a3);
          return a3;
        }(this.unicode), true);
      }
    };
    Font = class {
      constructor(e3, t3, i3) {
        var _a3;
        this.name = e3;
        this.psName = null;
        this.mimetype = null;
        this.disableFontFace = false;
        this.loadedName = i3.loadedName;
        this.isType3Font = i3.isType3Font;
        this.missingFile = false;
        this.cssFontInfo = i3.cssFontInfo;
        this._charsCache = /* @__PURE__ */ Object.create(null);
        this._glyphCache = /* @__PURE__ */ Object.create(null);
        let a3 = !!(i3.flags & Ki);
        if (!a3 && !i3.isSimulatedFlags) {
          const t4 = e3.replaceAll(/[,_]/g, "-").split("-", 1)[0], i4 = Xi();
          for (const e4 of t4.split("+"))
            if (i4[e4]) {
              a3 = true;
              break;
            }
        }
        this.isSerifFont = a3;
        this.isSymbolicFont = !!(i3.flags & Ti);
        this.isMonospace = !!(i3.flags & vi);
        let { type: s3, subtype: r3 } = i3;
        this.type = s3;
        this.subtype = r3;
        this.systemFontInfo = i3.systemFontInfo;
        const n3 = e3.match(/^InvalidPDFjsFont_(.*)_\d+$/);
        this.isInvalidPDFjsFont = !!n3;
        this.isInvalidPDFjsFont ? this.fallbackName = n3[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif";
        if ((_a3 = this.systemFontInfo) == null ? void 0 : _a3.guessFallback) {
          this.systemFontInfo.guessFallback = false;
          this.systemFontInfo.css += `,${this.fallbackName}`;
        }
        this.differences = i3.differences;
        this.widths = i3.widths;
        this.defaultWidth = i3.defaultWidth;
        this.composite = i3.composite;
        this.cMap = i3.cMap;
        this.capHeight = i3.capHeight / la;
        this.ascent = i3.ascent / la;
        this.descent = i3.descent / la;
        this.lineHeight = this.ascent - this.descent;
        this.fontMatrix = i3.fontMatrix;
        this.bbox = i3.bbox;
        this.defaultEncoding = i3.defaultEncoding;
        this.toUnicode = i3.toUnicode;
        this.toFontChar = [];
        if ("Type3" === i3.type) {
          for (let e4 = 0; e4 < 256; e4++)
            this.toFontChar[e4] = this.differences[e4] || i3.defaultEncoding[e4];
          return;
        }
        this.cidEncoding = i3.cidEncoding || "";
        this.vertical = !!i3.vertical;
        if (this.vertical) {
          this.vmetrics = i3.vmetrics;
          this.defaultVMetrics = i3.defaultVMetrics;
        }
        if (!t3 || t3.isEmpty) {
          t3 && warn('Font file is empty in "' + e3 + '" (' + this.loadedName + ")");
          this.fallbackToSystemFont(i3);
          return;
        }
        [s3, r3] = getFontFileType(t3, i3);
        s3 === this.type && r3 === this.subtype || info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s3}/${r3}.`);
        let o3;
        try {
          switch (s3) {
            case "MMType1":
              info("MMType1 font (" + e3 + "), falling back to Type1.");
            case "Type1":
            case "CIDFontType0":
              this.mimetype = "font/opentype";
              const a4 = "Type1C" === r3 || "CIDFontType0C" === r3 ? new CFFFont(t3, i3) : new Type1Font(e3, t3, i3);
              adjustWidths(i3);
              o3 = this.convert(e3, a4, i3);
              break;
            case "OpenType":
            case "TrueType":
            case "CIDFontType2":
              this.mimetype = "font/opentype";
              o3 = this.checkAndRepair(e3, t3, i3);
              if (this.isOpenType) {
                adjustWidths(i3);
                s3 = "OpenType";
              }
              break;
            default:
              throw new FormatError(`Font ${s3} is not supported`);
          }
        } catch (e4) {
          warn(e4);
          this.fallbackToSystemFont(i3);
          return;
        }
        amendFallbackToUnicode(i3);
        this.data = o3;
        this.type = s3;
        this.subtype = r3;
        this.fontMatrix = i3.fontMatrix;
        this.widths = i3.widths;
        this.defaultWidth = i3.defaultWidth;
        this.toUnicode = i3.toUnicode;
        this.seacMap = i3.seacMap;
      }
      get renderer() {
        return shadow(this, "renderer", FontRendererFactory.create(this, Yi));
      }
      exportData(e3 = false) {
        const t3 = e3 ? [...Ba, ...Qa] : Ba, i3 = /* @__PURE__ */ Object.create(null);
        let a3, s3;
        for (a3 of t3) {
          s3 = this[a3];
          void 0 !== s3 && (i3[a3] = s3);
        }
        return i3;
      }
      fallbackToSystemFont(e3) {
        this.missingFile = true;
        const { name: t3, type: i3 } = this;
        let a3 = normalizeFontName(t3);
        const s3 = Pi(), r3 = ji(), n3 = !!s3[a3], o3 = !(!r3[a3] || !s3[r3[a3]]);
        a3 = s3[a3] || r3[a3] || a3;
        const g3 = ea()[a3];
        if (g3) {
          isNaN(this.ascent) && (this.ascent = g3.ascent / la);
          isNaN(this.descent) && (this.descent = g3.descent / la);
          isNaN(this.capHeight) && (this.capHeight = g3.capHeight / la);
        }
        this.bold = /bold/gi.test(a3);
        this.italic = /oblique|italic/gi.test(a3);
        this.black = /Black/g.test(t3);
        const c3 = /Narrow/g.test(t3);
        this.remeasure = (!n3 || c3) && Object.keys(this.widths).length > 0;
        if ((n3 || o3) && "CIDFontType2" === i3 && this.cidEncoding.startsWith("Identity-")) {
          const i4 = e3.cidToGidMap, a4 = [];
          applyStandardFontGlyphMap(a4, Vi());
          /Arial-?Black/i.test(t3) ? applyStandardFontGlyphMap(a4, zi()) : /Calibri/i.test(t3) && applyStandardFontGlyphMap(a4, _i2());
          if (i4) {
            for (const e4 in a4) {
              const t4 = a4[e4];
              void 0 !== i4[t4] && (a4[+e4] = i4[t4]);
            }
            i4.length !== this.toUnicode.length && e3.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e4, t4) {
              const s4 = a4[e4];
              void 0 === i4[s4] && (a4[+e4] = t4);
            });
          }
          this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e4, t4) {
            a4[+e4] = t4;
          });
          this.toFontChar = a4;
          this.toUnicode = new ToUnicodeMap(a4);
        } else if (/Symbol/i.test(a3))
          this.toFontChar = buildToFontChar(mi, Ri(), this.differences);
        else if (/Dingbats/i.test(a3))
          this.toFontChar = buildToFontChar(yi, Gi(), this.differences);
        else if (n3) {
          const e4 = buildToFontChar(this.defaultEncoding, Ri(), this.differences);
          "CIDFontType2" !== i3 || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t4, i4) {
            e4[+t4] = i4;
          });
          this.toFontChar = e4;
        } else {
          const e4 = Ri(), i4 = [];
          this.toUnicode.forEach((t4, a4) => {
            if (!this.composite) {
              const i5 = getUnicodeForGlyph(this.differences[t4] || this.defaultEncoding[t4], e4);
              -1 !== i5 && (a4 = i5);
            }
            i4[+t4] = a4;
          });
          this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t3) && applyStandardFontGlyphMap(i4, Vi());
          this.toFontChar = i4;
        }
        amendFallbackToUnicode(e3);
        this.loadedName = a3.split("-", 1)[0];
      }
      checkAndRepair(e3, t3, i3) {
        var _a3, _b2, _c2;
        const a3 = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
        function readTables(e4, t4) {
          const i4 = /* @__PURE__ */ Object.create(null);
          i4["OS/2"] = null;
          i4.cmap = null;
          i4.head = null;
          i4.hhea = null;
          i4.hmtx = null;
          i4.maxp = null;
          i4.name = null;
          i4.post = null;
          for (let s4 = 0; s4 < t4; s4++) {
            const t5 = readTableEntry(e4);
            a3.includes(t5.tag) && (0 !== t5.length && (i4[t5.tag] = t5));
          }
          return i4;
        }
        function readTableEntry(e4) {
          const t4 = e4.getString(4), i4 = e4.getInt32() >>> 0, a4 = e4.getInt32() >>> 0, s4 = e4.getInt32() >>> 0, r4 = e4.pos;
          e4.pos = e4.start || 0;
          e4.skip(a4);
          const n4 = e4.getBytes(s4);
          e4.pos = r4;
          if ("head" === t4) {
            n4[8] = n4[9] = n4[10] = n4[11] = 0;
            n4[17] |= 32;
          }
          return { tag: t4, checksum: i4, length: s4, offset: a4, data: n4 };
        }
        function readOpenTypeHeader(e4) {
          return { version: e4.getString(4), numTables: e4.getUint16(), searchRange: e4.getUint16(), entrySelector: e4.getUint16(), rangeShift: e4.getUint16() };
        }
        function sanitizeGlyph(e4, t4, i4, a4, s4, r4) {
          const n4 = { length: 0, sizeOfInstructions: 0 };
          if (t4 < 0 || t4 >= e4.length || i4 > e4.length || i4 - t4 <= 12)
            return n4;
          const o4 = e4.subarray(t4, i4), g4 = signedInt16(o4[2], o4[3]), c4 = signedInt16(o4[4], o4[5]), C4 = signedInt16(o4[6], o4[7]), h3 = signedInt16(o4[8], o4[9]);
          if (g4 > C4) {
            writeSignedInt16(o4, 2, C4);
            writeSignedInt16(o4, 6, g4);
          }
          if (c4 > h3) {
            writeSignedInt16(o4, 4, h3);
            writeSignedInt16(o4, 8, c4);
          }
          const l4 = signedInt16(o4[0], o4[1]);
          if (l4 < 0) {
            if (l4 < -1)
              return n4;
            a4.set(o4, s4);
            n4.length = o4.length;
            return n4;
          }
          let Q4, E4 = 10, u4 = 0;
          for (Q4 = 0; Q4 < l4; Q4++) {
            u4 = (o4[E4] << 8 | o4[E4 + 1]) + 1;
            E4 += 2;
          }
          const d4 = E4, f3 = o4[E4] << 8 | o4[E4 + 1];
          n4.sizeOfInstructions = f3;
          E4 += 2 + f3;
          const p3 = E4;
          let m4 = 0;
          for (Q4 = 0; Q4 < u4; Q4++) {
            const e5 = o4[E4++];
            192 & e5 && (o4[E4 - 1] = 63 & e5);
            let t5 = 2;
            2 & e5 ? t5 = 1 : 16 & e5 && (t5 = 0);
            let i5 = 2;
            4 & e5 ? i5 = 1 : 32 & e5 && (i5 = 0);
            const a5 = t5 + i5;
            m4 += a5;
            if (8 & e5) {
              const e6 = o4[E4++];
              0 === e6 && (o4[E4 - 1] ^= 8);
              Q4 += e6;
              m4 += e6 * a5;
            }
          }
          if (0 === m4)
            return n4;
          let y4 = E4 + m4;
          if (y4 > o4.length)
            return n4;
          if (!r4 && f3 > 0) {
            a4.set(o4.subarray(0, d4), s4);
            a4.set([0, 0], s4 + d4);
            a4.set(o4.subarray(p3, y4), s4 + d4 + 2);
            y4 -= f3;
            o4.length - y4 > 3 && (y4 = y4 + 3 & -4);
            n4.length = y4;
            return n4;
          }
          if (o4.length - y4 > 3) {
            y4 = y4 + 3 & -4;
            a4.set(o4.subarray(0, y4), s4);
            n4.length = y4;
            return n4;
          }
          a4.set(o4, s4);
          n4.length = o4.length;
          return n4;
        }
        function readNameTable(e4) {
          const i4 = (t3.start || 0) + e4.offset;
          t3.pos = i4;
          const a4 = [[], []], s4 = [], r4 = e4.length, n4 = i4 + r4;
          if (0 !== t3.getUint16() || r4 < 6)
            return [a4, s4];
          const o4 = t3.getUint16(), g4 = t3.getUint16();
          let c4, C4;
          for (c4 = 0; c4 < o4 && t3.pos + 12 <= n4; c4++) {
            const e5 = { platform: t3.getUint16(), encoding: t3.getUint16(), language: t3.getUint16(), name: t3.getUint16(), length: t3.getUint16(), offset: t3.getUint16() };
            (isMacNameRecord(e5) || isWinNameRecord(e5)) && s4.push(e5);
          }
          for (c4 = 0, C4 = s4.length; c4 < C4; c4++) {
            const e5 = s4[c4];
            if (e5.length <= 0)
              continue;
            const r5 = i4 + g4 + e5.offset;
            if (r5 + e5.length > n4)
              continue;
            t3.pos = r5;
            const o5 = e5.name;
            if (e5.encoding) {
              let i5 = "";
              for (let a5 = 0, s5 = e5.length; a5 < s5; a5 += 2)
                i5 += String.fromCharCode(t3.getUint16());
              a4[1][o5] = i5;
            } else
              a4[0][o5] = t3.getString(e5.length);
          }
          return [a4, s4];
        }
        const s3 = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
        function sanitizeTTProgram(e4, t4) {
          let i4, a4, r4, n4, o4, g4 = e4.data, c4 = 0, C4 = 0, h3 = 0;
          const l4 = [], Q4 = [], E4 = [];
          let u4 = t4.tooComplexToFollowFunctions, d4 = false, f3 = 0, p3 = 0;
          for (let e5 = g4.length; c4 < e5; ) {
            const e6 = g4[c4++];
            if (64 === e6) {
              a4 = g4[c4++];
              if (d4 || p3)
                c4 += a4;
              else
                for (i4 = 0; i4 < a4; i4++)
                  l4.push(g4[c4++]);
            } else if (65 === e6) {
              a4 = g4[c4++];
              if (d4 || p3)
                c4 += 2 * a4;
              else
                for (i4 = 0; i4 < a4; i4++) {
                  r4 = g4[c4++];
                  l4.push(r4 << 8 | g4[c4++]);
                }
            } else if (176 == (248 & e6)) {
              a4 = e6 - 176 + 1;
              if (d4 || p3)
                c4 += a4;
              else
                for (i4 = 0; i4 < a4; i4++)
                  l4.push(g4[c4++]);
            } else if (184 == (248 & e6)) {
              a4 = e6 - 184 + 1;
              if (d4 || p3)
                c4 += 2 * a4;
              else
                for (i4 = 0; i4 < a4; i4++) {
                  r4 = g4[c4++];
                  l4.push(r4 << 8 | g4[c4++]);
                }
            } else if (43 !== e6 || u4)
              if (44 !== e6 || u4) {
                if (45 === e6)
                  if (d4) {
                    d4 = false;
                    C4 = c4;
                  } else {
                    o4 = Q4.pop();
                    if (!o4) {
                      warn("TT: ENDF bad stack");
                      t4.hintsValid = false;
                      return;
                    }
                    n4 = E4.pop();
                    g4 = o4.data;
                    c4 = o4.i;
                    t4.functionsStackDeltas[n4] = l4.length - o4.stackTop;
                  }
                else if (137 === e6) {
                  if (d4 || p3) {
                    warn("TT: nested IDEFs not allowed");
                    u4 = true;
                  }
                  d4 = true;
                  h3 = c4;
                } else if (88 === e6)
                  ++f3;
                else if (27 === e6)
                  p3 = f3;
                else if (89 === e6) {
                  p3 === f3 && (p3 = 0);
                  --f3;
                } else if (28 === e6 && !d4 && !p3) {
                  const e7 = l4.at(-1);
                  e7 > 0 && (c4 += e7 - 1);
                }
              } else {
                if (d4 || p3) {
                  warn("TT: nested FDEFs not allowed");
                  u4 = true;
                }
                d4 = true;
                h3 = c4;
                n4 = l4.pop();
                t4.functionsDefined[n4] = { data: g4, i: c4 };
              }
            else if (!d4 && !p3) {
              n4 = l4.at(-1);
              if (isNaN(n4))
                info("TT: CALL empty stack (or invalid entry).");
              else {
                t4.functionsUsed[n4] = true;
                if (n4 in t4.functionsStackDeltas) {
                  const e7 = l4.length + t4.functionsStackDeltas[n4];
                  if (e7 < 0) {
                    warn("TT: CALL invalid functions stack delta.");
                    t4.hintsValid = false;
                    return;
                  }
                  l4.length = e7;
                } else if (n4 in t4.functionsDefined && !E4.includes(n4)) {
                  Q4.push({ data: g4, i: c4, stackTop: l4.length - 1 });
                  E4.push(n4);
                  o4 = t4.functionsDefined[n4];
                  if (!o4) {
                    warn("TT: CALL non-existent function");
                    t4.hintsValid = false;
                    return;
                  }
                  g4 = o4.data;
                  c4 = o4.i;
                }
              }
            }
            if (!d4 && !p3) {
              let t5 = 0;
              e6 <= 142 ? t5 = s3[e6] : e6 >= 192 && e6 <= 223 ? t5 = -1 : e6 >= 224 && (t5 = -2);
              if (e6 >= 113 && e6 <= 117) {
                a4 = l4.pop();
                isNaN(a4) || (t5 = 2 * -a4);
              }
              for (; t5 < 0 && l4.length > 0; ) {
                l4.pop();
                t5++;
              }
              for (; t5 > 0; ) {
                l4.push(NaN);
                t5--;
              }
            }
          }
          t4.tooComplexToFollowFunctions = u4;
          const m4 = [g4];
          c4 > g4.length && m4.push(new Uint8Array(c4 - g4.length));
          if (h3 > C4) {
            warn("TT: complementing a missing function tail");
            m4.push(new Uint8Array([34, 45]));
          }
          !function foldTTTable(e5, t5) {
            if (t5.length > 1) {
              let i5, a5, s4 = 0;
              for (i5 = 0, a5 = t5.length; i5 < a5; i5++)
                s4 += t5[i5].length;
              s4 = s4 + 3 & -4;
              const r5 = new Uint8Array(s4);
              let n5 = 0;
              for (i5 = 0, a5 = t5.length; i5 < a5; i5++) {
                r5.set(t5[i5], n5);
                n5 += t5[i5].length;
              }
              e5.data = r5;
              e5.length = s4;
            }
          }(e4, m4);
        }
        let r3, n3, o3, g3;
        if (isTrueTypeCollectionFile(t3 = new Stream(new Uint8Array(t3.getBytes())))) {
          const e4 = function readTrueTypeCollectionData(e5, t4) {
            var _a4;
            const { numFonts: i4, offsetTable: a4 } = function readTrueTypeCollectionHeader(e6) {
              const t5 = e6.getString(4);
              assert("ttcf" === t5, "Must be a TrueType Collection font.");
              const i5 = e6.getUint16(), a5 = e6.getUint16(), s5 = e6.getInt32() >>> 0, r5 = [];
              for (let t6 = 0; t6 < s5; t6++)
                r5.push(e6.getInt32() >>> 0);
              const n4 = { ttcTag: t5, majorVersion: i5, minorVersion: a5, numFonts: s5, offsetTable: r5 };
              switch (i5) {
                case 1:
                  return n4;
                case 2:
                  n4.dsigTag = e6.getInt32() >>> 0;
                  n4.dsigLength = e6.getInt32() >>> 0;
                  n4.dsigOffset = e6.getInt32() >>> 0;
                  return n4;
              }
              throw new FormatError(`Invalid TrueType Collection majorVersion: ${i5}.`);
            }(e5), s4 = t4.split("+");
            let r4;
            for (let n4 = 0; n4 < i4; n4++) {
              e5.pos = (e5.start || 0) + a4[n4];
              const i5 = readOpenTypeHeader(e5), o4 = readTables(e5, i5.numTables);
              if (!o4.name)
                throw new FormatError('TrueType Collection font must contain a "name" table.');
              const [g4] = readNameTable(o4.name);
              for (let e6 = 0, a5 = g4.length; e6 < a5; e6++)
                for (let a6 = 0, n5 = g4[e6].length; a6 < n5; a6++) {
                  const n6 = (_a4 = g4[e6][a6]) == null ? void 0 : _a4.replaceAll(/\s/g, "");
                  if (n6) {
                    if (n6 === t4)
                      return { header: i5, tables: o4 };
                    if (!(s4.length < 2))
                      for (const e7 of s4)
                        n6 === e7 && (r4 = { name: e7, header: i5, tables: o4 });
                  }
                }
            }
            if (r4) {
              warn(`TrueType Collection does not contain "${t4}" font, falling back to "${r4.name}" font instead.`);
              return { header: r4.header, tables: r4.tables };
            }
            throw new FormatError(`TrueType Collection does not contain "${t4}" font.`);
          }(t3, this.name);
          r3 = e4.header;
          n3 = e4.tables;
        } else {
          r3 = readOpenTypeHeader(t3);
          n3 = readTables(t3, r3.numTables);
        }
        const c3 = !n3["CFF "];
        if (c3) {
          if (!n3.loca)
            throw new FormatError('Required "loca" table is not found');
          if (!n3.glyf) {
            warn('Required "glyf" table is not found -- trying to recover.');
            n3.glyf = { tag: "glyf", data: new Uint8Array(0) };
          }
          this.isOpenType = false;
        } else {
          const t4 = i3.composite && (((_a3 = i3.cidToGidMap) == null ? void 0 : _a3.length) > 0 || !(i3.cMap instanceof IdentityCMap));
          if ("OTTO" === r3.version && !t4 || !n3.head || !n3.hhea || !n3.maxp || !n3.post) {
            g3 = new Stream(n3["CFF "].data);
            o3 = new CFFFont(g3, i3);
            adjustWidths(i3);
            return this.convert(e3, o3, i3);
          }
          delete n3.glyf;
          delete n3.loca;
          delete n3.fpgm;
          delete n3.prep;
          delete n3["cvt "];
          this.isOpenType = true;
        }
        if (!n3.maxp)
          throw new FormatError('Required "maxp" table is not found');
        t3.pos = (t3.start || 0) + n3.maxp.offset;
        let C3 = t3.getInt32();
        const h2 = t3.getUint16();
        if (65536 !== C3 && 20480 !== C3) {
          if (6 === n3.maxp.length)
            C3 = 20480;
          else {
            if (!(n3.maxp.length >= 32))
              throw new FormatError('"maxp" table has a wrong version number');
            C3 = 65536;
          }
          !function writeUint32(e4, t4, i4) {
            e4[t4 + 3] = 255 & i4;
            e4[t4 + 2] = i4 >>> 8;
            e4[t4 + 1] = i4 >>> 16;
            e4[t4] = i4 >>> 24;
          }(n3.maxp.data, 0, C3);
        }
        if (((_b2 = i3.scaleFactors) == null ? void 0 : _b2.length) === h2 && c3) {
          const { scaleFactors: e4 } = i3, t4 = int16(n3.head.data[50], n3.head.data[51]), a4 = new GlyfTable({ glyfTable: n3.glyf.data, isGlyphLocationsLong: t4, locaTable: n3.loca.data, numGlyphs: h2 });
          a4.scale(e4);
          const { glyf: s4, loca: r4, isLocationLong: o4 } = a4.write();
          n3.glyf.data = s4;
          n3.loca.data = r4;
          if (o4 !== !!t4) {
            n3.head.data[50] = 0;
            n3.head.data[51] = o4 ? 1 : 0;
          }
          const g4 = n3.hmtx.data;
          for (let t5 = 0; t5 < h2; t5++) {
            const i4 = 4 * t5, a5 = Math.round(e4[t5] * int16(g4[i4], g4[i4 + 1]));
            g4[i4] = a5 >> 8 & 255;
            g4[i4 + 1] = 255 & a5;
            writeSignedInt16(g4, i4 + 2, Math.round(e4[t5] * signedInt16(g4[i4 + 2], g4[i4 + 3])));
          }
        }
        let l3 = h2 + 1, Q3 = true;
        if (l3 > 65535) {
          Q3 = false;
          l3 = h2;
          warn("Not enough space in glyfs to duplicate first glyph.");
        }
        let E3 = 0, u3 = 0;
        if (C3 >= 65536 && n3.maxp.length >= 32) {
          t3.pos += 8;
          if (t3.getUint16() > 2) {
            n3.maxp.data[14] = 0;
            n3.maxp.data[15] = 2;
          }
          t3.pos += 4;
          E3 = t3.getUint16();
          t3.pos += 4;
          u3 = t3.getUint16();
        }
        n3.maxp.data[4] = l3 >> 8;
        n3.maxp.data[5] = 255 & l3;
        const d3 = function sanitizeTTPrograms(e4, t4, i4, a4) {
          const s4 = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true };
          e4 && sanitizeTTProgram(e4, s4);
          t4 && sanitizeTTProgram(t4, s4);
          e4 && function checkInvalidFunctions(e5, t5) {
            if (!e5.tooComplexToFollowFunctions)
              if (e5.functionsDefined.length > t5) {
                warn("TT: more functions defined than expected");
                e5.hintsValid = false;
              } else
                for (let i5 = 0, a5 = e5.functionsUsed.length; i5 < a5; i5++) {
                  if (i5 > t5) {
                    warn("TT: invalid function id: " + i5);
                    e5.hintsValid = false;
                    return;
                  }
                  if (e5.functionsUsed[i5] && !e5.functionsDefined[i5]) {
                    warn("TT: undefined function: " + i5);
                    e5.hintsValid = false;
                    return;
                  }
                }
          }(s4, a4);
          if (i4 && 1 & i4.length) {
            const e5 = new Uint8Array(i4.length + 1);
            e5.set(i4.data);
            i4.data = e5;
          }
          return s4.hintsValid;
        }(n3.fpgm, n3.prep, n3["cvt "], E3);
        if (!d3) {
          delete n3.fpgm;
          delete n3.prep;
          delete n3["cvt "];
        }
        !function sanitizeMetrics(e4, t4, i4, a4, s4, r4) {
          if (!t4) {
            i4 && (i4.data = null);
            return;
          }
          e4.pos = (e4.start || 0) + t4.offset;
          e4.pos += 4;
          e4.pos += 2;
          e4.pos += 2;
          e4.pos += 2;
          e4.pos += 2;
          e4.pos += 2;
          e4.pos += 2;
          e4.pos += 2;
          e4.pos += 2;
          e4.pos += 2;
          const n4 = e4.getUint16();
          e4.pos += 8;
          e4.pos += 2;
          let o4 = e4.getUint16();
          if (0 !== n4) {
            if (!(2 & int16(a4.data[44], a4.data[45]))) {
              t4.data[22] = 0;
              t4.data[23] = 0;
            }
          }
          if (o4 > s4) {
            info(`The numOfMetrics (${o4}) should not be greater than the numGlyphs (${s4}).`);
            o4 = s4;
            t4.data[34] = (65280 & o4) >> 8;
            t4.data[35] = 255 & o4;
          }
          const g4 = s4 - o4 - (i4.length - 4 * o4 >> 1);
          if (g4 > 0) {
            const e5 = new Uint8Array(i4.length + 2 * g4);
            e5.set(i4.data);
            if (r4) {
              e5[i4.length] = i4.data[2];
              e5[i4.length + 1] = i4.data[3];
            }
            i4.data = e5;
          }
        }(t3, n3.hhea, n3.hmtx, n3.head, l3, Q3);
        if (!n3.head)
          throw new FormatError('Required "head" table is not found');
        !function sanitizeHead(e4, t4, i4) {
          const a4 = e4.data, s4 = function int32(e5, t5, i5, a5) {
            return (e5 << 24) + (t5 << 16) + (i5 << 8) + a5;
          }(a4[0], a4[1], a4[2], a4[3]);
          if (s4 >> 16 != 1) {
            info("Attempting to fix invalid version in head table: " + s4);
            a4[0] = 0;
            a4[1] = 1;
            a4[2] = 0;
            a4[3] = 0;
          }
          const r4 = int16(a4[50], a4[51]);
          if (r4 < 0 || r4 > 1) {
            info("Attempting to fix invalid indexToLocFormat in head table: " + r4);
            const e5 = t4 + 1;
            if (i4 === e5 << 1) {
              a4[50] = 0;
              a4[51] = 0;
            } else {
              if (i4 !== e5 << 2)
                throw new FormatError("Could not fix indexToLocFormat: " + r4);
              a4[50] = 0;
              a4[51] = 1;
            }
          }
        }(n3.head, h2, c3 ? n3.loca.length : 0);
        let f2 = /* @__PURE__ */ Object.create(null);
        if (c3) {
          const e4 = int16(n3.head.data[50], n3.head.data[51]), t4 = function sanitizeGlyphLocations(e5, t5, i4, a4, s4, r4, n4) {
            let o4, g4, c4;
            if (a4) {
              o4 = 4;
              g4 = function fontItemDecodeLong(e6, t6) {
                return e6[t6] << 24 | e6[t6 + 1] << 16 | e6[t6 + 2] << 8 | e6[t6 + 3];
              };
              c4 = function fontItemEncodeLong(e6, t6, i5) {
                e6[t6] = i5 >>> 24 & 255;
                e6[t6 + 1] = i5 >> 16 & 255;
                e6[t6 + 2] = i5 >> 8 & 255;
                e6[t6 + 3] = 255 & i5;
              };
            } else {
              o4 = 2;
              g4 = function fontItemDecode(e6, t6) {
                return e6[t6] << 9 | e6[t6 + 1] << 1;
              };
              c4 = function fontItemEncode(e6, t6, i5) {
                e6[t6] = i5 >> 9 & 255;
                e6[t6 + 1] = i5 >> 1 & 255;
              };
            }
            const C4 = r4 ? i4 + 1 : i4, h3 = o4 * (1 + C4), l4 = new Uint8Array(h3);
            l4.set(e5.data.subarray(0, h3));
            e5.data = l4;
            const Q4 = t5.data, E4 = Q4.length, u4 = new Uint8Array(E4);
            let d4, f3;
            const p3 = [];
            for (d4 = 0, f3 = 0; d4 < i4 + 1; d4++, f3 += o4) {
              let e6 = g4(l4, f3);
              e6 > E4 && (e6 = E4);
              p3.push({ index: d4, offset: e6, endOffset: 0 });
            }
            p3.sort((e6, t6) => e6.offset - t6.offset);
            for (d4 = 0; d4 < i4; d4++)
              p3[d4].endOffset = p3[d4 + 1].offset;
            p3.sort((e6, t6) => e6.index - t6.index);
            for (d4 = 0; d4 < i4; d4++) {
              const { offset: e6, endOffset: t6 } = p3[d4];
              if (0 !== e6 || 0 !== t6)
                break;
              const i5 = p3[d4 + 1].offset;
              if (0 !== i5) {
                p3[d4].endOffset = i5;
                break;
              }
            }
            const m4 = p3.at(-2);
            0 !== m4.offset && 0 === m4.endOffset && (m4.endOffset = E4);
            const y4 = /* @__PURE__ */ Object.create(null);
            let w4 = 0;
            c4(l4, 0, w4);
            for (d4 = 0, f3 = o4; d4 < i4; d4++, f3 += o4) {
              const e6 = sanitizeGlyph(Q4, p3[d4].offset, p3[d4].endOffset, u4, w4, s4), t6 = e6.length;
              0 === t6 && (y4[d4] = true);
              e6.sizeOfInstructions > n4 && (n4 = e6.sizeOfInstructions);
              w4 += t6;
              c4(l4, f3, w4);
            }
            if (0 === w4) {
              const e6 = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
              for (d4 = 0, f3 = o4; d4 < C4; d4++, f3 += o4)
                c4(l4, f3, e6.length);
              t5.data = e6;
            } else if (r4) {
              const i5 = g4(l4, o4);
              if (u4.length > i5 + w4)
                t5.data = u4.subarray(0, i5 + w4);
              else {
                t5.data = new Uint8Array(i5 + w4);
                t5.data.set(u4.subarray(0, w4));
              }
              t5.data.set(u4.subarray(0, i5), w4);
              c4(e5.data, l4.length - o4, w4 + i5);
            } else
              t5.data = u4.subarray(0, w4);
            return { missingGlyphs: y4, maxSizeOfInstructions: n4 };
          }(n3.loca, n3.glyf, h2, e4, d3, Q3, u3);
          f2 = t4.missingGlyphs;
          if (C3 >= 65536 && n3.maxp.length >= 32) {
            n3.maxp.data[26] = t4.maxSizeOfInstructions >> 8;
            n3.maxp.data[27] = 255 & t4.maxSizeOfInstructions;
          }
        }
        if (!n3.hhea)
          throw new FormatError('Required "hhea" table is not found');
        if (0 === n3.hhea.data[10] && 0 === n3.hhea.data[11]) {
          n3.hhea.data[10] = 255;
          n3.hhea.data[11] = 255;
        }
        const p2 = { unitsPerEm: int16(n3.head.data[18], n3.head.data[19]), yMax: signedInt16(n3.head.data[42], n3.head.data[43]), yMin: signedInt16(n3.head.data[38], n3.head.data[39]), ascent: signedInt16(n3.hhea.data[4], n3.hhea.data[5]), descent: signedInt16(n3.hhea.data[6], n3.hhea.data[7]), lineGap: signedInt16(n3.hhea.data[8], n3.hhea.data[9]) };
        this.ascent = p2.ascent / p2.unitsPerEm;
        this.descent = p2.descent / p2.unitsPerEm;
        this.lineGap = p2.lineGap / p2.unitsPerEm;
        if ((_c2 = this.cssFontInfo) == null ? void 0 : _c2.lineHeight) {
          this.lineHeight = this.cssFontInfo.metrics.lineHeight;
          this.lineGap = this.cssFontInfo.metrics.lineGap;
        } else
          this.lineHeight = this.ascent - this.descent + this.lineGap;
        n3.post && function readPostScriptTable(e4, i4, a4) {
          const s4 = (t3.start || 0) + e4.offset;
          t3.pos = s4;
          const r4 = s4 + e4.length, n4 = t3.getInt32();
          t3.skip(28);
          let o4, g4, c4 = true;
          switch (n4) {
            case 65536:
              o4 = Oi;
              break;
            case 131072:
              const e5 = t3.getUint16();
              if (e5 !== a4) {
                c4 = false;
                break;
              }
              const s5 = [];
              for (g4 = 0; g4 < e5; ++g4) {
                const e6 = t3.getUint16();
                if (e6 >= 32768) {
                  c4 = false;
                  break;
                }
                s5.push(e6);
              }
              if (!c4)
                break;
              const C4 = [], h3 = [];
              for (; t3.pos < r4; ) {
                const e6 = t3.getByte();
                h3.length = e6;
                for (g4 = 0; g4 < e6; ++g4)
                  h3[g4] = String.fromCharCode(t3.getByte());
                C4.push(h3.join(""));
              }
              o4 = [];
              for (g4 = 0; g4 < e5; ++g4) {
                const e6 = s5[g4];
                e6 < 258 ? o4.push(Oi[e6]) : o4.push(C4[e6 - 258]);
              }
              break;
            case 196608:
              break;
            default:
              warn("Unknown/unsupported post table version " + n4);
              c4 = false;
              i4.defaultEncoding && (o4 = i4.defaultEncoding);
          }
          i4.glyphNames = o4;
          return c4;
        }(n3.post, i3, h2);
        n3.post = { tag: "post", data: createPostTable(i3) };
        const m3 = [];
        function hasGlyph(e4) {
          return !f2[e4];
        }
        if (i3.composite) {
          const e4 = i3.cidToGidMap || [], t4 = 0 === e4.length;
          i3.cMap.forEach(function(i4, a4) {
            "string" == typeof a4 && (a4 = convertCidString(i4, a4, true));
            if (a4 > 65535)
              throw new FormatError("Max size of CID is 65,535");
            let s4 = -1;
            t4 ? s4 = a4 : void 0 !== e4[a4] && (s4 = e4[a4]);
            s4 >= 0 && s4 < h2 && hasGlyph(s4) && (m3[i4] = s4);
          });
        } else {
          const e4 = function readCmapTable(e5, t4, i4, a5) {
            if (!e5) {
              warn("No cmap table available.");
              return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
            }
            let s5, r5 = (t4.start || 0) + e5.offset;
            t4.pos = r5;
            t4.skip(2);
            const n4 = t4.getUint16();
            let o5, g5 = false;
            for (let e6 = 0; e6 < n4; e6++) {
              const s6 = t4.getUint16(), r6 = t4.getUint16(), c5 = t4.getInt32() >>> 0;
              let C5 = false;
              if ((o5 == null ? void 0 : o5.platformId) !== s6 || (o5 == null ? void 0 : o5.encodingId) !== r6) {
                if (0 !== s6 || 0 !== r6 && 1 !== r6 && 3 !== r6)
                  if (1 === s6 && 0 === r6)
                    C5 = true;
                  else if (3 !== s6 || 1 !== r6 || !a5 && o5) {
                    if (i4 && 3 === s6 && 0 === r6) {
                      C5 = true;
                      let i5 = true;
                      if (e6 < n4 - 1) {
                        const e7 = t4.peekBytes(2);
                        int16(e7[0], e7[1]) < s6 && (i5 = false);
                      }
                      i5 && (g5 = true);
                    }
                  } else {
                    C5 = true;
                    i4 || (g5 = true);
                  }
                else
                  C5 = true;
                C5 && (o5 = { platformId: s6, encodingId: r6, offset: c5 });
                if (g5)
                  break;
              }
            }
            o5 && (t4.pos = r5 + o5.offset);
            if (!o5 || -1 === t4.peekByte()) {
              warn("Could not find a preferred cmap table.");
              return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
            }
            const c4 = t4.getUint16();
            let C4 = false;
            const h3 = [];
            let l4, Q4;
            if (0 === c4) {
              t4.skip(4);
              for (l4 = 0; l4 < 256; l4++) {
                const e6 = t4.getByte();
                e6 && h3.push({ charCode: l4, glyphId: e6 });
              }
              C4 = true;
            } else if (2 === c4) {
              t4.skip(4);
              const e6 = [];
              let i5 = 0;
              for (let a7 = 0; a7 < 256; a7++) {
                const a8 = t4.getUint16() >> 3;
                e6.push(a8);
                i5 = Math.max(a8, i5);
              }
              const a6 = [];
              for (let e7 = 0; e7 <= i5; e7++)
                a6.push({ firstCode: t4.getUint16(), entryCount: t4.getUint16(), idDelta: signedInt16(t4.getByte(), t4.getByte()), idRangePos: t4.pos + t4.getUint16() });
              for (let i6 = 0; i6 < 256; i6++)
                if (0 === e6[i6]) {
                  t4.pos = a6[0].idRangePos + 2 * i6;
                  Q4 = t4.getUint16();
                  h3.push({ charCode: i6, glyphId: Q4 });
                } else {
                  const s6 = a6[e6[i6]];
                  for (l4 = 0; l4 < s6.entryCount; l4++) {
                    const e7 = (i6 << 8) + l4 + s6.firstCode;
                    t4.pos = s6.idRangePos + 2 * l4;
                    Q4 = t4.getUint16();
                    0 !== Q4 && (Q4 = (Q4 + s6.idDelta) % 65536);
                    h3.push({ charCode: e7, glyphId: Q4 });
                  }
                }
            } else if (4 === c4) {
              t4.skip(4);
              const e6 = t4.getUint16() >> 1;
              t4.skip(6);
              const i5 = [];
              let a6;
              for (a6 = 0; a6 < e6; a6++)
                i5.push({ end: t4.getUint16() });
              t4.skip(2);
              for (a6 = 0; a6 < e6; a6++)
                i5[a6].start = t4.getUint16();
              for (a6 = 0; a6 < e6; a6++)
                i5[a6].delta = t4.getUint16();
              let n5, o6 = 0;
              for (a6 = 0; a6 < e6; a6++) {
                s5 = i5[a6];
                const r6 = t4.getUint16();
                if (r6) {
                  n5 = (r6 >> 1) - (e6 - a6);
                  s5.offsetIndex = n5;
                  o6 = Math.max(o6, n5 + s5.end - s5.start + 1);
                } else
                  s5.offsetIndex = -1;
              }
              const g6 = [];
              for (l4 = 0; l4 < o6; l4++)
                g6.push(t4.getUint16());
              for (a6 = 0; a6 < e6; a6++) {
                s5 = i5[a6];
                r5 = s5.start;
                const e7 = s5.end, t5 = s5.delta;
                n5 = s5.offsetIndex;
                for (l4 = r5; l4 <= e7; l4++)
                  if (65535 !== l4) {
                    Q4 = n5 < 0 ? l4 : g6[n5 + l4 - r5];
                    Q4 = Q4 + t5 & 65535;
                    h3.push({ charCode: l4, glyphId: Q4 });
                  }
              }
            } else if (6 === c4) {
              t4.skip(4);
              const e6 = t4.getUint16(), i5 = t4.getUint16();
              for (l4 = 0; l4 < i5; l4++) {
                Q4 = t4.getUint16();
                const i6 = e6 + l4;
                h3.push({ charCode: i6, glyphId: Q4 });
              }
            } else {
              if (12 !== c4) {
                warn("cmap table has unsupported format: " + c4);
                return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
              }
              {
                t4.skip(10);
                const e6 = t4.getInt32() >>> 0;
                for (l4 = 0; l4 < e6; l4++) {
                  const e7 = t4.getInt32() >>> 0, i5 = t4.getInt32() >>> 0;
                  let a6 = t4.getInt32() >>> 0;
                  for (let t5 = e7; t5 <= i5; t5++)
                    h3.push({ charCode: t5, glyphId: a6++ });
                }
              }
            }
            h3.sort(function(e6, t5) {
              return e6.charCode - t5.charCode;
            });
            for (let e6 = 1; e6 < h3.length; e6++)
              if (h3[e6 - 1].charCode === h3[e6].charCode) {
                h3.splice(e6, 1);
                e6--;
              }
            return { platformId: o5.platformId, encodingId: o5.encodingId, mappings: h3, hasShortCmap: C4 };
          }(n3.cmap, t3, this.isSymbolicFont, i3.hasEncoding), a4 = e4.platformId, s4 = e4.encodingId, r4 = e4.mappings;
          let o4 = [], g4 = false;
          !i3.hasEncoding || "MacRomanEncoding" !== i3.baseEncodingName && "WinAnsiEncoding" !== i3.baseEncodingName || (o4 = getEncoding(i3.baseEncodingName));
          if (i3.hasEncoding && !this.isSymbolicFont && (3 === a4 && 1 === s4 || 1 === a4 && 0 === s4)) {
            const e5 = Ri();
            for (let t4 = 0; t4 < 256; t4++) {
              let n4;
              n4 = void 0 !== this.differences[t4] ? this.differences[t4] : o4.length && "" !== o4[t4] ? o4[t4] : fi[t4];
              if (!n4)
                continue;
              const g5 = recoverGlyphName(n4, e5);
              let c4;
              3 === a4 && 1 === s4 ? c4 = e5[g5] : 1 === a4 && 0 === s4 && (c4 = di.indexOf(g5));
              if (void 0 === c4) {
                if (!i3.glyphNames && i3.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
                  const e6 = this.toUnicode.get(t4);
                  e6 && (c4 = e6.codePointAt(0));
                }
                if (void 0 === c4)
                  continue;
              }
              for (const e6 of r4)
                if (e6.charCode === c4) {
                  m3[t4] = e6.glyphId;
                  break;
                }
            }
          } else if (0 === a4) {
            for (const e5 of r4)
              m3[e5.charCode] = e5.glyphId;
            g4 = true;
          } else if (3 === a4 && 0 === s4)
            for (const e5 of r4) {
              let t4 = e5.charCode;
              t4 >= 61440 && t4 <= 61695 && (t4 &= 255);
              m3[t4] = e5.glyphId;
            }
          else
            for (const e5 of r4)
              m3[e5.charCode] = e5.glyphId;
          if (i3.glyphNames && (o4.length || this.differences.length))
            for (let e5 = 0; e5 < 256; ++e5) {
              if (!g4 && void 0 !== m3[e5])
                continue;
              const t4 = this.differences[e5] || o4[e5];
              if (!t4)
                continue;
              const a5 = i3.glyphNames.indexOf(t4);
              a5 > 0 && hasGlyph(a5) && (m3[e5] = a5);
            }
        }
        0 === m3.length && (m3[0] = 0);
        let y3 = l3 - 1;
        Q3 || (y3 = 0);
        if (!i3.cssFontInfo) {
          const e4 = adjustMapping(m3, hasGlyph, y3, this.toUnicode);
          this.toFontChar = e4.toFontChar;
          n3.cmap = { tag: "cmap", data: createCmapTable(e4.charCodeToGlyphId, e4.toUnicodeExtraMap, l3) };
          n3["OS/2"] && function validateOS2Table(e5, t4) {
            t4.pos = (t4.start || 0) + e5.offset;
            const i4 = t4.getUint16();
            t4.skip(60);
            const a4 = t4.getUint16();
            if (i4 < 4 && 768 & a4)
              return false;
            if (t4.getUint16() > t4.getUint16())
              return false;
            t4.skip(6);
            if (0 === t4.getUint16())
              return false;
            e5.data[8] = e5.data[9] = 0;
            return true;
          }(n3["OS/2"], t3) || (n3["OS/2"] = { tag: "OS/2", data: createOS2Table(i3, e4.charCodeToGlyphId, p2) });
        }
        if (!c3)
          try {
            g3 = new Stream(n3["CFF "].data);
            o3 = new CFFParser(g3, i3, Yi).parse();
            o3.duplicateFirstGlyph();
            const e4 = new CFFCompiler(o3);
            n3["CFF "].data = e4.compile();
          } catch {
            warn("Failed to compile font " + i3.loadedName);
          }
        if (n3.name) {
          const [t4, a4] = readNameTable(n3.name);
          n3.name.data = createNameTable(e3, t4);
          this.psName = t4[0][6] || null;
          i3.composite || function adjustTrueTypeToUnicode(e4, t5, i4) {
            if (e4.isInternalFont)
              return;
            if (e4.hasIncludedToUnicodeMap)
              return;
            if (e4.hasEncoding)
              return;
            if (e4.toUnicode instanceof IdentityToUnicodeMap)
              return;
            if (!t5)
              return;
            if (0 === i4.length)
              return;
            if (e4.defaultEncoding === pi)
              return;
            for (const e5 of i4)
              if (!isWinNameRecord(e5))
                return;
            const a5 = pi, s4 = [], r4 = Ri();
            for (const e5 in a5) {
              const t6 = a5[e5];
              if ("" === t6)
                continue;
              const i5 = r4[t6];
              void 0 !== i5 && (s4[e5] = String.fromCharCode(i5));
            }
            s4.length > 0 && e4.toUnicode.amend(s4);
          }(i3, this.isSymbolicFont, a4);
        } else
          n3.name = { tag: "name", data: createNameTable(this.name) };
        const w3 = new OpenTypeFileBuilder(r3.version);
        for (const e4 in n3)
          w3.addTable(e4, n3[e4].data);
        return w3.toArray();
      }
      convert(e3, t3, i3) {
        i3.fixedPitch = false;
        i3.builtInEncoding && function adjustType1ToUnicode(e4, t4) {
          if (e4.isInternalFont)
            return;
          if (e4.hasIncludedToUnicodeMap)
            return;
          if (t4 === e4.defaultEncoding)
            return;
          if (e4.toUnicode instanceof IdentityToUnicodeMap)
            return;
          const i4 = [], a3 = Ri();
          for (const s4 in t4) {
            if (e4.hasEncoding && (e4.baseEncodingName || void 0 !== e4.differences[s4]))
              continue;
            const r4 = getUnicodeForGlyph(t4[s4], a3);
            -1 !== r4 && (i4[s4] = String.fromCharCode(r4));
          }
          i4.length > 0 && e4.toUnicode.amend(i4);
        }(i3, i3.builtInEncoding);
        let s3 = 1;
        t3 instanceof CFFFont && (s3 = t3.numGlyphs - 1);
        const r3 = t3.getGlyphMapping(i3);
        let n3 = null, o3 = r3, g3 = null;
        if (!i3.cssFontInfo) {
          n3 = adjustMapping(r3, t3.hasGlyphId.bind(t3), s3, this.toUnicode);
          this.toFontChar = n3.toFontChar;
          o3 = n3.charCodeToGlyphId;
          g3 = n3.toUnicodeExtraMap;
        }
        const c3 = t3.numGlyphs;
        function getCharCodes(e4, t4) {
          let i4 = null;
          for (const a3 in e4)
            t4 === e4[a3] && (i4 || (i4 = [])).push(0 | a3);
          return i4;
        }
        function createCharCode(e4, t4) {
          for (const i4 in e4)
            if (t4 === e4[i4])
              return 0 | i4;
          n3.charCodeToGlyphId[n3.nextAvailableFontCharCode] = t4;
          return n3.nextAvailableFontCharCode++;
        }
        const C3 = t3.seacs;
        if (n3 && (C3 == null ? void 0 : C3.length)) {
          const e4 = i3.fontMatrix || a2, s4 = t3.getCharset(), o4 = /* @__PURE__ */ Object.create(null);
          for (let t4 in C3) {
            t4 |= 0;
            const i4 = C3[t4], a3 = fi[i4[2]], g4 = fi[i4[3]], c4 = s4.indexOf(a3), h3 = s4.indexOf(g4);
            if (c4 < 0 || h3 < 0)
              continue;
            const l4 = { x: i4[0] * e4[0] + i4[1] * e4[2] + e4[4], y: i4[0] * e4[1] + i4[1] * e4[3] + e4[5] }, Q3 = getCharCodes(r3, t4);
            if (Q3)
              for (const e5 of Q3) {
                const t5 = n3.charCodeToGlyphId, i5 = createCharCode(t5, c4), a4 = createCharCode(t5, h3);
                o4[e5] = { baseFontCharCode: i5, accentFontCharCode: a4, accentOffset: l4 };
              }
          }
          i3.seacMap = o4;
        }
        const h2 = 1 / (i3.fontMatrix || a2)[0], l3 = new OpenTypeFileBuilder("OTTO");
        l3.addTable("CFF ", t3.data);
        l3.addTable("OS/2", createOS2Table(i3, o3));
        l3.addTable("cmap", createCmapTable(o3, g3, c3));
        l3.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + safeString16(h2) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(i3.descent) + "ÿ" + safeString16(i3.ascent) + string16(i3.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
        l3.addTable("hhea", "\0\0\0" + safeString16(i3.ascent) + safeString16(i3.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + safeString16(i3.capHeight) + safeString16(Math.tan(i3.italicAngle) * i3.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(c3));
        l3.addTable("hmtx", function fontFieldsHmtx() {
          const e4 = t3.charstrings, i4 = t3.cff ? t3.cff.widths : null;
          let a3 = "\0\0\0\0";
          for (let t4 = 1, s4 = c3; t4 < s4; t4++) {
            let s5 = 0;
            if (e4) {
              const i5 = e4[t4 - 1];
              s5 = "width" in i5 ? i5.width : 0;
            } else
              i4 && (s5 = Math.ceil(i4[t4] || 0));
            a3 += string16(s5) + string16(0);
          }
          return a3;
        }());
        l3.addTable("maxp", "\0\0P\0" + string16(c3));
        l3.addTable("name", createNameTable(e3));
        l3.addTable("post", createPostTable(i3));
        return l3.toArray();
      }
      get spaceWidth() {
        const e3 = ["space", "minus", "one", "i", "I"];
        let t3;
        for (const i3 of e3) {
          if (i3 in this.widths) {
            t3 = this.widths[i3];
            break;
          }
          const e4 = Ri()[i3];
          let a3 = 0;
          if (this.composite && this.cMap.contains(e4)) {
            a3 = this.cMap.lookup(e4);
            "string" == typeof a3 && (a3 = convertCidString(e4, a3));
          }
          !a3 && this.toUnicode && (a3 = this.toUnicode.charCodeOf(e4));
          a3 <= 0 && (a3 = e4);
          t3 = this.widths[a3];
          if (t3)
            break;
        }
        return shadow(this, "spaceWidth", t3 || this.defaultWidth);
      }
      _charToGlyph(e3, t3 = false) {
        var _a3, _b2, _c2;
        let i3, a3, s3, r3 = this._glyphCache[e3];
        if ((r3 == null ? void 0 : r3.isSpace) === t3)
          return r3;
        let n3 = e3;
        if ((_a3 = this.cMap) == null ? void 0 : _a3.contains(e3)) {
          n3 = this.cMap.lookup(e3);
          "string" == typeof n3 && (n3 = convertCidString(e3, n3));
        }
        a3 = this.widths[n3];
        "number" != typeof a3 && (a3 = this.defaultWidth);
        const o3 = (_b2 = this.vmetrics) == null ? void 0 : _b2[n3];
        let g3 = this.toUnicode.get(e3) || e3;
        "number" == typeof g3 && (g3 = String.fromCharCode(g3));
        let c3 = void 0 !== this.toFontChar[e3];
        i3 = this.toFontChar[e3] || e3;
        if (this.missingFile) {
          const t4 = this.differences[e3] || this.defaultEncoding[e3];
          ".notdef" !== t4 && "" !== t4 || "Type1" !== this.type || (i3 = 32);
          i3 = function mapSpecialUnicodeValues(e4) {
            return e4 >= 65520 && e4 <= 65535 ? 0 : e4 >= 62976 && e4 <= 63743 ? xi()[e4] || e4 : 173 === e4 ? 45 : e4;
          }(i3);
        }
        this.isType3Font && (s3 = i3);
        let C3 = null;
        if ((_c2 = this.seacMap) == null ? void 0 : _c2[e3]) {
          c3 = true;
          const t4 = this.seacMap[e3];
          i3 = t4.baseFontCharCode;
          C3 = { fontChar: String.fromCodePoint(t4.accentFontCharCode), offset: t4.accentOffset };
        }
        let h2 = "";
        "number" == typeof i3 && (i3 <= 1114111 ? h2 = String.fromCodePoint(i3) : warn(`charToGlyph - invalid fontCharCode: ${i3}`));
        r3 = new fonts_Glyph(e3, h2, g3, C3, a3, o3, s3, t3, c3);
        return this._glyphCache[e3] = r3;
      }
      charsToGlyphs(e3) {
        let t3 = this._charsCache[e3];
        if (t3)
          return t3;
        t3 = [];
        if (this.cMap) {
          const i3 = /* @__PURE__ */ Object.create(null), a3 = e3.length;
          let s3 = 0;
          for (; s3 < a3; ) {
            this.cMap.readCharCode(e3, s3, i3);
            const { charcode: a4, length: r3 } = i3;
            s3 += r3;
            const n3 = this._charToGlyph(a4, 1 === r3 && 32 === e3.charCodeAt(s3 - 1));
            t3.push(n3);
          }
        } else
          for (let i3 = 0, a3 = e3.length; i3 < a3; ++i3) {
            const a4 = e3.charCodeAt(i3), s3 = this._charToGlyph(a4, 32 === a4);
            t3.push(s3);
          }
        return this._charsCache[e3] = t3;
      }
      getCharPositions(e3) {
        const t3 = [];
        if (this.cMap) {
          const i3 = /* @__PURE__ */ Object.create(null);
          let a3 = 0;
          for (; a3 < e3.length; ) {
            this.cMap.readCharCode(e3, a3, i3);
            const s3 = i3.length;
            t3.push([a3, a3 + s3]);
            a3 += s3;
          }
        } else
          for (let i3 = 0, a3 = e3.length; i3 < a3; ++i3)
            t3.push([i3, i3 + 1]);
        return t3;
      }
      get glyphCacheValues() {
        return Object.values(this._glyphCache);
      }
      encodeString(e3) {
        const t3 = [], i3 = [], hasCurrentBufErrors = () => t3.length % 2 == 1, a3 = this.toUnicode instanceof IdentityToUnicodeMap ? (e4) => this.toUnicode.charCodeOf(e4) : (e4) => this.toUnicode.charCodeOf(String.fromCodePoint(e4));
        for (let s3 = 0, r3 = e3.length; s3 < r3; s3++) {
          const r4 = e3.codePointAt(s3);
          r4 > 55295 && (r4 < 57344 || r4 > 65533) && s3++;
          if (this.toUnicode) {
            const e4 = a3(r4);
            if (-1 !== e4) {
              if (hasCurrentBufErrors()) {
                t3.push(i3.join(""));
                i3.length = 0;
              }
              for (let t4 = (this.cMap ? this.cMap.getCharCodeLength(e4) : 1) - 1; t4 >= 0; t4--)
                i3.push(String.fromCharCode(e4 >> 8 * t4 & 255));
              continue;
            }
          }
          if (!hasCurrentBufErrors()) {
            t3.push(i3.join(""));
            i3.length = 0;
          }
          i3.push(String.fromCodePoint(r4));
        }
        t3.push(i3.join(""));
        return t3;
      }
    };
    ErrorFont = class {
      constructor(e3) {
        this.error = e3;
        this.loadedName = "g_font_error";
        this.missingFile = true;
      }
      charsToGlyphs() {
        return [];
      }
      encodeString(e3) {
        return [e3];
      }
      exportData(e3 = false) {
        return { error: this.error };
      }
    };
    Ea = 2;
    ua = 3;
    da = 4;
    fa = 5;
    pa = 6;
    ma = 7;
    Pattern = class {
      constructor() {
        unreachable("Cannot initialize Pattern.");
      }
      static parseShading(e3, t3, i3, a3, s3) {
        const r3 = e3 instanceof BaseStream ? e3.dict : e3, n3 = r3.get("ShadingType");
        try {
          switch (n3) {
            case Ea:
            case ua:
              return new RadialAxialShading(r3, t3, i3, a3, s3);
            case da:
            case fa:
            case pa:
            case ma:
              return new MeshShading(e3, t3, i3, a3, s3);
            default:
              throw new FormatError("Unsupported ShadingType: " + n3);
          }
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn(e4);
          return new DummyShading();
        }
      }
    };
    _BaseShading = class _BaseShading {
      constructor() {
        this.constructor === _BaseShading && unreachable("Cannot initialize BaseShading.");
      }
      getIR() {
        unreachable("Abstract method `getIR` called.");
      }
    };
    __publicField(_BaseShading, "SMALL_NUMBER", 1e-6);
    BaseShading = _BaseShading;
    RadialAxialShading = class extends BaseShading {
      constructor(e3, t3, i3, a3, s3) {
        super();
        this.coordsArr = e3.getArray("Coords");
        this.shadingType = e3.get("ShadingType");
        const r3 = ColorSpace.parse({ cs: e3.getRaw("CS") || e3.getRaw("ColorSpace"), xref: t3, resources: i3, pdfFunctionFactory: a3, localColorSpaceCache: s3 }), n3 = e3.getArray("BBox");
        this.bbox = Array.isArray(n3) && 4 === n3.length ? Util.normalizeRect(n3) : null;
        let o3 = 0, g3 = 1;
        if (e3.has("Domain")) {
          const t4 = e3.getArray("Domain");
          o3 = t4[0];
          g3 = t4[1];
        }
        let c3 = false, C3 = false;
        if (e3.has("Extend")) {
          const t4 = e3.getArray("Extend");
          c3 = t4[0];
          C3 = t4[1];
        }
        if (!(this.shadingType !== ua || c3 && C3)) {
          const [e4, t4, i4, a4, s4, r4] = this.coordsArr, n4 = Math.hypot(e4 - a4, t4 - s4);
          i4 <= r4 + n4 && r4 <= i4 + n4 && warn("Unsupported radial gradient.");
        }
        this.extendStart = c3;
        this.extendEnd = C3;
        const h2 = e3.getRaw("Function"), l3 = a3.createFromArray(h2), Q3 = (g3 - o3) / 840, E3 = this.colorStops = [];
        if (o3 >= g3 || Q3 <= 0) {
          info("Bad shading domain.");
          return;
        }
        const u3 = new Float32Array(r3.numComps), d3 = new Float32Array(1);
        let f2, p2 = 0;
        d3[0] = o3;
        l3(d3, 0, u3, 0);
        let m3 = r3.getRgb(u3, 0);
        const y3 = Util.makeHexColor(m3[0], m3[1], m3[2]);
        E3.push([0, y3]);
        let w3 = 1;
        d3[0] = o3 + Q3;
        l3(d3, 0, u3, 0);
        let b3 = r3.getRgb(u3, 0), D3 = b3[0] - m3[0] + 1, F3 = b3[1] - m3[1] + 1, S3 = b3[2] - m3[2] + 1, k3 = b3[0] - m3[0] - 1, N3 = b3[1] - m3[1] - 1, R3 = b3[2] - m3[2] - 1;
        for (let e4 = 2; e4 < 840; e4++) {
          d3[0] = o3 + e4 * Q3;
          l3(d3, 0, u3, 0);
          f2 = r3.getRgb(u3, 0);
          const t4 = e4 - p2;
          D3 = Math.min(D3, (f2[0] - m3[0] + 1) / t4);
          F3 = Math.min(F3, (f2[1] - m3[1] + 1) / t4);
          S3 = Math.min(S3, (f2[2] - m3[2] + 1) / t4);
          k3 = Math.max(k3, (f2[0] - m3[0] - 1) / t4);
          N3 = Math.max(N3, (f2[1] - m3[1] - 1) / t4);
          R3 = Math.max(R3, (f2[2] - m3[2] - 1) / t4);
          if (!(k3 <= D3 && N3 <= F3 && R3 <= S3)) {
            const e5 = Util.makeHexColor(b3[0], b3[1], b3[2]);
            E3.push([w3 / 840, e5]);
            D3 = f2[0] - b3[0] + 1;
            F3 = f2[1] - b3[1] + 1;
            S3 = f2[2] - b3[2] + 1;
            k3 = f2[0] - b3[0] - 1;
            N3 = f2[1] - b3[1] - 1;
            R3 = f2[2] - b3[2] - 1;
            p2 = w3;
            m3 = b3;
          }
          w3 = e4;
          b3 = f2;
        }
        const G3 = Util.makeHexColor(b3[0], b3[1], b3[2]);
        E3.push([1, G3]);
        let x3 = "transparent";
        if (e3.has("Background")) {
          f2 = r3.getRgb(e3.get("Background"), 0);
          x3 = Util.makeHexColor(f2[0], f2[1], f2[2]);
        }
        if (!c3) {
          E3.unshift([0, x3]);
          E3[1][0] += BaseShading.SMALL_NUMBER;
        }
        if (!C3) {
          E3.at(-1)[0] -= BaseShading.SMALL_NUMBER;
          E3.push([1, x3]);
        }
        this.colorStops = E3;
      }
      getIR() {
        const e3 = this.coordsArr, t3 = this.shadingType;
        let i3, a3, s3, r3, n3;
        if (t3 === Ea) {
          a3 = [e3[0], e3[1]];
          s3 = [e3[2], e3[3]];
          r3 = null;
          n3 = null;
          i3 = "axial";
        } else if (t3 === ua) {
          a3 = [e3[0], e3[1]];
          s3 = [e3[3], e3[4]];
          r3 = e3[2];
          n3 = e3[5];
          i3 = "radial";
        } else
          unreachable(`getPattern type unknown: ${t3}`);
        return ["RadialAxial", i3, this.bbox, this.colorStops, a3, s3, r3, n3];
      }
    };
    MeshStreamReader = class {
      constructor(e3, t3) {
        this.stream = e3;
        this.context = t3;
        this.buffer = 0;
        this.bufferLength = 0;
        const i3 = t3.numComps;
        this.tmpCompsBuf = new Float32Array(i3);
        const a3 = t3.colorSpace.numComps;
        this.tmpCsCompsBuf = t3.colorFn ? new Float32Array(a3) : this.tmpCompsBuf;
      }
      get hasData() {
        if (this.stream.end)
          return this.stream.pos < this.stream.end;
        if (this.bufferLength > 0)
          return true;
        const e3 = this.stream.getByte();
        if (e3 < 0)
          return false;
        this.buffer = e3;
        this.bufferLength = 8;
        return true;
      }
      readBits(e3) {
        let t3 = this.buffer, i3 = this.bufferLength;
        if (32 === e3) {
          if (0 === i3)
            return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
          t3 = t3 << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
          const e4 = this.stream.getByte();
          this.buffer = e4 & (1 << i3) - 1;
          return (t3 << 8 - i3 | (255 & e4) >> i3) >>> 0;
        }
        if (8 === e3 && 0 === i3)
          return this.stream.getByte();
        for (; i3 < e3; ) {
          t3 = t3 << 8 | this.stream.getByte();
          i3 += 8;
        }
        i3 -= e3;
        this.bufferLength = i3;
        this.buffer = t3 & (1 << i3) - 1;
        return t3 >> i3;
      }
      align() {
        this.buffer = 0;
        this.bufferLength = 0;
      }
      readFlag() {
        return this.readBits(this.context.bitsPerFlag);
      }
      readCoordinate() {
        const e3 = this.context.bitsPerCoordinate, t3 = this.readBits(e3), i3 = this.readBits(e3), a3 = this.context.decode, s3 = e3 < 32 ? 1 / ((1 << e3) - 1) : 23283064365386963e-26;
        return [t3 * s3 * (a3[1] - a3[0]) + a3[0], i3 * s3 * (a3[3] - a3[2]) + a3[2]];
      }
      readComponents() {
        const e3 = this.context.numComps, t3 = this.context.bitsPerComponent, i3 = t3 < 32 ? 1 / ((1 << t3) - 1) : 23283064365386963e-26, a3 = this.context.decode, s3 = this.tmpCompsBuf;
        for (let r4 = 0, n3 = 4; r4 < e3; r4++, n3 += 2) {
          const e4 = this.readBits(t3);
          s3[r4] = e4 * i3 * (a3[n3 + 1] - a3[n3]) + a3[n3];
        }
        const r3 = this.tmpCsCompsBuf;
        this.context.colorFn && this.context.colorFn(s3, 0, r3, 0);
        return this.context.colorSpace.getRgb(r3, 0);
      }
    };
    ya = /* @__PURE__ */ Object.create(null);
    _MeshShading = class _MeshShading extends BaseShading {
      constructor(e3, t3, i3, a3, s3) {
        super();
        if (!(e3 instanceof BaseStream))
          throw new FormatError("Mesh data is not a stream");
        const r3 = e3.dict;
        this.shadingType = r3.get("ShadingType");
        const n3 = r3.getArray("BBox");
        this.bbox = Array.isArray(n3) && 4 === n3.length ? Util.normalizeRect(n3) : null;
        const o3 = ColorSpace.parse({ cs: r3.getRaw("CS") || r3.getRaw("ColorSpace"), xref: t3, resources: i3, pdfFunctionFactory: a3, localColorSpaceCache: s3 });
        this.background = r3.has("Background") ? o3.getRgb(r3.get("Background"), 0) : null;
        const g3 = r3.getRaw("Function"), c3 = g3 ? a3.createFromArray(g3) : null;
        this.coords = [];
        this.colors = [];
        this.figures = [];
        const C3 = { bitsPerCoordinate: r3.get("BitsPerCoordinate"), bitsPerComponent: r3.get("BitsPerComponent"), bitsPerFlag: r3.get("BitsPerFlag"), decode: r3.getArray("Decode"), colorFn: c3, colorSpace: o3, numComps: c3 ? 1 : o3.numComps }, h2 = new MeshStreamReader(e3, C3);
        let l3 = false;
        switch (this.shadingType) {
          case da:
            this._decodeType4Shading(h2);
            break;
          case fa:
            const e4 = 0 | r3.get("VerticesPerRow");
            if (e4 < 2)
              throw new FormatError("Invalid VerticesPerRow");
            this._decodeType5Shading(h2, e4);
            break;
          case pa:
            this._decodeType6Shading(h2);
            l3 = true;
            break;
          case ma:
            this._decodeType7Shading(h2);
            l3 = true;
            break;
          default:
            unreachable("Unsupported mesh type.");
        }
        if (l3) {
          this._updateBounds();
          for (let e4 = 0, t4 = this.figures.length; e4 < t4; e4++)
            this._buildFigureFromPatch(e4);
        }
        this._updateBounds();
        this._packData();
      }
      _decodeType4Shading(e3) {
        const t3 = this.coords, i3 = this.colors, a3 = [], s3 = [];
        let r3 = 0;
        for (; e3.hasData; ) {
          const n3 = e3.readFlag(), o3 = e3.readCoordinate(), g3 = e3.readComponents();
          if (0 === r3) {
            if (!(0 <= n3 && n3 <= 2))
              throw new FormatError("Unknown type4 flag");
            switch (n3) {
              case 0:
                r3 = 3;
                break;
              case 1:
                s3.push(s3.at(-2), s3.at(-1));
                r3 = 1;
                break;
              case 2:
                s3.push(s3.at(-3), s3.at(-1));
                r3 = 1;
            }
            a3.push(n3);
          }
          s3.push(t3.length);
          t3.push(o3);
          i3.push(g3);
          r3--;
          e3.align();
        }
        this.figures.push({ type: "triangles", coords: new Int32Array(s3), colors: new Int32Array(s3) });
      }
      _decodeType5Shading(e3, t3) {
        const i3 = this.coords, a3 = this.colors, s3 = [];
        for (; e3.hasData; ) {
          const t4 = e3.readCoordinate(), r3 = e3.readComponents();
          s3.push(i3.length);
          i3.push(t4);
          a3.push(r3);
        }
        this.figures.push({ type: "lattice", coords: new Int32Array(s3), colors: new Int32Array(s3), verticesPerRow: t3 });
      }
      _decodeType6Shading(e3) {
        const t3 = this.coords, i3 = this.colors, a3 = new Int32Array(16), s3 = new Int32Array(4);
        for (; e3.hasData; ) {
          const r3 = e3.readFlag();
          if (!(0 <= r3 && r3 <= 3))
            throw new FormatError("Unknown type6 flag");
          const n3 = t3.length;
          for (let i4 = 0, a4 = 0 !== r3 ? 8 : 12; i4 < a4; i4++)
            t3.push(e3.readCoordinate());
          const o3 = i3.length;
          for (let t4 = 0, a4 = 0 !== r3 ? 2 : 4; t4 < a4; t4++)
            i3.push(e3.readComponents());
          let g3, c3, C3, h2;
          switch (r3) {
            case 0:
              a3[12] = n3 + 3;
              a3[13] = n3 + 4;
              a3[14] = n3 + 5;
              a3[15] = n3 + 6;
              a3[8] = n3 + 2;
              a3[11] = n3 + 7;
              a3[4] = n3 + 1;
              a3[7] = n3 + 8;
              a3[0] = n3;
              a3[1] = n3 + 11;
              a3[2] = n3 + 10;
              a3[3] = n3 + 9;
              s3[2] = o3 + 1;
              s3[3] = o3 + 2;
              s3[0] = o3;
              s3[1] = o3 + 3;
              break;
            case 1:
              g3 = a3[12];
              c3 = a3[13];
              C3 = a3[14];
              h2 = a3[15];
              a3[12] = h2;
              a3[13] = n3 + 0;
              a3[14] = n3 + 1;
              a3[15] = n3 + 2;
              a3[8] = C3;
              a3[11] = n3 + 3;
              a3[4] = c3;
              a3[7] = n3 + 4;
              a3[0] = g3;
              a3[1] = n3 + 7;
              a3[2] = n3 + 6;
              a3[3] = n3 + 5;
              g3 = s3[2];
              c3 = s3[3];
              s3[2] = c3;
              s3[3] = o3;
              s3[0] = g3;
              s3[1] = o3 + 1;
              break;
            case 2:
              g3 = a3[15];
              c3 = a3[11];
              a3[12] = a3[3];
              a3[13] = n3 + 0;
              a3[14] = n3 + 1;
              a3[15] = n3 + 2;
              a3[8] = a3[7];
              a3[11] = n3 + 3;
              a3[4] = c3;
              a3[7] = n3 + 4;
              a3[0] = g3;
              a3[1] = n3 + 7;
              a3[2] = n3 + 6;
              a3[3] = n3 + 5;
              g3 = s3[3];
              s3[2] = s3[1];
              s3[3] = o3;
              s3[0] = g3;
              s3[1] = o3 + 1;
              break;
            case 3:
              a3[12] = a3[0];
              a3[13] = n3 + 0;
              a3[14] = n3 + 1;
              a3[15] = n3 + 2;
              a3[8] = a3[1];
              a3[11] = n3 + 3;
              a3[4] = a3[2];
              a3[7] = n3 + 4;
              a3[0] = a3[3];
              a3[1] = n3 + 7;
              a3[2] = n3 + 6;
              a3[3] = n3 + 5;
              s3[2] = s3[0];
              s3[3] = o3;
              s3[0] = s3[1];
              s3[1] = o3 + 1;
          }
          a3[5] = t3.length;
          t3.push([(-4 * t3[a3[0]][0] - t3[a3[15]][0] + 6 * (t3[a3[4]][0] + t3[a3[1]][0]) - 2 * (t3[a3[12]][0] + t3[a3[3]][0]) + 3 * (t3[a3[13]][0] + t3[a3[7]][0])) / 9, (-4 * t3[a3[0]][1] - t3[a3[15]][1] + 6 * (t3[a3[4]][1] + t3[a3[1]][1]) - 2 * (t3[a3[12]][1] + t3[a3[3]][1]) + 3 * (t3[a3[13]][1] + t3[a3[7]][1])) / 9]);
          a3[6] = t3.length;
          t3.push([(-4 * t3[a3[3]][0] - t3[a3[12]][0] + 6 * (t3[a3[2]][0] + t3[a3[7]][0]) - 2 * (t3[a3[0]][0] + t3[a3[15]][0]) + 3 * (t3[a3[4]][0] + t3[a3[14]][0])) / 9, (-4 * t3[a3[3]][1] - t3[a3[12]][1] + 6 * (t3[a3[2]][1] + t3[a3[7]][1]) - 2 * (t3[a3[0]][1] + t3[a3[15]][1]) + 3 * (t3[a3[4]][1] + t3[a3[14]][1])) / 9]);
          a3[9] = t3.length;
          t3.push([(-4 * t3[a3[12]][0] - t3[a3[3]][0] + 6 * (t3[a3[8]][0] + t3[a3[13]][0]) - 2 * (t3[a3[0]][0] + t3[a3[15]][0]) + 3 * (t3[a3[11]][0] + t3[a3[1]][0])) / 9, (-4 * t3[a3[12]][1] - t3[a3[3]][1] + 6 * (t3[a3[8]][1] + t3[a3[13]][1]) - 2 * (t3[a3[0]][1] + t3[a3[15]][1]) + 3 * (t3[a3[11]][1] + t3[a3[1]][1])) / 9]);
          a3[10] = t3.length;
          t3.push([(-4 * t3[a3[15]][0] - t3[a3[0]][0] + 6 * (t3[a3[11]][0] + t3[a3[14]][0]) - 2 * (t3[a3[12]][0] + t3[a3[3]][0]) + 3 * (t3[a3[2]][0] + t3[a3[8]][0])) / 9, (-4 * t3[a3[15]][1] - t3[a3[0]][1] + 6 * (t3[a3[11]][1] + t3[a3[14]][1]) - 2 * (t3[a3[12]][1] + t3[a3[3]][1]) + 3 * (t3[a3[2]][1] + t3[a3[8]][1])) / 9]);
          this.figures.push({ type: "patch", coords: new Int32Array(a3), colors: new Int32Array(s3) });
        }
      }
      _decodeType7Shading(e3) {
        const t3 = this.coords, i3 = this.colors, a3 = new Int32Array(16), s3 = new Int32Array(4);
        for (; e3.hasData; ) {
          const r3 = e3.readFlag();
          if (!(0 <= r3 && r3 <= 3))
            throw new FormatError("Unknown type7 flag");
          const n3 = t3.length;
          for (let i4 = 0, a4 = 0 !== r3 ? 12 : 16; i4 < a4; i4++)
            t3.push(e3.readCoordinate());
          const o3 = i3.length;
          for (let t4 = 0, a4 = 0 !== r3 ? 2 : 4; t4 < a4; t4++)
            i3.push(e3.readComponents());
          let g3, c3, C3, h2;
          switch (r3) {
            case 0:
              a3[12] = n3 + 3;
              a3[13] = n3 + 4;
              a3[14] = n3 + 5;
              a3[15] = n3 + 6;
              a3[8] = n3 + 2;
              a3[9] = n3 + 13;
              a3[10] = n3 + 14;
              a3[11] = n3 + 7;
              a3[4] = n3 + 1;
              a3[5] = n3 + 12;
              a3[6] = n3 + 15;
              a3[7] = n3 + 8;
              a3[0] = n3;
              a3[1] = n3 + 11;
              a3[2] = n3 + 10;
              a3[3] = n3 + 9;
              s3[2] = o3 + 1;
              s3[3] = o3 + 2;
              s3[0] = o3;
              s3[1] = o3 + 3;
              break;
            case 1:
              g3 = a3[12];
              c3 = a3[13];
              C3 = a3[14];
              h2 = a3[15];
              a3[12] = h2;
              a3[13] = n3 + 0;
              a3[14] = n3 + 1;
              a3[15] = n3 + 2;
              a3[8] = C3;
              a3[9] = n3 + 9;
              a3[10] = n3 + 10;
              a3[11] = n3 + 3;
              a3[4] = c3;
              a3[5] = n3 + 8;
              a3[6] = n3 + 11;
              a3[7] = n3 + 4;
              a3[0] = g3;
              a3[1] = n3 + 7;
              a3[2] = n3 + 6;
              a3[3] = n3 + 5;
              g3 = s3[2];
              c3 = s3[3];
              s3[2] = c3;
              s3[3] = o3;
              s3[0] = g3;
              s3[1] = o3 + 1;
              break;
            case 2:
              g3 = a3[15];
              c3 = a3[11];
              a3[12] = a3[3];
              a3[13] = n3 + 0;
              a3[14] = n3 + 1;
              a3[15] = n3 + 2;
              a3[8] = a3[7];
              a3[9] = n3 + 9;
              a3[10] = n3 + 10;
              a3[11] = n3 + 3;
              a3[4] = c3;
              a3[5] = n3 + 8;
              a3[6] = n3 + 11;
              a3[7] = n3 + 4;
              a3[0] = g3;
              a3[1] = n3 + 7;
              a3[2] = n3 + 6;
              a3[3] = n3 + 5;
              g3 = s3[3];
              s3[2] = s3[1];
              s3[3] = o3;
              s3[0] = g3;
              s3[1] = o3 + 1;
              break;
            case 3:
              a3[12] = a3[0];
              a3[13] = n3 + 0;
              a3[14] = n3 + 1;
              a3[15] = n3 + 2;
              a3[8] = a3[1];
              a3[9] = n3 + 9;
              a3[10] = n3 + 10;
              a3[11] = n3 + 3;
              a3[4] = a3[2];
              a3[5] = n3 + 8;
              a3[6] = n3 + 11;
              a3[7] = n3 + 4;
              a3[0] = a3[3];
              a3[1] = n3 + 7;
              a3[2] = n3 + 6;
              a3[3] = n3 + 5;
              s3[2] = s3[0];
              s3[3] = o3;
              s3[0] = s3[1];
              s3[1] = o3 + 1;
          }
          this.figures.push({ type: "patch", coords: new Int32Array(a3), colors: new Int32Array(s3) });
        }
      }
      _buildFigureFromPatch(e3) {
        const t3 = this.figures[e3];
        assert("patch" === t3.type, "Unexpected patch mesh figure");
        const i3 = this.coords, a3 = this.colors, s3 = t3.coords, r3 = t3.colors, n3 = Math.min(i3[s3[0]][0], i3[s3[3]][0], i3[s3[12]][0], i3[s3[15]][0]), o3 = Math.min(i3[s3[0]][1], i3[s3[3]][1], i3[s3[12]][1], i3[s3[15]][1]), g3 = Math.max(i3[s3[0]][0], i3[s3[3]][0], i3[s3[12]][0], i3[s3[15]][0]), c3 = Math.max(i3[s3[0]][1], i3[s3[3]][1], i3[s3[12]][1], i3[s3[15]][1]);
        let C3 = Math.ceil((g3 - n3) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
        C3 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, C3));
        let h2 = Math.ceil((c3 - o3) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
        h2 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, h2));
        const l3 = C3 + 1, Q3 = new Int32Array((h2 + 1) * l3), E3 = new Int32Array((h2 + 1) * l3);
        let u3 = 0;
        const d3 = new Uint8Array(3), f2 = new Uint8Array(3), p2 = a3[r3[0]], m3 = a3[r3[1]], y3 = a3[r3[2]], w3 = a3[r3[3]], b3 = getB(h2), D3 = getB(C3);
        for (let e4 = 0; e4 <= h2; e4++) {
          d3[0] = (p2[0] * (h2 - e4) + y3[0] * e4) / h2 | 0;
          d3[1] = (p2[1] * (h2 - e4) + y3[1] * e4) / h2 | 0;
          d3[2] = (p2[2] * (h2 - e4) + y3[2] * e4) / h2 | 0;
          f2[0] = (m3[0] * (h2 - e4) + w3[0] * e4) / h2 | 0;
          f2[1] = (m3[1] * (h2 - e4) + w3[1] * e4) / h2 | 0;
          f2[2] = (m3[2] * (h2 - e4) + w3[2] * e4) / h2 | 0;
          for (let t4 = 0; t4 <= C3; t4++, u3++) {
            if (!(0 !== e4 && e4 !== h2 || 0 !== t4 && t4 !== C3))
              continue;
            let r4 = 0, n4 = 0, o4 = 0;
            for (let a4 = 0; a4 <= 3; a4++)
              for (let g5 = 0; g5 <= 3; g5++, o4++) {
                const c4 = b3[e4][a4] * D3[t4][g5];
                r4 += i3[s3[o4]][0] * c4;
                n4 += i3[s3[o4]][1] * c4;
              }
            Q3[u3] = i3.length;
            i3.push([r4, n4]);
            E3[u3] = a3.length;
            const g4 = new Uint8Array(3);
            g4[0] = (d3[0] * (C3 - t4) + f2[0] * t4) / C3 | 0;
            g4[1] = (d3[1] * (C3 - t4) + f2[1] * t4) / C3 | 0;
            g4[2] = (d3[2] * (C3 - t4) + f2[2] * t4) / C3 | 0;
            a3.push(g4);
          }
        }
        Q3[0] = s3[0];
        E3[0] = r3[0];
        Q3[C3] = s3[3];
        E3[C3] = r3[1];
        Q3[l3 * h2] = s3[12];
        E3[l3 * h2] = r3[2];
        Q3[l3 * h2 + C3] = s3[15];
        E3[l3 * h2 + C3] = r3[3];
        this.figures[e3] = { type: "lattice", coords: Q3, colors: E3, verticesPerRow: l3 };
      }
      _updateBounds() {
        let e3 = this.coords[0][0], t3 = this.coords[0][1], i3 = e3, a3 = t3;
        for (let s3 = 1, r3 = this.coords.length; s3 < r3; s3++) {
          const r4 = this.coords[s3][0], n3 = this.coords[s3][1];
          e3 = e3 > r4 ? r4 : e3;
          t3 = t3 > n3 ? n3 : t3;
          i3 = i3 < r4 ? r4 : i3;
          a3 = a3 < n3 ? n3 : a3;
        }
        this.bounds = [e3, t3, i3, a3];
      }
      _packData() {
        let e3, t3, i3, a3;
        const s3 = this.coords, r3 = new Float32Array(2 * s3.length);
        for (e3 = 0, i3 = 0, t3 = s3.length; e3 < t3; e3++) {
          const t4 = s3[e3];
          r3[i3++] = t4[0];
          r3[i3++] = t4[1];
        }
        this.coords = r3;
        const n3 = this.colors, o3 = new Uint8Array(3 * n3.length);
        for (e3 = 0, i3 = 0, t3 = n3.length; e3 < t3; e3++) {
          const t4 = n3[e3];
          o3[i3++] = t4[0];
          o3[i3++] = t4[1];
          o3[i3++] = t4[2];
        }
        this.colors = o3;
        const g3 = this.figures;
        for (e3 = 0, t3 = g3.length; e3 < t3; e3++) {
          const t4 = g3[e3], s4 = t4.coords, r4 = t4.colors;
          for (i3 = 0, a3 = s4.length; i3 < a3; i3++) {
            s4[i3] *= 2;
            r4[i3] *= 3;
          }
        }
      }
      getIR() {
        const { bounds: e3 } = this;
        if (e3[2] - e3[0] == 0 || e3[3] - e3[1] == 0)
          throw new FormatError(`Invalid MeshShading bounds: [${e3}].`);
        return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, e3, this.bbox, this.background];
      }
    };
    __publicField(_MeshShading, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
    __publicField(_MeshShading, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
    __publicField(_MeshShading, "TRIANGLE_DENSITY", 20);
    MeshShading = _MeshShading;
    DummyShading = class extends BaseShading {
      getIR() {
        return ["Dummy"];
      }
    };
    wa = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    ba = { lineHeight: 1.2207, lineGap: 0.2207 };
    Da = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Fa = { lineHeight: 1.2207, lineGap: 0.2207 };
    Sa = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    ka = { lineHeight: 1.2207, lineGap: 0.2207 };
    Na = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Ra = { lineHeight: 1.2207, lineGap: 0.2207 };
    Ga = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    xa = { lineHeight: 1.2, lineGap: 0.2 };
    Ua = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Ma = { lineHeight: 1.35, lineGap: 0.2 };
    La = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Ha = { lineHeight: 1.35, lineGap: 0.2 };
    Ja = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Ya = { lineHeight: 1.2, lineGap: 0.2 };
    va = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
    Ka = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Ta = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
    qa = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Oa = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
    Pa = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Wa = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
    ja = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    Xa = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    Za = { lineHeight: 1.2, lineGap: 0.2 };
    Va = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    za = { lineHeight: 1.2, lineGap: 0.2 };
    _a2 = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    $a = { lineHeight: 1.2, lineGap: 0.2 };
    As = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    es = { lineHeight: 1.2, lineGap: 0.2 };
    ts = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    is = { lineHeight: 1.33008, lineGap: 0 };
    as = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    ss = { lineHeight: 1.33008, lineGap: 0 };
    rs = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    ns = { lineHeight: 1.33008, lineGap: 0 };
    os = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    gs = { lineHeight: 1.33008, lineGap: 0 };
    Is = getLookupTableFactory(function(e3) {
      e3["MyriadPro-Regular"] = e3["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: As, baseWidths: Wa, baseMapping: ja, metrics: es };
      e3["MyriadPro-Bold"] = e3["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: Xa, baseWidths: va, baseMapping: Ka, metrics: Za };
      e3["MyriadPro-It"] = e3["MyriadPro-Italic"] = e3["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: _a2, baseWidths: Oa, baseMapping: Pa, metrics: $a };
      e3["MyriadPro-BoldIt"] = e3["MyriadPro-BoldItalic"] = e3["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Va, baseWidths: Ta, baseMapping: qa, metrics: za };
      e3.ArialMT = e3.Arial = e3["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: Wa, baseMapping: ja };
      e3["Arial-BoldMT"] = e3["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: va, baseMapping: Ka };
      e3["Arial-ItalicMT"] = e3["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: Oa, baseMapping: Pa };
      e3["Arial-BoldItalicMT"] = e3["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: Ta, baseMapping: qa };
      e3["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: Na, baseWidths: Wa, baseMapping: ja, metrics: Ra };
      e3["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: wa, baseWidths: va, baseMapping: Ka, metrics: ba };
      e3["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: Sa, baseWidths: Oa, baseMapping: Pa, metrics: ka };
      e3["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Da, baseWidths: Ta, baseMapping: qa, metrics: Fa };
      e3["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: os, baseWidths: Wa, baseMapping: ja, metrics: gs };
      e3["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: ts, baseWidths: va, baseMapping: Ka, metrics: is };
      e3["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: rs, baseWidths: Oa, baseMapping: Pa, metrics: ns };
      e3["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: as, baseWidths: Ta, baseMapping: qa, metrics: ss };
      e3["Helvetica-Regular"] = e3.Helvetica = { name: "LiberationSans-Regular", factors: Ja, baseWidths: Wa, baseMapping: ja, metrics: Ya };
      e3["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: Ga, baseWidths: va, baseMapping: Ka, metrics: xa };
      e3["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: La, baseWidths: Oa, baseMapping: Pa, metrics: Ha };
      e3["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Ua, baseWidths: Ta, baseMapping: qa, metrics: Ma };
    });
    PostScriptParser = class {
      constructor(e3) {
        this.lexer = e3;
        this.operators = [];
        this.token = null;
        this.prev = null;
      }
      nextToken() {
        this.prev = this.token;
        this.token = this.lexer.getToken();
      }
      accept(e3) {
        if (this.token.type === e3) {
          this.nextToken();
          return true;
        }
        return false;
      }
      expect(e3) {
        if (this.accept(e3))
          return true;
        throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e3}.`);
      }
      parse() {
        this.nextToken();
        this.expect(cs.LBRACE);
        this.parseBlock();
        this.expect(cs.RBRACE);
        return this.operators;
      }
      parseBlock() {
        for (; ; )
          if (this.accept(cs.NUMBER))
            this.operators.push(this.prev.value);
          else if (this.accept(cs.OPERATOR))
            this.operators.push(this.prev.value);
          else {
            if (!this.accept(cs.LBRACE))
              return;
            this.parseCondition();
          }
      }
      parseCondition() {
        const e3 = this.operators.length;
        this.operators.push(null, null);
        this.parseBlock();
        this.expect(cs.RBRACE);
        if (this.accept(cs.IF)) {
          this.operators[e3] = this.operators.length;
          this.operators[e3 + 1] = "jz";
        } else {
          if (!this.accept(cs.LBRACE))
            throw new FormatError("PS Function: error parsing conditional.");
          {
            const t3 = this.operators.length;
            this.operators.push(null, null);
            const i3 = this.operators.length;
            this.parseBlock();
            this.expect(cs.RBRACE);
            this.expect(cs.IFELSE);
            this.operators[t3] = this.operators.length;
            this.operators[t3 + 1] = "j";
            this.operators[e3] = i3;
            this.operators[e3 + 1] = "jz";
          }
        }
      }
    };
    cs = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
    PostScriptToken = class _PostScriptToken {
      static get opCache() {
        return shadow(this, "opCache", /* @__PURE__ */ Object.create(null));
      }
      constructor(e3, t3) {
        this.type = e3;
        this.value = t3;
      }
      static getOperator(e3) {
        var _a3;
        return (_a3 = _PostScriptToken.opCache)[e3] || (_a3[e3] = new _PostScriptToken(cs.OPERATOR, e3));
      }
      static get LBRACE() {
        return shadow(this, "LBRACE", new _PostScriptToken(cs.LBRACE, "{"));
      }
      static get RBRACE() {
        return shadow(this, "RBRACE", new _PostScriptToken(cs.RBRACE, "}"));
      }
      static get IF() {
        return shadow(this, "IF", new _PostScriptToken(cs.IF, "IF"));
      }
      static get IFELSE() {
        return shadow(this, "IFELSE", new _PostScriptToken(cs.IFELSE, "IFELSE"));
      }
    };
    PostScriptLexer = class {
      constructor(e3) {
        this.stream = e3;
        this.nextChar();
        this.strBuf = [];
      }
      nextChar() {
        return this.currentChar = this.stream.getByte();
      }
      getToken() {
        let e3 = false, t3 = this.currentChar;
        for (; ; ) {
          if (t3 < 0)
            return pt;
          if (e3)
            10 !== t3 && 13 !== t3 || (e3 = false);
          else if (37 === t3)
            e3 = true;
          else if (!isWhiteSpace(t3))
            break;
          t3 = this.nextChar();
        }
        switch (0 | t3) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 43:
          case 45:
          case 46:
            return new PostScriptToken(cs.NUMBER, this.getNumber());
          case 123:
            this.nextChar();
            return PostScriptToken.LBRACE;
          case 125:
            this.nextChar();
            return PostScriptToken.RBRACE;
        }
        const i3 = this.strBuf;
        i3.length = 0;
        i3[0] = String.fromCharCode(t3);
        for (; (t3 = this.nextChar()) >= 0 && (t3 >= 65 && t3 <= 90 || t3 >= 97 && t3 <= 122); )
          i3.push(String.fromCharCode(t3));
        const a3 = i3.join("");
        switch (a3.toLowerCase()) {
          case "if":
            return PostScriptToken.IF;
          case "ifelse":
            return PostScriptToken.IFELSE;
          default:
            return PostScriptToken.getOperator(a3);
        }
      }
      getNumber() {
        let e3 = this.currentChar;
        const t3 = this.strBuf;
        t3.length = 0;
        t3[0] = String.fromCharCode(e3);
        for (; (e3 = this.nextChar()) >= 0 && (e3 >= 48 && e3 <= 57 || 45 === e3 || 46 === e3); )
          t3.push(String.fromCharCode(e3));
        const i3 = parseFloat(t3.join(""));
        if (isNaN(i3))
          throw new FormatError(`Invalid floating point number: ${i3}`);
        return i3;
      }
    };
    BaseLocalCache = class _BaseLocalCache {
      constructor(e3) {
        this.constructor === _BaseLocalCache && unreachable("Cannot initialize BaseLocalCache.");
        this._onlyRefs = true === (e3 == null ? void 0 : e3.onlyRefs);
        if (!this._onlyRefs) {
          this._nameRefMap = /* @__PURE__ */ new Map();
          this._imageMap = /* @__PURE__ */ new Map();
        }
        this._imageCache = new RefSetCache();
      }
      getByName(e3) {
        this._onlyRefs && unreachable("Should not call `getByName` method.");
        const t3 = this._nameRefMap.get(e3);
        return t3 ? this.getByRef(t3) : this._imageMap.get(e3) || null;
      }
      getByRef(e3) {
        return this._imageCache.get(e3) || null;
      }
      set(e3, t3, i3) {
        unreachable("Abstract method `set` called.");
      }
    };
    LocalImageCache = class extends BaseLocalCache {
      set(e3, t3 = null, i3) {
        if ("string" != typeof e3)
          throw new Error('LocalImageCache.set - expected "name" argument.');
        if (t3) {
          if (this._imageCache.has(t3))
            return;
          this._nameRefMap.set(e3, t3);
          this._imageCache.put(t3, i3);
        } else
          this._imageMap.has(e3) || this._imageMap.set(e3, i3);
      }
    };
    LocalColorSpaceCache = class extends BaseLocalCache {
      set(e3 = null, t3 = null, i3) {
        if ("string" != typeof e3 && !t3)
          throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
        if (t3) {
          if (this._imageCache.has(t3))
            return;
          null !== e3 && this._nameRefMap.set(e3, t3);
          this._imageCache.put(t3, i3);
        } else
          this._imageMap.has(e3) || this._imageMap.set(e3, i3);
      }
    };
    LocalFunctionCache = class extends BaseLocalCache {
      constructor(e3) {
        super({ onlyRefs: true });
      }
      set(e3 = null, t3, i3) {
        if (!t3)
          throw new Error('LocalFunctionCache.set - expected "ref" argument.');
        this._imageCache.has(t3) || this._imageCache.put(t3, i3);
      }
    };
    LocalGStateCache = class extends BaseLocalCache {
      set(e3, t3 = null, i3) {
        if ("string" != typeof e3)
          throw new Error('LocalGStateCache.set - expected "name" argument.');
        if (t3) {
          if (this._imageCache.has(t3))
            return;
          this._nameRefMap.set(e3, t3);
          this._imageCache.put(t3, i3);
        } else
          this._imageMap.has(e3) || this._imageMap.set(e3, i3);
      }
    };
    LocalTilingPatternCache = class extends BaseLocalCache {
      constructor(e3) {
        super({ onlyRefs: true });
      }
      set(e3 = null, t3, i3) {
        if (!t3)
          throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
        this._imageCache.has(t3) || this._imageCache.put(t3, i3);
      }
    };
    RegionalImageCache = class extends BaseLocalCache {
      constructor(e3) {
        super({ onlyRefs: true });
      }
      set(e3 = null, t3, i3) {
        if (!t3)
          throw new Error('RegionalImageCache.set - expected "ref" argument.');
        this._imageCache.has(t3) || this._imageCache.put(t3, i3);
      }
    };
    _GlobalImageCache = class _GlobalImageCache {
      constructor() {
        this._refCache = new RefSetCache();
        this._imageCache = new RefSetCache();
      }
      get _byteSize() {
        let e3 = 0;
        for (const t3 of this._imageCache)
          e3 += t3.byteSize;
        return e3;
      }
      get _cacheLimitReached() {
        return !(this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(this._byteSize < _GlobalImageCache.MAX_BYTE_SIZE);
      }
      shouldCache(e3, t3) {
        let i3 = this._refCache.get(e3);
        if (!i3) {
          i3 = /* @__PURE__ */ new Set();
          this._refCache.put(e3, i3);
        }
        i3.add(t3);
        return !(i3.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e3) && this._cacheLimitReached);
      }
      addByteSize(e3, t3) {
        const i3 = this._imageCache.get(e3);
        i3 && (i3.byteSize || (i3.byteSize = t3));
      }
      getData(e3, t3) {
        const i3 = this._refCache.get(e3);
        if (!i3)
          return null;
        if (i3.size < _GlobalImageCache.NUM_PAGES_THRESHOLD)
          return null;
        const a3 = this._imageCache.get(e3);
        if (!a3)
          return null;
        i3.add(t3);
        return a3;
      }
      setData(e3, t3) {
        if (!this._refCache.has(e3))
          throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
        this._imageCache.has(e3) || (this._cacheLimitReached ? warn("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e3, t3));
      }
      clear(e3 = false) {
        e3 || this._refCache.clear();
        this._imageCache.clear();
      }
    };
    __publicField(_GlobalImageCache, "NUM_PAGES_THRESHOLD", 2);
    __publicField(_GlobalImageCache, "MIN_IMAGES_TO_CACHE", 10);
    __publicField(_GlobalImageCache, "MAX_BYTE_SIZE", 5e7);
    GlobalImageCache = _GlobalImageCache;
    PDFFunctionFactory = class {
      constructor({ xref: e3, isEvalSupported: t3 = true }) {
        this.xref = e3;
        this.isEvalSupported = false !== t3;
      }
      create(e3) {
        const t3 = this.getCached(e3);
        if (t3)
          return t3;
        const i3 = PDFFunction.parse({ xref: this.xref, isEvalSupported: this.isEvalSupported, fn: e3 instanceof Ref ? this.xref.fetch(e3) : e3 });
        this._cache(e3, i3);
        return i3;
      }
      createFromArray(e3) {
        const t3 = this.getCached(e3);
        if (t3)
          return t3;
        const i3 = PDFFunction.parseArray({ xref: this.xref, isEvalSupported: this.isEvalSupported, fnObj: e3 instanceof Ref ? this.xref.fetch(e3) : e3 });
        this._cache(e3, i3);
        return i3;
      }
      getCached(e3) {
        var _a3;
        let t3;
        e3 instanceof Ref ? t3 = e3 : e3 instanceof Dict ? t3 = e3.objId : e3 instanceof BaseStream && (t3 = (_a3 = e3.dict) == null ? void 0 : _a3.objId);
        if (t3) {
          const e4 = this._localFunctionCache.getByRef(t3);
          if (e4)
            return e4;
        }
        return null;
      }
      _cache(e3, t3) {
        var _a3;
        if (!t3)
          throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
        let i3;
        e3 instanceof Ref ? i3 = e3 : e3 instanceof Dict ? i3 = e3.objId : e3 instanceof BaseStream && (i3 = (_a3 = e3.dict) == null ? void 0 : _a3.objId);
        i3 && this._localFunctionCache.set(null, i3, t3);
      }
      get _localFunctionCache() {
        return shadow(this, "_localFunctionCache", new LocalFunctionCache());
      }
    };
    PDFFunction = class {
      static getSampleArray(e3, t3, i3, a3) {
        let s3, r3, n3 = 1;
        for (s3 = 0, r3 = e3.length; s3 < r3; s3++)
          n3 *= e3[s3];
        n3 *= t3;
        const o3 = new Array(n3);
        let g3 = 0, c3 = 0;
        const C3 = 1 / (2 ** i3 - 1), h2 = a3.getBytes((n3 * i3 + 7) / 8);
        let l3 = 0;
        for (s3 = 0; s3 < n3; s3++) {
          for (; g3 < i3; ) {
            c3 <<= 8;
            c3 |= h2[l3++];
            g3 += 8;
          }
          g3 -= i3;
          o3[s3] = (c3 >> g3) * C3;
          c3 &= (1 << g3) - 1;
        }
        return o3;
      }
      static parse({ xref: e3, isEvalSupported: t3, fn: i3 }) {
        const a3 = i3.dict || i3;
        switch (a3.get("FunctionType")) {
          case 0:
            return this.constructSampled({ xref: e3, isEvalSupported: t3, fn: i3, dict: a3 });
          case 1:
            break;
          case 2:
            return this.constructInterpolated({ xref: e3, isEvalSupported: t3, dict: a3 });
          case 3:
            return this.constructStiched({ xref: e3, isEvalSupported: t3, dict: a3 });
          case 4:
            return this.constructPostScript({ xref: e3, isEvalSupported: t3, fn: i3, dict: a3 });
        }
        throw new FormatError("Unknown type of function");
      }
      static parseArray({ xref: e3, isEvalSupported: t3, fnObj: i3 }) {
        if (!Array.isArray(i3))
          return this.parse({ xref: e3, isEvalSupported: t3, fn: i3 });
        const a3 = [];
        for (const s3 of i3)
          a3.push(this.parse({ xref: e3, isEvalSupported: t3, fn: e3.fetchIfRef(s3) }));
        return function(e4, t4, i4, s3) {
          for (let r3 = 0, n3 = a3.length; r3 < n3; r3++)
            a3[r3](e4, t4, i4, s3 + r3);
        };
      }
      static constructSampled({ xref: e3, isEvalSupported: t3, fn: i3, dict: a3 }) {
        function toMultiArray(e4) {
          const t4 = e4.length, i4 = [];
          let a4 = 0;
          for (let s4 = 0; s4 < t4; s4 += 2)
            i4[a4++] = [e4[s4], e4[s4 + 1]];
          return i4;
        }
        function interpolate(e4, t4, i4, a4, s4) {
          return a4 + (s4 - a4) / (i4 - t4) * (e4 - t4);
        }
        let s3 = toNumberArray(a3.getArray("Domain")), r3 = toNumberArray(a3.getArray("Range"));
        if (!s3 || !r3)
          throw new FormatError("No domain or range");
        const n3 = s3.length / 2, o3 = r3.length / 2;
        s3 = toMultiArray(s3);
        r3 = toMultiArray(r3);
        const g3 = toNumberArray(a3.getArray("Size")), c3 = a3.get("BitsPerSample"), C3 = a3.get("Order") || 1;
        1 !== C3 && info("No support for cubic spline interpolation: " + C3);
        let h2 = toNumberArray(a3.getArray("Encode"));
        if (h2)
          h2 = toMultiArray(h2);
        else {
          h2 = [];
          for (let e4 = 0; e4 < n3; ++e4)
            h2.push([0, g3[e4] - 1]);
        }
        let l3 = toNumberArray(a3.getArray("Decode"));
        l3 = l3 ? toMultiArray(l3) : r3;
        const Q3 = this.getSampleArray(g3, o3, c3, i3);
        return function constructSampledFn(e4, t4, i4, a4) {
          const c4 = 1 << n3, C4 = new Float64Array(c4), E3 = new Uint32Array(c4);
          let u3, d3;
          for (d3 = 0; d3 < c4; d3++)
            C4[d3] = 1;
          let f2 = o3, p2 = 1;
          for (u3 = 0; u3 < n3; ++u3) {
            const i5 = s3[u3][0], a5 = s3[u3][1];
            let r4 = interpolate(Math.min(Math.max(e4[t4 + u3], i5), a5), i5, a5, h2[u3][0], h2[u3][1]);
            const n4 = g3[u3];
            r4 = Math.min(Math.max(r4, 0), n4 - 1);
            const o4 = r4 < n4 - 1 ? Math.floor(r4) : r4 - 1, l4 = o4 + 1 - r4, Q4 = r4 - o4, m3 = o4 * f2, y3 = m3 + f2;
            for (d3 = 0; d3 < c4; d3++)
              if (d3 & p2) {
                C4[d3] *= Q4;
                E3[d3] += y3;
              } else {
                C4[d3] *= l4;
                E3[d3] += m3;
              }
            f2 *= n4;
            p2 <<= 1;
          }
          for (d3 = 0; d3 < o3; ++d3) {
            let e5 = 0;
            for (u3 = 0; u3 < c4; u3++)
              e5 += Q3[E3[u3] + d3] * C4[u3];
            e5 = interpolate(e5, 0, 1, l3[d3][0], l3[d3][1]);
            i4[a4 + d3] = Math.min(Math.max(e5, r3[d3][0]), r3[d3][1]);
          }
        };
      }
      static constructInterpolated({ xref: e3, isEvalSupported: t3, dict: i3 }) {
        const a3 = toNumberArray(i3.getArray("C0")) || [0], s3 = toNumberArray(i3.getArray("C1")) || [1], r3 = i3.get("N"), n3 = [];
        for (let e4 = 0, t4 = a3.length; e4 < t4; ++e4)
          n3.push(s3[e4] - a3[e4]);
        const o3 = n3.length;
        return function constructInterpolatedFn(e4, t4, i4, s4) {
          const g3 = 1 === r3 ? e4[t4] : e4[t4] ** r3;
          for (let e5 = 0; e5 < o3; ++e5)
            i4[s4 + e5] = a3[e5] + g3 * n3[e5];
        };
      }
      static constructStiched({ xref: e3, isEvalSupported: t3, dict: i3 }) {
        const a3 = toNumberArray(i3.getArray("Domain"));
        if (!a3)
          throw new FormatError("No domain");
        if (1 !== a3.length / 2)
          throw new FormatError("Bad domain for stiched function");
        const s3 = [];
        for (const a4 of i3.get("Functions"))
          s3.push(this.parse({ xref: e3, isEvalSupported: t3, fn: e3.fetchIfRef(a4) }));
        const r3 = toNumberArray(i3.getArray("Bounds")), n3 = toNumberArray(i3.getArray("Encode")), o3 = new Float32Array(1);
        return function constructStichedFn(e4, t4, i4, g3) {
          const c3 = function constructStichedFromIRClip(e5, t5, i5) {
            e5 > i5 ? e5 = i5 : e5 < t5 && (e5 = t5);
            return e5;
          }(e4[t4], a3[0], a3[1]), C3 = r3.length;
          let h2;
          for (h2 = 0; h2 < C3 && !(c3 < r3[h2]); ++h2)
            ;
          let l3 = a3[0];
          h2 > 0 && (l3 = r3[h2 - 1]);
          let Q3 = a3[1];
          h2 < r3.length && (Q3 = r3[h2]);
          const E3 = n3[2 * h2], u3 = n3[2 * h2 + 1];
          o3[0] = l3 === Q3 ? E3 : E3 + (c3 - l3) * (u3 - E3) / (Q3 - l3);
          s3[h2](o3, 0, i4, g3);
        };
      }
      static constructPostScript({ xref: e3, isEvalSupported: t3, fn: i3, dict: a3 }) {
        const s3 = toNumberArray(a3.getArray("Domain")), r3 = toNumberArray(a3.getArray("Range"));
        if (!s3)
          throw new FormatError("No domain.");
        if (!r3)
          throw new FormatError("No range.");
        const n3 = new PostScriptLexer(i3), o3 = new PostScriptParser(n3).parse();
        if (t3 && FeatureTest.isEvalSupported) {
          const e4 = new PostScriptCompiler().compile(o3, s3, r3);
          if (e4)
            return new Function("src", "srcOffset", "dest", "destOffset", e4);
        }
        info("Unable to compile PS function");
        const g3 = r3.length >> 1, c3 = s3.length >> 1, C3 = new PostScriptEvaluator(o3), h2 = /* @__PURE__ */ Object.create(null);
        let l3 = 8192;
        const Q3 = new Float32Array(c3);
        return function constructPostScriptFn(e4, t4, i4, a4) {
          let s4, n4, o4 = "";
          const E3 = Q3;
          for (s4 = 0; s4 < c3; s4++) {
            n4 = e4[t4 + s4];
            E3[s4] = n4;
            o4 += n4 + "_";
          }
          const u3 = h2[o4];
          if (void 0 !== u3) {
            i4.set(u3, a4);
            return;
          }
          const d3 = new Float32Array(g3), f2 = C3.execute(E3), p2 = f2.length - g3;
          for (s4 = 0; s4 < g3; s4++) {
            n4 = f2[p2 + s4];
            let e5 = r3[2 * s4];
            if (n4 < e5)
              n4 = e5;
            else {
              e5 = r3[2 * s4 + 1];
              n4 > e5 && (n4 = e5);
            }
            d3[s4] = n4;
          }
          if (l3 > 0) {
            l3--;
            h2[o4] = d3;
          }
          i4.set(d3, a4);
        };
      }
    };
    _PostScriptStack = class _PostScriptStack {
      constructor(e3) {
        this.stack = e3 ? Array.from(e3) : [];
      }
      push(e3) {
        if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE)
          throw new Error("PostScript function stack overflow.");
        this.stack.push(e3);
      }
      pop() {
        if (this.stack.length <= 0)
          throw new Error("PostScript function stack underflow.");
        return this.stack.pop();
      }
      copy(e3) {
        if (this.stack.length + e3 >= _PostScriptStack.MAX_STACK_SIZE)
          throw new Error("PostScript function stack overflow.");
        const t3 = this.stack;
        for (let i3 = t3.length - e3, a3 = e3 - 1; a3 >= 0; a3--, i3++)
          t3.push(t3[i3]);
      }
      index(e3) {
        this.push(this.stack[this.stack.length - e3 - 1]);
      }
      roll(e3, t3) {
        const i3 = this.stack, a3 = i3.length - e3, s3 = i3.length - 1, r3 = a3 + (t3 - Math.floor(t3 / e3) * e3);
        for (let e4 = a3, t4 = s3; e4 < t4; e4++, t4--) {
          const a4 = i3[e4];
          i3[e4] = i3[t4];
          i3[t4] = a4;
        }
        for (let e4 = a3, t4 = r3 - 1; e4 < t4; e4++, t4--) {
          const a4 = i3[e4];
          i3[e4] = i3[t4];
          i3[t4] = a4;
        }
        for (let e4 = r3, t4 = s3; e4 < t4; e4++, t4--) {
          const a4 = i3[e4];
          i3[e4] = i3[t4];
          i3[t4] = a4;
        }
      }
    };
    __publicField(_PostScriptStack, "MAX_STACK_SIZE", 100);
    PostScriptStack = _PostScriptStack;
    PostScriptEvaluator = class {
      constructor(e3) {
        this.operators = e3;
      }
      execute(e3) {
        const t3 = new PostScriptStack(e3);
        let i3 = 0;
        const a3 = this.operators, s3 = a3.length;
        let r3, n3, o3;
        for (; i3 < s3; ) {
          r3 = a3[i3++];
          if ("number" != typeof r3)
            switch (r3) {
              case "jz":
                o3 = t3.pop();
                n3 = t3.pop();
                n3 || (i3 = o3);
                break;
              case "j":
                n3 = t3.pop();
                i3 = n3;
                break;
              case "abs":
                n3 = t3.pop();
                t3.push(Math.abs(n3));
                break;
              case "add":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 + o3);
                break;
              case "and":
                o3 = t3.pop();
                n3 = t3.pop();
                "boolean" == typeof n3 && "boolean" == typeof o3 ? t3.push(n3 && o3) : t3.push(n3 & o3);
                break;
              case "atan":
                o3 = t3.pop();
                n3 = t3.pop();
                n3 = Math.atan2(n3, o3) / Math.PI * 180;
                n3 < 0 && (n3 += 360);
                t3.push(n3);
                break;
              case "bitshift":
                o3 = t3.pop();
                n3 = t3.pop();
                n3 > 0 ? t3.push(n3 << o3) : t3.push(n3 >> o3);
                break;
              case "ceiling":
                n3 = t3.pop();
                t3.push(Math.ceil(n3));
                break;
              case "copy":
                n3 = t3.pop();
                t3.copy(n3);
                break;
              case "cos":
                n3 = t3.pop();
                t3.push(Math.cos(n3 % 360 / 180 * Math.PI));
                break;
              case "cvi":
                n3 = 0 | t3.pop();
                t3.push(n3);
                break;
              case "cvr":
                break;
              case "div":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 / o3);
                break;
              case "dup":
                t3.copy(1);
                break;
              case "eq":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 === o3);
                break;
              case "exch":
                t3.roll(2, 1);
                break;
              case "exp":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 ** o3);
                break;
              case "false":
                t3.push(false);
                break;
              case "floor":
                n3 = t3.pop();
                t3.push(Math.floor(n3));
                break;
              case "ge":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 >= o3);
                break;
              case "gt":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 > o3);
                break;
              case "idiv":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 / o3 | 0);
                break;
              case "index":
                n3 = t3.pop();
                t3.index(n3);
                break;
              case "le":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 <= o3);
                break;
              case "ln":
                n3 = t3.pop();
                t3.push(Math.log(n3));
                break;
              case "log":
                n3 = t3.pop();
                t3.push(Math.log10(n3));
                break;
              case "lt":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 < o3);
                break;
              case "mod":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 % o3);
                break;
              case "mul":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 * o3);
                break;
              case "ne":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 !== o3);
                break;
              case "neg":
                n3 = t3.pop();
                t3.push(-n3);
                break;
              case "not":
                n3 = t3.pop();
                "boolean" == typeof n3 ? t3.push(!n3) : t3.push(~n3);
                break;
              case "or":
                o3 = t3.pop();
                n3 = t3.pop();
                "boolean" == typeof n3 && "boolean" == typeof o3 ? t3.push(n3 || o3) : t3.push(n3 | o3);
                break;
              case "pop":
                t3.pop();
                break;
              case "roll":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.roll(n3, o3);
                break;
              case "round":
                n3 = t3.pop();
                t3.push(Math.round(n3));
                break;
              case "sin":
                n3 = t3.pop();
                t3.push(Math.sin(n3 % 360 / 180 * Math.PI));
                break;
              case "sqrt":
                n3 = t3.pop();
                t3.push(Math.sqrt(n3));
                break;
              case "sub":
                o3 = t3.pop();
                n3 = t3.pop();
                t3.push(n3 - o3);
                break;
              case "true":
                t3.push(true);
                break;
              case "truncate":
                n3 = t3.pop();
                n3 = n3 < 0 ? Math.ceil(n3) : Math.floor(n3);
                t3.push(n3);
                break;
              case "xor":
                o3 = t3.pop();
                n3 = t3.pop();
                "boolean" == typeof n3 && "boolean" == typeof o3 ? t3.push(n3 !== o3) : t3.push(n3 ^ o3);
                break;
              default:
                throw new FormatError(`Unknown operator ${r3}`);
            }
          else
            t3.push(r3);
        }
        return t3.stack;
      }
    };
    AstNode = class {
      constructor(e3) {
        this.type = e3;
      }
      visit(e3) {
        unreachable("abstract method");
      }
    };
    AstArgument = class extends AstNode {
      constructor(e3, t3, i3) {
        super("args");
        this.index = e3;
        this.min = t3;
        this.max = i3;
      }
      visit(e3) {
        e3.visitArgument(this);
      }
    };
    AstLiteral = class extends AstNode {
      constructor(e3) {
        super("literal");
        this.number = e3;
        this.min = e3;
        this.max = e3;
      }
      visit(e3) {
        e3.visitLiteral(this);
      }
    };
    AstBinaryOperation = class extends AstNode {
      constructor(e3, t3, i3, a3, s3) {
        super("binary");
        this.op = e3;
        this.arg1 = t3;
        this.arg2 = i3;
        this.min = a3;
        this.max = s3;
      }
      visit(e3) {
        e3.visitBinaryOperation(this);
      }
    };
    AstMin = class extends AstNode {
      constructor(e3, t3) {
        super("max");
        this.arg = e3;
        this.min = e3.min;
        this.max = t3;
      }
      visit(e3) {
        e3.visitMin(this);
      }
    };
    AstVariable = class extends AstNode {
      constructor(e3, t3, i3) {
        super("var");
        this.index = e3;
        this.min = t3;
        this.max = i3;
      }
      visit(e3) {
        e3.visitVariable(this);
      }
    };
    AstVariableDefinition = class extends AstNode {
      constructor(e3, t3) {
        super("definition");
        this.variable = e3;
        this.arg = t3;
      }
      visit(e3) {
        e3.visitVariableDefinition(this);
      }
    };
    ExpressionBuilderVisitor = class {
      constructor() {
        this.parts = [];
      }
      visitArgument(e3) {
        this.parts.push("Math.max(", e3.min, ", Math.min(", e3.max, ", src[srcOffset + ", e3.index, "]))");
      }
      visitVariable(e3) {
        this.parts.push("v", e3.index);
      }
      visitLiteral(e3) {
        this.parts.push(e3.number);
      }
      visitBinaryOperation(e3) {
        this.parts.push("(");
        e3.arg1.visit(this);
        this.parts.push(" ", e3.op, " ");
        e3.arg2.visit(this);
        this.parts.push(")");
      }
      visitVariableDefinition(e3) {
        this.parts.push("var ");
        e3.variable.visit(this);
        this.parts.push(" = ");
        e3.arg.visit(this);
        this.parts.push(";");
      }
      visitMin(e3) {
        this.parts.push("Math.min(");
        e3.arg.visit(this);
        this.parts.push(", ", e3.max, ")");
      }
      toString() {
        return this.parts.join("");
      }
    };
    PostScriptCompiler = class {
      compile(e3, t3, i3) {
        const a3 = [], s3 = [], r3 = t3.length >> 1, n3 = i3.length >> 1;
        let o3, g3, c3, C3, h2, l3, Q3, E3, u3 = 0;
        for (let e4 = 0; e4 < r3; e4++)
          a3.push(new AstArgument(e4, t3[2 * e4], t3[2 * e4 + 1]));
        for (let t4 = 0, i4 = e3.length; t4 < i4; t4++) {
          E3 = e3[t4];
          if ("number" != typeof E3)
            switch (E3) {
              case "add":
                if (a3.length < 2)
                  return null;
                C3 = a3.pop();
                c3 = a3.pop();
                a3.push(buildAddOperation(c3, C3));
                break;
              case "cvr":
                if (a3.length < 1)
                  return null;
                break;
              case "mul":
                if (a3.length < 2)
                  return null;
                C3 = a3.pop();
                c3 = a3.pop();
                a3.push(buildMulOperation(c3, C3));
                break;
              case "sub":
                if (a3.length < 2)
                  return null;
                C3 = a3.pop();
                c3 = a3.pop();
                a3.push(buildSubOperation(c3, C3));
                break;
              case "exch":
                if (a3.length < 2)
                  return null;
                h2 = a3.pop();
                l3 = a3.pop();
                a3.push(h2, l3);
                break;
              case "pop":
                if (a3.length < 1)
                  return null;
                a3.pop();
                break;
              case "index":
                if (a3.length < 1)
                  return null;
                c3 = a3.pop();
                if ("literal" !== c3.type)
                  return null;
                o3 = c3.number;
                if (o3 < 0 || !Number.isInteger(o3) || a3.length < o3)
                  return null;
                h2 = a3[a3.length - o3 - 1];
                if ("literal" === h2.type || "var" === h2.type) {
                  a3.push(h2);
                  break;
                }
                Q3 = new AstVariable(u3++, h2.min, h2.max);
                a3[a3.length - o3 - 1] = Q3;
                a3.push(Q3);
                s3.push(new AstVariableDefinition(Q3, h2));
                break;
              case "dup":
                if (a3.length < 1)
                  return null;
                if ("number" == typeof e3[t4 + 1] && "gt" === e3[t4 + 2] && e3[t4 + 3] === t4 + 7 && "jz" === e3[t4 + 4] && "pop" === e3[t4 + 5] && e3[t4 + 6] === e3[t4 + 1]) {
                  c3 = a3.pop();
                  a3.push(buildMinOperation(c3, e3[t4 + 1]));
                  t4 += 6;
                  break;
                }
                h2 = a3.at(-1);
                if ("literal" === h2.type || "var" === h2.type) {
                  a3.push(h2);
                  break;
                }
                Q3 = new AstVariable(u3++, h2.min, h2.max);
                a3[a3.length - 1] = Q3;
                a3.push(Q3);
                s3.push(new AstVariableDefinition(Q3, h2));
                break;
              case "roll":
                if (a3.length < 2)
                  return null;
                C3 = a3.pop();
                c3 = a3.pop();
                if ("literal" !== C3.type || "literal" !== c3.type)
                  return null;
                g3 = C3.number;
                o3 = c3.number;
                if (o3 <= 0 || !Number.isInteger(o3) || !Number.isInteger(g3) || a3.length < o3)
                  return null;
                g3 = (g3 % o3 + o3) % o3;
                if (0 === g3)
                  break;
                a3.push(...a3.splice(a3.length - o3, o3 - g3));
                break;
              default:
                return null;
            }
          else
            a3.push(new AstLiteral(E3));
        }
        if (a3.length !== n3)
          return null;
        const d3 = [];
        for (const e4 of s3) {
          const t4 = new ExpressionBuilderVisitor();
          e4.visit(t4);
          d3.push(t4.toString());
        }
        for (let e4 = 0, t4 = a3.length; e4 < t4; e4++) {
          const t5 = a3[e4], s4 = new ExpressionBuilderVisitor();
          t5.visit(s4);
          const r4 = i3[2 * e4], n4 = i3[2 * e4 + 1], o4 = [s4.toString()];
          if (r4 > t5.min) {
            o4.unshift("Math.max(", r4, ", ");
            o4.push(")");
          }
          if (n4 < t5.max) {
            o4.unshift("Math.min(", n4, ", ");
            o4.push(")");
          }
          o4.unshift("dest[destOffset + ", e4, "] = ");
          o4.push(";");
          d3.push(o4.join(""));
        }
        return d3.join("\n");
      }
    };
    Cs = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
    hs = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
    ls = [];
    Bs = [];
    Qs = { style: "normal", weight: "normal" };
    Es = { style: "normal", weight: "bold" };
    us = { style: "italic", weight: "normal" };
    ds = { style: "italic", weight: "bold" };
    fs = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: Qs, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: Es, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: us, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: ds, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: Qs, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: Es, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: us, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: ds, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"], style: Qs, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: Es, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: us, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: ds, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: Qs, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: Es, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: us, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: ds, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: Qs, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: Es, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: us, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: ds, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: Qs }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]);
    ps = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
    ImageResizer = class _ImageResizer {
      constructor(e3, t3) {
        this._imgData = e3;
        this._isMask = t3;
      }
      static needsToBeResized(e3, t3) {
        if (e3 <= this._goodSquareLength && t3 <= this._goodSquareLength)
          return false;
        const { MAX_DIM: i3 } = this;
        if (e3 > i3 || t3 > i3)
          return true;
        const a3 = e3 * t3;
        if (this._hasMaxArea)
          return a3 > this.MAX_AREA;
        if (a3 < this._goodSquareLength ** 2)
          return false;
        if (this._areGoodDims(e3, t3)) {
          this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(e3 * t3)));
          return false;
        }
        this._goodSquareLength = this._guessMax(this._goodSquareLength, i3, 128, 0);
        return a3 > (this.MAX_AREA = this._goodSquareLength ** 2);
      }
      static get MAX_DIM() {
        return shadow(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
      }
      static get MAX_AREA() {
        this._hasMaxArea = true;
        return shadow(this, "MAX_AREA", this._guessMax(_ImageResizer._goodSquareLength, this.MAX_DIM, 128, 0) ** 2);
      }
      static set MAX_AREA(e3) {
        if (e3 >= 0) {
          this._hasMaxArea = true;
          shadow(this, "MAX_AREA", e3);
        }
      }
      static setMaxArea(e3) {
        this._hasMaxArea || (this.MAX_AREA = e3 >> 2);
      }
      static _areGoodDims(e3, t3) {
        try {
          const i3 = new OffscreenCanvas(e3, t3), a3 = i3.getContext("2d");
          a3.fillRect(0, 0, 1, 1);
          const s3 = a3.getImageData(0, 0, 1, 1).data[3];
          i3.width = i3.height = 1;
          return 0 !== s3;
        } catch {
          return false;
        }
      }
      static _guessMax(e3, t3, i3, a3) {
        for (; e3 + i3 + 1 < t3; ) {
          const i4 = Math.floor((e3 + t3) / 2), s3 = a3 || i4;
          this._areGoodDims(i4, s3) ? e3 = i4 : t3 = i4;
        }
        return e3;
      }
      static async createImage(e3, t3 = false) {
        return new _ImageResizer(e3, t3)._createImage();
      }
      async _createImage() {
        const e3 = this._encodeBMP(), t3 = new Blob([e3.buffer], { type: "image/bmp" }), i3 = createImageBitmap(t3), { MAX_AREA: a3, MAX_DIM: s3 } = _ImageResizer, { _imgData: r3 } = this, { width: n3, height: o3 } = r3, g3 = Math.max(n3 / s3, o3 / s3, Math.sqrt(n3 * o3 / a3)), c3 = Math.max(g3, 2), C3 = Math.round(10 * (g3 + 1.25)) / 10 / c3, h2 = Math.floor(Math.log2(C3)), l3 = new Array(h2 + 2).fill(2);
        l3[0] = c3;
        l3.splice(-1, 1, C3 / (1 << h2));
        let Q3 = n3, E3 = o3, u3 = await i3;
        for (const e4 of l3) {
          const t4 = Q3, i4 = E3;
          Q3 = Math.floor(Q3 / e4) - 1;
          E3 = Math.floor(E3 / e4) - 1;
          const a4 = new OffscreenCanvas(Q3, E3);
          a4.getContext("2d").drawImage(u3, 0, 0, t4, i4, 0, 0, Q3, E3);
          u3 = a4.transferToImageBitmap();
        }
        r3.data = null;
        r3.bitmap = u3;
        r3.width = Q3;
        r3.height = E3;
        return r3;
      }
      _encodeBMP() {
        const { width: e3, height: t3, kind: i3 } = this._imgData;
        let a3, s3 = this._imgData.data, r3 = new Uint8Array(0), n3 = r3, o3 = 0;
        switch (i3) {
          case b2: {
            a3 = 1;
            r3 = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
            const i5 = e3 + 7 >> 3, n4 = i5 + 3 & -4;
            if (i5 !== n4) {
              const e4 = new Uint8Array(n4 * t3);
              let a4 = 0;
              for (let r4 = 0, o4 = t3 * i5; r4 < o4; r4 += i5, a4 += n4)
                e4.set(s3.subarray(r4, r4 + i5), a4);
              s3 = e4;
            }
            break;
          }
          case D2:
            a3 = 24;
            if (3 & e3) {
              const i5 = 3 * e3, a4 = i5 + 3 & -4, r4 = a4 - i5, n4 = new Uint8Array(a4 * t3);
              let o4 = 0;
              for (let e4 = 0, a5 = t3 * i5; e4 < a5; e4 += i5) {
                const t4 = s3.subarray(e4, e4 + i5);
                for (let e5 = 0; e5 < i5; e5 += 3) {
                  n4[o4++] = t4[e5 + 2];
                  n4[o4++] = t4[e5 + 1];
                  n4[o4++] = t4[e5];
                }
                o4 += r4;
              }
              s3 = n4;
            } else
              for (let e4 = 0, t4 = s3.length; e4 < t4; e4 += 3) {
                const t5 = s3[e4];
                s3[e4] = s3[e4 + 2];
                s3[e4 + 2] = t5;
              }
            break;
          case F2:
            a3 = 32;
            o3 = 3;
            n3 = new Uint8Array(68);
            const i4 = new DataView(n3.buffer);
            if (FeatureTest.isLittleEndian) {
              i4.setUint32(0, 255, true);
              i4.setUint32(4, 65280, true);
              i4.setUint32(8, 16711680, true);
              i4.setUint32(12, 4278190080, true);
            } else {
              i4.setUint32(0, 4278190080, true);
              i4.setUint32(4, 16711680, true);
              i4.setUint32(8, 65280, true);
              i4.setUint32(12, 255, true);
            }
            break;
          default:
            throw new Error("invalid format");
        }
        let g3 = 0;
        const c3 = 40 + n3.length, C3 = 14 + c3 + r3.length + s3.length, h2 = new Uint8Array(C3), l3 = new DataView(h2.buffer);
        l3.setUint16(g3, 19778, true);
        g3 += 2;
        l3.setUint32(g3, C3, true);
        g3 += 4;
        l3.setUint32(g3, 0, true);
        g3 += 4;
        l3.setUint32(g3, 14 + c3 + r3.length, true);
        g3 += 4;
        l3.setUint32(g3, c3, true);
        g3 += 4;
        l3.setInt32(g3, e3, true);
        g3 += 4;
        l3.setInt32(g3, -t3, true);
        g3 += 4;
        l3.setUint16(g3, 1, true);
        g3 += 2;
        l3.setUint16(g3, a3, true);
        g3 += 2;
        l3.setUint32(g3, o3, true);
        g3 += 4;
        l3.setUint32(g3, 0, true);
        g3 += 4;
        l3.setInt32(g3, 0, true);
        g3 += 4;
        l3.setInt32(g3, 0, true);
        g3 += 4;
        l3.setUint32(g3, r3.length / 4, true);
        g3 += 4;
        l3.setUint32(g3, 0, true);
        g3 += 4;
        h2.set(n3, g3);
        g3 += n3.length;
        h2.set(r3, g3);
        g3 += r3.length;
        h2.set(s3, g3);
        return h2;
      }
    };
    ImageResizer._goodSquareLength = 2048;
    ms = 3285377520;
    ys = 4294901760;
    ws = 65535;
    MurmurHash3_64 = class {
      constructor(e3) {
        this.h1 = e3 ? 4294967295 & e3 : ms;
        this.h2 = e3 ? 4294967295 & e3 : ms;
      }
      update(e3) {
        let t3, i3;
        if ("string" == typeof e3) {
          t3 = new Uint8Array(2 * e3.length);
          i3 = 0;
          for (let a4 = 0, s4 = e3.length; a4 < s4; a4++) {
            const s5 = e3.charCodeAt(a4);
            if (s5 <= 255)
              t3[i3++] = s5;
            else {
              t3[i3++] = s5 >>> 8;
              t3[i3++] = 255 & s5;
            }
          }
        } else {
          if (!ArrayBuffer.isView(e3))
            throw new Error("Invalid data format, must be a string or TypedArray.");
          t3 = e3.slice();
          i3 = t3.byteLength;
        }
        const a3 = i3 >> 2, s3 = i3 - 4 * a3, r3 = new Uint32Array(t3.buffer, 0, a3);
        let n3 = 0, o3 = 0, g3 = this.h1, c3 = this.h2;
        const C3 = 3432918353, h2 = 461845907, l3 = 11601, Q3 = 13715;
        for (let e4 = 0; e4 < a3; e4++)
          if (1 & e4) {
            n3 = r3[e4];
            n3 = n3 * C3 & ys | n3 * l3 & ws;
            n3 = n3 << 15 | n3 >>> 17;
            n3 = n3 * h2 & ys | n3 * Q3 & ws;
            g3 ^= n3;
            g3 = g3 << 13 | g3 >>> 19;
            g3 = 5 * g3 + 3864292196;
          } else {
            o3 = r3[e4];
            o3 = o3 * C3 & ys | o3 * l3 & ws;
            o3 = o3 << 15 | o3 >>> 17;
            o3 = o3 * h2 & ys | o3 * Q3 & ws;
            c3 ^= o3;
            c3 = c3 << 13 | c3 >>> 19;
            c3 = 5 * c3 + 3864292196;
          }
        n3 = 0;
        switch (s3) {
          case 3:
            n3 ^= t3[4 * a3 + 2] << 16;
          case 2:
            n3 ^= t3[4 * a3 + 1] << 8;
          case 1:
            n3 ^= t3[4 * a3];
            n3 = n3 * C3 & ys | n3 * l3 & ws;
            n3 = n3 << 15 | n3 >>> 17;
            n3 = n3 * h2 & ys | n3 * Q3 & ws;
            1 & a3 ? g3 ^= n3 : c3 ^= n3;
        }
        this.h1 = g3;
        this.h2 = c3;
      }
      hexdigest() {
        let e3 = this.h1, t3 = this.h2;
        e3 ^= t3 >>> 1;
        e3 = 3981806797 * e3 & ys | 36045 * e3 & ws;
        t3 = 4283543511 * t3 & ys | (2950163797 * (t3 << 16 | e3 >>> 16) & ys) >>> 16;
        e3 ^= t3 >>> 1;
        e3 = 444984403 * e3 & ys | 60499 * e3 & ws;
        t3 = 3301882366 * t3 & ys | (3120437893 * (t3 << 16 | e3 >>> 16) & ys) >>> 16;
        e3 ^= t3 >>> 1;
        return (e3 >>> 0).toString(16).padStart(8, "0") + (t3 >>> 0).toString(16).padStart(8, "0");
      }
    };
    bs = [];
    addState(bs, [GA, UA, ze2, xA], null, function iterateInlineImageGroup(e3, t3) {
      const i3 = e3.fnArray, a3 = (t3 - (e3.iCurr - 3)) % 4;
      switch (a3) {
        case 0:
          return i3[t3] === GA;
        case 1:
          return i3[t3] === UA;
        case 2:
          return i3[t3] === ze2;
        case 3:
          return i3[t3] === xA;
      }
      throw new Error(`iterateInlineImageGroup - invalid pos: ${a3}`);
    }, function foundInlineImageGroup(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = e3.iCurr, r3 = s3 - 3, n3 = s3 - 2, o3 = s3 - 1, g3 = Math.min(Math.floor((t3 - r3) / 4), 200);
      if (g3 < 10)
        return t3 - (t3 - r3) % 4;
      let c3 = 0;
      const C3 = [];
      let h2 = 0, l3 = 1, Q3 = 1;
      for (let e4 = 0; e4 < g3; e4++) {
        const t4 = a3[n3 + (e4 << 2)], i4 = a3[o3 + (e4 << 2)][0];
        if (l3 + i4.width > 1e3) {
          c3 = Math.max(c3, l3);
          Q3 += h2 + 2;
          l3 = 0;
          h2 = 0;
        }
        C3.push({ transform: t4, x: l3, y: Q3, w: i4.width, h: i4.height });
        l3 += i4.width + 2;
        h2 = Math.max(h2, i4.height);
      }
      const E3 = Math.max(c3, l3) + 1, u3 = Q3 + h2 + 1, d3 = new Uint8Array(E3 * u3 * 4), f2 = E3 << 2;
      for (let e4 = 0; e4 < g3; e4++) {
        const t4 = a3[o3 + (e4 << 2)][0].data, i4 = C3[e4].w << 2;
        let s4 = 0, r4 = C3[e4].x + C3[e4].y * E3 << 2;
        d3.set(t4.subarray(0, i4), r4 - f2);
        for (let a4 = 0, n4 = C3[e4].h; a4 < n4; a4++) {
          d3.set(t4.subarray(s4, s4 + i4), r4);
          s4 += i4;
          r4 += f2;
        }
        d3.set(t4.subarray(s4 - i4, s4), r4);
        for (; r4 >= 0; ) {
          t4[r4 - 4] = t4[r4];
          t4[r4 - 3] = t4[r4 + 1];
          t4[r4 - 2] = t4[r4 + 2];
          t4[r4 - 1] = t4[r4 + 3];
          t4[r4 + i4] = t4[r4 + i4 - 4];
          t4[r4 + i4 + 1] = t4[r4 + i4 - 3];
          t4[r4 + i4 + 2] = t4[r4 + i4 - 2];
          t4[r4 + i4 + 3] = t4[r4 + i4 - 1];
          r4 -= f2;
        }
      }
      const p2 = { width: E3, height: u3 };
      if (e3.isOffscreenCanvasSupported) {
        const e4 = new OffscreenCanvas(E3, u3);
        e4.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(d3.buffer), E3, u3), 0, 0);
        p2.bitmap = e4.transferToImageBitmap();
        p2.data = null;
      } else {
        p2.kind = F2;
        p2.data = d3;
      }
      i3.splice(r3, 4 * g3, _e2);
      a3.splice(r3, 4 * g3, [p2, C3]);
      return r3 + 1;
    });
    addState(bs, [GA, UA, Xe2, xA], null, function iterateImageMaskGroup(e3, t3) {
      const i3 = e3.fnArray, a3 = (t3 - (e3.iCurr - 3)) % 4;
      switch (a3) {
        case 0:
          return i3[t3] === GA;
        case 1:
          return i3[t3] === UA;
        case 2:
          return i3[t3] === Xe2;
        case 3:
          return i3[t3] === xA;
      }
      throw new Error(`iterateImageMaskGroup - invalid pos: ${a3}`);
    }, function foundImageMaskGroup(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = e3.iCurr, r3 = s3 - 3, n3 = s3 - 2, o3 = s3 - 1;
      let g3 = Math.floor((t3 - r3) / 4);
      if (g3 < 10)
        return t3 - (t3 - r3) % 4;
      let c3, C3, h2 = false;
      const l3 = a3[o3][0], Q3 = a3[n3][0], E3 = a3[n3][1], u3 = a3[n3][2], d3 = a3[n3][3];
      if (E3 === u3) {
        h2 = true;
        c3 = n3 + 4;
        let e4 = o3 + 4;
        for (let t4 = 1; t4 < g3; t4++, c3 += 4, e4 += 4) {
          C3 = a3[c3];
          if (a3[e4][0] !== l3 || C3[0] !== Q3 || C3[1] !== E3 || C3[2] !== u3 || C3[3] !== d3) {
            t4 < 10 ? h2 = false : g3 = t4;
            break;
          }
        }
      }
      if (h2) {
        g3 = Math.min(g3, 1e3);
        const e4 = new Float32Array(2 * g3);
        c3 = n3;
        for (let t4 = 0; t4 < g3; t4++, c3 += 4) {
          C3 = a3[c3];
          e4[t4 << 1] = C3[4];
          e4[1 + (t4 << 1)] = C3[5];
        }
        i3.splice(r3, 4 * g3, At);
        a3.splice(r3, 4 * g3, [l3, Q3, E3, u3, d3, e4]);
      } else {
        g3 = Math.min(g3, 100);
        const e4 = [];
        for (let t4 = 0; t4 < g3; t4++) {
          C3 = a3[n3 + (t4 << 2)];
          const i4 = a3[o3 + (t4 << 2)][0];
          e4.push({ data: i4.data, width: i4.width, height: i4.height, interpolate: i4.interpolate, count: i4.count, transform: C3 });
        }
        i3.splice(r3, 4 * g3, Ze2);
        a3.splice(r3, 4 * g3, [e4]);
      }
      return r3 + 1;
    });
    addState(bs, [GA, UA, Ve2, xA], function(e3) {
      const t3 = e3.argsArray, i3 = e3.iCurr - 2;
      return 0 === t3[i3][1] && 0 === t3[i3][2];
    }, function iterateImageGroup(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = (t3 - (e3.iCurr - 3)) % 4;
      switch (s3) {
        case 0:
          return i3[t3] === GA;
        case 1:
          if (i3[t3] !== UA)
            return false;
          const s4 = e3.iCurr - 2, r3 = a3[s4][0], n3 = a3[s4][3];
          return a3[t3][0] === r3 && 0 === a3[t3][1] && 0 === a3[t3][2] && a3[t3][3] === n3;
        case 2:
          if (i3[t3] !== Ve2)
            return false;
          const o3 = a3[e3.iCurr - 1][0];
          return a3[t3][0] === o3;
        case 3:
          return i3[t3] === xA;
      }
      throw new Error(`iterateImageGroup - invalid pos: ${s3}`);
    }, function(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = e3.iCurr, r3 = s3 - 3, n3 = s3 - 2, o3 = a3[s3 - 1][0], g3 = a3[n3][0], c3 = a3[n3][3], C3 = Math.min(Math.floor((t3 - r3) / 4), 1e3);
      if (C3 < 3)
        return t3 - (t3 - r3) % 4;
      const h2 = new Float32Array(2 * C3);
      let l3 = n3;
      for (let e4 = 0; e4 < C3; e4++, l3 += 4) {
        const t4 = a3[l3];
        h2[e4 << 1] = t4[4];
        h2[1 + (e4 << 1)] = t4[5];
      }
      const Q3 = [o3, g3, c3, h2];
      i3.splice(r3, 4 * C3, $e2);
      a3.splice(r3, 4 * C3, Q3);
      return r3 + 1;
    });
    addState(bs, [$A, se2, Ie2, Ce2, Ae2], null, function iterateShowTextGroup(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = (t3 - (e3.iCurr - 4)) % 5;
      switch (s3) {
        case 0:
          return i3[t3] === $A;
        case 1:
          return i3[t3] === se2;
        case 2:
          return i3[t3] === Ie2;
        case 3:
          if (i3[t3] !== Ce2)
            return false;
          const s4 = e3.iCurr - 3, r3 = a3[s4][0], n3 = a3[s4][1];
          return a3[t3][0] === r3 && a3[t3][1] === n3;
        case 4:
          return i3[t3] === Ae2;
      }
      throw new Error(`iterateShowTextGroup - invalid pos: ${s3}`);
    }, function(e3, t3) {
      const i3 = e3.fnArray, a3 = e3.argsArray, s3 = e3.iCurr, r3 = s3 - 4, n3 = s3 - 3, o3 = s3 - 2, g3 = s3 - 1, c3 = s3, C3 = a3[n3][0], h2 = a3[n3][1];
      let l3 = Math.min(Math.floor((t3 - r3) / 5), 1e3);
      if (l3 < 3)
        return t3 - (t3 - r3) % 5;
      let Q3 = r3;
      if (r3 >= 4 && i3[r3 - 4] === i3[n3] && i3[r3 - 3] === i3[o3] && i3[r3 - 2] === i3[g3] && i3[r3 - 1] === i3[c3] && a3[r3 - 4][0] === C3 && a3[r3 - 4][1] === h2) {
        l3++;
        Q3 -= 5;
      }
      let E3 = Q3 + 4;
      for (let e4 = 1; e4 < l3; e4++) {
        i3.splice(E3, 3);
        a3.splice(E3, 3);
        E3 += 2;
      }
      return E3 + 1;
    });
    NullOptimizer = class {
      constructor(e3) {
        this.queue = e3;
      }
      _optimize() {
      }
      push(e3, t3) {
        this.queue.fnArray.push(e3);
        this.queue.argsArray.push(t3);
        this._optimize();
      }
      flush() {
      }
      reset() {
      }
    };
    QueueOptimizer = class extends NullOptimizer {
      constructor(e3) {
        super(e3);
        this.state = null;
        this.context = { iCurr: 0, fnArray: e3.fnArray, argsArray: e3.argsArray, isOffscreenCanvasSupported: false };
        this.match = null;
        this.lastProcessed = 0;
      }
      set isOffscreenCanvasSupported(e3) {
        this.context.isOffscreenCanvasSupported = e3;
      }
      _optimize() {
        const e3 = this.queue.fnArray;
        let t3 = this.lastProcessed, i3 = e3.length, a3 = this.state, s3 = this.match;
        if (!a3 && !s3 && t3 + 1 === i3 && !bs[e3[t3]]) {
          this.lastProcessed = i3;
          return;
        }
        const r3 = this.context;
        for (; t3 < i3; ) {
          if (s3) {
            if ((0, s3.iterateFn)(r3, t3)) {
              t3++;
              continue;
            }
            t3 = (0, s3.processFn)(r3, t3 + 1);
            i3 = e3.length;
            s3 = null;
            a3 = null;
            if (t3 >= i3)
              break;
          }
          a3 = (a3 || bs)[e3[t3]];
          if (a3 && !Array.isArray(a3)) {
            r3.iCurr = t3;
            t3++;
            if (!a3.checkFn || (0, a3.checkFn)(r3)) {
              s3 = a3;
              a3 = null;
            } else
              a3 = null;
          } else
            t3++;
        }
        this.state = a3;
        this.match = s3;
        this.lastProcessed = t3;
      }
      flush() {
        for (; this.match; ) {
          const e3 = this.queue.fnArray.length;
          this.lastProcessed = (0, this.match.processFn)(this.context, e3);
          this.match = null;
          this.state = null;
          this._optimize();
        }
      }
      reset() {
        this.state = null;
        this.match = null;
        this.lastProcessed = 0;
      }
    };
    _OperatorList = class _OperatorList {
      constructor(e3 = 0, t3) {
        this._streamSink = t3;
        this.fnArray = [];
        this.argsArray = [];
        this.optimizer = !t3 || e3 & Q2 ? new NullOptimizer(this) : new QueueOptimizer(this);
        this.dependencies = /* @__PURE__ */ new Set();
        this._totalLength = 0;
        this.weight = 0;
        this._resolved = t3 ? null : Promise.resolve();
      }
      set isOffscreenCanvasSupported(e3) {
        this.optimizer.isOffscreenCanvasSupported = e3;
      }
      get length() {
        return this.argsArray.length;
      }
      get ready() {
        return this._resolved || this._streamSink.ready;
      }
      get totalLength() {
        return this._totalLength + this.length;
      }
      addOp(e3, t3) {
        this.optimizer.push(e3, t3);
        this.weight++;
        this._streamSink && (this.weight >= _OperatorList.CHUNK_SIZE || this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (e3 === xA || e3 === Ae2)) && this.flush();
      }
      addImageOps(e3, t3, i3) {
        void 0 !== i3 && this.addOp(Je2, ["OC", i3]);
        this.addOp(e3, t3);
        void 0 !== i3 && this.addOp(Ye2, []);
      }
      addDependency(e3) {
        if (!this.dependencies.has(e3)) {
          this.dependencies.add(e3);
          this.addOp(yA, [e3]);
        }
      }
      addDependencies(e3) {
        for (const t3 of e3)
          this.addDependency(t3);
      }
      addOpList(e3) {
        if (e3 instanceof _OperatorList) {
          for (const t3 of e3.dependencies)
            this.dependencies.add(t3);
          for (let t3 = 0, i3 = e3.length; t3 < i3; t3++)
            this.addOp(e3.fnArray[t3], e3.argsArray[t3]);
        } else
          warn('addOpList - ignoring invalid "opList" parameter.');
      }
      getIR() {
        return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
      }
      get _transfers() {
        var _a3;
        const e3 = [], { fnArray: t3, argsArray: i3, length: a3 } = this;
        for (let s3 = 0; s3 < a3; s3++)
          switch (t3[s3]) {
            case ze2:
            case _e2:
            case Xe2:
              const t4 = i3[s3][0];
              !t4.cached && ((_a3 = t4.data) == null ? void 0 : _a3.buffer) instanceof ArrayBuffer && e3.push(t4.data.buffer);
          }
        return e3;
      }
      flush(e3 = false, t3 = null) {
        this.optimizer.flush();
        const i3 = this.length;
        this._totalLength += i3;
        this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: e3, separateAnnots: t3, length: i3 }, 1, this._transfers);
        this.dependencies.clear();
        this.fnArray.length = 0;
        this.argsArray.length = 0;
        this.weight = 0;
        this.optimizer.reset();
      }
    };
    __publicField(_OperatorList, "CHUNK_SIZE", 1e3);
    __publicField(_OperatorList, "CHUNK_SIZE_ABOUT", _OperatorList.CHUNK_SIZE - 5);
    OperatorList = _OperatorList;
    PDFImage = class _PDFImage {
      constructor({ xref: e3, res: t3, image: i3, isInline: a3 = false, smask: s3 = null, mask: r3 = null, isMask: n3 = false, pdfFunctionFactory: o3, localColorSpaceCache: g3 }) {
        var _a3;
        this.image = i3;
        let c3 = false;
        const C3 = i3.dict, h2 = C3.get("F", "Filter");
        let l3;
        if (h2 instanceof Name)
          l3 = h2.name;
        else if (Array.isArray(h2)) {
          const t4 = e3.fetchIfRef(h2[0]);
          t4 instanceof Name && (l3 = t4.name);
        }
        switch (l3) {
          case "JPXDecode":
            ({ width: i3.width, height: i3.height, componentsCount: i3.numComps, bitsPerComponent: i3.bitsPerComponent } = JpxImage.parseImageProperties(i3.stream));
            i3.stream.reset();
            c3 = true;
            break;
          case "JBIG2Decode":
            i3.bitsPerComponent = 1;
            i3.numComps = 1;
        }
        let Q3 = C3.get("W", "Width"), E3 = C3.get("H", "Height");
        if (Number.isInteger(i3.width) && i3.width > 0 && Number.isInteger(i3.height) && i3.height > 0 && (i3.width !== Q3 || i3.height !== E3)) {
          warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
          Q3 = i3.width;
          E3 = i3.height;
        }
        if (Q3 < 1 || E3 < 1)
          throw new FormatError(`Invalid image width: ${Q3} or height: ${E3}`);
        this.width = Q3;
        this.height = E3;
        this.interpolate = C3.get("I", "Interpolate");
        this.imageMask = C3.get("IM", "ImageMask") || false;
        this.matte = C3.get("Matte") || false;
        let u3 = i3.bitsPerComponent;
        if (!u3) {
          u3 = C3.get("BPC", "BitsPerComponent");
          if (!u3) {
            if (!this.imageMask)
              throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);
            u3 = 1;
          }
        }
        this.bpc = u3;
        if (!this.imageMask) {
          let s4 = C3.getRaw("CS") || C3.getRaw("ColorSpace");
          if (!s4) {
            info("JPX images (which do not require color spaces)");
            switch (i3.numComps) {
              case 1:
                s4 = Name.get("DeviceGray");
                break;
              case 3:
                s4 = Name.get("DeviceRGB");
                break;
              case 4:
                s4 = Name.get("DeviceCMYK");
                break;
              default:
                throw new Error(`JPX images with ${i3.numComps} color components not supported.`);
            }
          }
          this.colorSpace = ColorSpace.parse({ cs: s4, xref: e3, resources: a3 ? t3 : null, pdfFunctionFactory: o3, localColorSpaceCache: g3 });
          this.numComps = this.colorSpace.numComps;
          this.ignoreColorSpace = c3 && "Indexed" === this.colorSpace.name;
        }
        this.decode = C3.getArray("D", "Decode");
        this.needsDecode = false;
        if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, u3) || n3 && !ColorSpace.isDefaultDecode(this.decode, 1))) {
          this.needsDecode = true;
          const e4 = (1 << u3) - 1;
          this.decodeCoefficients = [];
          this.decodeAddends = [];
          const t4 = "Indexed" === ((_a3 = this.colorSpace) == null ? void 0 : _a3.name);
          for (let i4 = 0, a4 = 0; i4 < this.decode.length; i4 += 2, ++a4) {
            const s4 = this.decode[i4], r4 = this.decode[i4 + 1];
            this.decodeCoefficients[a4] = t4 ? (r4 - s4) / e4 : r4 - s4;
            this.decodeAddends[a4] = t4 ? s4 : e4 * s4;
          }
        }
        if (s3)
          this.smask = new _PDFImage({ xref: e3, res: t3, image: s3, isInline: a3, pdfFunctionFactory: o3, localColorSpaceCache: g3 });
        else if (r3)
          if (r3 instanceof BaseStream) {
            r3.dict.get("IM", "ImageMask") ? this.mask = new _PDFImage({ xref: e3, res: t3, image: r3, isInline: a3, isMask: true, pdfFunctionFactory: o3, localColorSpaceCache: g3 }) : warn("Ignoring /Mask in image without /ImageMask.");
          } else
            this.mask = r3;
      }
      static async buildImage({ xref: e3, res: t3, image: i3, isInline: a3 = false, pdfFunctionFactory: s3, localColorSpaceCache: r3 }) {
        const n3 = i3;
        let o3 = null, g3 = null;
        const c3 = i3.dict.get("SMask"), C3 = i3.dict.get("Mask");
        c3 ? c3 instanceof BaseStream ? o3 = c3 : warn("Unsupported /SMask format.") : C3 && (C3 instanceof BaseStream || Array.isArray(C3) ? g3 = C3 : warn("Unsupported /Mask format."));
        return new _PDFImage({ xref: e3, res: t3, image: n3, isInline: a3, smask: o3, mask: g3, pdfFunctionFactory: s3, localColorSpaceCache: r3 });
      }
      static createRawMask({ imgArray: e3, width: t3, height: i3, imageIsFromDecodeStream: a3, inverseDecode: s3, interpolate: r3 }) {
        const n3 = (t3 + 7 >> 3) * i3, o3 = e3.byteLength;
        let g3, c3;
        if (!a3 || s3 && !(n3 === o3))
          if (s3) {
            g3 = new Uint8Array(n3);
            g3.set(e3);
            g3.fill(255, o3);
          } else
            g3 = new Uint8Array(e3);
        else
          g3 = e3;
        if (s3)
          for (c3 = 0; c3 < o3; c3++)
            g3[c3] ^= 255;
        return { data: g3, width: t3, height: i3, interpolate: r3 };
      }
      static async createMask({ imgArray: e3, width: t3, height: i3, imageIsFromDecodeStream: a3, inverseDecode: s3, interpolate: r3, isOffscreenCanvasSupported: n3 = false }) {
        const o3 = 1 === t3 && 1 === i3 && s3 === (0 === e3.length || !!(128 & e3[0]));
        if (o3)
          return { isSingleOpaquePixel: o3 };
        if (n3) {
          if (ImageResizer.needsToBeResized(t3, i3)) {
            const a5 = new Uint8ClampedArray(t3 * i3 * 4);
            convertBlackAndWhiteToRGBA({ src: e3, dest: a5, width: t3, height: i3, nonBlackColor: 0, inverseDecode: s3 });
            return ImageResizer.createImage({ kind: F2, data: a5, width: t3, height: i3, interpolate: r3 });
          }
          const a4 = new OffscreenCanvas(t3, i3), n4 = a4.getContext("2d"), o4 = n4.createImageData(t3, i3);
          convertBlackAndWhiteToRGBA({ src: e3, dest: o4.data, width: t3, height: i3, nonBlackColor: 0, inverseDecode: s3 });
          n4.putImageData(o4, 0, 0);
          return { data: null, width: t3, height: i3, interpolate: r3, bitmap: a4.transferToImageBitmap() };
        }
        return this.createRawMask({ imgArray: e3, width: t3, height: i3, inverseDecode: s3, imageIsFromDecodeStream: a3, interpolate: r3 });
      }
      get drawWidth() {
        var _a3, _b2;
        return Math.max(this.width, ((_a3 = this.smask) == null ? void 0 : _a3.width) || 0, ((_b2 = this.mask) == null ? void 0 : _b2.width) || 0);
      }
      get drawHeight() {
        var _a3, _b2;
        return Math.max(this.height, ((_a3 = this.smask) == null ? void 0 : _a3.height) || 0, ((_b2 = this.mask) == null ? void 0 : _b2.height) || 0);
      }
      decodeBuffer(e3) {
        const t3 = this.bpc, i3 = this.numComps, a3 = this.decodeAddends, s3 = this.decodeCoefficients, r3 = (1 << t3) - 1;
        let n3, o3;
        if (1 === t3) {
          for (n3 = 0, o3 = e3.length; n3 < o3; n3++)
            e3[n3] = +!e3[n3];
          return;
        }
        let g3 = 0;
        for (n3 = 0, o3 = this.width * this.height; n3 < o3; n3++)
          for (let t4 = 0; t4 < i3; t4++) {
            e3[g3] = decodeAndClamp(e3[g3], a3[t4], s3[t4], r3);
            g3++;
          }
      }
      getComponents(e3) {
        const t3 = this.bpc;
        if (8 === t3)
          return e3;
        const i3 = this.width, a3 = this.height, s3 = this.numComps, r3 = i3 * a3 * s3;
        let n3, o3 = 0;
        n3 = t3 <= 8 ? new Uint8Array(r3) : t3 <= 16 ? new Uint16Array(r3) : new Uint32Array(r3);
        const g3 = i3 * s3, c3 = (1 << t3) - 1;
        let C3, h2, l3 = 0;
        if (1 === t3) {
          let t4, i4, s4;
          for (let r4 = 0; r4 < a3; r4++) {
            i4 = l3 + (-8 & g3);
            s4 = l3 + g3;
            for (; l3 < i4; ) {
              h2 = e3[o3++];
              n3[l3] = h2 >> 7 & 1;
              n3[l3 + 1] = h2 >> 6 & 1;
              n3[l3 + 2] = h2 >> 5 & 1;
              n3[l3 + 3] = h2 >> 4 & 1;
              n3[l3 + 4] = h2 >> 3 & 1;
              n3[l3 + 5] = h2 >> 2 & 1;
              n3[l3 + 6] = h2 >> 1 & 1;
              n3[l3 + 7] = 1 & h2;
              l3 += 8;
            }
            if (l3 < s4) {
              h2 = e3[o3++];
              t4 = 128;
              for (; l3 < s4; ) {
                n3[l3++] = +!!(h2 & t4);
                t4 >>= 1;
              }
            }
          }
        } else {
          let i4 = 0;
          h2 = 0;
          for (l3 = 0, C3 = r3; l3 < C3; ++l3) {
            if (l3 % g3 == 0) {
              h2 = 0;
              i4 = 0;
            }
            for (; i4 < t3; ) {
              h2 = h2 << 8 | e3[o3++];
              i4 += 8;
            }
            const a4 = i4 - t3;
            let s4 = h2 >> a4;
            s4 < 0 ? s4 = 0 : s4 > c3 && (s4 = c3);
            n3[l3] = s4;
            h2 &= (1 << a4) - 1;
            i4 = a4;
          }
        }
        return n3;
      }
      fillOpacity(e3, t3, i3, a3, s3) {
        const r3 = this.smask, n3 = this.mask;
        let o3, g3, c3, C3, h2, l3;
        if (r3) {
          g3 = r3.width;
          c3 = r3.height;
          o3 = new Uint8ClampedArray(g3 * c3);
          r3.fillGrayBuffer(o3);
          g3 === t3 && c3 === i3 || (o3 = resizeImageMask(o3, r3.bpc, g3, c3, t3, i3));
        } else if (n3)
          if (n3 instanceof _PDFImage) {
            g3 = n3.width;
            c3 = n3.height;
            o3 = new Uint8ClampedArray(g3 * c3);
            n3.numComps = 1;
            n3.fillGrayBuffer(o3);
            for (C3 = 0, h2 = g3 * c3; C3 < h2; ++C3)
              o3[C3] = 255 - o3[C3];
            g3 === t3 && c3 === i3 || (o3 = resizeImageMask(o3, n3.bpc, g3, c3, t3, i3));
          } else {
            if (!Array.isArray(n3))
              throw new FormatError("Unknown mask format.");
            {
              o3 = new Uint8ClampedArray(t3 * i3);
              const e4 = this.numComps;
              for (C3 = 0, h2 = t3 * i3; C3 < h2; ++C3) {
                let t4 = 0;
                const i4 = C3 * e4;
                for (l3 = 0; l3 < e4; ++l3) {
                  const e5 = s3[i4 + l3], a4 = 2 * l3;
                  if (e5 < n3[a4] || e5 > n3[a4 + 1]) {
                    t4 = 255;
                    break;
                  }
                }
                o3[C3] = t4;
              }
            }
          }
        if (o3)
          for (C3 = 0, l3 = 3, h2 = t3 * a3; C3 < h2; ++C3, l3 += 4)
            e3[l3] = o3[C3];
        else
          for (C3 = 0, l3 = 3, h2 = t3 * a3; C3 < h2; ++C3, l3 += 4)
            e3[l3] = 255;
      }
      undoPreblend(e3, t3, i3) {
        var _a3;
        const a3 = (_a3 = this.smask) == null ? void 0 : _a3.matte;
        if (!a3)
          return;
        const s3 = this.colorSpace.getRgb(a3, 0), r3 = s3[0], n3 = s3[1], o3 = s3[2], g3 = t3 * i3 * 4;
        for (let t4 = 0; t4 < g3; t4 += 4) {
          const i4 = e3[t4 + 3];
          if (0 === i4) {
            e3[t4] = 255;
            e3[t4 + 1] = 255;
            e3[t4 + 2] = 255;
            continue;
          }
          const a4 = 255 / i4;
          e3[t4] = (e3[t4] - r3) * a4 + r3;
          e3[t4 + 1] = (e3[t4 + 1] - n3) * a4 + n3;
          e3[t4 + 2] = (e3[t4 + 2] - o3) * a4 + o3;
        }
      }
      async createImageData(e3 = false, t3 = false) {
        const i3 = this.drawWidth, a3 = this.drawHeight, s3 = { width: i3, height: a3, interpolate: this.interpolate, kind: 0, data: null }, r3 = this.numComps, n3 = this.width, o3 = this.height, g3 = this.bpc, c3 = n3 * r3 * g3 + 7 >> 3, C3 = t3 && ImageResizer.needsToBeResized(i3, a3);
        if (!e3) {
          let e4;
          "DeviceGray" === this.colorSpace.name && 1 === g3 ? e4 = b2 : "DeviceRGB" !== this.colorSpace.name || 8 !== g3 || this.needsDecode || (e4 = D2);
          if (e4 && !this.smask && !this.mask && i3 === n3 && a3 === o3) {
            const r4 = this.getImageBytes(o3 * c3, {});
            if (t3)
              return C3 ? ImageResizer.createImage({ data: r4, kind: e4, width: i3, height: a3, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(e4, n3, o3, r4);
            s3.kind = e4;
            s3.data = r4;
            if (this.needsDecode) {
              assert(e4 === b2, "PDFImage.createImageData: The image must be grayscale.");
              const t4 = s3.data;
              for (let e5 = 0, i4 = t4.length; e5 < i4; e5++)
                t4[e5] ^= 255;
            }
            return s3;
          }
          if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
            let e5 = o3 * c3;
            if (t3 && !C3) {
              let t4 = false;
              switch (this.colorSpace.name) {
                case "DeviceGray":
                  e5 *= 4;
                  t4 = true;
                  break;
                case "DeviceRGB":
                  e5 = e5 / 3 * 4;
                  t4 = true;
                  break;
                case "DeviceCMYK":
                  t4 = true;
              }
              if (t4) {
                const t5 = this.getImageBytes(e5, { drawWidth: i3, drawHeight: a3, forceRGBA: true });
                return this.createBitmap(F2, i3, a3, t5);
              }
            } else
              switch (this.colorSpace.name) {
                case "DeviceGray":
                  e5 *= 3;
                case "DeviceRGB":
                case "DeviceCMYK":
                  s3.kind = D2;
                  s3.data = this.getImageBytes(e5, { drawWidth: i3, drawHeight: a3, forceRGB: true });
                  return C3 ? ImageResizer.createImage(s3) : s3;
              }
          }
        }
        const h2 = this.getImageBytes(o3 * c3, { internal: true }), l3 = 0 | h2.length / c3 * a3 / o3, Q3 = this.getComponents(h2);
        let E3, u3, d3, f2, p2, m3;
        if (t3 && !C3) {
          d3 = new OffscreenCanvas(i3, a3);
          f2 = d3.getContext("2d");
          p2 = f2.createImageData(i3, a3);
          m3 = p2.data;
        }
        s3.kind = F2;
        if (e3 || this.smask || this.mask) {
          t3 && !C3 || (m3 = new Uint8ClampedArray(i3 * a3 * 4));
          E3 = 1;
          u3 = true;
          this.fillOpacity(m3, i3, a3, l3, Q3);
        } else {
          if (!t3 || C3) {
            s3.kind = D2;
            m3 = new Uint8ClampedArray(i3 * a3 * 3);
            E3 = 0;
          } else {
            new Uint32Array(m3.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255);
            E3 = 1;
          }
          u3 = false;
        }
        this.needsDecode && this.decodeBuffer(Q3);
        this.colorSpace.fillRgb(m3, n3, o3, i3, a3, l3, g3, Q3, E3);
        u3 && this.undoPreblend(m3, i3, l3);
        if (t3 && !C3) {
          f2.putImageData(p2, 0, 0);
          return { data: null, width: i3, height: a3, bitmap: d3.transferToImageBitmap(), interpolate: this.interpolate };
        }
        s3.data = m3;
        return C3 ? ImageResizer.createImage(s3) : s3;
      }
      fillGrayBuffer(e3) {
        const t3 = this.numComps;
        if (1 !== t3)
          throw new FormatError(`Reading gray scale from a color image: ${t3}`);
        const i3 = this.width, a3 = this.height, s3 = this.bpc, r3 = i3 * t3 * s3 + 7 >> 3, n3 = this.getImageBytes(a3 * r3, { internal: true }), o3 = this.getComponents(n3);
        let g3, c3;
        if (1 === s3) {
          c3 = i3 * a3;
          if (this.needsDecode)
            for (g3 = 0; g3 < c3; ++g3)
              e3[g3] = o3[g3] - 1 & 255;
          else
            for (g3 = 0; g3 < c3; ++g3)
              e3[g3] = 255 & -o3[g3];
          return;
        }
        this.needsDecode && this.decodeBuffer(o3);
        c3 = i3 * a3;
        const C3 = 255 / ((1 << s3) - 1);
        for (g3 = 0; g3 < c3; ++g3)
          e3[g3] = C3 * o3[g3];
      }
      createBitmap(e3, t3, i3, a3) {
        const s3 = new OffscreenCanvas(t3, i3), r3 = s3.getContext("2d");
        let n3;
        if (e3 === F2)
          n3 = new ImageData(a3, t3, i3);
        else {
          n3 = r3.createImageData(t3, i3);
          convertToRGBA({ kind: e3, src: a3, dest: new Uint32Array(n3.data.buffer), width: t3, height: i3, inverseDecode: this.needsDecode });
        }
        r3.putImageData(n3, 0, 0);
        return { data: null, width: t3, height: i3, bitmap: s3.transferToImageBitmap(), interpolate: this.interpolate };
      }
      getImageBytes(e3, { drawWidth: t3, drawHeight: i3, forceRGBA: a3 = false, forceRGB: s3 = false, internal: r3 = false }) {
        this.image.reset();
        this.image.drawWidth = t3 || this.width;
        this.image.drawHeight = i3 || this.height;
        this.image.forceRGBA = !!a3;
        this.image.forceRGB = !!s3;
        const n3 = this.image.getBytes(e3, this.ignoreColorSpace);
        if (r3 || this.image instanceof DecodeStream)
          return n3;
        assert(n3 instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
        return new Uint8Array(n3);
      }
    };
    Ds = Object.freeze({ maxImageSize: -1, disableFontFace: false, ignoreErrors: false, isEvalSupported: true, isOffscreenCanvasSupported: false, canvasMaxAreaInBytes: -1, fontExtraProperties: false, useSystemFonts: true, cMapUrl: null, standardFontDataUrl: null });
    Fs = 1;
    Ss = 2;
    ks = Promise.resolve();
    _TimeSlotManager = class _TimeSlotManager {
      constructor() {
        this.reset();
      }
      check() {
        if (++this.checked < _TimeSlotManager.CHECK_TIME_EVERY)
          return false;
        this.checked = 0;
        return this.endTime <= Date.now();
      }
      reset() {
        this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS;
        this.checked = 0;
      }
    };
    __publicField(_TimeSlotManager, "TIME_SLOT_DURATION_MS", 20);
    __publicField(_TimeSlotManager, "CHECK_TIME_EVERY", 100);
    TimeSlotManager = _TimeSlotManager;
    PartialEvaluator = class _PartialEvaluator {
      constructor({ xref: e3, handler: t3, pageIndex: i3, idFactory: a3, fontCache: s3, builtInCMapCache: r3, standardFontDataCache: n3, globalImageCache: o3, systemFontCache: g3, options: c3 = null }) {
        this.xref = e3;
        this.handler = t3;
        this.pageIndex = i3;
        this.idFactory = a3;
        this.fontCache = s3;
        this.builtInCMapCache = r3;
        this.standardFontDataCache = n3;
        this.globalImageCache = o3;
        this.systemFontCache = g3;
        this.options = c3 || Ds;
        this.parsingType3Font = false;
        this._regionalImageCache = new RegionalImageCache();
        this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
        ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
      }
      get _pdfFunctionFactory() {
        return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }));
      }
      clone(e3 = null) {
        const t3 = Object.create(this);
        t3.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e3);
        return t3;
      }
      hasBlendModes(e3, t3) {
        if (!(e3 instanceof Dict))
          return false;
        if (e3.objId && t3.has(e3.objId))
          return false;
        const i3 = new RefSet(t3);
        e3.objId && i3.put(e3.objId);
        const a3 = [e3], s3 = this.xref;
        for (; a3.length; ) {
          const e4 = a3.shift(), t4 = e4.get("ExtGState");
          if (t4 instanceof Dict)
            for (let e5 of t4.getRawValues()) {
              if (e5 instanceof Ref) {
                if (i3.has(e5))
                  continue;
                try {
                  e5 = s3.fetch(e5);
                } catch (t6) {
                  i3.put(e5);
                  info(`hasBlendModes - ignoring ExtGState: "${t6}".`);
                  continue;
                }
              }
              if (!(e5 instanceof Dict))
                continue;
              e5.objId && i3.put(e5.objId);
              const t5 = e5.get("BM");
              if (t5 instanceof Name) {
                if ("Normal" !== t5.name)
                  return true;
              } else if (void 0 !== t5 && Array.isArray(t5)) {
                for (const e6 of t5)
                  if (e6 instanceof Name && "Normal" !== e6.name)
                    return true;
              }
            }
          const r3 = e4.get("XObject");
          if (r3 instanceof Dict)
            for (let e5 of r3.getRawValues()) {
              if (e5 instanceof Ref) {
                if (i3.has(e5))
                  continue;
                try {
                  e5 = s3.fetch(e5);
                } catch (t6) {
                  i3.put(e5);
                  info(`hasBlendModes - ignoring XObject: "${t6}".`);
                  continue;
                }
              }
              if (!(e5 instanceof BaseStream))
                continue;
              e5.dict.objId && i3.put(e5.dict.objId);
              const t5 = e5.dict.get("Resources");
              if (t5 instanceof Dict && (!t5.objId || !i3.has(t5.objId))) {
                a3.push(t5);
                t5.objId && i3.put(t5.objId);
              }
            }
        }
        for (const e4 of i3)
          t3.put(e4);
        return false;
      }
      async fetchBuiltInCMap(e3) {
        const t3 = this.builtInCMapCache.get(e3);
        if (t3)
          return t3;
        let i3;
        if (null !== this.options.cMapUrl) {
          const t4 = `${this.options.cMapUrl}${e3}.bcmap`, a3 = await fetch(t4);
          if (!a3.ok)
            throw new Error(`fetchBuiltInCMap: failed to fetch file "${t4}" with "${a3.statusText}".`);
          i3 = { cMapData: new Uint8Array(await a3.arrayBuffer()), compressionType: mA.BINARY };
        } else
          i3 = await this.handler.sendWithPromise("FetchBuiltInCMap", { name: e3 });
        i3.compressionType !== mA.NONE && this.builtInCMapCache.set(e3, i3);
        return i3;
      }
      async fetchStandardFontData(e3) {
        const t3 = this.standardFontDataCache.get(e3);
        if (t3)
          return new Stream(t3);
        if (this.options.useSystemFonts && "Symbol" !== e3 && "ZapfDingbats" !== e3)
          return null;
        const i3 = Wi()[e3];
        let a3;
        if (null !== this.options.standardFontDataUrl) {
          const e4 = `${this.options.standardFontDataUrl}${i3}`, t4 = await fetch(e4);
          t4.ok ? a3 = new Uint8Array(await t4.arrayBuffer()) : warn(`fetchStandardFontData: failed to fetch file "${e4}" with "${t4.statusText}".`);
        } else
          try {
            a3 = await this.handler.sendWithPromise("FetchStandardFontData", { filename: i3 });
          } catch (e4) {
            warn(`fetchStandardFontData: failed to fetch file "${i3}" with "${e4}".`);
          }
        if (!a3)
          return null;
        this.standardFontDataCache.set(e3, a3);
        return new Stream(a3);
      }
      async buildFormXObject(e3, t3, i3, a3, s3, r3, n3) {
        const o3 = t3.dict, g3 = o3.getArray("Matrix");
        let c3, C3, h2 = o3.getArray("BBox");
        h2 = Array.isArray(h2) && 4 === h2.length ? Util.normalizeRect(h2) : null;
        o3.has("OC") && (c3 = await this.parseMarkedContentProps(o3.get("OC"), e3));
        void 0 !== c3 && a3.addOp(Je2, ["OC", c3]);
        const l3 = o3.get("Group");
        if (l3) {
          C3 = { matrix: g3, bbox: h2, smask: i3, isolated: false, knockout: false };
          let t4 = null;
          if (isName(l3.get("S"), "Transparency")) {
            C3.isolated = l3.get("I") || false;
            C3.knockout = l3.get("K") || false;
            if (l3.has("CS")) {
              const i4 = l3.getRaw("CS"), a4 = ColorSpace.getCached(i4, this.xref, n3);
              t4 = a4 || await this.parseColorSpace({ cs: i4, resources: e3, localColorSpaceCache: n3 });
            }
          }
          if (i3 == null ? void 0 : i3.backdrop) {
            t4 || (t4 = ColorSpace.singletons.rgb);
            i3.backdrop = t4.getRgb(i3.backdrop, 0);
          }
          a3.addOp(Oe2, [C3]);
        }
        const Q3 = l3 ? [g3, null] : [g3, h2];
        a3.addOp(Te2, Q3);
        await this.getOperatorList({ stream: t3, task: s3, resources: o3.get("Resources") || e3, operatorList: a3, initialState: r3 });
        a3.addOp(qe2, []);
        l3 && a3.addOp(Pe2, [C3]);
        void 0 !== c3 && a3.addOp(Ye2, []);
      }
      _sendImgData(e3, t3, i3 = false) {
        const a3 = t3 ? [t3.bitmap || t3.data.buffer] : null;
        return this.parsingType3Font || i3 ? this.handler.send("commonobj", [e3, "Image", t3], a3) : this.handler.send("obj", [e3, this.pageIndex, "Image", t3], a3);
      }
      async buildPaintImageXObject({ resources: e3, image: t3, isInline: i3 = false, operatorList: a3, cacheKey: s3, localImageCache: r3, localColorSpaceCache: n3 }) {
        const o3 = t3.dict, g3 = o3.objId, c3 = o3.get("W", "Width"), C3 = o3.get("H", "Height");
        if (!c3 || "number" != typeof c3 || !C3 || "number" != typeof C3) {
          warn("Image dimensions are missing, or not numbers.");
          return;
        }
        const h2 = this.options.maxImageSize;
        if (-1 !== h2 && c3 * C3 > h2) {
          const e4 = "Image exceeded maximum allowed size and was removed.";
          if (this.options.ignoreErrors) {
            warn(e4);
            return;
          }
          throw new Error(e4);
        }
        let l3;
        o3.has("OC") && (l3 = await this.parseMarkedContentProps(o3.get("OC"), e3));
        let Q3, E3;
        if (o3.get("IM", "ImageMask") || false) {
          const e4 = o3.get("I", "Interpolate"), i4 = c3 + 7 >> 3, n4 = t3.getBytes(i4 * C3), h3 = o3.getArray("D", "Decode");
          if (this.parsingType3Font) {
            Q3 = PDFImage.createRawMask({ imgArray: n4, width: c3, height: C3, imageIsFromDecodeStream: t3 instanceof DecodeStream, inverseDecode: (h3 == null ? void 0 : h3[0]) > 0, interpolate: e4 });
            Q3.cached = !!s3;
            E3 = [Q3];
            a3.addImageOps(Xe2, E3, l3);
            if (s3) {
              const e5 = { fn: Xe2, args: E3, optionalContent: l3 };
              r3.set(s3, g3, e5);
              g3 && this._regionalImageCache.set(null, g3, e5);
            }
            return;
          }
          Q3 = await PDFImage.createMask({ imgArray: n4, width: c3, height: C3, imageIsFromDecodeStream: t3 instanceof DecodeStream, inverseDecode: (h3 == null ? void 0 : h3[0]) > 0, interpolate: e4, isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported });
          if (Q3.isSingleOpaquePixel) {
            a3.addImageOps(et, [], l3);
            if (s3) {
              const e5 = { fn: et, args: [], optionalContent: l3 };
              r3.set(s3, g3, e5);
              g3 && this._regionalImageCache.set(null, g3, e5);
            }
            return;
          }
          const u4 = `mask_${this.idFactory.createObjId()}`;
          a3.addDependency(u4);
          Q3.dataLen = Q3.bitmap ? Q3.width * Q3.height * 4 : Q3.data.length;
          this._sendImgData(u4, Q3);
          E3 = [{ data: u4, width: Q3.width, height: Q3.height, interpolate: Q3.interpolate, count: 1 }];
          a3.addImageOps(Xe2, E3, l3);
          if (s3) {
            const e5 = { fn: Xe2, args: E3, optionalContent: l3 };
            r3.set(s3, g3, e5);
            g3 && this._regionalImageCache.set(null, g3, e5);
          }
          return;
        }
        if (i3 && c3 + C3 < 200 && !o3.has("SMask") && !o3.has("Mask")) {
          try {
            const s4 = new PDFImage({ xref: this.xref, res: e3, image: t3, isInline: i3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: n3 });
            Q3 = await s4.createImageData(true, false);
            a3.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;
            a3.addImageOps(ze2, [Q3], l3);
          } catch (e4) {
            const t4 = `Unable to decode inline image: "${e4}".`;
            if (!this.options.ignoreErrors)
              throw new Error(t4);
            warn(t4);
          }
          return;
        }
        let u3 = `img_${this.idFactory.createObjId()}`, d3 = false;
        if (this.parsingType3Font)
          u3 = `${this.idFactory.getDocId()}_type3_${u3}`;
        else if (s3 && g3) {
          d3 = this.globalImageCache.shouldCache(g3, this.pageIndex);
          if (d3) {
            assert(!i3, "Cannot cache an inline image globally.");
            u3 = `${this.idFactory.getDocId()}_${u3}`;
          }
        }
        a3.addDependency(u3);
        E3 = [u3, c3, C3];
        a3.addImageOps(Ve2, E3, l3);
        if (d3 && (c3 * C3 > 25e4 || o3.has("SMask") || o3.has("Mask"))) {
          const e4 = await this.handler.sendWithPromise("commonobj", [u3, "CopyLocalImage", { imageRef: g3 }]);
          if (e4) {
            this.globalImageCache.setData(g3, { objId: u3, fn: Ve2, args: E3, optionalContent: l3, byteSize: 0 });
            this.globalImageCache.addByteSize(g3, e4);
            return;
          }
        }
        PDFImage.buildImage({ xref: this.xref, res: e3, image: t3, isInline: i3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: n3 }).then(async (e4) => {
          Q3 = await e4.createImageData(false, this.options.isOffscreenCanvasSupported);
          Q3.dataLen = Q3.bitmap ? Q3.width * Q3.height * 4 : Q3.data.length;
          Q3.ref = g3;
          d3 && this.globalImageCache.addByteSize(g3, Q3.dataLen);
          return this._sendImgData(u3, Q3, d3);
        }).catch((e4) => {
          warn(`Unable to decode image "${u3}": "${e4}".`);
          return this._sendImgData(u3, null, d3);
        });
        if (s3) {
          const e4 = { fn: Ve2, args: E3, optionalContent: l3 };
          r3.set(s3, g3, e4);
          if (g3) {
            this._regionalImageCache.set(null, g3, e4);
            d3 && this.globalImageCache.setData(g3, { objId: u3, fn: Ve2, args: E3, optionalContent: l3, byteSize: 0 });
          }
        }
      }
      handleSMask(e3, t3, i3, a3, s3, r3) {
        const n3 = e3.get("G"), o3 = { subtype: e3.get("S").name, backdrop: e3.get("BC") }, g3 = e3.get("TR");
        if (isPDFFunction(g3)) {
          const e4 = this._pdfFunctionFactory.create(g3), t4 = new Uint8Array(256), i4 = new Float32Array(1);
          for (let a4 = 0; a4 < 256; a4++) {
            i4[0] = a4 / 255;
            e4(i4, 0, i4, 0);
            t4[a4] = 255 * i4[0] | 0;
          }
          o3.transferMap = t4;
        }
        return this.buildFormXObject(t3, n3, o3, i3, a3, s3.state.clone(), r3);
      }
      handleTransferFunction(e3) {
        let t3;
        if (Array.isArray(e3))
          t3 = e3;
        else {
          if (!isPDFFunction(e3))
            return null;
          t3 = [e3];
        }
        const i3 = [];
        let a3 = 0, s3 = 0;
        for (const e4 of t3) {
          const t4 = this.xref.fetchIfRef(e4);
          a3++;
          if (isName(t4, "Identity")) {
            i3.push(null);
            continue;
          }
          if (!isPDFFunction(t4))
            return null;
          const r3 = this._pdfFunctionFactory.create(t4), n3 = new Uint8Array(256), o3 = new Float32Array(1);
          for (let e5 = 0; e5 < 256; e5++) {
            o3[0] = e5 / 255;
            r3(o3, 0, o3, 0);
            n3[e5] = 255 * o3[0] | 0;
          }
          i3.push(n3);
          s3++;
        }
        return 1 !== a3 && 4 !== a3 || 0 === s3 ? null : i3;
      }
      handleTilingType(e3, t3, i3, a3, s3, r3, n3, o3) {
        const g3 = new OperatorList(), c3 = Dict.merge({ xref: this.xref, dictArray: [s3.get("Resources"), i3] });
        return this.getOperatorList({ stream: a3, task: n3, resources: c3, operatorList: g3 }).then(function() {
          const i4 = g3.getIR(), a4 = getTilingPatternIR(i4, s3, t3);
          r3.addDependencies(g3.dependencies);
          r3.addOp(e3, a4);
          s3.objId && o3.set(null, s3.objId, { operatorListIR: i4, dict: s3 });
        }).catch((e4) => {
          if (!(e4 instanceof AbortException)) {
            if (!this.options.ignoreErrors)
              throw e4;
            warn(`handleTilingType - ignoring pattern: "${e4}".`);
          }
        });
      }
      async handleSetFont(e3, t3, i3, a3, s3, r3, n3 = null, o3 = null) {
        const g3 = (t3 == null ? void 0 : t3[0]) instanceof Name ? t3[0].name : null;
        let c3 = await this.loadFont(g3, i3, e3, n3, o3);
        if (c3.font.isType3Font)
          try {
            await c3.loadType3Data(this, e3, s3);
            a3.addDependencies(c3.type3Dependencies);
          } catch (e4) {
            c3 = new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Type3 font load error: ${e4}`), dict: c3.font, evaluatorOptions: this.options });
          }
        r3.font = c3.font;
        c3.send(this.handler);
        return c3.loadedName;
      }
      handleText(e3, t3) {
        const i3 = t3.font, a3 = i3.charsToGlyphs(e3);
        if (i3.data) {
          (!!(t3.textRenderingMode & w2) || "Pattern" === t3.fillColorSpace.name || i3.disableFontFace || this.options.disableFontFace) && _PartialEvaluator.buildFontPaths(i3, a3, this.handler, this.options);
        }
        return a3;
      }
      ensureStateFont(e3) {
        if (e3.font)
          return;
        const t3 = new FormatError("Missing setFont (Tf) operator before text rendering operator.");
        if (!this.options.ignoreErrors)
          throw t3;
        warn(`ensureStateFont: "${t3}".`);
      }
      async setGState({ resources: e3, gState: t3, operatorList: i3, cacheKey: a3, task: s3, stateManager: r3, localGStateCache: n3, localColorSpaceCache: o3 }) {
        const g3 = t3.objId;
        let c3 = true;
        const C3 = [];
        let h2 = Promise.resolve();
        for (const a4 of t3.getKeys()) {
          const n4 = t3.get(a4);
          switch (a4) {
            case "Type":
              break;
            case "LW":
            case "LC":
            case "LJ":
            case "ML":
            case "D":
            case "RI":
            case "FL":
            case "CA":
            case "ca":
              C3.push([a4, n4]);
              break;
            case "Font":
              c3 = false;
              h2 = h2.then(() => this.handleSetFont(e3, null, n4[0], i3, s3, r3.state).then(function(e4) {
                i3.addDependency(e4);
                C3.push([a4, [e4, n4[1]]]);
              }));
              break;
            case "BM":
              C3.push([a4, normalizeBlendMode(n4)]);
              break;
            case "SMask":
              if (isName(n4, "None")) {
                C3.push([a4, false]);
                break;
              }
              if (n4 instanceof Dict) {
                c3 = false;
                h2 = h2.then(() => this.handleSMask(n4, e3, i3, s3, r3, o3));
                C3.push([a4, true]);
              } else
                warn("Unsupported SMask type");
              break;
            case "TR":
              const t4 = this.handleTransferFunction(n4);
              C3.push([a4, t4]);
              break;
            case "OP":
            case "op":
            case "OPM":
            case "BG":
            case "BG2":
            case "UCR":
            case "UCR2":
            case "TR2":
            case "HT":
            case "SM":
            case "SA":
            case "AIS":
            case "TK":
              info("graphic state operator " + a4);
              break;
            default:
              info("Unknown graphic state operator " + a4);
          }
        }
        await h2;
        C3.length > 0 && i3.addOp(RA, [C3]);
        c3 && n3.set(a3, g3, C3);
      }
      loadFont(e3, t3, i3, a3 = null, s3 = null) {
        const errorFont = async () => new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Font "${e3}" is not available.`), dict: t3, evaluatorOptions: this.options });
        let r3;
        if (t3)
          t3 instanceof Ref && (r3 = t3);
        else {
          const t4 = i3.get("Font");
          t4 && (r3 = t4.getRaw(e3));
        }
        if (r3) {
          if (this.parsingType3Font && this.type3FontRefs.has(r3))
            return errorFont();
          if (this.fontCache.has(r3))
            return this.fontCache.get(r3);
          t3 = this.xref.fetchIfRef(r3);
        }
        if (!(t3 instanceof Dict)) {
          if (!this.options.ignoreErrors && !this.parsingType3Font) {
            warn(`Font "${e3}" is not available.`);
            return errorFont();
          }
          warn(`Font "${e3}" is not available -- attempting to fallback to a default font.`);
          t3 = a3 || _PartialEvaluator.fallbackFontDict;
        }
        if (t3.cacheKey && this.fontCache.has(t3.cacheKey))
          return this.fontCache.get(t3.cacheKey);
        const { promise: n3, resolve: o3 } = Promise.withResolvers();
        let g3;
        try {
          g3 = this.preEvaluateFont(t3);
          g3.cssFontInfo = s3;
        } catch (e4) {
          warn(`loadFont - preEvaluateFont failed: "${e4}".`);
          return errorFont();
        }
        const { descriptor: c3, hash: C3 } = g3, h2 = r3 instanceof Ref;
        let l3;
        if (C3 && c3 instanceof Dict) {
          const e4 = c3.fontAliases || (c3.fontAliases = /* @__PURE__ */ Object.create(null));
          if (e4[C3]) {
            const t4 = e4[C3].aliasRef;
            if (h2 && t4 && this.fontCache.has(t4)) {
              this.fontCache.putAlias(r3, t4);
              return this.fontCache.get(r3);
            }
          } else
            e4[C3] = { fontID: this.idFactory.createFontId() };
          h2 && (e4[C3].aliasRef = r3);
          l3 = e4[C3].fontID;
        } else
          l3 = this.idFactory.createFontId();
        assert(l3 == null ? void 0 : l3.startsWith("f"), 'The "fontID" must be (correctly) defined.');
        if (h2)
          this.fontCache.put(r3, n3);
        else {
          t3.cacheKey = `cacheKey_${l3}`;
          this.fontCache.put(t3.cacheKey, n3);
        }
        t3.loadedName = `${this.idFactory.getDocId()}_${l3}`;
        this.translateFont(g3).then((e4) => {
          o3(new TranslatedFont({ loadedName: t3.loadedName, font: e4, dict: t3, evaluatorOptions: this.options }));
        }).catch((e4) => {
          warn(`loadFont - translateFont failed: "${e4}".`);
          o3(new TranslatedFont({ loadedName: t3.loadedName, font: new ErrorFont(e4 instanceof Error ? e4.message : e4), dict: t3, evaluatorOptions: this.options }));
        });
        return n3;
      }
      buildPath(e3, t3, i3, a3 = false) {
        const s3 = e3.length - 1;
        i3 || (i3 = []);
        if (s3 < 0 || e3.fnArray[s3] !== tt) {
          if (a3) {
            warn(`Encountered path operator "${t3}" inside of a text object.`);
            e3.addOp(GA, null);
          }
          let s4;
          switch (t3) {
            case KA:
              const e4 = i3[0] + i3[2], t4 = i3[1] + i3[3];
              s4 = [Math.min(i3[0], e4), Math.min(i3[1], t4), Math.max(i3[0], e4), Math.max(i3[1], t4)];
              break;
            case MA:
            case LA:
              s4 = [i3[0], i3[1], i3[0], i3[1]];
              break;
            default:
              s4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          }
          e3.addOp(tt, [[t3], i3, s4]);
          a3 && e3.addOp(xA, null);
        } else {
          const a4 = e3.argsArray[s3];
          a4[0].push(t3);
          a4[1].push(...i3);
          const r3 = a4[2];
          switch (t3) {
            case KA:
              const e4 = i3[0] + i3[2], t4 = i3[1] + i3[3];
              r3[0] = Math.min(r3[0], i3[0], e4);
              r3[1] = Math.min(r3[1], i3[1], t4);
              r3[2] = Math.max(r3[2], i3[0], e4);
              r3[3] = Math.max(r3[3], i3[1], t4);
              break;
            case MA:
            case LA:
              r3[0] = Math.min(r3[0], i3[0]);
              r3[1] = Math.min(r3[1], i3[1]);
              r3[2] = Math.max(r3[2], i3[0]);
              r3[3] = Math.max(r3[3], i3[1]);
          }
        }
      }
      parseColorSpace({ cs: e3, resources: t3, localColorSpaceCache: i3 }) {
        return ColorSpace.parseAsync({ cs: e3, xref: this.xref, resources: t3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: i3 }).catch((e4) => {
          if (e4 instanceof AbortException)
            return null;
          if (this.options.ignoreErrors) {
            warn(`parseColorSpace - ignoring ColorSpace: "${e4}".`);
            return null;
          }
          throw e4;
        });
      }
      parseShading({ shading: e3, resources: t3, localColorSpaceCache: i3, localShadingPatternCache: a3 }) {
        let s3, r3 = a3.get(e3);
        if (r3)
          return r3;
        try {
          s3 = Pattern.parseShading(e3, this.xref, t3, this._pdfFunctionFactory, i3).getIR();
        } catch (t4) {
          if (t4 instanceof AbortException)
            return null;
          if (this.options.ignoreErrors) {
            warn(`parseShading - ignoring shading: "${t4}".`);
            a3.set(e3, null);
            return null;
          }
          throw t4;
        }
        r3 = `pattern_${this.idFactory.createObjId()}`;
        this.parsingType3Font && (r3 = `${this.idFactory.getDocId()}_type3_${r3}`);
        a3.set(e3, r3);
        this.parsingType3Font ? this.handler.send("commonobj", [r3, "Pattern", s3]) : this.handler.send("obj", [r3, this.pageIndex, "Pattern", s3]);
        return r3;
      }
      handleColorN(e3, t3, i3, a3, s3, r3, n3, o3, g3, c3) {
        const C3 = i3.pop();
        if (C3 instanceof Name) {
          const h2 = s3.getRaw(C3.name), l3 = h2 instanceof Ref && g3.getByRef(h2);
          if (l3)
            try {
              const s4 = a3.base ? a3.base.getRgb(i3, 0) : null, r4 = getTilingPatternIR(l3.operatorListIR, l3.dict, s4);
              e3.addOp(t3, r4);
              return;
            } catch {
            }
          const Q3 = this.xref.fetchIfRef(h2);
          if (Q3) {
            const s4 = Q3 instanceof BaseStream ? Q3.dict : Q3, C4 = s4.get("PatternType");
            if (C4 === Fs) {
              const o4 = a3.base ? a3.base.getRgb(i3, 0) : null;
              return this.handleTilingType(t3, o4, r3, Q3, s4, e3, n3, g3);
            }
            if (C4 === Ss) {
              const i4 = s4.get("Shading"), a4 = this.parseShading({ shading: i4, resources: r3, localColorSpaceCache: o3, localShadingPatternCache: c3 });
              if (a4) {
                const i5 = s4.getArray("Matrix");
                e3.addOp(t3, ["Shading", a4, i5]);
              }
              return;
            }
            throw new FormatError(`Unknown PatternType: ${C4}`);
          }
        }
        throw new FormatError(`Unknown PatternName: ${C3}`);
      }
      _parseVisibilityExpression(e3, t3, i3) {
        if (++t3 > 10) {
          warn("Visibility expression is too deeply nested");
          return;
        }
        const a3 = e3.length, s3 = this.xref.fetchIfRef(e3[0]);
        if (!(a3 < 2) && s3 instanceof Name) {
          switch (s3.name) {
            case "And":
            case "Or":
            case "Not":
              i3.push(s3.name);
              break;
            default:
              warn(`Invalid operator ${s3.name} in visibility expression`);
              return;
          }
          for (let s4 = 1; s4 < a3; s4++) {
            const a4 = e3[s4], r3 = this.xref.fetchIfRef(a4);
            if (Array.isArray(r3)) {
              const e4 = [];
              i3.push(e4);
              this._parseVisibilityExpression(r3, t3, e4);
            } else
              a4 instanceof Ref && i3.push(a4.toString());
          }
        } else
          warn("Invalid visibility expression");
      }
      async parseMarkedContentProps(e3, t3) {
        var _a3;
        let i3;
        if (e3 instanceof Name) {
          i3 = t3.get("Properties").get(e3.name);
        } else {
          if (!(e3 instanceof Dict))
            throw new FormatError("Optional content properties malformed.");
          i3 = e3;
        }
        const a3 = (_a3 = i3.get("Type")) == null ? void 0 : _a3.name;
        if ("OCG" === a3)
          return { type: a3, id: i3.objId };
        if ("OCMD" === a3) {
          const e4 = i3.get("VE");
          if (Array.isArray(e4)) {
            const t5 = [];
            this._parseVisibilityExpression(e4, 0, t5);
            if (t5.length > 0)
              return { type: "OCMD", expression: t5 };
          }
          const t4 = i3.get("OCGs");
          if (Array.isArray(t4) || t4 instanceof Dict) {
            const e5 = [];
            if (Array.isArray(t4))
              for (const i4 of t4)
                e5.push(i4.toString());
            else
              e5.push(t4.objId);
            return { type: a3, ids: e5, policy: i3.get("P") instanceof Name ? i3.get("P").name : null, expression: null };
          }
          if (t4 instanceof Ref)
            return { type: a3, id: t4.toString() };
        }
        return null;
      }
      getOperatorList({ stream: e3, task: t3, resources: i3, operatorList: a3, initialState: s3 = null, fallbackFontDict: r3 = null }) {
        i3 || (i3 = Dict.empty);
        s3 || (s3 = new EvalState());
        if (!a3)
          throw new Error('getOperatorList: missing "operatorList" parameter');
        const n3 = this, o3 = this.xref;
        let g3 = false;
        const c3 = new LocalImageCache(), C3 = new LocalColorSpaceCache(), h2 = new LocalGStateCache(), l3 = new LocalTilingPatternCache(), Q3 = /* @__PURE__ */ new Map(), E3 = i3.get("XObject") || Dict.empty, u3 = i3.get("Pattern") || Dict.empty, d3 = new StateManager(s3), f2 = new EvaluatorPreprocessor(e3, o3, d3), p2 = new TimeSlotManager();
        function closePendingRestoreOPS(e4) {
          for (let e5 = 0, t4 = f2.savedStatesDepth; e5 < t4; e5++)
            a3.addOp(xA, []);
        }
        return new Promise(function promiseBody(e4, s4) {
          const next = function(t4) {
            Promise.all([t4, a3.ready]).then(function() {
              try {
                promiseBody(e4, s4);
              } catch (e5) {
                s4(e5);
              }
            }, s4);
          };
          t3.ensureNotTerminated();
          p2.reset();
          const m3 = {};
          let y3, w3, b3, D3, F3, S3;
          for (; !(y3 = p2.check()); ) {
            m3.args = null;
            if (!f2.read(m3))
              break;
            let e5 = m3.args, s5 = m3.fn;
            switch (0 | s5) {
              case Ue2:
                S3 = e5[0] instanceof Name;
                F3 = e5[0].name;
                if (S3) {
                  const t4 = c3.getByName(F3);
                  if (t4) {
                    a3.addImageOps(t4.fn, t4.args, t4.optionalContent);
                    incrementCachedImageMaskCount(t4);
                    e5 = null;
                    continue;
                  }
                }
                next(new Promise(function(e6, s6) {
                  if (!S3)
                    throw new FormatError("XObject must be referred to by name.");
                  let r4 = E3.getRaw(F3);
                  if (r4 instanceof Ref) {
                    const t4 = c3.getByRef(r4) || n3._regionalImageCache.getByRef(r4);
                    if (t4) {
                      a3.addImageOps(t4.fn, t4.args, t4.optionalContent);
                      incrementCachedImageMaskCount(t4);
                      e6();
                      return;
                    }
                    const i4 = n3.globalImageCache.getData(r4, n3.pageIndex);
                    if (i4) {
                      a3.addDependency(i4.objId);
                      a3.addImageOps(i4.fn, i4.args, i4.optionalContent);
                      e6();
                      return;
                    }
                    r4 = o3.fetch(r4);
                  }
                  if (!(r4 instanceof BaseStream))
                    throw new FormatError("XObject should be a stream");
                  const g4 = r4.dict.get("Subtype");
                  if (!(g4 instanceof Name))
                    throw new FormatError("XObject should have a Name subtype");
                  if ("Form" !== g4.name)
                    if ("Image" !== g4.name) {
                      if ("PS" !== g4.name)
                        throw new FormatError(`Unhandled XObject subtype ${g4.name}`);
                      info("Ignored XObject subtype PS");
                      e6();
                    } else
                      n3.buildPaintImageXObject({ resources: i3, image: r4, operatorList: a3, cacheKey: F3, localImageCache: c3, localColorSpaceCache: C3 }).then(e6, s6);
                  else {
                    d3.save();
                    n3.buildFormXObject(i3, r4, null, a3, t3, d3.state.clone(), C3).then(function() {
                      d3.restore();
                      e6();
                    }, s6);
                  }
                }).catch(function(e6) {
                  if (!(e6 instanceof AbortException)) {
                    if (!n3.options.ignoreErrors)
                      throw e6;
                    warn(`getOperatorList - ignoring XObject: "${e6}".`);
                  }
                }));
                return;
              case se2:
                var k3 = e5[1];
                next(n3.handleSetFont(i3, e5, null, a3, t3, d3.state, r3).then(function(e6) {
                  a3.addDependency(e6);
                  a3.addOp(se2, [e6, k3]);
                }));
                return;
              case $A:
                g3 = true;
                break;
              case Ae2:
                g3 = false;
                break;
              case xe2:
                var N3 = e5[0].cacheKey;
                if (N3) {
                  const t4 = c3.getByName(N3);
                  if (t4) {
                    a3.addImageOps(t4.fn, t4.args, t4.optionalContent);
                    incrementCachedImageMaskCount(t4);
                    e5 = null;
                    continue;
                  }
                }
                next(n3.buildPaintImageXObject({ resources: i3, image: e5[0], isInline: true, operatorList: a3, cacheKey: N3, localImageCache: c3, localColorSpaceCache: C3 }));
                return;
              case Ce2:
                if (!d3.state.font) {
                  n3.ensureStateFont(d3.state);
                  continue;
                }
                e5[0] = n3.handleText(e5[0], d3.state);
                break;
              case he2:
                if (!d3.state.font) {
                  n3.ensureStateFont(d3.state);
                  continue;
                }
                var R3 = [], G3 = d3.state;
                for (const t4 of e5[0])
                  "string" == typeof t4 ? R3.push(...n3.handleText(t4, G3)) : "number" == typeof t4 && R3.push(t4);
                e5[0] = R3;
                s5 = Ce2;
                break;
              case le2:
                if (!d3.state.font) {
                  n3.ensureStateFont(d3.state);
                  continue;
                }
                a3.addOp(ce2);
                e5[0] = n3.handleText(e5[0], d3.state);
                s5 = Ce2;
                break;
              case Be2:
                if (!d3.state.font) {
                  n3.ensureStateFont(d3.state);
                  continue;
                }
                a3.addOp(ce2);
                a3.addOp(te2, [e5.shift()]);
                a3.addOp(ee2, [e5.shift()]);
                e5[0] = n3.handleText(e5[0], d3.state);
                s5 = Ce2;
                break;
              case re2:
                d3.state.textRenderingMode = e5[0];
                break;
              case de2: {
                const t4 = ColorSpace.getCached(e5[0], o3, C3);
                if (t4) {
                  d3.state.fillColorSpace = t4;
                  continue;
                }
                next(n3.parseColorSpace({ cs: e5[0], resources: i3, localColorSpaceCache: C3 }).then(function(e6) {
                  e6 && (d3.state.fillColorSpace = e6);
                }));
                return;
              }
              case ue2: {
                const t4 = ColorSpace.getCached(e5[0], o3, C3);
                if (t4) {
                  d3.state.strokeColorSpace = t4;
                  continue;
                }
                next(n3.parseColorSpace({ cs: e5[0], resources: i3, localColorSpaceCache: C3 }).then(function(e6) {
                  e6 && (d3.state.strokeColorSpace = e6);
                }));
                return;
              }
              case me2:
                D3 = d3.state.fillColorSpace;
                e5 = D3.getRgb(e5, 0);
                s5 = Fe2;
                break;
              case fe2:
                D3 = d3.state.strokeColorSpace;
                e5 = D3.getRgb(e5, 0);
                s5 = De2;
                break;
              case be2:
                d3.state.fillColorSpace = ColorSpace.singletons.gray;
                e5 = ColorSpace.singletons.gray.getRgb(e5, 0);
                s5 = Fe2;
                break;
              case we2:
                d3.state.strokeColorSpace = ColorSpace.singletons.gray;
                e5 = ColorSpace.singletons.gray.getRgb(e5, 0);
                s5 = De2;
                break;
              case ke2:
                d3.state.fillColorSpace = ColorSpace.singletons.cmyk;
                e5 = ColorSpace.singletons.cmyk.getRgb(e5, 0);
                s5 = Fe2;
                break;
              case Se2:
                d3.state.strokeColorSpace = ColorSpace.singletons.cmyk;
                e5 = ColorSpace.singletons.cmyk.getRgb(e5, 0);
                s5 = De2;
                break;
              case Fe2:
                d3.state.fillColorSpace = ColorSpace.singletons.rgb;
                e5 = ColorSpace.singletons.rgb.getRgb(e5, 0);
                break;
              case De2:
                d3.state.strokeColorSpace = ColorSpace.singletons.rgb;
                e5 = ColorSpace.singletons.rgb.getRgb(e5, 0);
                break;
              case ye2:
                D3 = d3.state.fillColorSpace;
                if ("Pattern" === D3.name) {
                  next(n3.handleColorN(a3, ye2, e5, D3, u3, i3, t3, C3, l3, Q3));
                  return;
                }
                e5 = D3.getRgb(e5, 0);
                s5 = Fe2;
                break;
              case pe2:
                D3 = d3.state.strokeColorSpace;
                if ("Pattern" === D3.name) {
                  next(n3.handleColorN(a3, pe2, e5, D3, u3, i3, t3, C3, l3, Q3));
                  return;
                }
                e5 = D3.getRgb(e5, 0);
                s5 = De2;
                break;
              case Ne2:
                var x3 = i3.get("Shading");
                if (!x3)
                  throw new FormatError("No shading resource found");
                var U3 = x3.get(e5[0].name);
                if (!U3)
                  throw new FormatError("No shading object found");
                const f3 = n3.parseShading({ shading: U3, resources: i3, localColorSpaceCache: C3, localShadingPatternCache: Q3 });
                if (!f3)
                  continue;
                e5 = [f3];
                s5 = Ne2;
                break;
              case RA:
                S3 = e5[0] instanceof Name;
                F3 = e5[0].name;
                if (S3) {
                  const t4 = h2.getByName(F3);
                  if (t4) {
                    t4.length > 0 && a3.addOp(RA, [t4]);
                    e5 = null;
                    continue;
                  }
                }
                next(new Promise(function(e6, s6) {
                  if (!S3)
                    throw new FormatError("GState must be referred to by name.");
                  const r4 = i3.get("ExtGState");
                  if (!(r4 instanceof Dict))
                    throw new FormatError("ExtGState should be a dictionary.");
                  const o4 = r4.get(F3);
                  if (!(o4 instanceof Dict))
                    throw new FormatError("GState should be a dictionary.");
                  n3.setGState({ resources: i3, gState: o4, operatorList: a3, cacheKey: F3, task: t3, stateManager: d3, localGStateCache: h2, localColorSpaceCache: C3 }).then(e6, s6);
                }).catch(function(e6) {
                  if (!(e6 instanceof AbortException)) {
                    if (!n3.options.ignoreErrors)
                      throw e6;
                    warn(`getOperatorList - ignoring ExtGState: "${e6}".`);
                  }
                }));
                return;
              case MA:
              case LA:
              case HA:
              case JA:
              case YA:
              case vA:
              case KA:
                n3.buildPath(a3, s5, e5, g3);
                continue;
              case Me2:
              case Le2:
              case ve2:
              case Ke:
                continue;
              case Je2:
                if (!(e5[0] instanceof Name)) {
                  warn(`Expected name for beginMarkedContentProps arg0=${e5[0]}`);
                  a3.addOp(Je2, ["OC", null]);
                  continue;
                }
                if ("OC" === e5[0].name) {
                  next(n3.parseMarkedContentProps(e5[1], i3).then((e6) => {
                    a3.addOp(Je2, ["OC", e6]);
                  }).catch((e6) => {
                    if (!(e6 instanceof AbortException)) {
                      if (!n3.options.ignoreErrors)
                        throw e6;
                      warn(`getOperatorList - ignoring beginMarkedContentProps: "${e6}".`);
                      a3.addOp(Je2, ["OC", null]);
                    }
                  }));
                  return;
                }
                e5 = [e5[0].name, e5[1] instanceof Dict ? e5[1].get("MCID") : null];
                break;
              default:
                if (null !== e5) {
                  for (w3 = 0, b3 = e5.length; w3 < b3 && !(e5[w3] instanceof Dict); w3++)
                    ;
                  if (w3 < b3) {
                    warn("getOperatorList - ignoring operator: " + s5);
                    continue;
                  }
                }
            }
            a3.addOp(s5, e5);
          }
          if (y3)
            next(ks);
          else {
            closePendingRestoreOPS();
            e4();
          }
        }).catch((e4) => {
          if (!(e4 instanceof AbortException)) {
            if (!this.options.ignoreErrors)
              throw e4;
            warn(`getOperatorList - ignoring errors during "${t3.name}" task: "${e4}".`);
            closePendingRestoreOPS();
          }
        });
      }
      getTextContent({ stream: e3, task: t3, resources: s3, stateManager: r3 = null, includeMarkedContent: n3 = false, sink: o3, seenStyles: g3 = /* @__PURE__ */ new Set(), viewBox: c3, markedContentData: C3 = null, disableNormalization: h2 = false, keepWhiteSpace: l3 = false }) {
        s3 || (s3 = Dict.empty);
        r3 || (r3 = new StateManager(new TextState()));
        n3 && (C3 || (C3 = { level: 0 }));
        const Q3 = { items: [], styles: /* @__PURE__ */ Object.create(null) }, E3 = { initialized: false, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: false, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: false }, u3 = [" ", " "];
        let d3 = 0;
        function saveLastChar(e4) {
          const t4 = (d3 + 1) % 2, i3 = " " !== u3[d3] && " " === u3[t4];
          u3[d3] = e4;
          d3 = t4;
          return !l3 && i3;
        }
        function shouldAddWhitepsace() {
          return !l3 && " " !== u3[d3] && " " === u3[(d3 + 1) % 2];
        }
        function resetLastChars() {
          u3[0] = u3[1] = " ";
          d3 = 0;
        }
        const f2 = this, p2 = this.xref, m3 = [];
        let y3 = null;
        const w3 = new LocalImageCache(), b3 = new LocalGStateCache(), D3 = new EvaluatorPreprocessor(e3, p2, r3);
        let F3;
        function pushWhitespace({ width: e4 = 0, height: t4 = 0, transform: i3 = E3.prevTransform, fontName: a3 = E3.fontName }) {
          Q3.items.push({ str: " ", dir: "ltr", width: e4, height: t4, transform: i3, fontName: a3, hasEOL: false });
        }
        function getCurrentTextTransform() {
          const e4 = F3.font, t4 = [F3.fontSize * F3.textHScale, 0, 0, F3.fontSize, 0, F3.textRise];
          if (e4.isType3Font && (F3.fontSize <= 1 || e4.isCharBBox) && !isArrayEqual(F3.fontMatrix, a2)) {
            const i3 = e4.bbox[3] - e4.bbox[1];
            i3 > 0 && (t4[3] *= i3 * F3.fontMatrix[3]);
          }
          return Util.transform(F3.ctm, Util.transform(F3.textMatrix, t4));
        }
        function ensureTextContentItem() {
          if (E3.initialized)
            return E3;
          const { font: e4, loadedName: t4 } = F3;
          if (!g3.has(t4)) {
            g3.add(t4);
            Q3.styles[t4] = { fontFamily: e4.fallbackName, ascent: e4.ascent, descent: e4.descent, vertical: e4.vertical };
            if (f2.options.fontExtraProperties && e4.systemFontInfo) {
              const i4 = Q3.styles[t4];
              i4.fontSubstitution = e4.systemFontInfo.css;
              i4.fontSubstitutionLoadedName = e4.systemFontInfo.loadedName;
            }
          }
          E3.fontName = t4;
          const i3 = E3.transform = getCurrentTextTransform();
          if (e4.vertical) {
            E3.width = E3.totalWidth = Math.hypot(i3[0], i3[1]);
            E3.height = E3.totalHeight = 0;
            E3.vertical = true;
          } else {
            E3.width = E3.totalWidth = 0;
            E3.height = E3.totalHeight = Math.hypot(i3[2], i3[3]);
            E3.vertical = false;
          }
          const a3 = Math.hypot(F3.textLineMatrix[0], F3.textLineMatrix[1]), s4 = Math.hypot(F3.ctm[0], F3.ctm[1]);
          E3.textAdvanceScale = s4 * a3;
          const { fontSize: r4 } = F3;
          E3.trackingSpaceMin = 0.102 * r4;
          E3.notASpace = 0.03 * r4;
          E3.negativeSpaceMax = -0.2 * r4;
          E3.spaceInFlowMin = 0.102 * r4;
          E3.spaceInFlowMax = 0.6 * r4;
          E3.hasEOL = false;
          E3.initialized = true;
          return E3;
        }
        function updateAdvanceScale() {
          if (!E3.initialized)
            return;
          const e4 = Math.hypot(F3.textLineMatrix[0], F3.textLineMatrix[1]), t4 = Math.hypot(F3.ctm[0], F3.ctm[1]) * e4;
          if (t4 !== E3.textAdvanceScale) {
            if (E3.vertical) {
              E3.totalHeight += E3.height * E3.textAdvanceScale;
              E3.height = 0;
            } else {
              E3.totalWidth += E3.width * E3.textAdvanceScale;
              E3.width = 0;
            }
            E3.textAdvanceScale = t4;
          }
        }
        function runBidiTransform(e4) {
          let t4 = e4.str.join("");
          h2 || (t4 = function normalizeUnicode(e5) {
            if (!gt) {
              gt = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
              It = /* @__PURE__ */ new Map([["ﬅ", "ſt"]]);
            }
            return e5.replaceAll(gt, (e6, t5, i4) => t5 ? t5.normalize("NFKC") : It.get(i4));
          }(t4));
          const i3 = bidi(t4, -1, e4.vertical);
          return { str: i3.str, dir: i3.dir, width: Math.abs(e4.totalWidth), height: Math.abs(e4.totalHeight), transform: e4.transform, fontName: e4.fontName, hasEOL: e4.hasEOL };
        }
        async function handleSetFont(e4, i3) {
          const r4 = await f2.loadFont(e4, i3, s3);
          if (r4.font.isType3Font)
            try {
              await r4.loadType3Data(f2, s3, t3);
            } catch {
            }
          F3.loadedName = r4.loadedName;
          F3.font = r4.font;
          F3.fontMatrix = r4.font.fontMatrix || a2;
        }
        function applyInverseRotation(e4, t4, i3) {
          const a3 = Math.hypot(i3[0], i3[1]);
          return [(i3[0] * e4 + i3[1] * t4) / a3, (i3[2] * e4 + i3[3] * t4) / a3];
        }
        function compareWithLastPosition(e4) {
          var _a3;
          const t4 = getCurrentTextTransform();
          let i3 = t4[4], a3 = t4[5];
          if ((_a3 = F3.font) == null ? void 0 : _a3.vertical) {
            if (i3 < c3[0] || i3 > c3[2] || a3 + e4 < c3[1] || a3 > c3[3])
              return false;
          } else if (i3 + e4 < c3[0] || i3 > c3[2] || a3 < c3[1] || a3 > c3[3])
            return false;
          if (!F3.font || !E3.prevTransform)
            return true;
          let s4 = E3.prevTransform[4], r4 = E3.prevTransform[5];
          if (s4 === i3 && r4 === a3)
            return true;
          let n4 = -1;
          t4[0] && 0 === t4[1] && 0 === t4[2] ? n4 = t4[0] > 0 ? 0 : 180 : t4[1] && 0 === t4[0] && 0 === t4[3] && (n4 = t4[1] > 0 ? 90 : 270);
          switch (n4) {
            case 0:
              break;
            case 90:
              [i3, a3] = [a3, i3];
              [s4, r4] = [r4, s4];
              break;
            case 180:
              [i3, a3, s4, r4] = [-i3, -a3, -s4, -r4];
              break;
            case 270:
              [i3, a3] = [-a3, -i3];
              [s4, r4] = [-r4, -s4];
              break;
            default:
              [i3, a3] = applyInverseRotation(i3, a3, t4);
              [s4, r4] = applyInverseRotation(s4, r4, E3.prevTransform);
          }
          if (F3.font.vertical) {
            const e5 = (r4 - a3) / E3.textAdvanceScale, t5 = i3 - s4, n5 = Math.sign(E3.height);
            if (e5 < n5 * E3.negativeSpaceMax) {
              if (Math.abs(t5) > 0.5 * E3.width) {
                appendEOL();
                return true;
              }
              resetLastChars();
              flushTextContentItem();
              return true;
            }
            if (Math.abs(t5) > E3.width) {
              appendEOL();
              return true;
            }
            e5 <= n5 * E3.notASpace && resetLastChars();
            if (e5 <= n5 * E3.trackingSpaceMin)
              if (shouldAddWhitepsace()) {
                resetLastChars();
                flushTextContentItem();
                pushWhitespace({ height: Math.abs(e5) });
              } else
                E3.height += e5;
            else if (!addFakeSpaces(e5, E3.prevTransform, n5))
              if (0 === E3.str.length) {
                resetLastChars();
                pushWhitespace({ height: Math.abs(e5) });
              } else
                E3.height += e5;
            Math.abs(t5) > 0.25 * E3.width && flushTextContentItem();
            return true;
          }
          const o4 = (i3 - s4) / E3.textAdvanceScale, g4 = a3 - r4, C4 = Math.sign(E3.width);
          if (o4 < C4 * E3.negativeSpaceMax) {
            if (Math.abs(g4) > 0.5 * E3.height) {
              appendEOL();
              return true;
            }
            resetLastChars();
            flushTextContentItem();
            return true;
          }
          if (Math.abs(g4) > E3.height) {
            appendEOL();
            return true;
          }
          o4 <= C4 * E3.notASpace && resetLastChars();
          if (o4 <= C4 * E3.trackingSpaceMin)
            if (shouldAddWhitepsace()) {
              resetLastChars();
              flushTextContentItem();
              pushWhitespace({ width: Math.abs(o4) });
            } else
              E3.width += o4;
          else if (!addFakeSpaces(o4, E3.prevTransform, C4))
            if (0 === E3.str.length) {
              resetLastChars();
              pushWhitespace({ width: Math.abs(o4) });
            } else
              E3.width += o4;
          Math.abs(g4) > 0.25 * E3.height && flushTextContentItem();
          return true;
        }
        function buildTextContentItem({ chars: e4, extraSpacing: t4 }) {
          const i3 = F3.font;
          if (!e4) {
            const e5 = F3.charSpacing + t4;
            e5 && (i3.vertical ? F3.translateTextMatrix(0, -e5) : F3.translateTextMatrix(e5 * F3.textHScale, 0));
            l3 && compareWithLastPosition(0);
            return;
          }
          const a3 = i3.charsToGlyphs(e4), s4 = F3.fontMatrix[0] * F3.fontSize;
          for (let e5 = 0, r4 = a3.length; e5 < r4; e5++) {
            const n4 = a3[e5], { category: o4 } = n4;
            if (o4.isInvisibleFormatMark)
              continue;
            let g4 = F3.charSpacing + (e5 + 1 === r4 ? t4 : 0), c4 = n4.width;
            i3.vertical && (c4 = n4.vmetric ? n4.vmetric[0] : -c4);
            let C4 = c4 * s4;
            if (!l3 && o4.isWhitespace) {
              if (i3.vertical) {
                g4 += -C4 + F3.wordSpacing;
                F3.translateTextMatrix(0, -g4);
              } else {
                g4 += C4 + F3.wordSpacing;
                F3.translateTextMatrix(g4 * F3.textHScale, 0);
              }
              saveLastChar(" ");
              continue;
            }
            if (!o4.isZeroWidthDiacritic && !compareWithLastPosition(C4)) {
              i3.vertical ? F3.translateTextMatrix(0, C4) : F3.translateTextMatrix(C4 * F3.textHScale, 0);
              continue;
            }
            const h3 = ensureTextContentItem();
            o4.isZeroWidthDiacritic && (C4 = 0);
            if (i3.vertical) {
              F3.translateTextMatrix(0, C4);
              C4 = Math.abs(C4);
              h3.height += C4;
            } else {
              C4 *= F3.textHScale;
              F3.translateTextMatrix(C4, 0);
              h3.width += C4;
            }
            C4 && (h3.prevTransform = getCurrentTextTransform());
            const Q4 = n4.unicode;
            saveLastChar(Q4) && h3.str.push(" ");
            h3.str.push(Q4);
            g4 && (i3.vertical ? F3.translateTextMatrix(0, -g4) : F3.translateTextMatrix(g4 * F3.textHScale, 0));
          }
        }
        function appendEOL() {
          resetLastChars();
          if (E3.initialized) {
            E3.hasEOL = true;
            flushTextContentItem();
          } else
            Q3.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: getCurrentTextTransform(), fontName: F3.loadedName, hasEOL: true });
        }
        function addFakeSpaces(e4, t4, i3) {
          if (i3 * E3.spaceInFlowMin <= e4 && e4 <= i3 * E3.spaceInFlowMax) {
            if (E3.initialized) {
              resetLastChars();
              E3.str.push(" ");
            }
            return false;
          }
          const a3 = E3.fontName;
          let s4 = 0;
          if (E3.vertical) {
            s4 = e4;
            e4 = 0;
          }
          flushTextContentItem();
          resetLastChars();
          pushWhitespace({ width: Math.abs(e4), height: Math.abs(s4), transform: t4 || getCurrentTextTransform(), fontName: a3 });
          return true;
        }
        function flushTextContentItem() {
          if (E3.initialized && E3.str) {
            E3.vertical ? E3.totalHeight += E3.height * E3.textAdvanceScale : E3.totalWidth += E3.width * E3.textAdvanceScale;
            Q3.items.push(runBidiTransform(E3));
            E3.initialized = false;
            E3.str.length = 0;
          }
        }
        function enqueueChunk(e4 = false) {
          const t4 = Q3.items.length;
          if (0 !== t4 && !(e4 && t4 < 10)) {
            o3.enqueue(Q3, t4);
            Q3.items = [];
            Q3.styles = /* @__PURE__ */ Object.create(null);
          }
        }
        const S3 = new TimeSlotManager();
        return new Promise(function promiseBody(e4, a3) {
          const next = function(t4) {
            enqueueChunk(true);
            Promise.all([t4, o3.ready]).then(function() {
              try {
                promiseBody(e4, a3);
              } catch (e5) {
                a3(e5);
              }
            }, a3);
          };
          t3.ensureNotTerminated();
          S3.reset();
          const E4 = {};
          let u4, d4 = [];
          for (; !(u4 = S3.check()); ) {
            d4.length = 0;
            E4.args = d4;
            if (!D3.read(E4))
              break;
            const e5 = F3;
            F3 = r3.state;
            const a4 = E4.fn;
            d4 = E4.args;
            switch (0 | a4) {
              case se2:
                var k3 = d4[0].name, N3 = d4[1];
                if (F3.font && k3 === F3.fontName && N3 === F3.fontSize)
                  break;
                flushTextContentItem();
                F3.fontName = k3;
                F3.fontSize = N3;
                next(handleSetFont(k3, null));
                return;
              case ne2:
                F3.textRise = d4[0];
                break;
              case ie2:
                F3.textHScale = d4[0] / 100;
                break;
              case ae2:
                F3.leading = d4[0];
                break;
              case oe2:
                F3.translateTextLineMatrix(d4[0], d4[1]);
                F3.textMatrix = F3.textLineMatrix.slice();
                break;
              case ge2:
                F3.leading = -d4[1];
                F3.translateTextLineMatrix(d4[0], d4[1]);
                F3.textMatrix = F3.textLineMatrix.slice();
                break;
              case ce2:
                F3.carriageReturn();
                break;
              case Ie2:
                F3.setTextMatrix(d4[0], d4[1], d4[2], d4[3], d4[4], d4[5]);
                F3.setTextLineMatrix(d4[0], d4[1], d4[2], d4[3], d4[4], d4[5]);
                updateAdvanceScale();
                break;
              case ee2:
                F3.charSpacing = d4[0];
                break;
              case te2:
                F3.wordSpacing = d4[0];
                break;
              case $A:
                F3.textMatrix = i2.slice();
                F3.textLineMatrix = i2.slice();
                break;
              case he2:
                if (!r3.state.font) {
                  f2.ensureStateFont(r3.state);
                  continue;
                }
                const a5 = (F3.font.vertical ? 1 : -1) * F3.fontSize / 1e3, E5 = d4[0];
                for (let e6 = 0, t4 = E5.length; e6 < t4; e6++) {
                  const t5 = E5[e6];
                  if ("string" == typeof t5)
                    m3.push(t5);
                  else if ("number" == typeof t5 && 0 !== t5) {
                    const e7 = m3.join("");
                    m3.length = 0;
                    buildTextContentItem({ chars: e7, extraSpacing: t5 * a5 });
                  }
                }
                if (m3.length > 0) {
                  const e6 = m3.join("");
                  m3.length = 0;
                  buildTextContentItem({ chars: e6, extraSpacing: 0 });
                }
                break;
              case Ce2:
                if (!r3.state.font) {
                  f2.ensureStateFont(r3.state);
                  continue;
                }
                buildTextContentItem({ chars: d4[0], extraSpacing: 0 });
                break;
              case le2:
                if (!r3.state.font) {
                  f2.ensureStateFont(r3.state);
                  continue;
                }
                F3.carriageReturn();
                buildTextContentItem({ chars: d4[0], extraSpacing: 0 });
                break;
              case Be2:
                if (!r3.state.font) {
                  f2.ensureStateFont(r3.state);
                  continue;
                }
                F3.wordSpacing = d4[0];
                F3.charSpacing = d4[1];
                F3.carriageReturn();
                buildTextContentItem({ chars: d4[2], extraSpacing: 0 });
                break;
              case Ue2:
                flushTextContentItem();
                y3 || (y3 = s3.get("XObject") || Dict.empty);
                var R3 = d4[0] instanceof Name, G3 = d4[0].name;
                if (R3 && w3.getByName(G3))
                  break;
                next(new Promise(function(e6, i3) {
                  if (!R3)
                    throw new FormatError("XObject must be referred to by name.");
                  let a6 = y3.getRaw(G3);
                  if (a6 instanceof Ref) {
                    if (w3.getByRef(a6)) {
                      e6();
                      return;
                    }
                    if (f2.globalImageCache.getData(a6, f2.pageIndex)) {
                      e6();
                      return;
                    }
                    a6 = p2.fetch(a6);
                  }
                  if (!(a6 instanceof BaseStream))
                    throw new FormatError("XObject should be a stream");
                  const Q4 = a6.dict.get("Subtype");
                  if (!(Q4 instanceof Name))
                    throw new FormatError("XObject should have a Name subtype");
                  if ("Form" !== Q4.name) {
                    w3.set(G3, a6.dict.objId, true);
                    e6();
                    return;
                  }
                  const E6 = r3.state.clone(), u5 = new StateManager(E6), d5 = a6.dict.getArray("Matrix");
                  Array.isArray(d5) && 6 === d5.length && u5.transform(d5);
                  enqueueChunk();
                  const m4 = { enqueueInvoked: false, enqueue(e7, t4) {
                    this.enqueueInvoked = true;
                    o3.enqueue(e7, t4);
                  }, get desiredSize() {
                    return o3.desiredSize;
                  }, get ready() {
                    return o3.ready;
                  } };
                  f2.getTextContent({ stream: a6, task: t3, resources: a6.dict.get("Resources") || s3, stateManager: u5, includeMarkedContent: n3, sink: m4, seenStyles: g3, viewBox: c3, markedContentData: C3, disableNormalization: h2, keepWhiteSpace: l3 }).then(function() {
                    m4.enqueueInvoked || w3.set(G3, a6.dict.objId, true);
                    e6();
                  }, i3);
                }).catch(function(e6) {
                  if (!(e6 instanceof AbortException)) {
                    if (!f2.options.ignoreErrors)
                      throw e6;
                    warn(`getTextContent - ignoring XObject: "${e6}".`);
                  }
                }));
                return;
              case RA:
                R3 = d4[0] instanceof Name;
                G3 = d4[0].name;
                if (R3 && b3.getByName(G3))
                  break;
                next(new Promise(function(e6, t4) {
                  if (!R3)
                    throw new FormatError("GState must be referred to by name.");
                  const i3 = s3.get("ExtGState");
                  if (!(i3 instanceof Dict))
                    throw new FormatError("ExtGState should be a dictionary.");
                  const a6 = i3.get(G3);
                  if (!(a6 instanceof Dict))
                    throw new FormatError("GState should be a dictionary.");
                  const r4 = a6.get("Font");
                  if (r4) {
                    flushTextContentItem();
                    F3.fontName = null;
                    F3.fontSize = r4[1];
                    handleSetFont(null, r4[0]).then(e6, t4);
                  } else {
                    b3.set(G3, a6.objId, true);
                    e6();
                  }
                }).catch(function(e6) {
                  if (!(e6 instanceof AbortException)) {
                    if (!f2.options.ignoreErrors)
                      throw e6;
                    warn(`getTextContent - ignoring ExtGState: "${e6}".`);
                  }
                }));
                return;
              case He2:
                flushTextContentItem();
                if (n3) {
                  C3.level++;
                  Q3.items.push({ type: "beginMarkedContent", tag: d4[0] instanceof Name ? d4[0].name : null });
                }
                break;
              case Je2:
                flushTextContentItem();
                if (n3) {
                  C3.level++;
                  let e6 = null;
                  d4[1] instanceof Dict && (e6 = d4[1].get("MCID"));
                  Q3.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(e6) ? `${f2.idFactory.getPageObjId()}_mc${e6}` : null, tag: d4[0] instanceof Name ? d4[0].name : null });
                }
                break;
              case Ye2:
                flushTextContentItem();
                if (n3) {
                  if (0 === C3.level)
                    break;
                  C3.level--;
                  Q3.items.push({ type: "endMarkedContent" });
                }
                break;
              case xA:
                !e5 || e5.font === F3.font && e5.fontSize === F3.fontSize && e5.fontName === F3.fontName || flushTextContentItem();
            }
            if (Q3.items.length >= o3.desiredSize) {
              u4 = true;
              break;
            }
          }
          if (u4)
            next(ks);
          else {
            flushTextContentItem();
            enqueueChunk();
            e4();
          }
        }).catch((e4) => {
          if (!(e4 instanceof AbortException)) {
            if (!this.options.ignoreErrors)
              throw e4;
            warn(`getTextContent - ignoring errors during "${t3.name}" task: "${e4}".`);
            flushTextContentItem();
            enqueueChunk();
          }
        });
      }
      async extractDataStructures(e3, t3) {
        const i3 = this.xref;
        let a3;
        const s3 = this.readToUnicode(t3.toUnicode);
        if (t3.composite) {
          const i4 = e3.get("CIDSystemInfo");
          i4 instanceof Dict && (t3.cidSystemInfo = { registry: stringToPDFString(i4.get("Registry")), ordering: stringToPDFString(i4.get("Ordering")), supplement: i4.get("Supplement") });
          try {
            const t4 = e3.get("CIDToGIDMap");
            t4 instanceof BaseStream && (a3 = t4.getBytes());
          } catch (e4) {
            if (!this.options.ignoreErrors)
              throw e4;
            warn(`extractDataStructures - ignoring CIDToGIDMap data: "${e4}".`);
          }
        }
        const r3 = [];
        let n3, o3 = null;
        if (e3.has("Encoding")) {
          n3 = e3.get("Encoding");
          if (n3 instanceof Dict) {
            o3 = n3.get("BaseEncoding");
            o3 = o3 instanceof Name ? o3.name : null;
            if (n3.has("Differences")) {
              const e4 = n3.get("Differences");
              let t4 = 0;
              for (const a4 of e4) {
                const e5 = i3.fetchIfRef(a4);
                if ("number" == typeof e5)
                  t4 = e5;
                else {
                  if (!(e5 instanceof Name))
                    throw new FormatError(`Invalid entry in 'Differences' array: ${e5}`);
                  r3[t4++] = e5.name;
                }
              }
            }
          } else if (n3 instanceof Name)
            o3 = n3.name;
          else {
            const e4 = "Encoding is not a Name nor a Dict";
            if (!this.options.ignoreErrors)
              throw new FormatError(e4);
            warn(e4);
          }
          "MacRomanEncoding" !== o3 && "MacExpertEncoding" !== o3 && "WinAnsiEncoding" !== o3 && (o3 = null);
        }
        const g3 = !t3.file || t3.isInternalFont, c3 = Zi()[t3.name];
        o3 && g3 && c3 && (o3 = null);
        if (o3)
          t3.defaultEncoding = getEncoding(o3);
        else {
          const e4 = !!(t3.flags & Ti), i4 = !!(t3.flags & qi);
          n3 = fi;
          "TrueType" !== t3.type || i4 || (n3 = pi);
          if (e4 || c3) {
            n3 = di;
            g3 && (/Symbol/i.test(t3.name) ? n3 = mi : /Dingbats/i.test(t3.name) ? n3 = yi : /Wingdings/i.test(t3.name) && (n3 = pi));
          }
          t3.defaultEncoding = n3;
        }
        t3.differences = r3;
        t3.baseEncodingName = o3;
        t3.hasEncoding = !!o3 || r3.length > 0;
        t3.dict = e3;
        t3.toUnicode = await s3;
        const C3 = await this.buildToUnicode(t3);
        t3.toUnicode = C3;
        a3 && (t3.cidToGidMap = this.readCidToGidMap(a3, C3));
        return t3;
      }
      _simpleFontToUnicode(e3, t3 = false) {
        assert(!e3.composite, "Must be a simple font.");
        const i3 = [], a3 = e3.defaultEncoding.slice(), s3 = e3.baseEncodingName, r3 = e3.differences;
        for (const e4 in r3) {
          const t4 = r3[e4];
          ".notdef" !== t4 && (a3[e4] = t4);
        }
        const n3 = Ri();
        for (const r4 in a3) {
          let o3 = a3[r4];
          if ("" === o3)
            continue;
          let g3 = n3[o3];
          if (void 0 !== g3) {
            i3[r4] = String.fromCharCode(g3);
            continue;
          }
          let c3 = 0;
          switch (o3[0]) {
            case "G":
              3 === o3.length && (c3 = parseInt(o3.substring(1), 16));
              break;
            case "g":
              5 === o3.length && (c3 = parseInt(o3.substring(1), 16));
              break;
            case "C":
            case "c":
              if (o3.length >= 3 && o3.length <= 4) {
                const i4 = o3.substring(1);
                if (t3) {
                  c3 = parseInt(i4, 16);
                  break;
                }
                c3 = +i4;
                if (Number.isNaN(c3) && Number.isInteger(parseInt(i4, 16)))
                  return this._simpleFontToUnicode(e3, true);
              }
              break;
            case "u":
              g3 = getUnicodeForGlyph(o3, n3);
              -1 !== g3 && (c3 = g3);
              break;
            default:
              switch (o3) {
                case "f_h":
                case "f_t":
                case "T_h":
                  i3[r4] = o3.replaceAll("_", "");
                  continue;
              }
          }
          if (c3 > 0 && c3 <= 1114111 && Number.isInteger(c3)) {
            if (s3 && c3 === +r4) {
              const e4 = getEncoding(s3);
              if (e4 && (o3 = e4[r4])) {
                i3[r4] = String.fromCharCode(n3[o3]);
                continue;
              }
            }
            i3[r4] = String.fromCodePoint(c3);
          }
        }
        return i3;
      }
      async buildToUnicode(e3) {
        var _a3, _b2;
        e3.hasIncludedToUnicodeMap = ((_a3 = e3.toUnicode) == null ? void 0 : _a3.length) > 0;
        if (e3.hasIncludedToUnicodeMap) {
          !e3.composite && e3.hasEncoding && (e3.fallbackToUnicode = this._simpleFontToUnicode(e3));
          return e3.toUnicode;
        }
        if (!e3.composite)
          return new ToUnicodeMap(this._simpleFontToUnicode(e3));
        if (e3.composite && (e3.cMap.builtInCMap && !(e3.cMap instanceof IdentityCMap) || "Adobe" === ((_b2 = e3.cidSystemInfo) == null ? void 0 : _b2.registry) && ("GB1" === e3.cidSystemInfo.ordering || "CNS1" === e3.cidSystemInfo.ordering || "Japan1" === e3.cidSystemInfo.ordering || "Korea1" === e3.cidSystemInfo.ordering))) {
          const { registry: t3, ordering: i3 } = e3.cidSystemInfo, a3 = Name.get(`${t3}-${i3}-UCS2`), s3 = await CMapFactory.create({ encoding: a3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), r3 = [], n3 = [];
          e3.cMap.forEach(function(e4, t4) {
            if (t4 > 65535)
              throw new FormatError("Max size of CID is 65,535");
            const i4 = s3.lookup(t4);
            if (i4) {
              n3.length = 0;
              for (let e5 = 0, t5 = i4.length; e5 < t5; e5 += 2)
                n3.push((i4.charCodeAt(e5) << 8) + i4.charCodeAt(e5 + 1));
              r3[e4] = String.fromCharCode(...n3);
            }
          });
          return new ToUnicodeMap(r3);
        }
        return new IdentityToUnicodeMap(e3.firstChar, e3.lastChar);
      }
      async readToUnicode(e3) {
        if (!e3)
          return null;
        if (e3 instanceof Name) {
          const t3 = await CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
          return t3 instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t3.getMap());
        }
        if (e3 instanceof BaseStream)
          try {
            const t3 = await CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
            if (t3 instanceof IdentityCMap)
              return new IdentityToUnicodeMap(0, 65535);
            const i3 = new Array(t3.length);
            t3.forEach(function(e4, t4) {
              if ("number" == typeof t4) {
                i3[e4] = String.fromCodePoint(t4);
                return;
              }
              const a3 = [];
              for (let e5 = 0; e5 < t4.length; e5 += 2) {
                const i4 = t4.charCodeAt(e5) << 8 | t4.charCodeAt(e5 + 1);
                if (55296 != (63488 & i4)) {
                  a3.push(i4);
                  continue;
                }
                e5 += 2;
                const s3 = t4.charCodeAt(e5) << 8 | t4.charCodeAt(e5 + 1);
                a3.push(((1023 & i4) << 10) + (1023 & s3) + 65536);
              }
              i3[e4] = String.fromCodePoint(...a3);
            });
            return new ToUnicodeMap(i3);
          } catch (e4) {
            if (e4 instanceof AbortException)
              return null;
            if (this.options.ignoreErrors) {
              warn(`readToUnicode - ignoring ToUnicode data: "${e4}".`);
              return null;
            }
            throw e4;
          }
        return null;
      }
      readCidToGidMap(e3, t3) {
        const i3 = [];
        for (let a3 = 0, s3 = e3.length; a3 < s3; a3++) {
          const s4 = e3[a3++] << 8 | e3[a3], r3 = a3 >> 1;
          (0 !== s4 || t3.has(r3)) && (i3[r3] = s4);
        }
        return i3;
      }
      extractWidths(e3, t3, i3) {
        const a3 = this.xref;
        let s3 = [], r3 = 0;
        const n3 = [];
        let o3;
        if (i3.composite) {
          const t4 = e3.get("DW");
          r3 = Number.isInteger(t4) ? t4 : 1e3;
          const g4 = e3.get("W");
          if (Array.isArray(g4))
            for (let e4 = 0, t5 = g4.length; e4 < t5; e4++) {
              let t6 = a3.fetchIfRef(g4[e4++]);
              if (!Number.isInteger(t6))
                break;
              const i4 = a3.fetchIfRef(g4[e4]);
              if (Array.isArray(i4))
                for (const e5 of i4) {
                  const i5 = a3.fetchIfRef(e5);
                  "number" == typeof i5 && (s3[t6] = i5);
                  t6++;
                }
              else {
                if (!Number.isInteger(i4))
                  break;
                {
                  const r4 = a3.fetchIfRef(g4[++e4]);
                  if ("number" != typeof r4)
                    continue;
                  for (let e5 = t6; e5 <= i4; e5++)
                    s3[e5] = r4;
                }
              }
            }
          if (i3.vertical) {
            const t5 = e3.getArray("DW2");
            let i4 = isNumberArray(t5, 2) ? t5 : [880, -1e3];
            o3 = [i4[1], 0.5 * r3, i4[0]];
            i4 = e3.get("W2");
            if (Array.isArray(i4))
              for (let e4 = 0, t6 = i4.length; e4 < t6; e4++) {
                let t7 = a3.fetchIfRef(i4[e4++]);
                if (!Number.isInteger(t7))
                  break;
                const s4 = a3.fetchIfRef(i4[e4]);
                if (Array.isArray(s4))
                  for (let e5 = 0, i5 = s4.length; e5 < i5; e5++) {
                    const i6 = [a3.fetchIfRef(s4[e5++]), a3.fetchIfRef(s4[e5++]), a3.fetchIfRef(s4[e5])];
                    isNumberArray(i6, null) && (n3[t7] = i6);
                    t7++;
                  }
                else {
                  if (!Number.isInteger(s4))
                    break;
                  {
                    const r4 = [a3.fetchIfRef(i4[++e4]), a3.fetchIfRef(i4[++e4]), a3.fetchIfRef(i4[++e4])];
                    if (!isNumberArray(r4, null))
                      continue;
                    for (let e5 = t7; e5 <= s4; e5++)
                      n3[e5] = r4;
                  }
                }
              }
          }
        } else {
          const n4 = e3.get("Widths");
          if (Array.isArray(n4)) {
            let e4 = i3.firstChar;
            for (const t4 of n4) {
              const i4 = a3.fetchIfRef(t4);
              "number" == typeof i4 && (s3[e4] = i4);
              e4++;
            }
            const o4 = t3.get("MissingWidth");
            r3 = "number" == typeof o4 ? o4 : 0;
          } else {
            const t4 = e3.get("BaseFont");
            if (t4 instanceof Name) {
              const e4 = this.getBaseFontMetrics(t4.name);
              s3 = this.buildCharCodeToWidth(e4.widths, i3);
              r3 = e4.defaultWidth;
            }
          }
        }
        let g3 = true, c3 = r3;
        for (const e4 in s3) {
          const t4 = s3[e4];
          if (t4)
            if (c3) {
              if (c3 !== t4) {
                g3 = false;
                break;
              }
            } else
              c3 = t4;
        }
        g3 ? i3.flags |= vi : i3.flags &= ~vi;
        i3.defaultWidth = r3;
        i3.widths = s3;
        i3.defaultVMetrics = o3;
        i3.vmetrics = n3;
      }
      isSerifFont(e3) {
        const t3 = e3.split("-", 1)[0];
        return t3 in Xi() || /serif/gi.test(t3);
      }
      getBaseFontMetrics(e3) {
        let t3 = 0, i3 = /* @__PURE__ */ Object.create(null), a3 = false;
        let s3 = Pi()[e3] || e3;
        const r3 = Aa();
        s3 in r3 || (s3 = this.isSerifFont(e3) ? "Times-Roman" : "Helvetica");
        const n3 = r3[s3];
        if ("number" == typeof n3) {
          t3 = n3;
          a3 = true;
        } else
          i3 = n3();
        return { defaultWidth: t3, monospace: a3, widths: i3 };
      }
      buildCharCodeToWidth(e3, t3) {
        const i3 = /* @__PURE__ */ Object.create(null), a3 = t3.differences, s3 = t3.defaultEncoding;
        for (let t4 = 0; t4 < 256; t4++)
          t4 in a3 && e3[a3[t4]] ? i3[t4] = e3[a3[t4]] : t4 in s3 && e3[s3[t4]] && (i3[t4] = e3[s3[t4]]);
        return i3;
      }
      preEvaluateFont(e3) {
        const t3 = e3;
        let i3 = e3.get("Subtype");
        if (!(i3 instanceof Name))
          throw new FormatError("invalid font Subtype");
        let a3, s3 = false;
        if ("Type0" === i3.name) {
          const t4 = e3.get("DescendantFonts");
          if (!t4)
            throw new FormatError("Descendant fonts are not specified");
          if (!((e3 = Array.isArray(t4) ? this.xref.fetchIfRef(t4[0]) : t4) instanceof Dict))
            throw new FormatError("Descendant font is not a dictionary.");
          i3 = e3.get("Subtype");
          if (!(i3 instanceof Name))
            throw new FormatError("invalid font Subtype");
          s3 = true;
        }
        let r3 = e3.get("FirstChar");
        Number.isInteger(r3) || (r3 = 0);
        let n3 = e3.get("LastChar");
        Number.isInteger(n3) || (n3 = s3 ? 65535 : 255);
        const o3 = e3.get("FontDescriptor"), g3 = e3.get("ToUnicode") || t3.get("ToUnicode");
        if (o3) {
          a3 = new MurmurHash3_64();
          const i4 = t3.getRaw("Encoding");
          if (i4 instanceof Name)
            a3.update(i4.name);
          else if (i4 instanceof Ref)
            a3.update(i4.toString());
          else if (i4 instanceof Dict) {
            for (const e4 of i4.getRawValues())
              if (e4 instanceof Name)
                a3.update(e4.name);
              else if (e4 instanceof Ref)
                a3.update(e4.toString());
              else if (Array.isArray(e4)) {
                const t4 = e4.length, i5 = new Array(t4);
                for (let a4 = 0; a4 < t4; a4++) {
                  const t5 = e4[a4];
                  t5 instanceof Name ? i5[a4] = t5.name : ("number" == typeof t5 || t5 instanceof Ref) && (i5[a4] = t5.toString());
                }
                a3.update(i5.join());
              }
          }
          a3.update(`${r3}-${n3}`);
          if (g3 instanceof BaseStream) {
            const e4 = g3.str || g3, t4 = e4.buffer ? new Uint8Array(e4.buffer.buffer, 0, e4.bufferLength) : new Uint8Array(e4.bytes.buffer, e4.start, e4.end - e4.start);
            a3.update(t4);
          } else
            g3 instanceof Name && a3.update(g3.name);
          const o4 = e3.get("Widths") || t3.get("Widths");
          if (Array.isArray(o4)) {
            const e4 = [];
            for (const t4 of o4)
              ("number" == typeof t4 || t4 instanceof Ref) && e4.push(t4.toString());
            a3.update(e4.join());
          }
          if (s3) {
            a3.update("compositeFont");
            const i5 = e3.get("W") || t3.get("W");
            if (Array.isArray(i5)) {
              const e4 = [];
              for (const t4 of i5)
                if ("number" == typeof t4 || t4 instanceof Ref)
                  e4.push(t4.toString());
                else if (Array.isArray(t4)) {
                  const i6 = [];
                  for (const e5 of t4)
                    ("number" == typeof e5 || e5 instanceof Ref) && i6.push(e5.toString());
                  e4.push(`[${i6.join()}]`);
                }
              a3.update(e4.join());
            }
            const s4 = e3.getRaw("CIDToGIDMap") || t3.getRaw("CIDToGIDMap");
            s4 instanceof Name ? a3.update(s4.name) : s4 instanceof Ref ? a3.update(s4.toString()) : s4 instanceof BaseStream && a3.update(s4.peekBytes());
          }
        }
        return { descriptor: o3, dict: e3, baseDict: t3, composite: s3, type: i3.name, firstChar: r3, lastChar: n3, toUnicode: g3, hash: a3 ? a3.hexdigest() : "" };
      }
      async translateFont({ descriptor: e3, dict: t3, baseDict: i3, composite: s3, type: r3, firstChar: n3, lastChar: o3, toUnicode: g3, cssFontInfo: c3 }) {
        const C3 = "Type3" === r3;
        if (!e3) {
          if (!C3) {
            let e4 = t3.get("BaseFont");
            if (!(e4 instanceof Name))
              throw new FormatError("Base font is not specified");
            e4 = e4.name.replaceAll(/[,_]/g, "-");
            const a3 = this.getBaseFontMetrics(e4), s4 = e4.split("-", 1)[0], c4 = (this.isSerifFont(s4) ? Ki : 0) | (a3.monospace ? vi : 0) | (Zi()[s4] ? Ti : qi), h3 = { type: r3, name: e4, loadedName: i3.loadedName, systemFontInfo: null, widths: a3.widths, defaultWidth: a3.defaultWidth, isSimulatedFlags: true, flags: c4, firstChar: n3, lastChar: o3, toUnicode: g3, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: C3 }, l4 = t3.get("Widths"), Q4 = getStandardFontName(e4);
            let E4 = null;
            if (Q4) {
              E4 = await this.fetchStandardFontData(Q4);
              h3.isInternalFont = !!E4;
            }
            !h3.isInternalFont && this.options.useSystemFonts && (h3.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e4, Q4, r3));
            const u4 = await this.extractDataStructures(t3, h3);
            if (l4) {
              const e5 = [];
              let t4 = n3;
              for (const i4 of l4)
                e5[t4++] = this.xref.fetchIfRef(i4);
              u4.widths = e5;
            } else
              u4.widths = this.buildCharCodeToWidth(a3.widths, u4);
            return new Font(e4, E4, u4);
          }
          {
            let i4 = t3.getArray("FontBBox");
            isNumberArray(i4, 4) || (i4 = [0, 0, 0, 0]);
            (e3 = new Dict(null)).set("FontName", Name.get(r3));
            e3.set("FontBBox", i4);
          }
        }
        let h2 = e3.get("FontName"), l3 = t3.get("BaseFont");
        "string" == typeof h2 && (h2 = Name.get(h2));
        "string" == typeof l3 && (l3 = Name.get(l3));
        const Q3 = h2 == null ? void 0 : h2.name, E3 = l3 == null ? void 0 : l3.name;
        if (!C3 && Q3 !== E3) {
          info(`The FontDescriptor's FontName is "${Q3}" but should be the same as the Font's BaseFont "${E3}".`);
          Q3 && E3 && (E3.startsWith(Q3) || !isKnownFontName(Q3) && isKnownFontName(E3)) && (h2 = null);
        }
        h2 || (h2 = l3);
        if (!(h2 instanceof Name))
          throw new FormatError("invalid font name");
        let u3, d3, f2, p2, m3;
        try {
          u3 = e3.get("FontFile", "FontFile2", "FontFile3");
        } catch (e4) {
          if (!this.options.ignoreErrors)
            throw e4;
          warn(`translateFont - fetching "${h2.name}" font file: "${e4}".`);
          u3 = new NullStream();
        }
        let y3 = false, w3 = null, b3 = null;
        if (u3) {
          if (u3.dict) {
            const e4 = u3.dict.get("Subtype");
            e4 instanceof Name && (d3 = e4.name);
            f2 = u3.dict.get("Length1");
            p2 = u3.dict.get("Length2");
            m3 = u3.dict.get("Length3");
          }
        } else if (c3) {
          const e4 = getXfaFontName(h2.name);
          if (e4) {
            c3.fontFamily = `${c3.fontFamily}-PdfJS-XFA`;
            c3.metrics = e4.metrics || null;
            w3 = e4.factors || null;
            u3 = await this.fetchStandardFontData(e4.name);
            y3 = !!u3;
            i3 = t3 = getXfaFontDict(h2.name);
            s3 = true;
          }
        } else if (!C3) {
          const e4 = getStandardFontName(h2.name);
          if (e4) {
            u3 = await this.fetchStandardFontData(e4);
            y3 = !!u3;
          }
          !y3 && this.options.useSystemFonts && (b3 = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, h2.name, e4, r3));
        }
        let D3 = t3.getArray("FontMatrix");
        isNumberArray(D3, 6) || (D3 = a2);
        let F3 = e3.getArray("FontBBox") || t3.getArray("FontBBox");
        isNumberArray(F3, 4) || (F3 = void 0);
        let S3 = e3.get("Ascent");
        "number" != typeof S3 && (S3 = void 0);
        let k3 = e3.get("Descent");
        "number" != typeof k3 && (k3 = void 0);
        let N3 = e3.get("XHeight");
        "number" != typeof N3 && (N3 = 0);
        let R3 = e3.get("CapHeight");
        "number" != typeof R3 && (R3 = 0);
        let G3 = e3.get("Flags");
        Number.isInteger(G3) || (G3 = 0);
        let x3 = e3.get("ItalicAngle");
        "number" != typeof x3 && (x3 = 0);
        const U3 = { type: r3, name: h2.name, subtype: d3, file: u3, length1: f2, length2: p2, length3: m3, isInternalFont: y3, loadedName: i3.loadedName, composite: s3, fixedPitch: false, fontMatrix: D3, firstChar: n3, lastChar: o3, toUnicode: g3, bbox: F3, ascent: S3, descent: k3, xHeight: N3, capHeight: R3, flags: G3, italicAngle: x3, isType3Font: C3, cssFontInfo: c3, scaleFactors: w3, systemFontInfo: b3 };
        if (s3) {
          const e4 = i3.get("Encoding");
          e4 instanceof Name && (U3.cidEncoding = e4.name);
          const t4 = await CMapFactory.create({ encoding: e4, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
          U3.cMap = t4;
          U3.vertical = U3.cMap.vertical;
        }
        const M3 = await this.extractDataStructures(t3, U3);
        this.extractWidths(t3, e3, M3);
        return new Font(h2.name, u3, M3);
      }
      static buildFontPaths(e3, t3, i3, a3) {
        function buildPath(t4) {
          const s3 = `${e3.loadedName}_path_${t4}`;
          try {
            if (e3.renderer.hasBuiltPath(t4))
              return;
            i3.send("commonobj", [s3, "FontPath", e3.renderer.getPathJs(t4)]);
          } catch (e4) {
            if (a3.ignoreErrors) {
              warn(`buildFontPaths - ignoring ${s3} glyph: "${e4}".`);
              return;
            }
            throw e4;
          }
        }
        for (const e4 of t3) {
          buildPath(e4.fontChar);
          const t4 = e4.accent;
          (t4 == null ? void 0 : t4.fontChar) && buildPath(t4.fontChar);
        }
      }
      static get fallbackFontDict() {
        const e3 = new Dict();
        e3.set("BaseFont", Name.get("Helvetica"));
        e3.set("Type", Name.get("FallbackType"));
        e3.set("Subtype", Name.get("FallbackType"));
        e3.set("Encoding", Name.get("WinAnsiEncoding"));
        return shadow(this, "fallbackFontDict", e3);
      }
    };
    TranslatedFont = class {
      constructor({ loadedName: e3, font: t3, dict: i3, evaluatorOptions: a3 }) {
        this.loadedName = e3;
        this.font = t3;
        this.dict = i3;
        this._evaluatorOptions = a3 || Ds;
        this.type3Loaded = null;
        this.type3Dependencies = t3.isType3Font ? /* @__PURE__ */ new Set() : null;
        this.sent = false;
      }
      send(e3) {
        if (!this.sent) {
          this.sent = true;
          e3.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
        }
      }
      fallback(e3) {
        if (this.font.data) {
          this.font.disableFontFace = true;
          PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e3, this._evaluatorOptions);
        }
      }
      loadType3Data(e3, t3, i3) {
        if (this.type3Loaded)
          return this.type3Loaded;
        if (!this.font.isType3Font)
          throw new Error("Must be a Type3 font.");
        const a3 = e3.clone({ ignoreErrors: false });
        a3.parsingType3Font = true;
        const s3 = new RefSet(e3.type3FontRefs);
        this.dict.objId && !s3.has(this.dict.objId) && s3.put(this.dict.objId);
        a3.type3FontRefs = s3;
        const r3 = this.font, n3 = this.type3Dependencies;
        let o3 = Promise.resolve();
        const g3 = this.dict.get("CharProcs"), c3 = this.dict.get("Resources") || t3, C3 = /* @__PURE__ */ Object.create(null), h2 = Util.normalizeRect(r3.bbox || [0, 0, 0, 0]), l3 = h2[2] - h2[0], Q3 = h2[3] - h2[1], E3 = Math.hypot(l3, Q3);
        for (const e4 of g3.getKeys())
          o3 = o3.then(() => {
            const t4 = g3.get(e4), s4 = new OperatorList();
            return a3.getOperatorList({ stream: t4, task: i3, resources: c3, operatorList: s4 }).then(() => {
              s4.fnArray[0] === Ee2 && this._removeType3ColorOperators(s4, E3);
              C3[e4] = s4.getIR();
              for (const e5 of s4.dependencies)
                n3.add(e5);
            }).catch(function(t5) {
              warn(`Type3 font resource "${e4}" is not available.`);
              const i4 = new OperatorList();
              C3[e4] = i4.getIR();
            });
          });
        this.type3Loaded = o3.then(() => {
          r3.charProcOperatorList = C3;
          if (this._bbox) {
            r3.isCharBBox = true;
            r3.bbox = this._bbox;
          }
        });
        return this.type3Loaded;
      }
      _removeType3ColorOperators(e3, t3 = NaN) {
        const i3 = Util.normalizeRect(e3.argsArray[0].slice(2)), a3 = i3[2] - i3[0], s3 = i3[3] - i3[1], r3 = Math.hypot(a3, s3);
        if (0 === a3 || 0 === s3) {
          e3.fnArray.splice(0, 1);
          e3.argsArray.splice(0, 1);
        } else if (0 === t3 || Math.round(r3 / t3) >= 10) {
          this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]);
          this._bbox[0] = Math.min(this._bbox[0], i3[0]);
          this._bbox[1] = Math.min(this._bbox[1], i3[1]);
          this._bbox[2] = Math.max(this._bbox[2], i3[2]);
          this._bbox[3] = Math.max(this._bbox[3], i3[3]);
        }
        let n3 = 0, o3 = e3.length;
        for (; n3 < o3; ) {
          switch (e3.fnArray[n3]) {
            case Ee2:
              break;
            case ue2:
            case de2:
            case fe2:
            case pe2:
            case me2:
            case ye2:
            case we2:
            case be2:
            case De2:
            case Fe2:
            case Se2:
            case ke2:
            case Ne2:
            case kA:
              e3.fnArray.splice(n3, 1);
              e3.argsArray.splice(n3, 1);
              o3--;
              continue;
            case RA:
              const [t4] = e3.argsArray[n3];
              let i4 = 0, a4 = t4.length;
              for (; i4 < a4; ) {
                const [e4] = t4[i4];
                switch (e4) {
                  case "TR":
                  case "TR2":
                  case "HT":
                  case "BG":
                  case "BG2":
                  case "UCR":
                  case "UCR2":
                    t4.splice(i4, 1);
                    a4--;
                    continue;
                }
                i4++;
              }
          }
          n3++;
        }
      }
    };
    StateManager = class {
      constructor(e3 = new EvalState()) {
        this.state = e3;
        this.stateStack = [];
      }
      save() {
        const e3 = this.state;
        this.stateStack.push(this.state);
        this.state = e3.clone();
      }
      restore() {
        const e3 = this.stateStack.pop();
        e3 && (this.state = e3);
      }
      transform(e3) {
        this.state.ctm = Util.transform(this.state.ctm, e3);
      }
    };
    TextState = class {
      constructor() {
        this.ctm = new Float32Array(i2);
        this.fontName = null;
        this.fontSize = 0;
        this.loadedName = null;
        this.font = null;
        this.fontMatrix = a2;
        this.textMatrix = i2.slice();
        this.textLineMatrix = i2.slice();
        this.charSpacing = 0;
        this.wordSpacing = 0;
        this.leading = 0;
        this.textHScale = 1;
        this.textRise = 0;
      }
      setTextMatrix(e3, t3, i3, a3, s3, r3) {
        const n3 = this.textMatrix;
        n3[0] = e3;
        n3[1] = t3;
        n3[2] = i3;
        n3[3] = a3;
        n3[4] = s3;
        n3[5] = r3;
      }
      setTextLineMatrix(e3, t3, i3, a3, s3, r3) {
        const n3 = this.textLineMatrix;
        n3[0] = e3;
        n3[1] = t3;
        n3[2] = i3;
        n3[3] = a3;
        n3[4] = s3;
        n3[5] = r3;
      }
      translateTextMatrix(e3, t3) {
        const i3 = this.textMatrix;
        i3[4] = i3[0] * e3 + i3[2] * t3 + i3[4];
        i3[5] = i3[1] * e3 + i3[3] * t3 + i3[5];
      }
      translateTextLineMatrix(e3, t3) {
        const i3 = this.textLineMatrix;
        i3[4] = i3[0] * e3 + i3[2] * t3 + i3[4];
        i3[5] = i3[1] * e3 + i3[3] * t3 + i3[5];
      }
      carriageReturn() {
        this.translateTextLineMatrix(0, -this.leading);
        this.textMatrix = this.textLineMatrix.slice();
      }
      clone() {
        const e3 = Object.create(this);
        e3.textMatrix = this.textMatrix.slice();
        e3.textLineMatrix = this.textLineMatrix.slice();
        e3.fontMatrix = this.fontMatrix.slice();
        return e3;
      }
    };
    EvalState = class {
      constructor() {
        this.ctm = new Float32Array(i2);
        this.font = null;
        this.textRenderingMode = y2;
        this.fillColorSpace = ColorSpace.singletons.gray;
        this.strokeColorSpace = ColorSpace.singletons.gray;
      }
      clone() {
        return Object.create(this);
      }
    };
    _EvaluatorPreprocessor = class _EvaluatorPreprocessor {
      static get opMap() {
        return shadow(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), { w: { id: wA, numArgs: 1, variableArgs: false }, J: { id: bA, numArgs: 1, variableArgs: false }, j: { id: DA, numArgs: 1, variableArgs: false }, M: { id: FA, numArgs: 1, variableArgs: false }, d: { id: SA, numArgs: 2, variableArgs: false }, ri: { id: kA, numArgs: 1, variableArgs: false }, i: { id: NA, numArgs: 1, variableArgs: false }, gs: { id: RA, numArgs: 1, variableArgs: false }, q: { id: GA, numArgs: 0, variableArgs: false }, Q: { id: xA, numArgs: 0, variableArgs: false }, cm: { id: UA, numArgs: 6, variableArgs: false }, m: { id: MA, numArgs: 2, variableArgs: false }, l: { id: LA, numArgs: 2, variableArgs: false }, c: { id: HA, numArgs: 6, variableArgs: false }, v: { id: JA, numArgs: 4, variableArgs: false }, y: { id: YA, numArgs: 4, variableArgs: false }, h: { id: vA, numArgs: 0, variableArgs: false }, re: { id: KA, numArgs: 4, variableArgs: false }, S: { id: TA, numArgs: 0, variableArgs: false }, s: { id: qA, numArgs: 0, variableArgs: false }, f: { id: OA, numArgs: 0, variableArgs: false }, F: { id: OA, numArgs: 0, variableArgs: false }, "f*": { id: PA, numArgs: 0, variableArgs: false }, B: { id: WA, numArgs: 0, variableArgs: false }, "B*": { id: jA, numArgs: 0, variableArgs: false }, b: { id: XA, numArgs: 0, variableArgs: false }, "b*": { id: ZA, numArgs: 0, variableArgs: false }, n: { id: VA, numArgs: 0, variableArgs: false }, W: { id: zA, numArgs: 0, variableArgs: false }, "W*": { id: _A, numArgs: 0, variableArgs: false }, BT: { id: $A, numArgs: 0, variableArgs: false }, ET: { id: Ae2, numArgs: 0, variableArgs: false }, Tc: { id: ee2, numArgs: 1, variableArgs: false }, Tw: { id: te2, numArgs: 1, variableArgs: false }, Tz: { id: ie2, numArgs: 1, variableArgs: false }, TL: { id: ae2, numArgs: 1, variableArgs: false }, Tf: { id: se2, numArgs: 2, variableArgs: false }, Tr: { id: re2, numArgs: 1, variableArgs: false }, Ts: { id: ne2, numArgs: 1, variableArgs: false }, Td: { id: oe2, numArgs: 2, variableArgs: false }, TD: { id: ge2, numArgs: 2, variableArgs: false }, Tm: { id: Ie2, numArgs: 6, variableArgs: false }, "T*": { id: ce2, numArgs: 0, variableArgs: false }, Tj: { id: Ce2, numArgs: 1, variableArgs: false }, TJ: { id: he2, numArgs: 1, variableArgs: false }, "'": { id: le2, numArgs: 1, variableArgs: false }, '"': { id: Be2, numArgs: 3, variableArgs: false }, d0: { id: Qe, numArgs: 2, variableArgs: false }, d1: { id: Ee2, numArgs: 6, variableArgs: false }, CS: { id: ue2, numArgs: 1, variableArgs: false }, cs: { id: de2, numArgs: 1, variableArgs: false }, SC: { id: fe2, numArgs: 4, variableArgs: true }, SCN: { id: pe2, numArgs: 33, variableArgs: true }, sc: { id: me2, numArgs: 4, variableArgs: true }, scn: { id: ye2, numArgs: 33, variableArgs: true }, G: { id: we2, numArgs: 1, variableArgs: false }, g: { id: be2, numArgs: 1, variableArgs: false }, RG: { id: De2, numArgs: 3, variableArgs: false }, rg: { id: Fe2, numArgs: 3, variableArgs: false }, K: { id: Se2, numArgs: 4, variableArgs: false }, k: { id: ke2, numArgs: 4, variableArgs: false }, sh: { id: Ne2, numArgs: 1, variableArgs: false }, BI: { id: Re2, numArgs: 0, variableArgs: false }, ID: { id: Ge2, numArgs: 0, variableArgs: false }, EI: { id: xe2, numArgs: 1, variableArgs: false }, Do: { id: Ue2, numArgs: 1, variableArgs: false }, MP: { id: Me2, numArgs: 1, variableArgs: false }, DP: { id: Le2, numArgs: 2, variableArgs: false }, BMC: { id: He2, numArgs: 1, variableArgs: false }, BDC: { id: Je2, numArgs: 2, variableArgs: false }, EMC: { id: Ye2, numArgs: 0, variableArgs: false }, BX: { id: ve2, numArgs: 0, variableArgs: false }, EX: { id: Ke, numArgs: 0, variableArgs: false }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null }));
      }
      constructor(e3, t3, i3 = new StateManager()) {
        this.parser = new Parser({ lexer: new Lexer(e3, _EvaluatorPreprocessor.opMap), xref: t3 });
        this.stateManager = i3;
        this.nonProcessedArgs = [];
        this._isPathOp = false;
        this._numInvalidPathOPS = 0;
      }
      get savedStatesDepth() {
        return this.stateManager.stateStack.length;
      }
      read(e3) {
        let t3 = e3.args;
        for (; ; ) {
          const i3 = this.parser.getObj();
          if (i3 instanceof Cmd) {
            const a3 = i3.cmd, s3 = _EvaluatorPreprocessor.opMap[a3];
            if (!s3) {
              warn(`Unknown command "${a3}".`);
              continue;
            }
            const r3 = s3.id, n3 = s3.numArgs;
            let o3 = null !== t3 ? t3.length : 0;
            this._isPathOp || (this._numInvalidPathOPS = 0);
            this._isPathOp = r3 >= MA && r3 <= VA;
            if (s3.variableArgs)
              o3 > n3 && info(`Command ${a3}: expected [0, ${n3}] args, but received ${o3} args.`);
            else {
              if (o3 !== n3) {
                const e4 = this.nonProcessedArgs;
                for (; o3 > n3; ) {
                  e4.push(t3.shift());
                  o3--;
                }
                for (; o3 < n3 && 0 !== e4.length; ) {
                  null === t3 && (t3 = []);
                  t3.unshift(e4.pop());
                  o3++;
                }
              }
              if (o3 < n3) {
                const e4 = `command ${a3}: expected ${n3} args, but received ${o3} args.`;
                if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS)
                  throw new FormatError(`Invalid ${e4}`);
                warn(`Skipping ${e4}`);
                null !== t3 && (t3.length = 0);
                continue;
              }
            }
            this.preprocessCommand(r3, t3);
            e3.fn = r3;
            e3.args = t3;
            return true;
          }
          if (i3 === pt)
            return false;
          if (null !== i3) {
            null === t3 && (t3 = []);
            t3.push(i3);
            if (t3.length > 33)
              throw new FormatError("Too many arguments");
          }
        }
      }
      preprocessCommand(e3, t3) {
        switch (0 | e3) {
          case GA:
            this.stateManager.save();
            break;
          case xA:
            this.stateManager.restore();
            break;
          case UA:
            this.stateManager.transform(t3);
        }
      }
    };
    __publicField(_EvaluatorPreprocessor, "MAX_INVALID_PATH_OPS", 10);
    EvaluatorPreprocessor = _EvaluatorPreprocessor;
    DefaultAppearanceEvaluator = class extends EvaluatorPreprocessor {
      constructor(e3) {
        super(new StringStream(e3));
      }
      parse() {
        const e3 = { fn: 0, args: [] }, t3 = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
        try {
          for (; ; ) {
            e3.args.length = 0;
            if (!this.read(e3))
              break;
            if (0 !== this.savedStatesDepth)
              continue;
            const { fn: i3, args: a3 } = e3;
            switch (0 | i3) {
              case se2:
                const [e4, i4] = a3;
                e4 instanceof Name && (t3.fontName = e4.name);
                "number" == typeof i4 && i4 > 0 && (t3.fontSize = i4);
                break;
              case Fe2:
                ColorSpace.singletons.rgb.getRgbItem(a3, 0, t3.fontColor, 0);
                break;
              case be2:
                ColorSpace.singletons.gray.getRgbItem(a3, 0, t3.fontColor, 0);
                break;
              case ke2:
                ColorSpace.singletons.cmyk.getRgbItem(a3, 0, t3.fontColor, 0);
            }
          }
        } catch (e4) {
          warn(`parseDefaultAppearance - ignoring errors: "${e4}".`);
        }
        return t3;
      }
    };
    AppearanceStreamEvaluator = class extends EvaluatorPreprocessor {
      constructor(e3, t3, i3) {
        var _a3;
        super(e3);
        this.stream = e3;
        this.evaluatorOptions = t3;
        this.xref = i3;
        this.resources = (_a3 = e3.dict) == null ? void 0 : _a3.get("Resources");
      }
      parse() {
        const e3 = { fn: 0, args: [] };
        let t3 = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: ColorSpace.singletons.gray }, i3 = false;
        const a3 = [];
        try {
          for (; ; ) {
            e3.args.length = 0;
            if (i3 || !this.read(e3))
              break;
            const { fn: s3, args: r3 } = e3;
            switch (0 | s3) {
              case GA:
                a3.push({ scaleFactor: t3.scaleFactor, fontSize: t3.fontSize, fontName: t3.fontName, fontColor: t3.fontColor.slice(), fillColorSpace: t3.fillColorSpace });
                break;
              case xA:
                t3 = a3.pop() || t3;
                break;
              case Ie2:
                t3.scaleFactor *= Math.hypot(r3[0], r3[1]);
                break;
              case se2:
                const [e4, s4] = r3;
                e4 instanceof Name && (t3.fontName = e4.name);
                "number" == typeof s4 && s4 > 0 && (t3.fontSize = s4 * t3.scaleFactor);
                break;
              case de2:
                t3.fillColorSpace = ColorSpace.parse({ cs: r3[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: this._localColorSpaceCache });
                break;
              case me2:
                t3.fillColorSpace.getRgbItem(r3, 0, t3.fontColor, 0);
                break;
              case Fe2:
                ColorSpace.singletons.rgb.getRgbItem(r3, 0, t3.fontColor, 0);
                break;
              case be2:
                ColorSpace.singletons.gray.getRgbItem(r3, 0, t3.fontColor, 0);
                break;
              case ke2:
                ColorSpace.singletons.cmyk.getRgbItem(r3, 0, t3.fontColor, 0);
                break;
              case Ce2:
              case he2:
              case le2:
              case Be2:
                i3 = true;
            }
          }
        } catch (e4) {
          warn(`parseAppearanceStream - ignoring errors: "${e4}".`);
        }
        this.stream.reset();
        delete t3.scaleFactor;
        delete t3.fillColorSpace;
        return t3;
      }
      get _localColorSpaceCache() {
        return shadow(this, "_localColorSpaceCache", new LocalColorSpaceCache());
      }
      get _pdfFunctionFactory() {
        return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported }));
      }
    };
    FakeUnicodeFont = class _FakeUnicodeFont {
      constructor(e3, t3) {
        this.xref = e3;
        this.widths = null;
        this.firstChar = 1 / 0;
        this.lastChar = -1 / 0;
        this.fontFamily = t3;
        const i3 = new OffscreenCanvas(1, 1);
        this.ctxMeasure = i3.getContext("2d");
        _FakeUnicodeFont._fontNameId || (_FakeUnicodeFont._fontNameId = 1);
        this.fontName = Name.get(`InvalidPDFjsFont_${t3}_${_FakeUnicodeFont._fontNameId++}`);
      }
      get fontDescriptorRef() {
        if (!_FakeUnicodeFont._fontDescriptorRef) {
          const e3 = new Dict(this.xref);
          e3.set("Type", Name.get("FontDescriptor"));
          e3.set("FontName", this.fontName);
          e3.set("FontFamily", "MyriadPro Regular");
          e3.set("FontBBox", [0, 0, 0, 0]);
          e3.set("FontStretch", Name.get("Normal"));
          e3.set("FontWeight", 400);
          e3.set("ItalicAngle", 0);
          _FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e3);
        }
        return _FakeUnicodeFont._fontDescriptorRef;
      }
      get descendantFontRef() {
        const e3 = new Dict(this.xref);
        e3.set("BaseFont", this.fontName);
        e3.set("Type", Name.get("Font"));
        e3.set("Subtype", Name.get("CIDFontType0"));
        e3.set("CIDToGIDMap", Name.get("Identity"));
        e3.set("FirstChar", this.firstChar);
        e3.set("LastChar", this.lastChar);
        e3.set("FontDescriptor", this.fontDescriptorRef);
        e3.set("DW", 1e3);
        const t3 = [], i3 = [...this.widths.entries()].sort();
        let a3 = null, s3 = null;
        for (const [e4, r4] of i3)
          if (a3)
            if (e4 === a3 + s3.length)
              s3.push(r4);
            else {
              t3.push(a3, s3);
              a3 = e4;
              s3 = [r4];
            }
          else {
            a3 = e4;
            s3 = [r4];
          }
        a3 && t3.push(a3, s3);
        e3.set("W", t3);
        const r3 = new Dict(this.xref);
        r3.set("Ordering", "Identity");
        r3.set("Registry", "Adobe");
        r3.set("Supplement", 0);
        e3.set("CIDSystemInfo", r3);
        return this.xref.getNewPersistentRef(e3);
      }
      get baseFontRef() {
        const e3 = new Dict(this.xref);
        e3.set("BaseFont", this.fontName);
        e3.set("Type", Name.get("Font"));
        e3.set("Subtype", Name.get("Type0"));
        e3.set("Encoding", Name.get("Identity-H"));
        e3.set("DescendantFonts", [this.descendantFontRef]);
        e3.set("ToUnicode", Name.get("Identity-H"));
        return this.xref.getNewPersistentRef(e3);
      }
      get resources() {
        const e3 = new Dict(this.xref), t3 = new Dict(this.xref);
        t3.set(this.fontName.name, this.baseFontRef);
        e3.set("Font", t3);
        return e3;
      }
      _createContext() {
        this.widths = /* @__PURE__ */ new Map();
        this.ctxMeasure.font = `1000px ${this.fontFamily}`;
        return this.ctxMeasure;
      }
      createFontResources(e3) {
        const t3 = this._createContext();
        for (const i3 of e3.split(/\r\n?|\n/))
          for (const e4 of i3.split("")) {
            const i4 = e4.charCodeAt(0);
            if (this.widths.has(i4))
              continue;
            const a3 = t3.measureText(e4), s3 = Math.ceil(a3.width);
            this.widths.set(i4, s3);
            this.firstChar = Math.min(i4, this.firstChar);
            this.lastChar = Math.max(i4, this.lastChar);
          }
        return this.resources;
      }
      static getFirstPositionInfo(e3, t3, i3) {
        const [a3, n3, o3, g3] = e3;
        let c3 = o3 - a3, C3 = g3 - n3;
        t3 % 180 != 0 && ([c3, C3] = [C3, c3]);
        const h2 = s2 * i3;
        return { coords: [0, C3 + r2 * i3 - h2], bbox: [0, 0, c3, C3], matrix: 0 !== t3 ? getRotationMatrix(t3, C3, h2) : void 0 };
      }
      createAppearance(e3, t3, i3, a3, n3, o3) {
        const g3 = this._createContext(), c3 = [];
        let C3 = -1 / 0;
        for (const t4 of e3.split(/\r\n?|\n/)) {
          c3.push(t4);
          const e4 = g3.measureText(t4).width;
          C3 = Math.max(C3, e4);
          for (const e5 of codePointIter(t4)) {
            const t5 = String.fromCodePoint(e5);
            let i4 = this.widths.get(e5);
            if (void 0 === i4) {
              const a4 = g3.measureText(t5);
              i4 = Math.ceil(a4.width);
              this.widths.set(e5, i4);
              this.firstChar = Math.min(e5, this.firstChar);
              this.lastChar = Math.max(e5, this.lastChar);
            }
          }
        }
        C3 *= a3 / 1e3;
        const [h2, l3, Q3, E3] = t3;
        let u3 = Q3 - h2, d3 = E3 - l3;
        i3 % 180 != 0 && ([u3, d3] = [d3, u3]);
        let f2 = 1;
        C3 > u3 && (f2 = u3 / C3);
        let p2 = 1;
        const m3 = s2 * a3, y3 = r2 * a3, w3 = m3 * c3.length;
        w3 > d3 && (p2 = d3 / w3);
        const b3 = a3 * Math.min(f2, p2), D3 = ["q", `0 0 ${numberToString(u3)} ${numberToString(d3)} re W n`, "BT", `1 0 0 1 0 ${numberToString(d3 + y3)} Tm 0 Tc ${getPdfColor(n3, true)}`, `/${this.fontName.name} ${numberToString(b3)} Tf`], { resources: F3 } = this;
        if (1 !== (o3 = "number" == typeof o3 && o3 >= 0 && o3 <= 1 ? o3 : 1)) {
          D3.push("/R0 gs");
          const e4 = new Dict(this.xref), t4 = new Dict(this.xref);
          t4.set("ca", o3);
          t4.set("CA", o3);
          t4.set("Type", Name.get("ExtGState"));
          e4.set("R0", t4);
          F3.set("ExtGState", e4);
        }
        const S3 = numberToString(m3);
        for (const e4 of c3)
          D3.push(`0 -${S3} Td <${stringToUTF16HexString(e4)}> Tj`);
        D3.push("ET", "Q");
        const k3 = D3.join("\n"), N3 = new Dict(this.xref);
        N3.set("Subtype", Name.get("Form"));
        N3.set("Type", Name.get("XObject"));
        N3.set("BBox", [0, 0, u3, d3]);
        N3.set("Length", k3.length);
        N3.set("Resources", F3);
        if (i3) {
          const e4 = getRotationMatrix(i3, u3, d3);
          N3.set("Matrix", e4);
        }
        const R3 = new StringStream(k3);
        R3.dict = N3;
        return R3;
      }
    };
    NameOrNumberTree = class _NameOrNumberTree {
      constructor(e3, t3, i3) {
        this.constructor === _NameOrNumberTree && unreachable("Cannot initialize NameOrNumberTree.");
        this.root = e3;
        this.xref = t3;
        this._type = i3;
      }
      getAll() {
        const e3 = /* @__PURE__ */ new Map();
        if (!this.root)
          return e3;
        const t3 = this.xref, i3 = new RefSet();
        i3.put(this.root);
        const a3 = [this.root];
        for (; a3.length > 0; ) {
          const s3 = t3.fetchIfRef(a3.shift());
          if (!(s3 instanceof Dict))
            continue;
          if (s3.has("Kids")) {
            const e4 = s3.get("Kids");
            if (!Array.isArray(e4))
              continue;
            for (const t4 of e4) {
              if (i3.has(t4))
                throw new FormatError(`Duplicate entry in "${this._type}" tree.`);
              a3.push(t4);
              i3.put(t4);
            }
            continue;
          }
          const r3 = s3.get(this._type);
          if (Array.isArray(r3))
            for (let i4 = 0, a4 = r3.length; i4 < a4; i4 += 2)
              e3.set(t3.fetchIfRef(r3[i4]), t3.fetchIfRef(r3[i4 + 1]));
        }
        return e3;
      }
      get(e3) {
        if (!this.root)
          return null;
        const t3 = this.xref;
        let i3 = t3.fetchIfRef(this.root), a3 = 0;
        for (; i3.has("Kids"); ) {
          if (++a3 > 10) {
            warn(`Search depth limit reached for "${this._type}" tree.`);
            return null;
          }
          const s4 = i3.get("Kids");
          if (!Array.isArray(s4))
            return null;
          let r3 = 0, n3 = s4.length - 1;
          for (; r3 <= n3; ) {
            const a4 = r3 + n3 >> 1, o3 = t3.fetchIfRef(s4[a4]), g3 = o3.get("Limits");
            if (e3 < t3.fetchIfRef(g3[0]))
              n3 = a4 - 1;
            else {
              if (!(e3 > t3.fetchIfRef(g3[1]))) {
                i3 = o3;
                break;
              }
              r3 = a4 + 1;
            }
          }
          if (r3 > n3)
            return null;
        }
        const s3 = i3.get(this._type);
        if (Array.isArray(s3)) {
          let i4 = 0, a4 = s3.length - 2;
          for (; i4 <= a4; ) {
            const r3 = i4 + a4 >> 1, n3 = r3 + (1 & r3), o3 = t3.fetchIfRef(s3[n3]);
            if (e3 < o3)
              a4 = n3 - 2;
            else {
              if (!(e3 > o3))
                return t3.fetchIfRef(s3[n3 + 1]);
              i4 = n3 + 2;
            }
          }
        }
        return null;
      }
    };
    NameTree = class extends NameOrNumberTree {
      constructor(e3, t3) {
        super(e3, t3, "Names");
      }
    };
    NumberTree = class extends NameOrNumberTree {
      constructor(e3, t3) {
        super(e3, t3, "Nums");
      }
    };
    FileSpec = class {
      constructor(e3, t3, i3 = false) {
        __privateAdd(this, _w, false);
        if (e3 instanceof Dict) {
          this.xref = t3;
          this.root = e3;
          e3.has("FS") && (this.fs = e3.get("FS"));
          this.description = e3.has("Desc") ? stringToPDFString(e3.get("Desc")) : "";
          e3.has("RF") && warn("Related file specifications are not supported");
          i3 || (e3.has("EF") ? __privateSet(this, _w, true) : warn("Non-embedded file specifications are not supported"));
        }
      }
      get filename() {
        if (!this._filename && this.root) {
          const e3 = pickPlatformItem(this.root) || "unnamed";
          this._filename = stringToPDFString(e3).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/");
        }
        return this._filename;
      }
      get content() {
        if (!__privateGet(this, _w))
          return null;
        !this.contentRef && this.root && (this.contentRef = pickPlatformItem(this.root.get("EF")));
        let e3 = null;
        if (this.contentRef) {
          const t3 = this.xref.fetchIfRef(this.contentRef);
          t3 instanceof BaseStream ? e3 = t3.getBytes() : warn("Embedded file specification points to non-existing/invalid content");
        } else
          warn("Embedded file specification does not have a content");
        return e3;
      }
      get serializable() {
        return { filename: this.filename, content: this.content };
      }
    };
    _w = new WeakMap();
    Ns = 0;
    Rs = -2;
    Gs = -3;
    xs = -4;
    Us = -5;
    Ms = -6;
    Ls = -9;
    XMLParserBase = class {
      _resolveEntities(e3) {
        return e3.replaceAll(/&([^;]+);/g, (e4, t3) => {
          if ("#x" === t3.substring(0, 2))
            return String.fromCodePoint(parseInt(t3.substring(2), 16));
          if ("#" === t3.substring(0, 1))
            return String.fromCodePoint(parseInt(t3.substring(1), 10));
          switch (t3) {
            case "lt":
              return "<";
            case "gt":
              return ">";
            case "amp":
              return "&";
            case "quot":
              return '"';
            case "apos":
              return "'";
          }
          return this.onResolveEntity(t3);
        });
      }
      _parseContent(e3, t3) {
        const i3 = [];
        let a3 = t3;
        function skipWs() {
          for (; a3 < e3.length && isWhitespace(e3, a3); )
            ++a3;
        }
        for (; a3 < e3.length && !isWhitespace(e3, a3) && ">" !== e3[a3] && "/" !== e3[a3]; )
          ++a3;
        const s3 = e3.substring(t3, a3);
        skipWs();
        for (; a3 < e3.length && ">" !== e3[a3] && "/" !== e3[a3] && "?" !== e3[a3]; ) {
          skipWs();
          let t4 = "", s4 = "";
          for (; a3 < e3.length && !isWhitespace(e3, a3) && "=" !== e3[a3]; ) {
            t4 += e3[a3];
            ++a3;
          }
          skipWs();
          if ("=" !== e3[a3])
            return null;
          ++a3;
          skipWs();
          const r3 = e3[a3];
          if ('"' !== r3 && "'" !== r3)
            return null;
          const n3 = e3.indexOf(r3, ++a3);
          if (n3 < 0)
            return null;
          s4 = e3.substring(a3, n3);
          i3.push({ name: t4, value: this._resolveEntities(s4) });
          a3 = n3 + 1;
          skipWs();
        }
        return { name: s3, attributes: i3, parsed: a3 - t3 };
      }
      _parseProcessingInstruction(e3, t3) {
        let i3 = t3;
        for (; i3 < e3.length && !isWhitespace(e3, i3) && ">" !== e3[i3] && "?" !== e3[i3] && "/" !== e3[i3]; )
          ++i3;
        const a3 = e3.substring(t3, i3);
        !function skipWs() {
          for (; i3 < e3.length && isWhitespace(e3, i3); )
            ++i3;
        }();
        const s3 = i3;
        for (; i3 < e3.length && ("?" !== e3[i3] || ">" !== e3[i3 + 1]); )
          ++i3;
        return { name: a3, value: e3.substring(s3, i3), parsed: i3 - t3 };
      }
      parseXml(e3) {
        let t3 = 0;
        for (; t3 < e3.length; ) {
          let i3 = t3;
          if ("<" === e3[t3]) {
            ++i3;
            let t4;
            switch (e3[i3]) {
              case "/":
                ++i3;
                t4 = e3.indexOf(">", i3);
                if (t4 < 0) {
                  this.onError(Ls);
                  return;
                }
                this.onEndElement(e3.substring(i3, t4));
                i3 = t4 + 1;
                break;
              case "?":
                ++i3;
                const a3 = this._parseProcessingInstruction(e3, i3);
                if ("?>" !== e3.substring(i3 + a3.parsed, i3 + a3.parsed + 2)) {
                  this.onError(Gs);
                  return;
                }
                this.onPi(a3.name, a3.value);
                i3 += a3.parsed + 2;
                break;
              case "!":
                if ("--" === e3.substring(i3 + 1, i3 + 3)) {
                  t4 = e3.indexOf("-->", i3 + 3);
                  if (t4 < 0) {
                    this.onError(Us);
                    return;
                  }
                  this.onComment(e3.substring(i3 + 3, t4));
                  i3 = t4 + 3;
                } else if ("[CDATA[" === e3.substring(i3 + 1, i3 + 8)) {
                  t4 = e3.indexOf("]]>", i3 + 8);
                  if (t4 < 0) {
                    this.onError(Rs);
                    return;
                  }
                  this.onCdata(e3.substring(i3 + 8, t4));
                  i3 = t4 + 3;
                } else {
                  if ("DOCTYPE" !== e3.substring(i3 + 1, i3 + 8)) {
                    this.onError(Ms);
                    return;
                  }
                  {
                    const a4 = e3.indexOf("[", i3 + 8);
                    let s4 = false;
                    t4 = e3.indexOf(">", i3 + 8);
                    if (t4 < 0) {
                      this.onError(xs);
                      return;
                    }
                    if (a4 > 0 && t4 > a4) {
                      t4 = e3.indexOf("]>", i3 + 8);
                      if (t4 < 0) {
                        this.onError(xs);
                        return;
                      }
                      s4 = true;
                    }
                    const r4 = e3.substring(i3 + 8, t4 + (s4 ? 1 : 0));
                    this.onDoctype(r4);
                    i3 = t4 + (s4 ? 2 : 1);
                  }
                }
                break;
              default:
                const s3 = this._parseContent(e3, i3);
                if (null === s3) {
                  this.onError(Ms);
                  return;
                }
                let r3 = false;
                if ("/>" === e3.substring(i3 + s3.parsed, i3 + s3.parsed + 2))
                  r3 = true;
                else if (">" !== e3.substring(i3 + s3.parsed, i3 + s3.parsed + 1)) {
                  this.onError(Ls);
                  return;
                }
                this.onBeginElement(s3.name, s3.attributes, r3);
                i3 += s3.parsed + (r3 ? 2 : 1);
            }
          } else {
            for (; i3 < e3.length && "<" !== e3[i3]; )
              i3++;
            const a3 = e3.substring(t3, i3);
            this.onText(this._resolveEntities(a3));
          }
          t3 = i3;
        }
      }
      onResolveEntity(e3) {
        return `&${e3};`;
      }
      onPi(e3, t3) {
      }
      onComment(e3) {
      }
      onCdata(e3) {
      }
      onDoctype(e3) {
      }
      onText(e3) {
      }
      onBeginElement(e3, t3, i3) {
      }
      onEndElement(e3) {
      }
      onError(e3) {
      }
    };
    SimpleDOMNode = class {
      constructor(e3, t3) {
        this.nodeName = e3;
        this.nodeValue = t3;
        Object.defineProperty(this, "parentNode", { value: null, writable: true });
      }
      get firstChild() {
        var _a3;
        return (_a3 = this.childNodes) == null ? void 0 : _a3[0];
      }
      get nextSibling() {
        const e3 = this.parentNode.childNodes;
        if (!e3)
          return;
        const t3 = e3.indexOf(this);
        return -1 !== t3 ? e3[t3 + 1] : void 0;
      }
      get textContent() {
        return this.childNodes ? this.childNodes.map(function(e3) {
          return e3.textContent;
        }).join("") : this.nodeValue || "";
      }
      get children() {
        return this.childNodes || [];
      }
      hasChildNodes() {
        var _a3;
        return ((_a3 = this.childNodes) == null ? void 0 : _a3.length) > 0;
      }
      searchNode(e3, t3) {
        var _a3;
        if (t3 >= e3.length)
          return this;
        const i3 = e3[t3];
        if (i3.name.startsWith("#") && t3 < e3.length - 1)
          return this.searchNode(e3, t3 + 1);
        const a3 = [];
        let s3 = this;
        for (; ; ) {
          if (i3.name === s3.nodeName) {
            if (0 !== i3.pos) {
              if (0 === a3.length)
                return null;
              {
                const [r3] = a3.pop();
                let n3 = 0;
                for (const a4 of r3.childNodes)
                  if (i3.name === a4.nodeName) {
                    if (n3 === i3.pos)
                      return a4.searchNode(e3, t3 + 1);
                    n3++;
                  }
                return s3.searchNode(e3, t3 + 1);
              }
            }
            {
              const i4 = s3.searchNode(e3, t3 + 1);
              if (null !== i4)
                return i4;
            }
          }
          if (((_a3 = s3.childNodes) == null ? void 0 : _a3.length) > 0) {
            a3.push([s3, 0]);
            s3 = s3.childNodes[0];
          } else {
            if (0 === a3.length)
              return null;
            for (; 0 !== a3.length; ) {
              const [e4, t4] = a3.pop(), i4 = t4 + 1;
              if (i4 < e4.childNodes.length) {
                a3.push([e4, i4]);
                s3 = e4.childNodes[i4];
                break;
              }
            }
            if (0 === a3.length)
              return null;
          }
        }
      }
      dump(e3) {
        if ("#text" !== this.nodeName) {
          e3.push(`<${this.nodeName}`);
          if (this.attributes)
            for (const t3 of this.attributes)
              e3.push(` ${t3.name}="${encodeToXmlString(t3.value)}"`);
          if (this.hasChildNodes()) {
            e3.push(">");
            for (const t3 of this.childNodes)
              t3.dump(e3);
            e3.push(`</${this.nodeName}>`);
          } else
            this.nodeValue ? e3.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e3.push("/>");
        } else
          e3.push(encodeToXmlString(this.nodeValue));
      }
    };
    SimpleXMLParser = class extends XMLParserBase {
      constructor({ hasAttributes: e3 = false, lowerCaseName: t3 = false }) {
        super();
        this._currentFragment = null;
        this._stack = null;
        this._errorCode = Ns;
        this._hasAttributes = e3;
        this._lowerCaseName = t3;
      }
      parseFromString(e3) {
        this._currentFragment = [];
        this._stack = [];
        this._errorCode = Ns;
        this.parseXml(e3);
        if (this._errorCode !== Ns)
          return;
        const [t3] = this._currentFragment;
        return t3 ? { documentElement: t3 } : void 0;
      }
      onText(e3) {
        if (function isWhitespaceString(e4) {
          for (let t4 = 0, i3 = e4.length; t4 < i3; t4++)
            if (!isWhitespace(e4, t4))
              return false;
          return true;
        }(e3))
          return;
        const t3 = new SimpleDOMNode("#text", e3);
        this._currentFragment.push(t3);
      }
      onCdata(e3) {
        const t3 = new SimpleDOMNode("#text", e3);
        this._currentFragment.push(t3);
      }
      onBeginElement(e3, t3, i3) {
        this._lowerCaseName && (e3 = e3.toLowerCase());
        const a3 = new SimpleDOMNode(e3);
        a3.childNodes = [];
        this._hasAttributes && (a3.attributes = t3);
        this._currentFragment.push(a3);
        if (!i3) {
          this._stack.push(this._currentFragment);
          this._currentFragment = a3.childNodes;
        }
      }
      onEndElement(e3) {
        this._currentFragment = this._stack.pop() || [];
        const t3 = this._currentFragment.at(-1);
        if (!t3)
          return null;
        for (const e4 of t3.childNodes)
          e4.parentNode = t3;
        return t3;
      }
      onError(e3) {
        this._errorCode = e3;
      }
    };
    MetadataParser = class {
      constructor(e3) {
        e3 = this._repair(e3);
        const t3 = new SimpleXMLParser({ lowerCaseName: true }).parseFromString(e3);
        this._metadataMap = /* @__PURE__ */ new Map();
        this._data = e3;
        t3 && this._parse(t3);
      }
      _repair(e3) {
        return e3.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e4, t3) {
          const i3 = t3.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e5, t4, i4, a4) {
            return String.fromCharCode(64 * t4 + 8 * i4 + 1 * a4);
          }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e5, t4) {
            switch (t4) {
              case "amp":
                return "&";
              case "apos":
                return "'";
              case "gt":
                return ">";
              case "lt":
                return "<";
              case "quot":
                return '"';
            }
            throw new Error(`_repair: ${t4} isn't defined.`);
          }), a3 = [">"];
          for (let e5 = 0, t4 = i3.length; e5 < t4; e5 += 2) {
            const t5 = 256 * i3.charCodeAt(e5) + i3.charCodeAt(e5 + 1);
            t5 >= 32 && t5 < 127 && 60 !== t5 && 62 !== t5 && 38 !== t5 ? a3.push(String.fromCharCode(t5)) : a3.push("&#x" + (65536 + t5).toString(16).substring(1) + ";");
          }
          return a3.join("");
        });
      }
      _getSequence(e3) {
        const t3 = e3.nodeName;
        return "rdf:bag" !== t3 && "rdf:seq" !== t3 && "rdf:alt" !== t3 ? null : e3.childNodes.filter((e4) => "rdf:li" === e4.nodeName);
      }
      _parseArray(e3) {
        if (!e3.hasChildNodes())
          return;
        const [t3] = e3.childNodes, i3 = this._getSequence(t3) || [];
        this._metadataMap.set(e3.nodeName, i3.map((e4) => e4.textContent.trim()));
      }
      _parse(e3) {
        let t3 = e3.documentElement;
        if ("rdf:rdf" !== t3.nodeName) {
          t3 = t3.firstChild;
          for (; t3 && "rdf:rdf" !== t3.nodeName; )
            t3 = t3.nextSibling;
        }
        if (t3 && "rdf:rdf" === t3.nodeName && t3.hasChildNodes()) {
          for (const e4 of t3.childNodes)
            if ("rdf:description" === e4.nodeName)
              for (const t4 of e4.childNodes) {
                const e5 = t4.nodeName;
                switch (e5) {
                  case "#text":
                    continue;
                  case "dc:creator":
                  case "dc:subject":
                    this._parseArray(t4);
                    continue;
                }
                this._metadataMap.set(e5, t4.textContent.trim());
              }
        }
      }
      get serializable() {
        return { parsedData: this._metadataMap, rawData: this._data };
      }
    };
    DecryptStream = class extends DecodeStream {
      constructor(e3, t3, i3) {
        super(t3);
        this.str = e3;
        this.dict = e3.dict;
        this.decrypt = i3;
        this.nextChunk = null;
        this.initialized = false;
      }
      readBlock() {
        var _a3;
        let e3;
        if (this.initialized)
          e3 = this.nextChunk;
        else {
          e3 = this.str.getBytes(512);
          this.initialized = true;
        }
        if (!e3 || 0 === e3.length) {
          this.eof = true;
          return;
        }
        this.nextChunk = this.str.getBytes(512);
        const t3 = ((_a3 = this.nextChunk) == null ? void 0 : _a3.length) > 0;
        e3 = (0, this.decrypt)(e3, !t3);
        const i3 = this.bufferLength, a3 = i3 + e3.length;
        this.ensureBuffer(a3).set(e3, i3);
        this.bufferLength = a3;
      }
    };
    ARCFourCipher = class {
      constructor(e3) {
        this.a = 0;
        this.b = 0;
        const t3 = new Uint8Array(256), i3 = e3.length;
        for (let e4 = 0; e4 < 256; ++e4)
          t3[e4] = e4;
        for (let a3 = 0, s3 = 0; a3 < 256; ++a3) {
          const r3 = t3[a3];
          s3 = s3 + r3 + e3[a3 % i3] & 255;
          t3[a3] = t3[s3];
          t3[s3] = r3;
        }
        this.s = t3;
      }
      encryptBlock(e3) {
        let t3 = this.a, i3 = this.b;
        const a3 = this.s, s3 = e3.length, r3 = new Uint8Array(s3);
        for (let n3 = 0; n3 < s3; ++n3) {
          t3 = t3 + 1 & 255;
          const s4 = a3[t3];
          i3 = i3 + s4 & 255;
          const o3 = a3[i3];
          a3[t3] = o3;
          a3[i3] = s4;
          r3[n3] = e3[n3] ^ a3[s4 + o3 & 255];
        }
        this.a = t3;
        this.b = i3;
        return r3;
      }
      decryptBlock(e3) {
        return this.encryptBlock(e3);
      }
      encrypt(e3) {
        return this.encryptBlock(e3);
      }
    };
    Hs = function calculateMD5Closure() {
      const e3 = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), t3 = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
      return function hash(i3, a3, s3) {
        let r3 = 1732584193, n3 = -271733879, o3 = -1732584194, g3 = 271733878;
        const c3 = s3 + 72 & -64, C3 = new Uint8Array(c3);
        let h2, l3;
        for (h2 = 0; h2 < s3; ++h2)
          C3[h2] = i3[a3++];
        C3[h2++] = 128;
        const Q3 = c3 - 8;
        for (; h2 < Q3; )
          C3[h2++] = 0;
        C3[h2++] = s3 << 3 & 255;
        C3[h2++] = s3 >> 5 & 255;
        C3[h2++] = s3 >> 13 & 255;
        C3[h2++] = s3 >> 21 & 255;
        C3[h2++] = s3 >>> 29 & 255;
        C3[h2++] = 0;
        C3[h2++] = 0;
        C3[h2++] = 0;
        const E3 = new Int32Array(16);
        for (h2 = 0; h2 < c3; ) {
          for (l3 = 0; l3 < 16; ++l3, h2 += 4)
            E3[l3] = C3[h2] | C3[h2 + 1] << 8 | C3[h2 + 2] << 16 | C3[h2 + 3] << 24;
          let i4, a4, s4 = r3, c4 = n3, Q4 = o3, u3 = g3;
          for (l3 = 0; l3 < 64; ++l3) {
            if (l3 < 16) {
              i4 = c4 & Q4 | ~c4 & u3;
              a4 = l3;
            } else if (l3 < 32) {
              i4 = u3 & c4 | ~u3 & Q4;
              a4 = 5 * l3 + 1 & 15;
            } else if (l3 < 48) {
              i4 = c4 ^ Q4 ^ u3;
              a4 = 3 * l3 + 5 & 15;
            } else {
              i4 = Q4 ^ (c4 | ~u3);
              a4 = 7 * l3 & 15;
            }
            const r4 = u3, n4 = s4 + i4 + t3[l3] + E3[a4] | 0, o4 = e3[l3];
            u3 = Q4;
            Q4 = c4;
            c4 = c4 + (n4 << o4 | n4 >>> 32 - o4) | 0;
            s4 = r4;
          }
          r3 = r3 + s4 | 0;
          n3 = n3 + c4 | 0;
          o3 = o3 + Q4 | 0;
          g3 = g3 + u3 | 0;
        }
        return new Uint8Array([255 & r3, r3 >> 8 & 255, r3 >> 16 & 255, r3 >>> 24 & 255, 255 & n3, n3 >> 8 & 255, n3 >> 16 & 255, n3 >>> 24 & 255, 255 & o3, o3 >> 8 & 255, o3 >> 16 & 255, o3 >>> 24 & 255, 255 & g3, g3 >> 8 & 255, g3 >> 16 & 255, g3 >>> 24 & 255]);
      };
    }();
    Word64 = class {
      constructor(e3, t3) {
        this.high = 0 | e3;
        this.low = 0 | t3;
      }
      and(e3) {
        this.high &= e3.high;
        this.low &= e3.low;
      }
      xor(e3) {
        this.high ^= e3.high;
        this.low ^= e3.low;
      }
      or(e3) {
        this.high |= e3.high;
        this.low |= e3.low;
      }
      shiftRight(e3) {
        if (e3 >= 32) {
          this.low = this.high >>> e3 - 32 | 0;
          this.high = 0;
        } else {
          this.low = this.low >>> e3 | this.high << 32 - e3;
          this.high = this.high >>> e3 | 0;
        }
      }
      shiftLeft(e3) {
        if (e3 >= 32) {
          this.high = this.low << e3 - 32;
          this.low = 0;
        } else {
          this.high = this.high << e3 | this.low >>> 32 - e3;
          this.low <<= e3;
        }
      }
      rotateRight(e3) {
        let t3, i3;
        if (32 & e3) {
          i3 = this.low;
          t3 = this.high;
        } else {
          t3 = this.low;
          i3 = this.high;
        }
        e3 &= 31;
        this.low = t3 >>> e3 | i3 << 32 - e3;
        this.high = i3 >>> e3 | t3 << 32 - e3;
      }
      not() {
        this.high = ~this.high;
        this.low = ~this.low;
      }
      add(e3) {
        const t3 = (this.low >>> 0) + (e3.low >>> 0);
        let i3 = (this.high >>> 0) + (e3.high >>> 0);
        t3 > 4294967295 && (i3 += 1);
        this.low = 0 | t3;
        this.high = 0 | i3;
      }
      copyTo(e3, t3) {
        e3[t3] = this.high >>> 24 & 255;
        e3[t3 + 1] = this.high >> 16 & 255;
        e3[t3 + 2] = this.high >> 8 & 255;
        e3[t3 + 3] = 255 & this.high;
        e3[t3 + 4] = this.low >>> 24 & 255;
        e3[t3 + 5] = this.low >> 16 & 255;
        e3[t3 + 6] = this.low >> 8 & 255;
        e3[t3 + 7] = 255 & this.low;
      }
      assign(e3) {
        this.high = e3.high;
        this.low = e3.low;
      }
    };
    Js = /* @__PURE__ */ function calculateSHA256Closure() {
      function rotr(e4, t3) {
        return e4 >>> t3 | e4 << 32 - t3;
      }
      function ch(e4, t3, i3) {
        return e4 & t3 ^ ~e4 & i3;
      }
      function maj(e4, t3, i3) {
        return e4 & t3 ^ e4 & i3 ^ t3 & i3;
      }
      function sigma(e4) {
        return rotr(e4, 2) ^ rotr(e4, 13) ^ rotr(e4, 22);
      }
      function sigmaPrime(e4) {
        return rotr(e4, 6) ^ rotr(e4, 11) ^ rotr(e4, 25);
      }
      function littleSigma(e4) {
        return rotr(e4, 7) ^ rotr(e4, 18) ^ e4 >>> 3;
      }
      const e3 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      return function hash(t3, i3, a3) {
        let s3 = 1779033703, r3 = 3144134277, n3 = 1013904242, o3 = 2773480762, g3 = 1359893119, c3 = 2600822924, C3 = 528734635, h2 = 1541459225;
        const l3 = 64 * Math.ceil((a3 + 9) / 64), Q3 = new Uint8Array(l3);
        let E3, u3;
        for (E3 = 0; E3 < a3; ++E3)
          Q3[E3] = t3[i3++];
        Q3[E3++] = 128;
        const d3 = l3 - 8;
        for (; E3 < d3; )
          Q3[E3++] = 0;
        Q3[E3++] = 0;
        Q3[E3++] = 0;
        Q3[E3++] = 0;
        Q3[E3++] = a3 >>> 29 & 255;
        Q3[E3++] = a3 >> 21 & 255;
        Q3[E3++] = a3 >> 13 & 255;
        Q3[E3++] = a3 >> 5 & 255;
        Q3[E3++] = a3 << 3 & 255;
        const f2 = new Uint32Array(64);
        for (E3 = 0; E3 < l3; ) {
          for (u3 = 0; u3 < 16; ++u3) {
            f2[u3] = Q3[E3] << 24 | Q3[E3 + 1] << 16 | Q3[E3 + 2] << 8 | Q3[E3 + 3];
            E3 += 4;
          }
          for (u3 = 16; u3 < 64; ++u3)
            f2[u3] = (rotr(p2 = f2[u3 - 2], 17) ^ rotr(p2, 19) ^ p2 >>> 10) + f2[u3 - 7] + littleSigma(f2[u3 - 15]) + f2[u3 - 16] | 0;
          let t4, i4, a4 = s3, l4 = r3, d4 = n3, m3 = o3, y3 = g3, w3 = c3, b3 = C3, D3 = h2;
          for (u3 = 0; u3 < 64; ++u3) {
            t4 = D3 + sigmaPrime(y3) + ch(y3, w3, b3) + e3[u3] + f2[u3];
            i4 = sigma(a4) + maj(a4, l4, d4);
            D3 = b3;
            b3 = w3;
            w3 = y3;
            y3 = m3 + t4 | 0;
            m3 = d4;
            d4 = l4;
            l4 = a4;
            a4 = t4 + i4 | 0;
          }
          s3 = s3 + a4 | 0;
          r3 = r3 + l4 | 0;
          n3 = n3 + d4 | 0;
          o3 = o3 + m3 | 0;
          g3 = g3 + y3 | 0;
          c3 = c3 + w3 | 0;
          C3 = C3 + b3 | 0;
          h2 = h2 + D3 | 0;
        }
        var p2;
        return new Uint8Array([s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255, 255 & s3, r3 >> 24 & 255, r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3, n3 >> 24 & 255, n3 >> 16 & 255, n3 >> 8 & 255, 255 & n3, o3 >> 24 & 255, o3 >> 16 & 255, o3 >> 8 & 255, 255 & o3, g3 >> 24 & 255, g3 >> 16 & 255, g3 >> 8 & 255, 255 & g3, c3 >> 24 & 255, c3 >> 16 & 255, c3 >> 8 & 255, 255 & c3, C3 >> 24 & 255, C3 >> 16 & 255, C3 >> 8 & 255, 255 & C3, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, 255 & h2]);
      };
    }();
    Ys = function calculateSHA512Closure() {
      function ch(e4, t3, i3, a3, s3) {
        e4.assign(t3);
        e4.and(i3);
        s3.assign(t3);
        s3.not();
        s3.and(a3);
        e4.xor(s3);
      }
      function maj(e4, t3, i3, a3, s3) {
        e4.assign(t3);
        e4.and(i3);
        s3.assign(t3);
        s3.and(a3);
        e4.xor(s3);
        s3.assign(i3);
        s3.and(a3);
        e4.xor(s3);
      }
      function sigma(e4, t3, i3) {
        e4.assign(t3);
        e4.rotateRight(28);
        i3.assign(t3);
        i3.rotateRight(34);
        e4.xor(i3);
        i3.assign(t3);
        i3.rotateRight(39);
        e4.xor(i3);
      }
      function sigmaPrime(e4, t3, i3) {
        e4.assign(t3);
        e4.rotateRight(14);
        i3.assign(t3);
        i3.rotateRight(18);
        e4.xor(i3);
        i3.assign(t3);
        i3.rotateRight(41);
        e4.xor(i3);
      }
      function littleSigma(e4, t3, i3) {
        e4.assign(t3);
        e4.rotateRight(1);
        i3.assign(t3);
        i3.rotateRight(8);
        e4.xor(i3);
        i3.assign(t3);
        i3.shiftRight(7);
        e4.xor(i3);
      }
      function littleSigmaPrime(e4, t3, i3) {
        e4.assign(t3);
        e4.rotateRight(19);
        i3.assign(t3);
        i3.rotateRight(61);
        e4.xor(i3);
        i3.assign(t3);
        i3.shiftRight(6);
        e4.xor(i3);
      }
      const e3 = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
      return function hash(t3, i3, a3, s3 = false) {
        let r3, n3, o3, g3, c3, C3, h2, l3;
        if (s3) {
          r3 = new Word64(3418070365, 3238371032);
          n3 = new Word64(1654270250, 914150663);
          o3 = new Word64(2438529370, 812702999);
          g3 = new Word64(355462360, 4144912697);
          c3 = new Word64(1731405415, 4290775857);
          C3 = new Word64(2394180231, 1750603025);
          h2 = new Word64(3675008525, 1694076839);
          l3 = new Word64(1203062813, 3204075428);
        } else {
          r3 = new Word64(1779033703, 4089235720);
          n3 = new Word64(3144134277, 2227873595);
          o3 = new Word64(1013904242, 4271175723);
          g3 = new Word64(2773480762, 1595750129);
          c3 = new Word64(1359893119, 2917565137);
          C3 = new Word64(2600822924, 725511199);
          h2 = new Word64(528734635, 4215389547);
          l3 = new Word64(1541459225, 327033209);
        }
        const Q3 = 128 * Math.ceil((a3 + 17) / 128), E3 = new Uint8Array(Q3);
        let u3, d3;
        for (u3 = 0; u3 < a3; ++u3)
          E3[u3] = t3[i3++];
        E3[u3++] = 128;
        const f2 = Q3 - 16;
        for (; u3 < f2; )
          E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = 0;
        E3[u3++] = a3 >>> 29 & 255;
        E3[u3++] = a3 >> 21 & 255;
        E3[u3++] = a3 >> 13 & 255;
        E3[u3++] = a3 >> 5 & 255;
        E3[u3++] = a3 << 3 & 255;
        const p2 = new Array(80);
        for (u3 = 0; u3 < 80; u3++)
          p2[u3] = new Word64(0, 0);
        let m3 = new Word64(0, 0), y3 = new Word64(0, 0), w3 = new Word64(0, 0), b3 = new Word64(0, 0), D3 = new Word64(0, 0), F3 = new Word64(0, 0), S3 = new Word64(0, 0), k3 = new Word64(0, 0);
        const N3 = new Word64(0, 0), R3 = new Word64(0, 0), G3 = new Word64(0, 0), x3 = new Word64(0, 0);
        let U3, M3;
        for (u3 = 0; u3 < Q3; ) {
          for (d3 = 0; d3 < 16; ++d3) {
            p2[d3].high = E3[u3] << 24 | E3[u3 + 1] << 16 | E3[u3 + 2] << 8 | E3[u3 + 3];
            p2[d3].low = E3[u3 + 4] << 24 | E3[u3 + 5] << 16 | E3[u3 + 6] << 8 | E3[u3 + 7];
            u3 += 8;
          }
          for (d3 = 16; d3 < 80; ++d3) {
            U3 = p2[d3];
            littleSigmaPrime(U3, p2[d3 - 2], x3);
            U3.add(p2[d3 - 7]);
            littleSigma(G3, p2[d3 - 15], x3);
            U3.add(G3);
            U3.add(p2[d3 - 16]);
          }
          m3.assign(r3);
          y3.assign(n3);
          w3.assign(o3);
          b3.assign(g3);
          D3.assign(c3);
          F3.assign(C3);
          S3.assign(h2);
          k3.assign(l3);
          for (d3 = 0; d3 < 80; ++d3) {
            N3.assign(k3);
            sigmaPrime(G3, D3, x3);
            N3.add(G3);
            ch(G3, D3, F3, S3, x3);
            N3.add(G3);
            N3.add(e3[d3]);
            N3.add(p2[d3]);
            sigma(R3, m3, x3);
            maj(G3, m3, y3, w3, x3);
            R3.add(G3);
            U3 = k3;
            k3 = S3;
            S3 = F3;
            F3 = D3;
            b3.add(N3);
            D3 = b3;
            b3 = w3;
            w3 = y3;
            y3 = m3;
            U3.assign(N3);
            U3.add(R3);
            m3 = U3;
          }
          r3.add(m3);
          n3.add(y3);
          o3.add(w3);
          g3.add(b3);
          c3.add(D3);
          C3.add(F3);
          h2.add(S3);
          l3.add(k3);
        }
        if (s3) {
          M3 = new Uint8Array(48);
          r3.copyTo(M3, 0);
          n3.copyTo(M3, 8);
          o3.copyTo(M3, 16);
          g3.copyTo(M3, 24);
          c3.copyTo(M3, 32);
          C3.copyTo(M3, 40);
        } else {
          M3 = new Uint8Array(64);
          r3.copyTo(M3, 0);
          n3.copyTo(M3, 8);
          o3.copyTo(M3, 16);
          g3.copyTo(M3, 24);
          c3.copyTo(M3, 32);
          C3.copyTo(M3, 40);
          h2.copyTo(M3, 48);
          l3.copyTo(M3, 56);
        }
        return M3;
      };
    }();
    NullCipher = class {
      decryptBlock(e3) {
        return e3;
      }
      encrypt(e3) {
        return e3;
      }
    };
    AESBaseCipher = class _AESBaseCipher {
      constructor() {
        this.constructor === _AESBaseCipher && unreachable("Cannot initialize AESBaseCipher.");
        this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
        this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
        this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
        this._mixCol = new Uint8Array(256);
        for (let e3 = 0; e3 < 256; e3++)
          this._mixCol[e3] = e3 < 128 ? e3 << 1 : e3 << 1 ^ 27;
        this.buffer = new Uint8Array(16);
        this.bufferPosition = 0;
      }
      _expandKey(e3) {
        unreachable("Cannot call `_expandKey` on the base class");
      }
      _decrypt(e3, t3) {
        let i3, a3, s3;
        const r3 = new Uint8Array(16);
        r3.set(e3);
        for (let e4 = 0, i4 = this._keySize; e4 < 16; ++e4, ++i4)
          r3[e4] ^= t3[i4];
        for (let e4 = this._cyclesOfRepetition - 1; e4 >= 1; --e4) {
          i3 = r3[13];
          r3[13] = r3[9];
          r3[9] = r3[5];
          r3[5] = r3[1];
          r3[1] = i3;
          i3 = r3[14];
          a3 = r3[10];
          r3[14] = r3[6];
          r3[10] = r3[2];
          r3[6] = i3;
          r3[2] = a3;
          i3 = r3[15];
          a3 = r3[11];
          s3 = r3[7];
          r3[15] = r3[3];
          r3[11] = i3;
          r3[7] = a3;
          r3[3] = s3;
          for (let e5 = 0; e5 < 16; ++e5)
            r3[e5] = this._inv_s[r3[e5]];
          for (let i4 = 0, a4 = 16 * e4; i4 < 16; ++i4, ++a4)
            r3[i4] ^= t3[a4];
          for (let e5 = 0; e5 < 16; e5 += 4) {
            const t4 = this._mix[r3[e5]], a4 = this._mix[r3[e5 + 1]], s4 = this._mix[r3[e5 + 2]], n3 = this._mix[r3[e5 + 3]];
            i3 = t4 ^ a4 >>> 8 ^ a4 << 24 ^ s4 >>> 16 ^ s4 << 16 ^ n3 >>> 24 ^ n3 << 8;
            r3[e5] = i3 >>> 24 & 255;
            r3[e5 + 1] = i3 >> 16 & 255;
            r3[e5 + 2] = i3 >> 8 & 255;
            r3[e5 + 3] = 255 & i3;
          }
        }
        i3 = r3[13];
        r3[13] = r3[9];
        r3[9] = r3[5];
        r3[5] = r3[1];
        r3[1] = i3;
        i3 = r3[14];
        a3 = r3[10];
        r3[14] = r3[6];
        r3[10] = r3[2];
        r3[6] = i3;
        r3[2] = a3;
        i3 = r3[15];
        a3 = r3[11];
        s3 = r3[7];
        r3[15] = r3[3];
        r3[11] = i3;
        r3[7] = a3;
        r3[3] = s3;
        for (let e4 = 0; e4 < 16; ++e4) {
          r3[e4] = this._inv_s[r3[e4]];
          r3[e4] ^= t3[e4];
        }
        return r3;
      }
      _encrypt(e3, t3) {
        const i3 = this._s;
        let a3, s3, r3;
        const n3 = new Uint8Array(16);
        n3.set(e3);
        for (let e4 = 0; e4 < 16; ++e4)
          n3[e4] ^= t3[e4];
        for (let e4 = 1; e4 < this._cyclesOfRepetition; e4++) {
          for (let e5 = 0; e5 < 16; ++e5)
            n3[e5] = i3[n3[e5]];
          r3 = n3[1];
          n3[1] = n3[5];
          n3[5] = n3[9];
          n3[9] = n3[13];
          n3[13] = r3;
          r3 = n3[2];
          s3 = n3[6];
          n3[2] = n3[10];
          n3[6] = n3[14];
          n3[10] = r3;
          n3[14] = s3;
          r3 = n3[3];
          s3 = n3[7];
          a3 = n3[11];
          n3[3] = n3[15];
          n3[7] = r3;
          n3[11] = s3;
          n3[15] = a3;
          for (let e5 = 0; e5 < 16; e5 += 4) {
            const t4 = n3[e5 + 0], i4 = n3[e5 + 1], s4 = n3[e5 + 2], r4 = n3[e5 + 3];
            a3 = t4 ^ i4 ^ s4 ^ r4;
            n3[e5 + 0] ^= a3 ^ this._mixCol[t4 ^ i4];
            n3[e5 + 1] ^= a3 ^ this._mixCol[i4 ^ s4];
            n3[e5 + 2] ^= a3 ^ this._mixCol[s4 ^ r4];
            n3[e5 + 3] ^= a3 ^ this._mixCol[r4 ^ t4];
          }
          for (let i4 = 0, a4 = 16 * e4; i4 < 16; ++i4, ++a4)
            n3[i4] ^= t3[a4];
        }
        for (let e4 = 0; e4 < 16; ++e4)
          n3[e4] = i3[n3[e4]];
        r3 = n3[1];
        n3[1] = n3[5];
        n3[5] = n3[9];
        n3[9] = n3[13];
        n3[13] = r3;
        r3 = n3[2];
        s3 = n3[6];
        n3[2] = n3[10];
        n3[6] = n3[14];
        n3[10] = r3;
        n3[14] = s3;
        r3 = n3[3];
        s3 = n3[7];
        a3 = n3[11];
        n3[3] = n3[15];
        n3[7] = r3;
        n3[11] = s3;
        n3[15] = a3;
        for (let e4 = 0, i4 = this._keySize; e4 < 16; ++e4, ++i4)
          n3[e4] ^= t3[i4];
        return n3;
      }
      _decryptBlock2(e3, t3) {
        const i3 = e3.length;
        let a3 = this.buffer, s3 = this.bufferPosition;
        const r3 = [];
        let n3 = this.iv;
        for (let t4 = 0; t4 < i3; ++t4) {
          a3[s3] = e3[t4];
          ++s3;
          if (s3 < 16)
            continue;
          const i4 = this._decrypt(a3, this._key);
          for (let e4 = 0; e4 < 16; ++e4)
            i4[e4] ^= n3[e4];
          n3 = a3;
          r3.push(i4);
          a3 = new Uint8Array(16);
          s3 = 0;
        }
        this.buffer = a3;
        this.bufferLength = s3;
        this.iv = n3;
        if (0 === r3.length)
          return new Uint8Array(0);
        let o3 = 16 * r3.length;
        if (t3) {
          const e4 = r3.at(-1);
          let t4 = e4[15];
          if (t4 <= 16) {
            for (let i4 = 15, a4 = 16 - t4; i4 >= a4; --i4)
              if (e4[i4] !== t4) {
                t4 = 0;
                break;
              }
            o3 -= t4;
            r3[r3.length - 1] = e4.subarray(0, 16 - t4);
          }
        }
        const g3 = new Uint8Array(o3);
        for (let e4 = 0, t4 = 0, i4 = r3.length; e4 < i4; ++e4, t4 += 16)
          g3.set(r3[e4], t4);
        return g3;
      }
      decryptBlock(e3, t3, i3 = null) {
        const a3 = e3.length, s3 = this.buffer;
        let r3 = this.bufferPosition;
        if (i3)
          this.iv = i3;
        else {
          for (let t4 = 0; r3 < 16 && t4 < a3; ++t4, ++r3)
            s3[r3] = e3[t4];
          if (r3 < 16) {
            this.bufferLength = r3;
            return new Uint8Array(0);
          }
          this.iv = s3;
          e3 = e3.subarray(16);
        }
        this.buffer = new Uint8Array(16);
        this.bufferLength = 0;
        this.decryptBlock = this._decryptBlock2;
        return this.decryptBlock(e3, t3);
      }
      encrypt(e3, t3) {
        const i3 = e3.length;
        let a3 = this.buffer, s3 = this.bufferPosition;
        const r3 = [];
        t3 || (t3 = new Uint8Array(16));
        for (let n4 = 0; n4 < i3; ++n4) {
          a3[s3] = e3[n4];
          ++s3;
          if (s3 < 16)
            continue;
          for (let e4 = 0; e4 < 16; ++e4)
            a3[e4] ^= t3[e4];
          const i4 = this._encrypt(a3, this._key);
          t3 = i4;
          r3.push(i4);
          a3 = new Uint8Array(16);
          s3 = 0;
        }
        this.buffer = a3;
        this.bufferLength = s3;
        this.iv = t3;
        if (0 === r3.length)
          return new Uint8Array(0);
        const n3 = 16 * r3.length, o3 = new Uint8Array(n3);
        for (let e4 = 0, t4 = 0, i4 = r3.length; e4 < i4; ++e4, t4 += 16)
          o3.set(r3[e4], t4);
        return o3;
      }
    };
    AES128Cipher = class extends AESBaseCipher {
      constructor(e3) {
        super();
        this._cyclesOfRepetition = 10;
        this._keySize = 160;
        this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
        this._key = this._expandKey(e3);
      }
      _expandKey(e3) {
        const t3 = this._s, i3 = this._rcon, a3 = new Uint8Array(176);
        a3.set(e3);
        for (let e4 = 16, s3 = 1; e4 < 176; ++s3) {
          let r3 = a3[e4 - 3], n3 = a3[e4 - 2], o3 = a3[e4 - 1], g3 = a3[e4 - 4];
          r3 = t3[r3];
          n3 = t3[n3];
          o3 = t3[o3];
          g3 = t3[g3];
          r3 ^= i3[s3];
          for (let t4 = 0; t4 < 4; ++t4) {
            a3[e4] = r3 ^= a3[e4 - 16];
            e4++;
            a3[e4] = n3 ^= a3[e4 - 16];
            e4++;
            a3[e4] = o3 ^= a3[e4 - 16];
            e4++;
            a3[e4] = g3 ^= a3[e4 - 16];
            e4++;
          }
        }
        return a3;
      }
    };
    AES256Cipher = class extends AESBaseCipher {
      constructor(e3) {
        super();
        this._cyclesOfRepetition = 14;
        this._keySize = 224;
        this._key = this._expandKey(e3);
      }
      _expandKey(e3) {
        const t3 = this._s, i3 = new Uint8Array(240);
        i3.set(e3);
        let a3, s3, r3, n3, o3 = 1;
        for (let e4 = 32, g3 = 1; e4 < 240; ++g3) {
          if (e4 % 32 == 16) {
            a3 = t3[a3];
            s3 = t3[s3];
            r3 = t3[r3];
            n3 = t3[n3];
          } else if (e4 % 32 == 0) {
            a3 = i3[e4 - 3];
            s3 = i3[e4 - 2];
            r3 = i3[e4 - 1];
            n3 = i3[e4 - 4];
            a3 = t3[a3];
            s3 = t3[s3];
            r3 = t3[r3];
            n3 = t3[n3];
            a3 ^= o3;
            (o3 <<= 1) >= 256 && (o3 = 255 & (27 ^ o3));
          }
          for (let t4 = 0; t4 < 4; ++t4) {
            i3[e4] = a3 ^= i3[e4 - 32];
            e4++;
            i3[e4] = s3 ^= i3[e4 - 32];
            e4++;
            i3[e4] = r3 ^= i3[e4 - 32];
            e4++;
            i3[e4] = n3 ^= i3[e4 - 32];
            e4++;
          }
        }
        return i3;
      }
    };
    PDF17 = class {
      checkOwnerPassword(e3, t3, i3, a3) {
        const s3 = new Uint8Array(e3.length + 56);
        s3.set(e3, 0);
        s3.set(t3, e3.length);
        s3.set(i3, e3.length + t3.length);
        return isArrayEqual(Js(s3, 0, s3.length), a3);
      }
      checkUserPassword(e3, t3, i3) {
        const a3 = new Uint8Array(e3.length + 8);
        a3.set(e3, 0);
        a3.set(t3, e3.length);
        return isArrayEqual(Js(a3, 0, a3.length), i3);
      }
      getOwnerKey(e3, t3, i3, a3) {
        const s3 = new Uint8Array(e3.length + 56);
        s3.set(e3, 0);
        s3.set(t3, e3.length);
        s3.set(i3, e3.length + t3.length);
        const r3 = Js(s3, 0, s3.length);
        return new AES256Cipher(r3).decryptBlock(a3, false, new Uint8Array(16));
      }
      getUserKey(e3, t3, i3) {
        const a3 = new Uint8Array(e3.length + 8);
        a3.set(e3, 0);
        a3.set(t3, e3.length);
        const s3 = Js(a3, 0, a3.length);
        return new AES256Cipher(s3).decryptBlock(i3, false, new Uint8Array(16));
      }
    };
    PDF20 = class {
      _hash(e3, t3, i3) {
        let a3 = Js(t3, 0, t3.length).subarray(0, 32), s3 = [0], r3 = 0;
        for (; r3 < 64 || s3.at(-1) > r3 - 32; ) {
          const t4 = e3.length + a3.length + i3.length, c3 = new Uint8Array(t4);
          let C3 = 0;
          c3.set(e3, C3);
          C3 += e3.length;
          c3.set(a3, C3);
          C3 += a3.length;
          c3.set(i3, C3);
          const h2 = new Uint8Array(64 * t4);
          for (let e4 = 0, i4 = 0; e4 < 64; e4++, i4 += t4)
            h2.set(c3, i4);
          s3 = new AES128Cipher(a3.subarray(0, 16)).encrypt(h2, a3.subarray(16, 32));
          const l3 = s3.slice(0, 16).reduce((e4, t5) => e4 + t5, 0) % 3;
          0 === l3 ? a3 = Js(s3, 0, s3.length) : 1 === l3 ? a3 = (n3 = s3, o3 = 0, g3 = s3.length, Ys(n3, o3, g3, true)) : 2 === l3 && (a3 = Ys(s3, 0, s3.length));
          r3++;
        }
        var n3, o3, g3;
        return a3.subarray(0, 32);
      }
      checkOwnerPassword(e3, t3, i3, a3) {
        const s3 = new Uint8Array(e3.length + 56);
        s3.set(e3, 0);
        s3.set(t3, e3.length);
        s3.set(i3, e3.length + t3.length);
        return isArrayEqual(this._hash(e3, s3, i3), a3);
      }
      checkUserPassword(e3, t3, i3) {
        const a3 = new Uint8Array(e3.length + 8);
        a3.set(e3, 0);
        a3.set(t3, e3.length);
        return isArrayEqual(this._hash(e3, a3, []), i3);
      }
      getOwnerKey(e3, t3, i3, a3) {
        const s3 = new Uint8Array(e3.length + 56);
        s3.set(e3, 0);
        s3.set(t3, e3.length);
        s3.set(i3, e3.length + t3.length);
        const r3 = this._hash(e3, s3, i3);
        return new AES256Cipher(r3).decryptBlock(a3, false, new Uint8Array(16));
      }
      getUserKey(e3, t3, i3) {
        const a3 = new Uint8Array(e3.length + 8);
        a3.set(e3, 0);
        a3.set(t3, e3.length);
        const s3 = this._hash(e3, a3, []);
        return new AES256Cipher(s3).decryptBlock(i3, false, new Uint8Array(16));
      }
    };
    CipherTransform = class {
      constructor(e3, t3) {
        this.StringCipherConstructor = e3;
        this.StreamCipherConstructor = t3;
      }
      createStream(e3, t3) {
        const i3 = new this.StreamCipherConstructor();
        return new DecryptStream(e3, t3, function cipherTransformDecryptStream(e4, t4) {
          return i3.decryptBlock(e4, t4);
        });
      }
      decryptString(e3) {
        const t3 = new this.StringCipherConstructor();
        let i3 = stringToBytes(e3);
        i3 = t3.decryptBlock(i3, true);
        return bytesToString(i3);
      }
      encryptString(e3) {
        const t3 = new this.StringCipherConstructor();
        if (t3 instanceof AESBaseCipher) {
          const i4 = 16 - e3.length % 16;
          e3 += String.fromCharCode(i4).repeat(i4);
          const a3 = new Uint8Array(16);
          if ("undefined" != typeof crypto)
            crypto.getRandomValues(a3);
          else
            for (let e4 = 0; e4 < 16; e4++)
              a3[e4] = Math.floor(256 * Math.random());
          let s3 = stringToBytes(e3);
          s3 = t3.encrypt(s3, a3);
          const r3 = new Uint8Array(16 + s3.length);
          r3.set(a3);
          r3.set(s3, 16);
          return bytesToString(r3);
        }
        let i3 = stringToBytes(e3);
        i3 = t3.encrypt(i3);
        return bytesToString(i3);
      }
    };
    _CipherTransformFactory = class _CipherTransformFactory {
      constructor(e3, t3, i3) {
        __privateAdd(this, _D);
        __privateAdd(this, _F);
        __privateAdd(this, _S);
        __privateAdd(this, _k);
        __privateAdd(this, _N);
        const a3 = e3.get("Filter");
        if (!isName(a3, "Standard"))
          throw new FormatError("unknown encryption method");
        this.filterName = a3.name;
        this.dict = e3;
        const s3 = e3.get("V");
        if (!Number.isInteger(s3) || 1 !== s3 && 2 !== s3 && 4 !== s3 && 5 !== s3)
          throw new FormatError("unsupported encryption algorithm");
        this.algorithm = s3;
        let r3 = e3.get("Length");
        if (!r3)
          if (s3 <= 3)
            r3 = 40;
          else {
            const t4 = e3.get("CF"), i4 = e3.get("StmF");
            if (t4 instanceof Dict && i4 instanceof Name) {
              t4.suppressEncryption = true;
              const e4 = t4.get(i4.name);
              r3 = (e4 == null ? void 0 : e4.get("Length")) || 128;
              r3 < 40 && (r3 <<= 3);
            }
          }
        if (!Number.isInteger(r3) || r3 < 40 || r3 % 8 != 0)
          throw new FormatError("invalid key length");
        const n3 = stringToBytes(e3.get("O")), o3 = stringToBytes(e3.get("U")), g3 = n3.subarray(0, 32), c3 = o3.subarray(0, 32), C3 = e3.get("P"), h2 = e3.get("R"), l3 = (4 === s3 || 5 === s3) && false !== e3.get("EncryptMetadata");
        this.encryptMetadata = l3;
        const Q3 = stringToBytes(t3);
        let E3, u3;
        if (i3) {
          if (6 === h2)
            try {
              i3 = utf8StringToString(i3);
            } catch {
              warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
            }
          E3 = stringToBytes(i3);
        }
        if (5 !== s3)
          u3 = __privateMethod(this, _F, F_fn).call(this, Q3, E3, g3, c3, C3, h2, r3, l3);
        else {
          const t4 = n3.subarray(32, 40), i4 = n3.subarray(40, 48), a4 = o3.subarray(0, 48), s4 = o3.subarray(32, 40), r4 = o3.subarray(40, 48), C4 = stringToBytes(e3.get("OE")), l4 = stringToBytes(e3.get("UE")), Q4 = stringToBytes(e3.get("Perms"));
          u3 = __privateMethod(this, _D, D_fn).call(this, h2, E3, g3, t4, i4, a4, c3, s4, r4, C4, l4, Q4);
        }
        if (!u3 && !i3)
          throw new PasswordException("No password given", it);
        if (!u3 && i3) {
          const e4 = __privateMethod(this, _S, S_fn).call(this, E3, g3, h2, r3);
          u3 = __privateMethod(this, _F, F_fn).call(this, Q3, e4, g3, c3, C3, h2, r3, l3);
        }
        if (!u3)
          throw new PasswordException("Incorrect Password", at);
        this.encryptionKey = u3;
        if (s3 >= 4) {
          const t4 = e3.get("CF");
          t4 instanceof Dict && (t4.suppressEncryption = true);
          this.cf = t4;
          this.stmf = e3.get("StmF") || Name.get("Identity");
          this.strf = e3.get("StrF") || Name.get("Identity");
          this.eff = e3.get("EFF") || this.stmf;
        }
      }
      createCipherTransform(e3, t3) {
        if (4 === this.algorithm || 5 === this.algorithm)
          return new CipherTransform(__privateMethod(this, _N, N_fn).call(this, this.cf, this.strf, e3, t3, this.encryptionKey), __privateMethod(this, _N, N_fn).call(this, this.cf, this.stmf, e3, t3, this.encryptionKey));
        const i3 = __privateMethod(this, _k, k_fn).call(this, e3, t3, this.encryptionKey, false), cipherConstructor = function() {
          return new ARCFourCipher(i3);
        };
        return new CipherTransform(cipherConstructor, cipherConstructor);
      }
    };
    _b = new WeakMap();
    _D = new WeakSet();
    D_fn = function(e3, t3, i3, a3, s3, r3, n3, o3, g3, c3, C3, h2) {
      if (t3) {
        const e4 = Math.min(127, t3.length);
        t3 = t3.subarray(0, e4);
      } else
        t3 = [];
      const l3 = 6 === e3 ? new PDF20() : new PDF17();
      return l3.checkUserPassword(t3, o3, n3) ? l3.getUserKey(t3, g3, C3) : t3.length && l3.checkOwnerPassword(t3, a3, r3, i3) ? l3.getOwnerKey(t3, s3, r3, c3) : null;
    };
    _F = new WeakSet();
    F_fn = function(e3, t3, i3, a3, s3, r3, n3, o3) {
      const g3 = 40 + i3.length + e3.length, c3 = new Uint8Array(g3);
      let C3, h2, l3 = 0;
      if (t3) {
        h2 = Math.min(32, t3.length);
        for (; l3 < h2; ++l3)
          c3[l3] = t3[l3];
      }
      C3 = 0;
      for (; l3 < 32; )
        c3[l3++] = __privateGet(_CipherTransformFactory, _b)[C3++];
      for (C3 = 0, h2 = i3.length; C3 < h2; ++C3)
        c3[l3++] = i3[C3];
      c3[l3++] = 255 & s3;
      c3[l3++] = s3 >> 8 & 255;
      c3[l3++] = s3 >> 16 & 255;
      c3[l3++] = s3 >>> 24 & 255;
      for (C3 = 0, h2 = e3.length; C3 < h2; ++C3)
        c3[l3++] = e3[C3];
      if (r3 >= 4 && !o3) {
        c3[l3++] = 255;
        c3[l3++] = 255;
        c3[l3++] = 255;
        c3[l3++] = 255;
      }
      let Q3 = Hs(c3, 0, l3);
      const E3 = n3 >> 3;
      if (r3 >= 3)
        for (C3 = 0; C3 < 50; ++C3)
          Q3 = Hs(Q3, 0, E3);
      const u3 = Q3.subarray(0, E3);
      let d3, f2;
      if (r3 >= 3) {
        for (l3 = 0; l3 < 32; ++l3)
          c3[l3] = __privateGet(_CipherTransformFactory, _b)[l3];
        for (C3 = 0, h2 = e3.length; C3 < h2; ++C3)
          c3[l3++] = e3[C3];
        d3 = new ARCFourCipher(u3);
        f2 = d3.encryptBlock(Hs(c3, 0, l3));
        h2 = u3.length;
        const t4 = new Uint8Array(h2);
        for (C3 = 1; C3 <= 19; ++C3) {
          for (let e4 = 0; e4 < h2; ++e4)
            t4[e4] = u3[e4] ^ C3;
          d3 = new ARCFourCipher(t4);
          f2 = d3.encryptBlock(f2);
        }
        for (C3 = 0, h2 = f2.length; C3 < h2; ++C3)
          if (a3[C3] !== f2[C3])
            return null;
      } else {
        d3 = new ARCFourCipher(u3);
        f2 = d3.encryptBlock(__privateGet(_CipherTransformFactory, _b));
        for (C3 = 0, h2 = f2.length; C3 < h2; ++C3)
          if (a3[C3] !== f2[C3])
            return null;
      }
      return u3;
    };
    _S = new WeakSet();
    S_fn = function(e3, t3, i3, a3) {
      const s3 = new Uint8Array(32);
      let r3 = 0;
      const n3 = Math.min(32, e3.length);
      for (; r3 < n3; ++r3)
        s3[r3] = e3[r3];
      let o3 = 0;
      for (; r3 < 32; )
        s3[r3++] = __privateGet(_CipherTransformFactory, _b)[o3++];
      let g3 = Hs(s3, 0, r3);
      const c3 = a3 >> 3;
      if (i3 >= 3)
        for (o3 = 0; o3 < 50; ++o3)
          g3 = Hs(g3, 0, g3.length);
      let C3, h2;
      if (i3 >= 3) {
        h2 = t3;
        const e4 = new Uint8Array(c3);
        for (o3 = 19; o3 >= 0; o3--) {
          for (let t4 = 0; t4 < c3; ++t4)
            e4[t4] = g3[t4] ^ o3;
          C3 = new ARCFourCipher(e4);
          h2 = C3.encryptBlock(h2);
        }
      } else {
        C3 = new ARCFourCipher(g3.subarray(0, c3));
        h2 = C3.encryptBlock(t3);
      }
      return h2;
    };
    _k = new WeakSet();
    k_fn = function(e3, t3, i3, a3 = false) {
      const s3 = new Uint8Array(i3.length + 9), r3 = i3.length;
      let n3;
      for (n3 = 0; n3 < r3; ++n3)
        s3[n3] = i3[n3];
      s3[n3++] = 255 & e3;
      s3[n3++] = e3 >> 8 & 255;
      s3[n3++] = e3 >> 16 & 255;
      s3[n3++] = 255 & t3;
      s3[n3++] = t3 >> 8 & 255;
      if (a3) {
        s3[n3++] = 115;
        s3[n3++] = 65;
        s3[n3++] = 108;
        s3[n3++] = 84;
      }
      return Hs(s3, 0, n3).subarray(0, Math.min(i3.length + 5, 16));
    };
    _N = new WeakSet();
    N_fn = function(e3, t3, i3, a3, s3) {
      if (!(t3 instanceof Name))
        throw new FormatError("Invalid crypt filter name.");
      const r3 = this, n3 = e3.get(t3.name), o3 = n3 == null ? void 0 : n3.get("CFM");
      if (!o3 || "None" === o3.name)
        return function() {
          return new NullCipher();
        };
      if ("V2" === o3.name)
        return function() {
          var _a3;
          return new ARCFourCipher(__privateMethod(_a3 = r3, _k, k_fn).call(_a3, i3, a3, s3, false));
        };
      if ("AESV2" === o3.name)
        return function() {
          var _a3;
          return new AES128Cipher(__privateMethod(_a3 = r3, _k, k_fn).call(_a3, i3, a3, s3, true));
        };
      if ("AESV3" === o3.name)
        return function() {
          return new AES256Cipher(s3);
        };
      throw new FormatError("Unknown crypto method");
    };
    __privateAdd(_CipherTransformFactory, _b, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
    CipherTransformFactory = _CipherTransformFactory;
    vs = 1;
    Ks = 2;
    Ts = 3;
    qs = 4;
    Os = 5;
    _StructTreeRoot = class _StructTreeRoot {
      constructor(e3, t3) {
        __privateAdd(this, _R);
        this.dict = e3;
        this.ref = t3 instanceof Ref ? t3 : null;
        this.roleMap = /* @__PURE__ */ new Map();
        this.structParentIds = null;
      }
      init() {
        this.readRoleMap();
      }
      addAnnotationIdToPage(e3, t3) {
        __privateMethod(this, _R, R_fn).call(this, e3, t3, qs);
      }
      readRoleMap() {
        const e3 = this.dict.get("RoleMap");
        e3 instanceof Dict && e3.forEach((e4, t3) => {
          t3 instanceof Name && this.roleMap.set(e4, t3.name);
        });
      }
      static async canCreateStructureTree({ catalogRef: e3, pdfManager: t3, newAnnotationsByPage: i3 }) {
        var _a3;
        if (!(e3 instanceof Ref)) {
          warn("Cannot save the struct tree: no catalog reference.");
          return false;
        }
        let a3 = 0, s3 = true;
        for (const [e4, r3] of i3) {
          const { ref: i4 } = await t3.getPage(e4);
          if (!(i4 instanceof Ref)) {
            warn(`Cannot save the struct tree: page ${e4} has no ref.`);
            s3 = true;
            break;
          }
          for (const e5 of r3)
            if ((_a3 = e5.accessibilityData) == null ? void 0 : _a3.type) {
              e5.parentTreeId = a3++;
              s3 = false;
            }
        }
        if (s3) {
          for (const e4 of i3.values())
            for (const t4 of e4)
              delete t4.parentTreeId;
          return false;
        }
        return true;
      }
      static async createStructureTree({ newAnnotationsByPage: e3, xref: t3, catalogRef: i3, pdfManager: a3, newRefs: s3 }) {
        const r3 = a3.catalog.cloneDict(), n3 = new RefSetCache();
        n3.put(i3, r3);
        const o3 = t3.getNewTemporaryRef();
        r3.set("StructTreeRoot", o3);
        const g3 = new Dict(t3);
        g3.set("Type", Name.get("StructTreeRoot"));
        const c3 = t3.getNewTemporaryRef();
        g3.set("ParentTree", c3);
        const C3 = [];
        g3.set("K", C3);
        n3.put(o3, g3);
        const h2 = new Dict(t3), l3 = [];
        h2.set("Nums", l3);
        const Q3 = await __privateMethod(this, _G, G_fn).call(this, { newAnnotationsByPage: e3, structTreeRootRef: o3, kids: C3, nums: l3, xref: t3, pdfManager: a3, cache: n3 });
        g3.set("ParentTreeNextKey", Q3);
        n3.put(c3, h2);
        const E3 = [];
        for (const [e4, i4] of n3.items()) {
          E3.length = 0;
          await writeObject(e4, i4, E3, t3);
          s3.push({ ref: e4, data: E3.join("") });
        }
      }
      async canUpdateStructTree({ pdfManager: e3, xref: t3, newAnnotationsByPage: i3 }) {
        var _a3, _b2;
        if (!this.ref) {
          warn("Cannot update the struct tree: no root reference.");
          return false;
        }
        let a3 = this.dict.get("ParentTreeNextKey");
        if (!Number.isInteger(a3) || a3 < 0) {
          warn("Cannot update the struct tree: invalid next key.");
          return false;
        }
        const s3 = this.dict.get("ParentTree");
        if (!(s3 instanceof Dict)) {
          warn("Cannot update the struct tree: ParentTree isn't a dict.");
          return false;
        }
        const r3 = s3.get("Nums");
        if (!Array.isArray(r3)) {
          warn("Cannot update the struct tree: nums isn't an array.");
          return false;
        }
        const n3 = new NumberTree(s3, t3);
        for (const t4 of i3.keys()) {
          const { pageDict: i4 } = await e3.getPage(t4);
          if (!i4.has("StructParents"))
            continue;
          const a4 = i4.get("StructParents");
          if (!Number.isInteger(a4) || !Array.isArray(n3.get(a4))) {
            warn(`Cannot save the struct tree: page ${t4} has a wrong id.`);
            return false;
          }
        }
        let o3 = true;
        for (const [t4, s4] of i3) {
          const { pageDict: i4 } = await e3.getPage(t4);
          __privateMethod(_a3 = _StructTreeRoot, _x, x_fn).call(_a3, { elements: s4, xref: this.dict.xref, pageDict: i4, numberTree: n3 });
          for (const e4 of s4)
            if ((_b2 = e4.accessibilityData) == null ? void 0 : _b2.type) {
              e4.parentTreeId = a3++;
              o3 = false;
            }
        }
        if (o3) {
          for (const e4 of i3.values())
            for (const t4 of e4) {
              delete t4.parentTreeId;
              delete t4.structTreeParent;
            }
          return false;
        }
        return true;
      }
      async updateStructureTree({ newAnnotationsByPage: e3, pdfManager: t3, newRefs: i3 }) {
        var _a3;
        const a3 = this.dict.xref, s3 = this.dict.clone(), r3 = this.ref, n3 = new RefSetCache();
        n3.put(r3, s3);
        let o3, g3 = s3.getRaw("ParentTree");
        if (g3 instanceof Ref)
          o3 = a3.fetch(g3);
        else {
          o3 = g3;
          g3 = a3.getNewTemporaryRef();
          s3.set("ParentTree", g3);
        }
        o3 = o3.clone();
        n3.put(g3, o3);
        let c3 = o3.getRaw("Nums"), C3 = null;
        if (c3 instanceof Ref) {
          C3 = c3;
          c3 = a3.fetch(C3);
        }
        c3 = c3.slice();
        C3 || o3.set("Nums", c3);
        const h2 = await __privateMethod(_a3 = _StructTreeRoot, _G, G_fn).call(_a3, { newAnnotationsByPage: e3, structTreeRootRef: r3, kids: null, nums: c3, xref: a3, pdfManager: t3, cache: n3 });
        s3.set("ParentTreeNextKey", h2);
        C3 && n3.put(C3, c3);
        const l3 = [];
        for (const [e4, t4] of n3.items()) {
          l3.length = 0;
          await writeObject(e4, t4, l3, a3);
          i3.push({ ref: e4, data: l3.join("") });
        }
      }
    };
    _R = new WeakSet();
    R_fn = function(e3, t3, i3) {
      if (!(e3 instanceof Ref) || t3 < 0)
        return;
      this.structParentIds || (this.structParentIds = new RefSetCache());
      let a3 = this.structParentIds.get(e3);
      if (!a3) {
        a3 = [];
        this.structParentIds.put(e3, a3);
      }
      a3.push([t3, i3]);
    };
    _G = new WeakSet();
    G_fn = async function({ newAnnotationsByPage: e3, structTreeRootRef: t3, kids: i3, nums: a3, xref: s3, pdfManager: r3, cache: n3 }) {
      const o3 = Name.get("OBJR");
      let g3 = -1 / 0;
      for (const [c3, C3] of e3) {
        const { ref: e4 } = await r3.getPage(c3), h2 = e4 instanceof Ref;
        for (const { accessibilityData: r4, ref: c4, parentTreeId: l3, structTreeParent: Q3 } of C3) {
          if (!(r4 == null ? void 0 : r4.type))
            continue;
          const { type: C4, title: E3, lang: u3, alt: d3, expanded: f2, actualText: p2 } = r4;
          g3 = Math.max(g3, l3);
          const m3 = s3.getNewTemporaryRef(), y3 = new Dict(s3);
          y3.set("S", Name.get(C4));
          E3 && y3.set("T", E3);
          u3 && y3.set("Lang", u3);
          d3 && y3.set("Alt", d3);
          f2 && y3.set("E", f2);
          p2 && y3.set("ActualText", p2);
          await __privateMethod(this, _U, U_fn).call(this, { structTreeParent: Q3, tagDict: y3, newTagRef: m3, structTreeRootRef: t3, fallbackKids: i3, xref: s3, cache: n3 });
          const w3 = new Dict(s3);
          y3.set("K", w3);
          w3.set("Type", o3);
          h2 && w3.set("Pg", e4);
          w3.set("Obj", c4);
          n3.put(m3, y3);
          a3.push(l3, m3);
        }
      }
      return g3 + 1;
    };
    _x = new WeakSet();
    x_fn = function({ elements: e3, xref: t3, pageDict: i3, numberTree: a3 }) {
      const s3 = /* @__PURE__ */ new Map();
      for (const t4 of e3)
        if (t4.structTreeParentId) {
          const e4 = parseInt(t4.structTreeParentId.split("_mc")[1], 10);
          let i4 = s3.get(e4);
          if (!i4) {
            i4 = [];
            s3.set(e4, i4);
          }
          i4.push(t4);
        }
      const r3 = i3.get("StructParents");
      if (!Number.isInteger(r3))
        return;
      const n3 = a3.get(r3), updateElement = (e4, i4, a4) => {
        const r4 = s3.get(e4);
        if (r4) {
          const e5 = i4.getRaw("P"), s4 = t3.fetchIfRef(e5);
          if (e5 instanceof Ref && s4 instanceof Dict) {
            const e6 = { ref: a4, dict: i4 };
            for (const t4 of r4)
              t4.structTreeParent = e6;
          }
          return true;
        }
        return false;
      };
      for (const e4 of n3) {
        if (!(e4 instanceof Ref))
          continue;
        const i4 = t3.fetch(e4), a4 = i4.get("K");
        if (Number.isInteger(a4))
          updateElement(a4, i4, e4);
        else if (Array.isArray(a4))
          for (let s4 of a4) {
            s4 = t3.fetchIfRef(s4);
            if (Number.isInteger(s4) && updateElement(s4, i4, e4))
              break;
            if (!(s4 instanceof Dict))
              continue;
            if (!isName(s4.get("Type"), "MCR"))
              break;
            const a5 = s4.get("MCID");
            if (Number.isInteger(a5) && updateElement(a5, i4, e4))
              break;
          }
      }
    };
    _U = new WeakSet();
    U_fn = async function({ structTreeParent: e3, tagDict: t3, newTagRef: i3, structTreeRootRef: a3, fallbackKids: s3, xref: r3, cache: n3 }) {
      let o3, g3 = null;
      if (e3) {
        ({ ref: g3 } = e3);
        o3 = e3.dict.getRaw("P") || a3;
      } else
        o3 = a3;
      t3.set("P", o3);
      const c3 = r3.fetchIfRef(o3);
      if (!c3) {
        s3.push(i3);
        return;
      }
      let C3 = n3.get(o3);
      if (!C3) {
        C3 = c3.clone();
        n3.put(o3, C3);
      }
      const h2 = C3.getRaw("K");
      let l3 = h2 instanceof Ref ? n3.get(h2) : null;
      if (!l3) {
        l3 = r3.fetchIfRef(h2);
        l3 = Array.isArray(l3) ? l3.slice() : [h2];
        const e4 = r3.getNewTemporaryRef();
        C3.set("K", e4);
        n3.put(e4, l3);
      }
      const Q3 = l3.indexOf(g3);
      l3.splice(Q3 >= 0 ? Q3 + 1 : l3.length, 0, i3);
    };
    __privateAdd(_StructTreeRoot, _G);
    __privateAdd(_StructTreeRoot, _x);
    __privateAdd(_StructTreeRoot, _U);
    StructTreeRoot = _StructTreeRoot;
    StructElementNode = class {
      constructor(e3, t3) {
        this.tree = e3;
        this.dict = t3;
        this.kids = [];
        this.parseKids();
      }
      get role() {
        const e3 = this.dict.get("S"), t3 = e3 instanceof Name ? e3.name : "", { root: i3 } = this.tree;
        return i3.roleMap.has(t3) ? i3.roleMap.get(t3) : t3;
      }
      parseKids() {
        let e3 = null;
        const t3 = this.dict.getRaw("Pg");
        t3 instanceof Ref && (e3 = t3.toString());
        const i3 = this.dict.get("K");
        if (Array.isArray(i3))
          for (const t4 of i3) {
            const i4 = this.parseKid(e3, t4);
            i4 && this.kids.push(i4);
          }
        else {
          const t4 = this.parseKid(e3, i3);
          t4 && this.kids.push(t4);
        }
      }
      parseKid(e3, t3) {
        if (Number.isInteger(t3))
          return this.tree.pageDict.objId !== e3 ? null : new StructElement({ type: vs, mcid: t3, pageObjId: e3 });
        let i3 = null;
        t3 instanceof Ref ? i3 = this.dict.xref.fetch(t3) : t3 instanceof Dict && (i3 = t3);
        if (!i3)
          return null;
        const a3 = i3.getRaw("Pg");
        a3 instanceof Ref && (e3 = a3.toString());
        const s3 = i3.get("Type") instanceof Name ? i3.get("Type").name : null;
        if ("MCR" === s3) {
          if (this.tree.pageDict.objId !== e3)
            return null;
          const t4 = i3.getRaw("Stm");
          return new StructElement({ type: Ks, refObjId: t4 instanceof Ref ? t4.toString() : null, pageObjId: e3, mcid: i3.get("MCID") });
        }
        if ("OBJR" === s3) {
          if (this.tree.pageDict.objId !== e3)
            return null;
          const t4 = i3.getRaw("Obj");
          return new StructElement({ type: Ts, refObjId: t4 instanceof Ref ? t4.toString() : null, pageObjId: e3 });
        }
        return new StructElement({ type: Os, dict: i3 });
      }
    };
    StructElement = class {
      constructor({ type: e3, dict: t3 = null, mcid: i3 = null, pageObjId: a3 = null, refObjId: s3 = null }) {
        this.type = e3;
        this.dict = t3;
        this.mcid = i3;
        this.pageObjId = a3;
        this.refObjId = s3;
        this.parentNode = null;
      }
    };
    StructTreePage = class {
      constructor(e3, t3) {
        this.root = e3;
        this.rootDict = e3 ? e3.dict : null;
        this.pageDict = t3;
        this.nodes = [];
      }
      parse(e3) {
        var _a3, _b2;
        if (!this.root || !this.rootDict)
          return;
        const t3 = this.rootDict.get("ParentTree");
        if (!t3)
          return;
        const i3 = this.pageDict.get("StructParents"), a3 = e3 instanceof Ref && ((_a3 = this.root.structParentIds) == null ? void 0 : _a3.get(e3));
        if (!Number.isInteger(i3) && !a3)
          return;
        const s3 = /* @__PURE__ */ new Map(), r3 = new NumberTree(t3, this.rootDict.xref);
        if (Number.isInteger(i3)) {
          const e4 = r3.get(i3);
          if (Array.isArray(e4))
            for (const t4 of e4)
              t4 instanceof Ref && this.addNode(this.rootDict.xref.fetch(t4), s3);
        }
        if (a3)
          for (const [e4, t4] of a3) {
            const i4 = r3.get(e4);
            if (i4) {
              const e5 = this.addNode(this.rootDict.xref.fetchIfRef(i4), s3);
              1 === ((_b2 = e5 == null ? void 0 : e5.kids) == null ? void 0 : _b2.length) && e5.kids[0].type === Ts && (e5.kids[0].type = t4);
            }
          }
      }
      addNode(e3, t3, i3 = 0) {
        if (i3 > 40) {
          warn("StructTree MAX_DEPTH reached.");
          return null;
        }
        if (t3.has(e3))
          return t3.get(e3);
        const a3 = new StructElementNode(this, e3);
        t3.set(e3, a3);
        const s3 = e3.get("P");
        if (!s3 || isName(s3.get("Type"), "StructTreeRoot")) {
          this.addTopLevelNode(e3, a3) || t3.delete(e3);
          return a3;
        }
        const r3 = this.addNode(s3, t3, i3 + 1);
        if (!r3)
          return a3;
        let n3 = false;
        for (const t4 of r3.kids)
          if (t4.type === Os && t4.dict === e3) {
            t4.parentNode = a3;
            n3 = true;
          }
        n3 || t3.delete(e3);
        return a3;
      }
      addTopLevelNode(e3, t3) {
        const i3 = this.rootDict.get("K");
        if (!i3)
          return false;
        if (i3 instanceof Dict) {
          if (i3.objId !== e3.objId)
            return false;
          this.nodes[0] = t3;
          return true;
        }
        if (!Array.isArray(i3))
          return true;
        let a3 = false;
        for (let s3 = 0; s3 < i3.length; s3++) {
          const r3 = i3[s3];
          if ((r3 == null ? void 0 : r3.toString()) === e3.objId) {
            this.nodes[s3] = t3;
            a3 = true;
          }
        }
        return a3;
      }
      get serializable() {
        function nodeToSerializable(e4, t3, i3 = 0) {
          if (i3 > 40) {
            warn("StructTree too deep to be fully serialized.");
            return;
          }
          const a3 = /* @__PURE__ */ Object.create(null);
          a3.role = e4.role;
          a3.children = [];
          t3.children.push(a3);
          const s3 = e4.dict.get("Alt");
          "string" == typeof s3 && (a3.alt = stringToPDFString(s3));
          const r3 = e4.dict.get("Lang");
          "string" == typeof r3 && (a3.lang = stringToPDFString(r3));
          for (const t4 of e4.kids) {
            const e5 = t4.type === Os ? t4.parentNode : null;
            e5 ? nodeToSerializable(e5, a3, i3 + 1) : t4.type === vs || t4.type === Ks ? a3.children.push({ type: "content", id: `p${t4.pageObjId}_mc${t4.mcid}` }) : t4.type === Ts ? a3.children.push({ type: "object", id: t4.refObjId }) : t4.type === qs && a3.children.push({ type: "annotation", id: `pdfjs_internal_id_${t4.refObjId}` });
          }
        }
        const e3 = /* @__PURE__ */ Object.create(null);
        e3.children = [];
        e3.role = "Root";
        for (const t3 of this.nodes)
          t3 && nodeToSerializable(t3, e3);
        return e3;
      }
    };
    _Catalog = class _Catalog {
      constructor(e3, t3) {
        __privateAdd(this, _M);
        __privateAdd(this, _L);
        this.pdfManager = e3;
        this.xref = t3;
        this._catDict = t3.getCatalogObj();
        if (!(this._catDict instanceof Dict))
          throw new FormatError("Catalog object is not a dictionary.");
        this.toplevelPagesDict;
        this._actualNumPages = null;
        this.fontCache = new RefSetCache();
        this.builtInCMapCache = /* @__PURE__ */ new Map();
        this.standardFontDataCache = /* @__PURE__ */ new Map();
        this.globalImageCache = new GlobalImageCache();
        this.pageKidsCountCache = new RefSetCache();
        this.pageIndexCache = new RefSetCache();
        this.nonBlendModesSet = new RefSet();
        this.systemFontCache = /* @__PURE__ */ new Map();
      }
      cloneDict() {
        return this._catDict.clone();
      }
      get version() {
        const e3 = this._catDict.get("Version");
        if (e3 instanceof Name) {
          if (Dt.test(e3.name))
            return shadow(this, "version", e3.name);
          warn(`Invalid PDF catalog version: ${e3.name}`);
        }
        return shadow(this, "version", null);
      }
      get lang() {
        const e3 = this._catDict.get("Lang");
        return shadow(this, "lang", "string" == typeof e3 ? stringToPDFString(e3) : null);
      }
      get needsRendering() {
        const e3 = this._catDict.get("NeedsRendering");
        return shadow(this, "needsRendering", "boolean" == typeof e3 && e3);
      }
      get collection() {
        let e3 = null;
        try {
          const t3 = this._catDict.get("Collection");
          t3 instanceof Dict && t3.size > 0 && (e3 = t3);
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          info("Cannot fetch Collection entry; assuming no collection is present.");
        }
        return shadow(this, "collection", e3);
      }
      get acroForm() {
        let e3 = null;
        try {
          const t3 = this._catDict.get("AcroForm");
          t3 instanceof Dict && t3.size > 0 && (e3 = t3);
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          info("Cannot fetch AcroForm entry; assuming no forms are present.");
        }
        return shadow(this, "acroForm", e3);
      }
      get acroFormRef() {
        const e3 = this._catDict.getRaw("AcroForm");
        return shadow(this, "acroFormRef", e3 instanceof Ref ? e3 : null);
      }
      get metadata() {
        var _a3;
        const e3 = this._catDict.getRaw("Metadata");
        if (!(e3 instanceof Ref))
          return shadow(this, "metadata", null);
        let t3 = null;
        try {
          const i3 = this.xref.fetch(e3, !((_a3 = this.xref.encrypt) == null ? void 0 : _a3.encryptMetadata));
          if (i3 instanceof BaseStream && i3.dict instanceof Dict) {
            const e4 = i3.dict.get("Type"), a3 = i3.dict.get("Subtype");
            if (isName(e4, "Metadata") && isName(a3, "XML")) {
              const e5 = stringToUTF8String(i3.getString());
              e5 && (t3 = new MetadataParser(e5).serializable);
            }
          }
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          info(`Skipping invalid Metadata: "${e4}".`);
        }
        return shadow(this, "metadata", t3);
      }
      get markInfo() {
        let e3 = null;
        try {
          e3 = this._readMarkInfo();
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn("Unable to read mark info.");
        }
        return shadow(this, "markInfo", e3);
      }
      _readMarkInfo() {
        const e3 = this._catDict.get("MarkInfo");
        if (!(e3 instanceof Dict))
          return null;
        const t3 = { Marked: false, UserProperties: false, Suspects: false };
        for (const i3 in t3) {
          const a3 = e3.get(i3);
          "boolean" == typeof a3 && (t3[i3] = a3);
        }
        return t3;
      }
      get structTreeRoot() {
        let e3 = null;
        try {
          e3 = this._readStructTreeRoot();
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn("Unable read to structTreeRoot info.");
        }
        return shadow(this, "structTreeRoot", e3);
      }
      _readStructTreeRoot() {
        const e3 = this._catDict.getRaw("StructTreeRoot"), t3 = this.xref.fetchIfRef(e3);
        if (!(t3 instanceof Dict))
          return null;
        const i3 = new StructTreeRoot(t3, e3);
        i3.init();
        return i3;
      }
      get toplevelPagesDict() {
        const e3 = this._catDict.get("Pages");
        if (!(e3 instanceof Dict))
          throw new FormatError("Invalid top-level pages dictionary.");
        return shadow(this, "toplevelPagesDict", e3);
      }
      get documentOutline() {
        let e3 = null;
        try {
          e3 = this._readDocumentOutline();
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn("Unable to read document outline.");
        }
        return shadow(this, "documentOutline", e3);
      }
      _readDocumentOutline() {
        let e3 = this._catDict.get("Outlines");
        if (!(e3 instanceof Dict))
          return null;
        e3 = e3.getRaw("First");
        if (!(e3 instanceof Ref))
          return null;
        const t3 = { items: [] }, i3 = [{ obj: e3, parent: t3 }], a3 = new RefSet();
        a3.put(e3);
        const s3 = this.xref, r3 = new Uint8ClampedArray(3);
        for (; i3.length > 0; ) {
          const t4 = i3.shift(), n3 = s3.fetchIfRef(t4.obj);
          if (null === n3)
            continue;
          n3.has("Title") || warn("Invalid outline item encountered.");
          const o3 = { url: null, dest: null, action: null };
          _Catalog.parseDestDictionary({ destDict: n3, resultObj: o3, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
          const g3 = n3.get("Title"), c3 = n3.get("F") || 0, C3 = n3.getArray("C"), h2 = n3.get("Count");
          let l3 = r3;
          !Array.isArray(C3) || 3 !== C3.length || 0 === C3[0] && 0 === C3[1] && 0 === C3[2] || (l3 = ColorSpace.singletons.rgb.getRgb(C3, 0));
          const Q3 = { action: o3.action, attachment: o3.attachment, dest: o3.dest, url: o3.url, unsafeUrl: o3.unsafeUrl, newWindow: o3.newWindow, setOCGState: o3.setOCGState, title: "string" == typeof g3 ? stringToPDFString(g3) : "", color: l3, count: Number.isInteger(h2) ? h2 : void 0, bold: !!(2 & c3), italic: !!(1 & c3), items: [] };
          t4.parent.items.push(Q3);
          e3 = n3.getRaw("First");
          if (e3 instanceof Ref && !a3.has(e3)) {
            i3.push({ obj: e3, parent: Q3 });
            a3.put(e3);
          }
          e3 = n3.getRaw("Next");
          if (e3 instanceof Ref && !a3.has(e3)) {
            i3.push({ obj: e3, parent: t4.parent });
            a3.put(e3);
          }
        }
        return t3.items.length > 0 ? t3.items : null;
      }
      get permissions() {
        let e3 = null;
        try {
          e3 = this._readPermissions();
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn("Unable to read permissions.");
        }
        return shadow(this, "permissions", e3);
      }
      _readPermissions() {
        const e3 = this.xref.trailer.get("Encrypt");
        if (!(e3 instanceof Dict))
          return null;
        let t3 = e3.get("P");
        if ("number" != typeof t3)
          return null;
        t3 += 2 ** 32;
        const i3 = [];
        for (const e4 in m2) {
          const a3 = m2[e4];
          t3 & a3 && i3.push(a3);
        }
        return i3;
      }
      get optionalContentConfig() {
        let e3 = null;
        try {
          const t3 = this._catDict.get("OCProperties");
          if (!t3)
            return shadow(this, "optionalContentConfig", null);
          const i3 = t3.get("D");
          if (!i3)
            return shadow(this, "optionalContentConfig", null);
          const a3 = t3.get("OCGs");
          if (!Array.isArray(a3))
            return shadow(this, "optionalContentConfig", null);
          const s3 = [], r3 = new RefSet();
          for (const e4 of a3)
            if (e4 instanceof Ref && !r3.has(e4)) {
              r3.put(e4);
              s3.push(__privateMethod(this, _M, M_fn).call(this, e4));
            }
          e3 = __privateMethod(this, _L, L_fn).call(this, i3, r3);
          e3.groups = s3;
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn(`Unable to read optional content config: ${e4}`);
        }
        return shadow(this, "optionalContentConfig", e3);
      }
      setActualNumPages(e3 = null) {
        this._actualNumPages = e3;
      }
      get hasActualNumPages() {
        return null !== this._actualNumPages;
      }
      get _pagesCount() {
        const e3 = this.toplevelPagesDict.get("Count");
        if (!Number.isInteger(e3))
          throw new FormatError("Page count in top-level pages dictionary is not an integer.");
        return shadow(this, "_pagesCount", e3);
      }
      get numPages() {
        return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
      }
      get destinations() {
        const e3 = this._readDests(), t3 = /* @__PURE__ */ Object.create(null);
        if (e3 instanceof NameTree)
          for (const [i3, a3] of e3.getAll()) {
            const e4 = fetchDest(a3);
            e4 && (t3[stringToPDFString(i3)] = e4);
          }
        else
          e3 instanceof Dict && e3.forEach(function(e4, i3) {
            const a3 = fetchDest(i3);
            a3 && (t3[e4] = a3);
          });
        return shadow(this, "destinations", t3);
      }
      getDestination(e3) {
        const t3 = this._readDests();
        if (t3 instanceof NameTree) {
          const i3 = fetchDest(t3.get(e3));
          if (i3)
            return i3;
          const a3 = this.destinations[e3];
          if (a3) {
            warn(`Found "${e3}" at an incorrect position in the NameTree.`);
            return a3;
          }
        } else if (t3 instanceof Dict) {
          const i3 = fetchDest(t3.get(e3));
          if (i3)
            return i3;
        }
        return null;
      }
      _readDests() {
        const e3 = this._catDict.get("Names");
        return (e3 == null ? void 0 : e3.has("Dests")) ? new NameTree(e3.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
      }
      get pageLabels() {
        let e3 = null;
        try {
          e3 = this._readPageLabels();
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn("Unable to read page labels.");
        }
        return shadow(this, "pageLabels", e3);
      }
      _readPageLabels() {
        const e3 = this._catDict.getRaw("PageLabels");
        if (!e3)
          return null;
        const t3 = new Array(this.numPages);
        let i3 = null, a3 = "";
        const s3 = new NumberTree(e3, this.xref).getAll();
        let r3 = "", n3 = 1;
        for (let e4 = 0, o3 = this.numPages; e4 < o3; e4++) {
          const o4 = s3.get(e4);
          if (void 0 !== o4) {
            if (!(o4 instanceof Dict))
              throw new FormatError("PageLabel is not a dictionary.");
            if (o4.has("Type") && !isName(o4.get("Type"), "PageLabel"))
              throw new FormatError("Invalid type in PageLabel dictionary.");
            if (o4.has("S")) {
              const e5 = o4.get("S");
              if (!(e5 instanceof Name))
                throw new FormatError("Invalid style in PageLabel dictionary.");
              i3 = e5.name;
            } else
              i3 = null;
            if (o4.has("P")) {
              const e5 = o4.get("P");
              if ("string" != typeof e5)
                throw new FormatError("Invalid prefix in PageLabel dictionary.");
              a3 = stringToPDFString(e5);
            } else
              a3 = "";
            if (o4.has("St")) {
              const e5 = o4.get("St");
              if (!(Number.isInteger(e5) && e5 >= 1))
                throw new FormatError("Invalid start in PageLabel dictionary.");
              n3 = e5;
            } else
              n3 = 1;
          }
          switch (i3) {
            case "D":
              r3 = n3;
              break;
            case "R":
            case "r":
              r3 = toRomanNumerals(n3, "r" === i3);
              break;
            case "A":
            case "a":
              const e5 = 26, t4 = "a" === i3 ? 97 : 65, a4 = n3 - 1;
              r3 = String.fromCharCode(t4 + a4 % e5).repeat(Math.floor(a4 / e5) + 1);
              break;
            default:
              if (i3)
                throw new FormatError(`Invalid style "${i3}" in PageLabel dictionary.`);
              r3 = "";
          }
          t3[e4] = a3 + r3;
          n3++;
        }
        return t3;
      }
      get pageLayout() {
        const e3 = this._catDict.get("PageLayout");
        let t3 = "";
        if (e3 instanceof Name)
          switch (e3.name) {
            case "SinglePage":
            case "OneColumn":
            case "TwoColumnLeft":
            case "TwoColumnRight":
            case "TwoPageLeft":
            case "TwoPageRight":
              t3 = e3.name;
          }
        return shadow(this, "pageLayout", t3);
      }
      get pageMode() {
        const e3 = this._catDict.get("PageMode");
        let t3 = "UseNone";
        if (e3 instanceof Name)
          switch (e3.name) {
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "FullScreen":
            case "UseOC":
            case "UseAttachments":
              t3 = e3.name;
          }
        return shadow(this, "pageMode", t3);
      }
      get viewerPreferences() {
        const e3 = this._catDict.get("ViewerPreferences");
        if (!(e3 instanceof Dict))
          return shadow(this, "viewerPreferences", null);
        let t3 = null;
        for (const i3 of e3.getKeys()) {
          const a3 = e3.get(i3);
          let s3;
          switch (i3) {
            case "HideToolbar":
            case "HideMenubar":
            case "HideWindowUI":
            case "FitWindow":
            case "CenterWindow":
            case "DisplayDocTitle":
            case "PickTrayByPDFSize":
              "boolean" == typeof a3 && (s3 = a3);
              break;
            case "NonFullScreenPageMode":
              if (a3 instanceof Name)
                switch (a3.name) {
                  case "UseNone":
                  case "UseOutlines":
                  case "UseThumbs":
                  case "UseOC":
                    s3 = a3.name;
                    break;
                  default:
                    s3 = "UseNone";
                }
              break;
            case "Direction":
              if (a3 instanceof Name)
                switch (a3.name) {
                  case "L2R":
                  case "R2L":
                    s3 = a3.name;
                    break;
                  default:
                    s3 = "L2R";
                }
              break;
            case "ViewArea":
            case "ViewClip":
            case "PrintArea":
            case "PrintClip":
              if (a3 instanceof Name)
                switch (a3.name) {
                  case "MediaBox":
                  case "CropBox":
                  case "BleedBox":
                  case "TrimBox":
                  case "ArtBox":
                    s3 = a3.name;
                    break;
                  default:
                    s3 = "CropBox";
                }
              break;
            case "PrintScaling":
              if (a3 instanceof Name)
                switch (a3.name) {
                  case "None":
                  case "AppDefault":
                    s3 = a3.name;
                    break;
                  default:
                    s3 = "AppDefault";
                }
              break;
            case "Duplex":
              if (a3 instanceof Name)
                switch (a3.name) {
                  case "Simplex":
                  case "DuplexFlipShortEdge":
                  case "DuplexFlipLongEdge":
                    s3 = a3.name;
                    break;
                  default:
                    s3 = "None";
                }
              break;
            case "PrintPageRange":
              if (Array.isArray(a3) && a3.length % 2 == 0) {
                a3.every((e4, t4, i4) => Number.isInteger(e4) && e4 > 0 && (0 === t4 || e4 >= i4[t4 - 1]) && e4 <= this.numPages) && (s3 = a3);
              }
              break;
            case "NumCopies":
              Number.isInteger(a3) && a3 > 0 && (s3 = a3);
              break;
            default:
              warn(`Ignoring non-standard key in ViewerPreferences: ${i3}.`);
              continue;
          }
          if (void 0 !== s3) {
            t3 || (t3 = /* @__PURE__ */ Object.create(null));
            t3[i3] = s3;
          } else
            warn(`Bad value, for key "${i3}", in ViewerPreferences: ${a3}.`);
        }
        return shadow(this, "viewerPreferences", t3);
      }
      get openAction() {
        const e3 = this._catDict.get("OpenAction"), t3 = /* @__PURE__ */ Object.create(null);
        if (e3 instanceof Dict) {
          const i3 = new Dict(this.xref);
          i3.set("A", e3);
          const a3 = { url: null, dest: null, action: null };
          _Catalog.parseDestDictionary({ destDict: i3, resultObj: a3 });
          Array.isArray(a3.dest) ? t3.dest = a3.dest : a3.action && (t3.action = a3.action);
        } else
          Array.isArray(e3) && (t3.dest = e3);
        return shadow(this, "openAction", objectSize(t3) > 0 ? t3 : null);
      }
      get attachments() {
        const e3 = this._catDict.get("Names");
        let t3 = null;
        if (e3 instanceof Dict && e3.has("EmbeddedFiles")) {
          const i3 = new NameTree(e3.getRaw("EmbeddedFiles"), this.xref);
          for (const [e4, a3] of i3.getAll()) {
            const i4 = new FileSpec(a3, this.xref);
            t3 || (t3 = /* @__PURE__ */ Object.create(null));
            t3[stringToPDFString(e4)] = i4.serializable;
          }
        }
        return shadow(this, "attachments", t3);
      }
      get xfaImages() {
        const e3 = this._catDict.get("Names");
        let t3 = null;
        if (e3 instanceof Dict && e3.has("XFAImages")) {
          const i3 = new NameTree(e3.getRaw("XFAImages"), this.xref);
          for (const [e4, a3] of i3.getAll()) {
            t3 || (t3 = new Dict(this.xref));
            t3.set(stringToPDFString(e4), a3);
          }
        }
        return shadow(this, "xfaImages", t3);
      }
      _collectJavaScript() {
        const e3 = this._catDict.get("Names");
        let t3 = null;
        function appendIfJavaScriptDict(e4, i4) {
          if (!(i4 instanceof Dict))
            return;
          if (!isName(i4.get("S"), "JavaScript"))
            return;
          let a3 = i4.get("JS");
          if (a3 instanceof BaseStream)
            a3 = a3.getString();
          else if ("string" != typeof a3)
            return;
          a3 = stringToPDFString(a3).replaceAll("\0", "");
          a3 && (t3 || (t3 = /* @__PURE__ */ new Map())).set(e4, a3);
        }
        if (e3 instanceof Dict && e3.has("JavaScript")) {
          const t4 = new NameTree(e3.getRaw("JavaScript"), this.xref);
          for (const [e4, i4] of t4.getAll())
            appendIfJavaScriptDict(stringToPDFString(e4), i4);
        }
        const i3 = this._catDict.get("OpenAction");
        i3 && appendIfJavaScriptDict("OpenAction", i3);
        return t3;
      }
      get jsActions() {
        const e3 = this._collectJavaScript();
        let t3 = collectActions(this.xref, this._catDict, dA);
        if (e3) {
          t3 || (t3 = /* @__PURE__ */ Object.create(null));
          for (const [i3, a3] of e3)
            i3 in t3 ? t3[i3].push(a3) : t3[i3] = [a3];
        }
        return shadow(this, "jsActions", t3);
      }
      async fontFallback(e3, t3) {
        const i3 = await Promise.all(this.fontCache);
        for (const a3 of i3)
          if (a3.loadedName === e3) {
            a3.fallback(t3);
            return;
          }
      }
      async cleanup(e3 = false) {
        clearGlobalCaches();
        this.globalImageCache.clear(e3);
        this.pageKidsCountCache.clear();
        this.pageIndexCache.clear();
        this.nonBlendModesSet.clear();
        const t3 = await Promise.all(this.fontCache);
        for (const { dict: e4 } of t3)
          delete e4.cacheKey;
        this.fontCache.clear();
        this.builtInCMapCache.clear();
        this.standardFontDataCache.clear();
        this.systemFontCache.clear();
      }
      async getPageDict(e3) {
        const t3 = [this.toplevelPagesDict], i3 = new RefSet(), a3 = this._catDict.getRaw("Pages");
        a3 instanceof Ref && i3.put(a3);
        const s3 = this.xref, r3 = this.pageKidsCountCache, n3 = this.pageIndexCache;
        let o3 = 0;
        for (; t3.length; ) {
          const a4 = t3.pop();
          if (a4 instanceof Ref) {
            const g4 = r3.get(a4);
            if (g4 >= 0 && o3 + g4 <= e3) {
              o3 += g4;
              continue;
            }
            if (i3.has(a4))
              throw new FormatError("Pages tree contains circular reference.");
            i3.put(a4);
            const c4 = await s3.fetchAsync(a4);
            if (c4 instanceof Dict) {
              let t4 = c4.getRaw("Type");
              t4 instanceof Ref && (t4 = await s3.fetchAsync(t4));
              if (isName(t4, "Page") || !c4.has("Kids")) {
                r3.has(a4) || r3.put(a4, 1);
                n3.has(a4) || n3.put(a4, o3);
                if (o3 === e3)
                  return [c4, a4];
                o3++;
                continue;
              }
            }
            t3.push(c4);
            continue;
          }
          if (!(a4 instanceof Dict))
            throw new FormatError("Page dictionary kid reference points to wrong type of object.");
          const { objId: g3 } = a4;
          let c3 = a4.getRaw("Count");
          c3 instanceof Ref && (c3 = await s3.fetchAsync(c3));
          if (Number.isInteger(c3) && c3 >= 0) {
            g3 && !r3.has(g3) && r3.put(g3, c3);
            if (o3 + c3 <= e3) {
              o3 += c3;
              continue;
            }
          }
          let C3 = a4.getRaw("Kids");
          C3 instanceof Ref && (C3 = await s3.fetchAsync(C3));
          if (!Array.isArray(C3)) {
            let t4 = a4.getRaw("Type");
            t4 instanceof Ref && (t4 = await s3.fetchAsync(t4));
            if (isName(t4, "Page") || !a4.has("Kids")) {
              if (o3 === e3)
                return [a4, null];
              o3++;
              continue;
            }
            throw new FormatError("Page dictionary kids object is not an array.");
          }
          for (let e4 = C3.length - 1; e4 >= 0; e4--)
            t3.push(C3[e4]);
        }
        throw new Error(`Page index ${e3} not found.`);
      }
      async getAllPageDicts(e3 = false) {
        const { ignoreErrors: t3 } = this.pdfManager.evaluatorOptions, i3 = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], a3 = new RefSet(), s3 = this._catDict.getRaw("Pages");
        s3 instanceof Ref && a3.put(s3);
        const r3 = /* @__PURE__ */ new Map(), n3 = this.xref, o3 = this.pageIndexCache;
        let g3 = 0;
        function addPageDict(e4, t4) {
          t4 && !o3.has(t4) && o3.put(t4, g3);
          r3.set(g3++, [e4, t4]);
        }
        function addPageError(i4) {
          if (i4 instanceof XRefEntryException && !e3)
            throw i4;
          if (e3 && t3 && 0 === g3) {
            warn(`getAllPageDicts - Skipping invalid first page: "${i4}".`);
            i4 = Dict.empty;
          }
          r3.set(g3++, [i4, null]);
        }
        for (; i3.length > 0; ) {
          const e4 = i3.at(-1), { currentNode: t4, posInKids: s4 } = e4;
          let r4 = t4.getRaw("Kids");
          if (r4 instanceof Ref)
            try {
              r4 = await n3.fetchAsync(r4);
            } catch (e5) {
              addPageError(e5);
              break;
            }
          if (!Array.isArray(r4)) {
            addPageError(new FormatError("Page dictionary kids object is not an array."));
            break;
          }
          if (s4 >= r4.length) {
            i3.pop();
            continue;
          }
          const o4 = r4[s4];
          let g4;
          if (o4 instanceof Ref) {
            if (a3.has(o4)) {
              addPageError(new FormatError("Pages tree contains circular reference."));
              break;
            }
            a3.put(o4);
            try {
              g4 = await n3.fetchAsync(o4);
            } catch (e5) {
              addPageError(e5);
              break;
            }
          } else
            g4 = o4;
          if (!(g4 instanceof Dict)) {
            addPageError(new FormatError("Page dictionary kid reference points to wrong type of object."));
            break;
          }
          let c3 = g4.getRaw("Type");
          if (c3 instanceof Ref)
            try {
              c3 = await n3.fetchAsync(c3);
            } catch (e5) {
              addPageError(e5);
              break;
            }
          isName(c3, "Page") || !g4.has("Kids") ? addPageDict(g4, o4 instanceof Ref ? o4 : null) : i3.push({ currentNode: g4, posInKids: 0 });
          e4.posInKids++;
        }
        return r3;
      }
      getPageIndex(e3) {
        const t3 = this.pageIndexCache.get(e3);
        if (void 0 !== t3)
          return Promise.resolve(t3);
        const i3 = this.xref;
        let a3 = 0;
        const next = (t4) => function pagesBeforeRef(t5) {
          let a4, s3 = 0;
          return i3.fetchAsync(t5).then(function(i4) {
            if (isRefsEqual(t5, e3) && !isDict(i4, "Page") && !(i4 instanceof Dict && !i4.has("Type") && i4.has("Contents")))
              throw new FormatError("The reference does not point to a /Page dictionary.");
            if (!i4)
              return null;
            if (!(i4 instanceof Dict))
              throw new FormatError("Node must be a dictionary.");
            a4 = i4.getRaw("Parent");
            return i4.getAsync("Parent");
          }).then(function(e4) {
            if (!e4)
              return null;
            if (!(e4 instanceof Dict))
              throw new FormatError("Parent must be a dictionary.");
            return e4.getAsync("Kids");
          }).then(function(e4) {
            if (!e4)
              return null;
            const r3 = [];
            let n3 = false;
            for (const a5 of e4) {
              if (!(a5 instanceof Ref))
                throw new FormatError("Kid must be a reference.");
              if (isRefsEqual(a5, t5)) {
                n3 = true;
                break;
              }
              r3.push(i3.fetchAsync(a5).then(function(e5) {
                if (!(e5 instanceof Dict))
                  throw new FormatError("Kid node must be a dictionary.");
                e5.has("Count") ? s3 += e5.get("Count") : s3++;
              }));
            }
            if (!n3)
              throw new FormatError("Kid reference not found in parent's kids.");
            return Promise.all(r3).then(function() {
              return [s3, a4];
            });
          });
        }(t4).then((t5) => {
          if (!t5) {
            this.pageIndexCache.put(e3, a3);
            return a3;
          }
          const [i4, s3] = t5;
          a3 += i4;
          return next(s3);
        });
        return next(e3);
      }
      get baseUrl() {
        const e3 = this._catDict.get("URI");
        if (e3 instanceof Dict) {
          const t3 = e3.get("Base");
          if ("string" == typeof t3) {
            const e4 = createValidAbsoluteUrl(t3, null, { tryConvertEncoding: true });
            if (e4)
              return shadow(this, "baseUrl", e4.href);
          }
        }
        return shadow(this, "baseUrl", this.pdfManager.docBaseUrl);
      }
      static parseDestDictionary({ destDict: e3, resultObj: t3, docBaseUrl: i3 = null, docAttachments: a3 = null }) {
        if (!(e3 instanceof Dict)) {
          warn("parseDestDictionary: `destDict` must be a dictionary.");
          return;
        }
        let s3, r3, n3 = e3.get("A");
        if (!(n3 instanceof Dict))
          if (e3.has("Dest"))
            n3 = e3.get("Dest");
          else {
            n3 = e3.get("AA");
            n3 instanceof Dict && (n3.has("D") ? n3 = n3.get("D") : n3.has("U") && (n3 = n3.get("U")));
          }
        if (n3 instanceof Dict) {
          const e4 = n3.get("S");
          if (!(e4 instanceof Name)) {
            warn("parseDestDictionary: Invalid type in Action dictionary.");
            return;
          }
          const i4 = e4.name;
          switch (i4) {
            case "ResetForm":
              const e5 = n3.get("Flags"), o3 = 0 == (1 & ("number" == typeof e5 ? e5 : 0)), g3 = [], c3 = [];
              for (const e6 of n3.get("Fields") || [])
                e6 instanceof Ref ? c3.push(e6.toString()) : "string" == typeof e6 && g3.push(stringToPDFString(e6));
              t3.resetForm = { fields: g3, refs: c3, include: o3 };
              break;
            case "URI":
              s3 = n3.get("URI");
              s3 instanceof Name && (s3 = "/" + s3.name);
              break;
            case "GoTo":
              r3 = n3.get("D");
              break;
            case "Launch":
            case "GoToR":
              const C3 = n3.get("F");
              if (C3 instanceof Dict) {
                const e6 = new FileSpec(C3, null, true), { filename: t4 } = e6.serializable;
                s3 = t4;
              } else
                "string" == typeof C3 && (s3 = C3);
              const h2 = fetchRemoteDest(n3);
              h2 && "string" == typeof s3 && (s3 = s3.split("#", 1)[0] + "#" + h2);
              const l3 = n3.get("NewWindow");
              "boolean" == typeof l3 && (t3.newWindow = l3);
              break;
            case "GoToE":
              const Q3 = n3.get("T");
              let E3;
              if (a3 && Q3 instanceof Dict) {
                const e6 = Q3.get("R"), t4 = Q3.get("N");
                isName(e6, "C") && "string" == typeof t4 && (E3 = a3[stringToPDFString(t4)]);
              }
              if (E3) {
                t3.attachment = E3;
                const e6 = fetchRemoteDest(n3);
                e6 && (t3.attachmentDest = e6);
              } else
                warn('parseDestDictionary - unimplemented "GoToE" action.');
              break;
            case "Named":
              const u3 = n3.get("N");
              u3 instanceof Name && (t3.action = u3.name);
              break;
            case "SetOCGState":
              const d3 = n3.get("State"), f2 = n3.get("PreserveRB");
              if (!Array.isArray(d3) || 0 === d3.length)
                break;
              const p2 = [];
              for (const e6 of d3)
                if (e6 instanceof Name)
                  switch (e6.name) {
                    case "ON":
                    case "OFF":
                    case "Toggle":
                      p2.push(e6.name);
                  }
                else
                  e6 instanceof Ref && p2.push(e6.toString());
              if (p2.length !== d3.length)
                break;
              t3.setOCGState = { state: p2, preserveRB: "boolean" != typeof f2 || f2 };
              break;
            case "JavaScript":
              const m3 = n3.get("JS");
              let y3;
              m3 instanceof BaseStream ? y3 = m3.getString() : "string" == typeof m3 && (y3 = m3);
              const w3 = y3 && recoverJsURL(stringToPDFString(y3));
              if (w3) {
                s3 = w3.url;
                t3.newWindow = w3.newWindow;
                break;
              }
            default:
              if ("JavaScript" === i4 || "SubmitForm" === i4)
                break;
              warn(`parseDestDictionary - unsupported action: "${i4}".`);
          }
        } else
          e3.has("Dest") && (r3 = e3.get("Dest"));
        if ("string" == typeof s3) {
          const e4 = createValidAbsoluteUrl(s3, i3, { addDefaultProtocol: true, tryConvertEncoding: true });
          e4 && (t3.url = e4.href);
          t3.unsafeUrl = s3;
        }
        if (r3) {
          r3 instanceof Name && (r3 = r3.name);
          "string" == typeof r3 ? t3.dest = stringToPDFString(r3) : isValidExplicitDest(r3) && (t3.dest = r3);
        }
      }
    };
    _M = new WeakSet();
    M_fn = function(e3) {
      const t3 = this.xref.fetch(e3), i3 = { id: e3.toString(), name: null, intent: null, usage: { print: null, view: null } }, a3 = t3.get("Name");
      "string" == typeof a3 && (i3.name = stringToPDFString(a3));
      let s3 = t3.getArray("Intent");
      Array.isArray(s3) || (s3 = [s3]);
      s3.every((e4) => e4 instanceof Name) && (i3.intent = s3.map((e4) => e4.name));
      const r3 = t3.get("Usage");
      if (!(r3 instanceof Dict))
        return i3;
      const n3 = i3.usage, o3 = r3.get("Print");
      if (o3 instanceof Dict) {
        const e4 = o3.get("PrintState");
        if (e4 instanceof Name)
          switch (e4.name) {
            case "ON":
            case "OFF":
              n3.print = { printState: e4.name };
          }
      }
      const g3 = r3.get("View");
      if (g3 instanceof Dict) {
        const e4 = g3.get("ViewState");
        if (e4 instanceof Name)
          switch (e4.name) {
            case "ON":
            case "OFF":
              n3.view = { viewState: e4.name };
          }
      }
      return i3;
    };
    _L = new WeakSet();
    L_fn = function(e3, t3) {
      function parseOnOff(e4) {
        const i4 = [];
        if (Array.isArray(e4))
          for (const a4 of e4)
            a4 instanceof Ref && t3.has(a4) && i4.push(a4.toString());
        return i4;
      }
      function parseOrder(e4, i4 = 0) {
        if (!Array.isArray(e4))
          return null;
        const s4 = [];
        for (const r4 of e4) {
          if (r4 instanceof Ref && t3.has(r4)) {
            a3.put(r4);
            s4.push(r4.toString());
            continue;
          }
          const e5 = parseNestedOrder(r4, i4);
          e5 && s4.push(e5);
        }
        if (i4 > 0)
          return s4;
        const r3 = [];
        for (const e5 of t3)
          a3.has(e5) || r3.push(e5.toString());
        r3.length && s4.push({ name: null, order: r3 });
        return s4;
      }
      function parseNestedOrder(e4, t4) {
        if (++t4 > s3) {
          warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");
          return null;
        }
        const a4 = i3.fetchIfRef(e4);
        if (!Array.isArray(a4))
          return null;
        const r3 = i3.fetchIfRef(a4[0]);
        if ("string" != typeof r3)
          return null;
        const n3 = parseOrder(a4.slice(1), t4);
        return n3 && n3.length ? { name: stringToPDFString(r3), order: n3 } : null;
      }
      const i3 = this.xref, a3 = new RefSet(), s3 = 10;
      return { name: "string" == typeof e3.get("Name") ? stringToPDFString(e3.get("Name")) : null, creator: "string" == typeof e3.get("Creator") ? stringToPDFString(e3.get("Creator")) : null, baseState: e3.get("BaseState") instanceof Name ? e3.get("BaseState").name : null, on: parseOnOff(e3.get("ON")), off: parseOnOff(e3.get("OFF")), order: parseOrder(e3.get("Order")), groups: null };
    };
    Catalog = _Catalog;
    ObjectLoader = class {
      constructor(e3, t3, i3) {
        this.dict = e3;
        this.keys = t3;
        this.xref = i3;
        this.refSet = null;
      }
      async load() {
        if (this.xref.stream.isDataLoaded)
          return;
        const { keys: e3, dict: t3 } = this;
        this.refSet = new RefSet();
        const i3 = [];
        for (const a3 of e3) {
          const e4 = t3.getRaw(a3);
          void 0 !== e4 && i3.push(e4);
        }
        return this._walk(i3);
      }
      async _walk(e3) {
        const t3 = [], i3 = [];
        for (; e3.length; ) {
          let a3 = e3.pop();
          if (a3 instanceof Ref) {
            if (this.refSet.has(a3))
              continue;
            try {
              this.refSet.put(a3);
              a3 = this.xref.fetch(a3);
            } catch (e4) {
              if (!(e4 instanceof MissingDataException)) {
                warn(`ObjectLoader._walk - requesting all data: "${e4}".`);
                this.refSet = null;
                const { manager: t4 } = this.xref.stream;
                return t4.requestAllChunks();
              }
              t3.push(a3);
              i3.push({ begin: e4.begin, end: e4.end });
            }
          }
          if (a3 instanceof BaseStream) {
            const e4 = a3.getBaseStreams();
            if (e4) {
              let s3 = false;
              for (const t4 of e4)
                if (!t4.isDataLoaded) {
                  s3 = true;
                  i3.push({ begin: t4.start, end: t4.end });
                }
              s3 && t3.push(a3);
            }
          }
          addChildren(a3, e3);
        }
        if (i3.length) {
          await this.xref.stream.manager.requestRanges(i3);
          for (const e4 of t3)
            e4 instanceof Ref && this.refSet.remove(e4);
          return this._walk(t3);
        }
        this.refSet = null;
      }
    };
    Ws = Symbol();
    js = Symbol();
    Xs = Symbol();
    Zs = Symbol();
    Vs = Symbol();
    zs = Symbol();
    _s2 = Symbol();
    $s = Symbol();
    Ar = Symbol();
    er = Symbol("content");
    tr = Symbol("data");
    ir = Symbol();
    ar = Symbol("extra");
    sr = Symbol();
    rr = Symbol();
    nr = Symbol();
    or = Symbol();
    gr = Symbol();
    Ir = Symbol();
    cr = Symbol();
    Cr = Symbol();
    hr = Symbol();
    lr = Symbol();
    Qr = Symbol();
    Er = Symbol();
    ur = Symbol();
    dr = Symbol();
    fr = Symbol();
    pr = Symbol();
    mr = Symbol();
    yr = Symbol();
    wr = Symbol();
    br = Symbol();
    Dr = Symbol();
    Fr = Symbol();
    Sr = Symbol();
    kr = Symbol();
    Nr = Symbol();
    Rr = Symbol();
    Gr = Symbol();
    xr = Symbol();
    Ur = Symbol();
    Mr = Symbol();
    Lr = Symbol();
    Hr = Symbol();
    Jr = Symbol("namespaceId");
    Yr = Symbol("nodeName");
    vr = Symbol();
    Kr = Symbol();
    Tr = Symbol();
    qr = Symbol();
    Or = Symbol();
    Pr = Symbol();
    Wr = Symbol();
    jr = Symbol();
    Xr = Symbol("root");
    Zr = Symbol();
    Vr = Symbol();
    zr = Symbol();
    _r2 = Symbol();
    $r = Symbol();
    An = Symbol();
    en = Symbol();
    tn = Symbol();
    an = Symbol();
    sn = Symbol();
    rn = Symbol();
    nn = Symbol("uid");
    on = Symbol();
    gn = { config: { id: 0, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (e3) => "http://ns.adobe.com/xdp/pdf/" === e3 }, signature: { id: 6, check: (e3) => "http://www.w3.org/2000/09/xmldsig#" === e3 }, sourceSet: { id: 7, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (e3) => "http://www.w3.org/1999/XSL/Transform" === e3 }, template: { id: 9, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (e3) => "http://ns.adobe.com/xdp/" === e3 }, xfdf: { id: 12, check: (e3) => "http://ns.adobe.com/xfdf/" === e3 }, xhtml: { id: 13, check: (e3) => "http://www.w3.org/1999/xhtml" === e3 }, xmpmeta: { id: 14, check: (e3) => "http://ns.adobe.com/xmpmeta/" === e3 } };
    In = { pt: (e3) => e3, cm: (e3) => e3 / 2.54 * 72, mm: (e3) => e3 / 25.4 * 72, in: (e3) => 72 * e3, px: (e3) => e3 };
    cn = /([+-]?\d+\.?\d*)(.*)/;
    HTMLResult = class _HTMLResult {
      static get FAILURE() {
        return shadow(this, "FAILURE", new _HTMLResult(false, null, null, null));
      }
      static get EMPTY() {
        return shadow(this, "EMPTY", new _HTMLResult(true, null, null, null));
      }
      constructor(e3, t3, i3, a3) {
        this.success = e3;
        this.html = t3;
        this.bbox = i3;
        this.breakNode = a3;
      }
      isBreak() {
        return !!this.breakNode;
      }
      static breakNode(e3) {
        return new _HTMLResult(false, null, null, e3);
      }
      static success(e3, t3 = null) {
        return new _HTMLResult(true, e3, t3, null);
      }
    };
    FontFinder = class {
      constructor(e3) {
        this.fonts = /* @__PURE__ */ new Map();
        this.cache = /* @__PURE__ */ new Map();
        this.warned = /* @__PURE__ */ new Set();
        this.defaultFont = null;
        this.add(e3);
      }
      add(e3, t3 = null) {
        for (const t4 of e3)
          this.addPdfFont(t4);
        for (const e4 of this.fonts.values())
          e4.regular || (e4.regular = e4.italic || e4.bold || e4.bolditalic);
        if (!t3 || 0 === t3.size)
          return;
        const i3 = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
        for (const e4 of t3)
          this.fonts.set(e4, i3);
      }
      addPdfFont(e3) {
        var _a3, _b2, _c2;
        const t3 = e3.cssFontInfo, i3 = t3.fontFamily;
        let a3 = this.fonts.get(i3);
        if (!a3) {
          a3 = /* @__PURE__ */ Object.create(null);
          this.fonts.set(i3, a3);
          this.defaultFont || (this.defaultFont = a3);
        }
        let s3 = "";
        const r3 = parseFloat(t3.fontWeight);
        0 !== parseFloat(t3.italicAngle) ? s3 = r3 >= 700 ? "bolditalic" : "italic" : r3 >= 700 && (s3 = "bold");
        if (!s3) {
          (e3.name.includes("Bold") || ((_a3 = e3.psName) == null ? void 0 : _a3.includes("Bold"))) && (s3 = "bold");
          (e3.name.includes("Italic") || e3.name.endsWith("It") || ((_b2 = e3.psName) == null ? void 0 : _b2.includes("Italic")) || ((_c2 = e3.psName) == null ? void 0 : _c2.endsWith("It"))) && (s3 += "italic");
        }
        s3 || (s3 = "regular");
        a3[s3] = e3;
      }
      getDefault() {
        return this.defaultFont;
      }
      find(e3, t3 = true) {
        var _a3, _b2;
        let i3 = this.fonts.get(e3) || this.cache.get(e3);
        if (i3)
          return i3;
        const a3 = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
        let s3 = e3.replaceAll(a3, "");
        i3 = this.fonts.get(s3);
        if (i3) {
          this.cache.set(e3, i3);
          return i3;
        }
        s3 = s3.toLowerCase();
        const r3 = [];
        for (const [e4, t4] of this.fonts.entries())
          e4.replaceAll(a3, "").toLowerCase().startsWith(s3) && r3.push(t4);
        if (0 === r3.length)
          for (const [, e4] of this.fonts.entries())
            ((_a3 = e4.regular.name) == null ? void 0 : _a3.replaceAll(a3, "").toLowerCase().startsWith(s3)) && r3.push(e4);
        if (0 === r3.length) {
          s3 = s3.replaceAll(/psmt|mt/gi, "");
          for (const [e4, t4] of this.fonts.entries())
            e4.replaceAll(a3, "").toLowerCase().startsWith(s3) && r3.push(t4);
        }
        if (0 === r3.length)
          for (const e4 of this.fonts.values())
            ((_b2 = e4.regular.name) == null ? void 0 : _b2.replaceAll(a3, "").toLowerCase().startsWith(s3)) && r3.push(e4);
        if (r3.length >= 1) {
          1 !== r3.length && t3 && warn(`XFA - Too many choices to guess the correct font: ${e3}`);
          this.cache.set(e3, r3[0]);
          return r3[0];
        }
        if (t3 && !this.warned.has(e3)) {
          this.warned.add(e3);
          warn(`XFA - Cannot find the font: ${e3}`);
        }
        return null;
      }
    };
    FontInfo = class {
      constructor(e3, t3, i3, a3) {
        this.lineHeight = i3;
        this.paraMargin = t3 || { top: 0, bottom: 0, left: 0, right: 0 };
        if (!e3) {
          [this.pdfFont, this.xfaFont] = this.defaultFont(a3);
          return;
        }
        this.xfaFont = { typeface: e3.typeface, posture: e3.posture, weight: e3.weight, size: e3.size, letterSpacing: e3.letterSpacing };
        const s3 = a3.find(e3.typeface);
        if (s3) {
          this.pdfFont = selectFont(e3, s3);
          this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(a3));
        } else
          [this.pdfFont, this.xfaFont] = this.defaultFont(a3);
      }
      defaultFont(e3) {
        const t3 = e3.find("Helvetica", false) || e3.find("Myriad Pro", false) || e3.find("Arial", false) || e3.getDefault();
        if (t3 == null ? void 0 : t3.regular) {
          const e4 = t3.regular;
          return [e4, { typeface: e4.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
        }
        return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
      }
    };
    FontSelector = class {
      constructor(e3, t3, i3, a3) {
        this.fontFinder = a3;
        this.stack = [new FontInfo(e3, t3, i3, a3)];
      }
      pushData(e3, t3, i3) {
        const a3 = this.stack.at(-1);
        for (const t4 of ["typeface", "posture", "weight", "size", "letterSpacing"])
          e3[t4] || (e3[t4] = a3.xfaFont[t4]);
        for (const e4 of ["top", "bottom", "left", "right"])
          isNaN(t3[e4]) && (t3[e4] = a3.paraMargin[e4]);
        const s3 = new FontInfo(e3, t3, i3 || a3.lineHeight, this.fontFinder);
        s3.pdfFont || (s3.pdfFont = a3.pdfFont);
        this.stack.push(s3);
      }
      popFont() {
        this.stack.pop();
      }
      topFont() {
        return this.stack.at(-1);
      }
    };
    TextMeasure = class {
      constructor(e3, t3, i3, a3) {
        this.glyphs = [];
        this.fontSelector = new FontSelector(e3, t3, i3, a3);
        this.extraHeight = 0;
      }
      pushData(e3, t3, i3) {
        this.fontSelector.pushData(e3, t3, i3);
      }
      popFont(e3) {
        return this.fontSelector.popFont();
      }
      addPara() {
        const e3 = this.fontSelector.topFont();
        this.extraHeight += e3.paraMargin.top + e3.paraMargin.bottom;
      }
      addString(e3) {
        if (!e3)
          return;
        const t3 = this.fontSelector.topFont(), i3 = t3.xfaFont.size;
        if (t3.pdfFont) {
          const a3 = t3.xfaFont.letterSpacing, s3 = t3.pdfFont, r3 = s3.lineHeight || 1.2, n3 = t3.lineHeight || Math.max(1.2, r3) * i3, o3 = r3 - (void 0 === s3.lineGap ? 0.2 : s3.lineGap), g3 = Math.max(1, o3) * i3, c3 = i3 / 1e3, C3 = s3.defaultWidth || s3.charsToGlyphs(" ")[0].width;
          for (const t4 of e3.split(/[\u2029\n]/)) {
            const e4 = s3.encodeString(t4).join(""), i4 = s3.charsToGlyphs(e4);
            for (const e5 of i4) {
              const t5 = e5.width || C3;
              this.glyphs.push([t5 * c3 + a3, n3, g3, e5.unicode, false]);
            }
            this.glyphs.push([0, 0, 0, "\n", true]);
          }
          this.glyphs.pop();
        } else {
          for (const t4 of e3.split(/[\u2029\n]/)) {
            for (const e4 of t4.split(""))
              this.glyphs.push([i3, 1.2 * i3, i3, e4, false]);
            this.glyphs.push([0, 0, 0, "\n", true]);
          }
          this.glyphs.pop();
        }
      }
      compute(e3) {
        let t3 = -1, i3 = 0, a3 = 0, s3 = 0, r3 = 0, n3 = 0, o3 = false, g3 = true;
        for (let c3 = 0, C3 = this.glyphs.length; c3 < C3; c3++) {
          const [C4, h2, l3, Q3, E3] = this.glyphs[c3], u3 = " " === Q3, d3 = g3 ? l3 : h2;
          if (E3) {
            a3 = Math.max(a3, r3);
            r3 = 0;
            s3 += n3;
            n3 = d3;
            t3 = -1;
            i3 = 0;
            g3 = false;
          } else if (u3)
            if (r3 + C4 > e3) {
              a3 = Math.max(a3, r3);
              r3 = 0;
              s3 += n3;
              n3 = d3;
              t3 = -1;
              i3 = 0;
              o3 = true;
              g3 = false;
            } else {
              n3 = Math.max(d3, n3);
              i3 = r3;
              r3 += C4;
              t3 = c3;
            }
          else if (r3 + C4 > e3) {
            s3 += n3;
            n3 = d3;
            if (-1 !== t3) {
              c3 = t3;
              a3 = Math.max(a3, i3);
              r3 = 0;
              t3 = -1;
              i3 = 0;
            } else {
              a3 = Math.max(a3, r3);
              r3 = C4;
            }
            o3 = true;
            g3 = false;
          } else {
            r3 += C4;
            n3 = Math.max(d3, n3);
          }
        }
        a3 = Math.max(a3, r3);
        s3 += n3 + this.extraHeight;
        return { width: 1.02 * a3, height: s3, isBroken: o3 };
      }
    };
    Cn = /^[^.[]+/;
    hn = /^[^\]]+/;
    ln = { dot: 0, dotDot: 1, dotHash: 2, dotBracket: 3, dotParen: 4 };
    Bn = /* @__PURE__ */ new Map([["$data", (e3, t3) => e3.datasets ? e3.datasets.data : e3], ["$record", (e3, t3) => (e3.datasets ? e3.datasets.data : e3)[Er]()[0]], ["$template", (e3, t3) => e3.template], ["$connectionSet", (e3, t3) => e3.connectionSet], ["$form", (e3, t3) => e3.form], ["$layout", (e3, t3) => e3.layout], ["$host", (e3, t3) => e3.host], ["$dataWindow", (e3, t3) => e3.dataWindow], ["$event", (e3, t3) => e3.event], ["!", (e3, t3) => e3.datasets], ["$xfa", (e3, t3) => e3], ["xfa", (e3, t3) => e3], ["$", (e3, t3) => t3]]);
    Qn = /* @__PURE__ */ new WeakMap();
    En = Symbol();
    un = Symbol();
    dn = Symbol();
    fn = Symbol("_children");
    pn = Symbol();
    mn = Symbol();
    yn = Symbol();
    wn = Symbol();
    bn = Symbol();
    Dn = Symbol();
    Fn = Symbol();
    Sn = Symbol();
    kn = Symbol();
    Nn = Symbol("parent");
    Rn = Symbol();
    Gn = Symbol();
    xn = Symbol();
    Un = 0;
    Mn = gn.datasets.id;
    XFAObject = class _XFAObject {
      constructor(e3, t3, i3 = false) {
        this[Jr] = e3;
        this[Yr] = t3;
        this[Fn] = i3;
        this[Nn] = null;
        this[fn] = [];
        this[nn] = `${t3}${Un++}`;
        this[yr] = null;
      }
      get isXFAObject() {
        return true;
      }
      get isXFAObjectArray() {
        return false;
      }
      createNodes(e3) {
        let t3 = this, i3 = null;
        for (const { name: a3, index: s3 } of e3) {
          for (let e4 = 0, r3 = isFinite(s3) ? s3 : 0; e4 <= r3; e4++) {
            const e5 = t3[Jr] === Mn ? -1 : t3[Jr];
            i3 = new XmlObject(e5, a3);
            t3[Xs](i3);
          }
          t3 = i3;
        }
        return i3;
      }
      [Kr](e3) {
        if (!this[Fn] || !this[Tr](e3))
          return false;
        const t3 = e3[Yr], i3 = this[t3];
        if (!(i3 instanceof XFAObjectArray)) {
          null !== i3 && this[jr](i3);
          this[t3] = e3;
          this[Xs](e3);
          return true;
        }
        if (i3.push(e3)) {
          this[Xs](e3);
          return true;
        }
        let a3 = "";
        this.id ? a3 = ` (id: ${this.id})` : this.name && (a3 = ` (name: ${this.name} ${this.h.value})`);
        warn(`XFA - node "${this[Yr]}"${a3} has already enough "${t3}"!`);
        return false;
      }
      [Tr](e3) {
        return this.hasOwnProperty(e3[Yr]) && e3[Jr] === this[Jr];
      }
      [Gr]() {
        return false;
      }
      [Ws]() {
        return false;
      }
      [Sr]() {
        return false;
      }
      [kr]() {
        return false;
      }
      [Pr]() {
        this.para && this[mr]()[ar].paraStack.pop();
      }
      [Wr]() {
        this[mr]()[ar].paraStack.push(this.para);
      }
      [zr](e3) {
        this.id && this[Jr] === gn.template.id && e3.set(this.id, this);
      }
      [mr]() {
        return this[yr].template;
      }
      [xr]() {
        return false;
      }
      [Ur]() {
        return false;
      }
      [Xs](e3) {
        e3[Nn] = this;
        this[fn].push(e3);
        !e3[yr] && this[yr] && (e3[yr] = this[yr]);
      }
      [jr](e3) {
        const t3 = this[fn].indexOf(e3);
        this[fn].splice(t3, 1);
      }
      [wr]() {
        return this.hasOwnProperty("value");
      }
      [$r](e3) {
      }
      [qr](e3) {
      }
      [sr]() {
      }
      [Vs](e3) {
        delete this[Fn];
        if (this[_s2]) {
          e3.clean(this[_s2]);
          delete this[_s2];
        }
      }
      [Dr](e3) {
        return this[fn].indexOf(e3);
      }
      [Fr](e3, t3) {
        t3[Nn] = this;
        this[fn].splice(e3, 0, t3);
        !t3[yr] && this[yr] && (t3[yr] = this[yr]);
      }
      [Mr]() {
        return !this.name;
      }
      [Hr]() {
        return "";
      }
      [en]() {
        return 0 === this[fn].length ? this[er] : this[fn].map((e3) => e3[en]()).join("");
      }
      get [dn]() {
        const e3 = Object.getPrototypeOf(this);
        if (!e3._attributes) {
          const t3 = e3._attributes = /* @__PURE__ */ new Set();
          for (const e4 of Object.getOwnPropertyNames(this)) {
            if (null === this[e4] || this[e4] instanceof _XFAObject || this[e4] instanceof XFAObjectArray)
              break;
            t3.add(e4);
          }
        }
        return shadow(this, dn, e3._attributes);
      }
      [Rr](e3) {
        let t3 = this;
        for (; t3; ) {
          if (t3 === e3)
            return true;
          t3 = t3[pr]();
        }
        return false;
      }
      [pr]() {
        return this[Nn];
      }
      [fr]() {
        return this[pr]();
      }
      [Er](e3 = null) {
        return e3 ? this[e3] : this[fn];
      }
      [ir]() {
        const e3 = /* @__PURE__ */ Object.create(null);
        this[er] && (e3.$content = this[er]);
        for (const t3 of Object.getOwnPropertyNames(this)) {
          const i3 = this[t3];
          null !== i3 && (i3 instanceof _XFAObject ? e3[t3] = i3[ir]() : i3 instanceof XFAObjectArray ? i3.isEmpty() || (e3[t3] = i3.dump()) : e3[t3] = i3);
        }
        return e3;
      }
      [rn]() {
        return null;
      }
      [an]() {
        return HTMLResult.EMPTY;
      }
      *[ur]() {
        for (const e3 of this[Er]())
          yield e3;
      }
      *[wn](e3, t3) {
        for (const i3 of this[ur]())
          if (!e3 || t3 === e3.has(i3[Yr])) {
            const e4 = this[gr](), t4 = i3[an](e4);
            t4.success || (this[ar].failingNode = i3);
            yield t4;
          }
      }
      [rr]() {
        return null;
      }
      [js](e3, t3) {
        this[ar].children.push(e3);
      }
      [gr]() {
      }
      [Zs]({ filter: e3 = null, include: t3 = true }) {
        if (this[ar].generator) {
          const e4 = this[gr](), t4 = this[ar].failingNode[an](e4);
          if (!t4.success)
            return t4;
          t4.html && this[js](t4.html, t4.bbox);
          delete this[ar].failingNode;
        } else
          this[ar].generator = this[wn](e3, t3);
        for (; ; ) {
          const e4 = this[ar].generator.next();
          if (e4.done)
            break;
          const t4 = e4.value;
          if (!t4.success)
            return t4;
          t4.html && this[js](t4.html, t4.bbox);
        }
        this[ar].generator = null;
        return HTMLResult.EMPTY;
      }
      [_r2](e3) {
        this[Gn] = new Set(Object.keys(e3));
      }
      [Dn](e3) {
        const t3 = this[dn], i3 = this[Gn];
        return [...e3].filter((e4) => t3.has(e4) && !i3.has(e4));
      }
      [Zr](e3, t3 = /* @__PURE__ */ new Set()) {
        for (const i3 of this[fn])
          i3[Rn](e3, t3);
      }
      [Rn](e3, t3) {
        const i3 = this[bn](e3, t3);
        i3 ? this[En](i3, e3, t3) : this[Zr](e3, t3);
      }
      [bn](e3, t3) {
        const { use: i3, usehref: a3 } = this;
        if (!i3 && !a3)
          return null;
        let s3 = null, r3 = null, n3 = null, o3 = i3;
        if (a3) {
          o3 = a3;
          a3.startsWith("#som(") && a3.endsWith(")") ? r3 = a3.slice(5, -1) : a3.startsWith(".#som(") && a3.endsWith(")") ? r3 = a3.slice(6, -1) : a3.startsWith("#") ? n3 = a3.slice(1) : a3.startsWith(".#") && (n3 = a3.slice(2));
        } else
          i3.startsWith("#") ? n3 = i3.slice(1) : r3 = i3;
        this.use = this.usehref = "";
        if (n3)
          s3 = e3.get(n3);
        else {
          s3 = searchNode(e3.get(Xr), this, r3, true, false);
          s3 && (s3 = s3[0]);
        }
        if (!s3) {
          warn(`XFA - Invalid prototype reference: ${o3}.`);
          return null;
        }
        if (s3[Yr] !== this[Yr]) {
          warn(`XFA - Incompatible prototype: ${s3[Yr]} !== ${this[Yr]}.`);
          return null;
        }
        if (t3.has(s3)) {
          warn("XFA - Cycle detected in prototypes use.");
          return null;
        }
        t3.add(s3);
        const g3 = s3[bn](e3, t3);
        g3 && s3[En](g3, e3, t3);
        s3[Zr](e3, t3);
        t3.delete(s3);
        return s3;
      }
      [En](e3, t3, i3) {
        if (i3.has(e3)) {
          warn("XFA - Cycle detected in prototypes use.");
          return;
        }
        !this[er] && e3[er] && (this[er] = e3[er]);
        new Set(i3).add(e3);
        for (const t4 of this[Dn](e3[Gn])) {
          this[t4] = e3[t4];
          this[Gn] && this[Gn].add(t4);
        }
        for (const a3 of Object.getOwnPropertyNames(this)) {
          if (this[dn].has(a3))
            continue;
          const s3 = this[a3], r3 = e3[a3];
          if (s3 instanceof XFAObjectArray) {
            for (const e4 of s3[fn])
              e4[Rn](t3, i3);
            for (let a4 = s3[fn].length, n3 = r3[fn].length; a4 < n3; a4++) {
              const r4 = e3[fn][a4][$s]();
              if (!s3.push(r4))
                break;
              r4[Nn] = this;
              this[fn].push(r4);
              r4[Rn](t3, i3);
            }
          } else if (null === s3) {
            if (null !== r3) {
              const e4 = r3[$s]();
              e4[Nn] = this;
              this[a3] = e4;
              this[fn].push(e4);
              e4[Rn](t3, i3);
            }
          } else {
            s3[Zr](t3, i3);
            r3 && s3[En](r3, t3, i3);
          }
        }
      }
      static [pn](e3) {
        return Array.isArray(e3) ? e3.map((e4) => _XFAObject[pn](e4)) : "object" == typeof e3 && null !== e3 ? Object.assign({}, e3) : e3;
      }
      [$s]() {
        const e3 = Object.create(Object.getPrototypeOf(this));
        for (const t3 of Object.getOwnPropertySymbols(this))
          try {
            e3[t3] = this[t3];
          } catch {
            shadow(e3, t3, this[t3]);
          }
        e3[nn] = `${e3[Yr]}${Un++}`;
        e3[fn] = [];
        for (const t3 of Object.getOwnPropertyNames(this)) {
          if (this[dn].has(t3)) {
            e3[t3] = _XFAObject[pn](this[t3]);
            continue;
          }
          const i3 = this[t3];
          e3[t3] = i3 instanceof XFAObjectArray ? new XFAObjectArray(i3[Sn]) : null;
        }
        for (const t3 of this[fn]) {
          const i3 = t3[Yr], a3 = t3[$s]();
          e3[fn].push(a3);
          a3[Nn] = e3;
          null === e3[i3] ? e3[i3] = a3 : e3[i3][fn].push(a3);
        }
        return e3;
      }
      [Er](e3 = null) {
        return e3 ? this[fn].filter((t3) => t3[Yr] === e3) : this[fn];
      }
      [Ir](e3) {
        return this[e3];
      }
      [cr](e3, t3, i3 = true) {
        return Array.from(this[Cr](e3, t3, i3));
      }
      *[Cr](e3, t3, i3 = true) {
        if ("parent" !== e3) {
          for (const i4 of this[fn]) {
            i4[Yr] === e3 && (yield i4);
            i4.name === e3 && (yield i4);
            (t3 || i4[Mr]()) && (yield* i4[Cr](e3, t3, false));
          }
          i3 && this[dn].has(e3) && (yield new XFAAttribute(this, e3, this[e3]));
        } else
          yield this[Nn];
      }
    };
    XFAObjectArray = class _XFAObjectArray {
      constructor(e3 = 1 / 0) {
        this[Sn] = e3;
        this[fn] = [];
      }
      get isXFAObject() {
        return false;
      }
      get isXFAObjectArray() {
        return true;
      }
      push(e3) {
        if (this[fn].length <= this[Sn]) {
          this[fn].push(e3);
          return true;
        }
        warn(`XFA - node "${e3[Yr]}" accepts no more than ${this[Sn]} children`);
        return false;
      }
      isEmpty() {
        return 0 === this[fn].length;
      }
      dump() {
        return 1 === this[fn].length ? this[fn][0][ir]() : this[fn].map((e3) => e3[ir]());
      }
      [$s]() {
        const e3 = new _XFAObjectArray(this[Sn]);
        e3[fn] = this[fn].map((e4) => e4[$s]());
        return e3;
      }
      get children() {
        return this[fn];
      }
      clear() {
        this[fn].length = 0;
      }
    };
    XFAAttribute = class {
      constructor(e3, t3, i3) {
        this[Nn] = e3;
        this[Yr] = t3;
        this[er] = i3;
        this[Ar] = false;
        this[nn] = "attribute" + Un++;
      }
      [pr]() {
        return this[Nn];
      }
      [Nr]() {
        return true;
      }
      [hr]() {
        return this[er].trim();
      }
      [$r](e3) {
        e3 = e3.value || "";
        this[er] = e3.toString();
      }
      [en]() {
        return this[er];
      }
      [Rr](e3) {
        return this[Nn] === e3 || this[Nn][Rr](e3);
      }
    };
    XmlObject = class _XmlObject extends XFAObject {
      constructor(e3, t3, i3 = {}) {
        super(e3, t3);
        this[er] = "";
        this[mn] = null;
        if ("#text" !== t3) {
          const e4 = /* @__PURE__ */ new Map();
          this[un] = e4;
          for (const [t4, a3] of Object.entries(i3))
            e4.set(t4, new XFAAttribute(this, t4, a3));
          if (i3.hasOwnProperty(vr)) {
            const e5 = i3[vr].xfa.dataNode;
            void 0 !== e5 && ("dataGroup" === e5 ? this[mn] = false : "dataValue" === e5 && (this[mn] = true));
          }
        }
        this[Ar] = false;
      }
      [sn](e3) {
        const t3 = this[Yr];
        if ("#text" === t3) {
          e3.push(encodeToXmlString(this[er]));
          return;
        }
        const i3 = utf8StringToString(t3), a3 = this[Jr] === Mn ? "xfa:" : "";
        e3.push(`<${a3}${i3}`);
        for (const [t4, i4] of this[un].entries()) {
          const a4 = utf8StringToString(t4);
          e3.push(` ${a4}="${encodeToXmlString(i4[er])}"`);
        }
        null !== this[mn] && (this[mn] ? e3.push(' xfa:dataNode="dataValue"') : e3.push(' xfa:dataNode="dataGroup"'));
        if (this[er] || 0 !== this[fn].length) {
          e3.push(">");
          if (this[er])
            "string" == typeof this[er] ? e3.push(encodeToXmlString(this[er])) : this[er][sn](e3);
          else
            for (const t4 of this[fn])
              t4[sn](e3);
          e3.push(`</${a3}${i3}>`);
        } else
          e3.push("/>");
      }
      [Kr](e3) {
        if (this[er]) {
          const e4 = new _XmlObject(this[Jr], "#text");
          this[Xs](e4);
          e4[er] = this[er];
          this[er] = "";
        }
        this[Xs](e3);
        return true;
      }
      [qr](e3) {
        this[er] += e3;
      }
      [sr]() {
        if (this[er] && this[fn].length > 0) {
          const e3 = new _XmlObject(this[Jr], "#text");
          this[Xs](e3);
          e3[er] = this[er];
          delete this[er];
        }
      }
      [an]() {
        return "#text" === this[Yr] ? HTMLResult.success({ name: "#text", value: this[er] }) : HTMLResult.EMPTY;
      }
      [Er](e3 = null) {
        return e3 ? this[fn].filter((t3) => t3[Yr] === e3) : this[fn];
      }
      [or]() {
        return this[un];
      }
      [Ir](e3) {
        const t3 = this[un].get(e3);
        return void 0 !== t3 ? t3 : this[Er](e3);
      }
      *[Cr](e3, t3) {
        const i3 = this[un].get(e3);
        i3 && (yield i3);
        for (const i4 of this[fn]) {
          i4[Yr] === e3 && (yield i4);
          t3 && (yield* i4[Cr](e3, t3));
        }
      }
      *[nr](e3, t3) {
        const i3 = this[un].get(e3);
        !i3 || t3 && i3[Ar] || (yield i3);
        for (const i4 of this[fn])
          yield* i4[nr](e3, t3);
      }
      *[Qr](e3, t3, i3) {
        for (const a3 of this[fn]) {
          a3[Yr] !== e3 || i3 && a3[Ar] || (yield a3);
          t3 && (yield* a3[Qr](e3, t3, i3));
        }
      }
      [Nr]() {
        return null === this[mn] ? 0 === this[fn].length || this[fn][0][Jr] === gn.xhtml.id : this[mn];
      }
      [hr]() {
        return null === this[mn] ? 0 === this[fn].length ? this[er].trim() : this[fn][0][Jr] === gn.xhtml.id ? this[fn][0][en]().trim() : null : this[er].trim();
      }
      [$r](e3) {
        e3 = e3.value || "";
        this[er] = e3.toString();
      }
      [ir](e3 = false) {
        const t3 = /* @__PURE__ */ Object.create(null);
        e3 && (t3.$ns = this[Jr]);
        this[er] && (t3.$content = this[er]);
        t3.$name = this[Yr];
        t3.children = [];
        for (const i3 of this[fn])
          t3.children.push(i3[ir](e3));
        t3.attributes = /* @__PURE__ */ Object.create(null);
        for (const [e4, i3] of this[un])
          t3.attributes[e4] = i3[er];
        return t3;
      }
    };
    ContentObject = class extends XFAObject {
      constructor(e3, t3) {
        super(e3, t3);
        this[er] = "";
      }
      [qr](e3) {
        this[er] += e3;
      }
      [sr]() {
      }
    };
    OptionObject = class extends ContentObject {
      constructor(e3, t3, i3) {
        super(e3, t3);
        this[kn] = i3;
      }
      [sr]() {
        this[er] = getKeyword({ data: this[er], defaultValue: this[kn][0], validate: (e3) => this[kn].includes(e3) });
      }
      [Vs](e3) {
        super[Vs](e3);
        delete this[kn];
      }
    };
    StringObject = class extends ContentObject {
      [sr]() {
        this[er] = this[er].trim();
      }
    };
    IntegerObject = class extends ContentObject {
      constructor(e3, t3, i3, a3) {
        super(e3, t3);
        this[yn] = i3;
        this[xn] = a3;
      }
      [sr]() {
        this[er] = getInteger({ data: this[er], defaultValue: this[yn], validate: this[xn] });
      }
      [Vs](e3) {
        super[Vs](e3);
        delete this[yn];
        delete this[xn];
      }
    };
    Option01 = class extends IntegerObject {
      constructor(e3, t3) {
        super(e3, t3, 0, (e4) => 1 === e4);
      }
    };
    Option10 = class extends IntegerObject {
      constructor(e3, t3) {
        super(e3, t3, 1, (e4) => 0 === e4);
      }
    };
    Ln = { anchorType(e3, t3) {
      const i3 = e3[fr]();
      if (i3 && (!i3.layout || "position" === i3.layout)) {
        "transform" in t3 || (t3.transform = "");
        switch (e3.anchorType) {
          case "bottomCenter":
            t3.transform += "translate(-50%, -100%)";
            break;
          case "bottomLeft":
            t3.transform += "translate(0,-100%)";
            break;
          case "bottomRight":
            t3.transform += "translate(-100%,-100%)";
            break;
          case "middleCenter":
            t3.transform += "translate(-50%,-50%)";
            break;
          case "middleLeft":
            t3.transform += "translate(0,-50%)";
            break;
          case "middleRight":
            t3.transform += "translate(-100%,-50%)";
            break;
          case "topCenter":
            t3.transform += "translate(-50%,0)";
            break;
          case "topRight":
            t3.transform += "translate(-100%,0)";
        }
      }
    }, dimensions(e3, t3) {
      var _a3;
      const i3 = e3[fr]();
      let a3 = e3.w;
      const s3 = e3.h;
      if ((_a3 = i3.layout) == null ? void 0 : _a3.includes("row")) {
        const t4 = i3[ar], s4 = e3.colSpan;
        let r3;
        if (-1 === s4) {
          r3 = t4.columnWidths.slice(t4.currentColumn).reduce((e4, t5) => e4 + t5, 0);
          t4.currentColumn = 0;
        } else {
          r3 = t4.columnWidths.slice(t4.currentColumn, t4.currentColumn + s4).reduce((e4, t5) => e4 + t5, 0);
          t4.currentColumn = (t4.currentColumn + e3.colSpan) % t4.columnWidths.length;
        }
        isNaN(r3) || (a3 = e3.w = r3);
      }
      t3.width = "" !== a3 ? measureToString(a3) : "auto";
      t3.height = "" !== s3 ? measureToString(s3) : "auto";
    }, position(e3, t3) {
      const i3 = e3[fr]();
      if (!(i3 == null ? void 0 : i3.layout) || "position" === i3.layout) {
        t3.position = "absolute";
        t3.left = measureToString(e3.x);
        t3.top = measureToString(e3.y);
      }
    }, rotate(e3, t3) {
      if (e3.rotate) {
        "transform" in t3 || (t3.transform = "");
        t3.transform += `rotate(-${e3.rotate}deg)`;
        t3.transformOrigin = "top left";
      }
    }, presence(e3, t3) {
      switch (e3.presence) {
        case "invisible":
          t3.visibility = "hidden";
          break;
        case "hidden":
        case "inactive":
          t3.display = "none";
      }
    }, hAlign(e3, t3) {
      if ("para" === e3[Yr])
        switch (e3.hAlign) {
          case "justifyAll":
            t3.textAlign = "justify-all";
            break;
          case "radix":
            t3.textAlign = "left";
            break;
          default:
            t3.textAlign = e3.hAlign;
        }
      else
        switch (e3.hAlign) {
          case "left":
            t3.alignSelf = "start";
            break;
          case "center":
            t3.alignSelf = "center";
            break;
          case "right":
            t3.alignSelf = "end";
        }
    }, margin(e3, t3) {
      e3.margin && (t3.margin = e3.margin[rn]().margin);
    } };
    Hn = gn.template.id;
    Jn = "http://www.w3.org/2000/svg";
    Yn = /^H(\d+)$/;
    vn = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
    Kn = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
    AppearanceFilter = class extends StringObject {
      constructor(e3) {
        super(Hn, "appearanceFilter");
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Arc = class extends XFAObject {
      constructor(e3) {
        super(Hn, "arc", true);
        this.circular = getInteger({ data: e3.circular, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.hand = getStringOption(e3.hand, ["even", "left", "right"]);
        this.id = e3.id || "";
        this.startAngle = getFloat({ data: e3.startAngle, defaultValue: 0, validate: (e4) => true });
        this.sweepAngle = getFloat({ data: e3.sweepAngle, defaultValue: 360, validate: (e4) => true });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.edge = null;
        this.fill = null;
      }
      [an]() {
        var _a3;
        const e3 = this.edge || new Edge({}), t3 = e3[rn](), i3 = /* @__PURE__ */ Object.create(null);
        "visible" === ((_a3 = this.fill) == null ? void 0 : _a3.presence) ? Object.assign(i3, this.fill[rn]()) : i3.fill = "transparent";
        i3.strokeWidth = measureToString("visible" === e3.presence ? e3.thickness : 0);
        i3.stroke = t3.color;
        let a3;
        const s3 = { xmlns: Jn, style: { width: "100%", height: "100%", overflow: "visible" } };
        if (360 === this.sweepAngle)
          a3 = { name: "ellipse", attributes: { xmlns: Jn, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: i3 } };
        else {
          const e4 = this.startAngle * Math.PI / 180, t4 = this.sweepAngle * Math.PI / 180, r4 = this.sweepAngle > 180 ? 1 : 0, [n3, o3, g3, c3] = [50 * (1 + Math.cos(e4)), 50 * (1 - Math.sin(e4)), 50 * (1 + Math.cos(e4 + t4)), 50 * (1 - Math.sin(e4 + t4))];
          a3 = { name: "path", attributes: { xmlns: Jn, d: `M ${n3} ${o3} A 50 50 0 ${r4} 0 ${g3} ${c3}`, vectorEffect: "non-scaling-stroke", style: i3 } };
          Object.assign(s3, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
        }
        const r3 = { name: "svg", children: [a3], attributes: s3 };
        if (hasMargin(this[pr]()[pr]()))
          return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [r3] });
        r3.attributes.style.position = "absolute";
        return HTMLResult.success(r3);
      }
    };
    Area = class extends XFAObject {
      constructor(e3) {
        super(Hn, "area", true);
        this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.relevant = getRelevant(e3.relevant);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.x = getMeasurement(e3.x, "0pt");
        this.y = getMeasurement(e3.y, "0pt");
        this.desc = null;
        this.extras = null;
        this.area = new XFAObjectArray();
        this.draw = new XFAObjectArray();
        this.exObject = new XFAObjectArray();
        this.exclGroup = new XFAObjectArray();
        this.field = new XFAObjectArray();
        this.subform = new XFAObjectArray();
        this.subformSet = new XFAObjectArray();
      }
      *[ur]() {
        yield* getContainedChildren(this);
      }
      [Mr]() {
        return true;
      }
      [kr]() {
        return true;
      }
      [js](e3, t3) {
        const [i3, a3, s3, r3] = t3;
        this[ar].width = Math.max(this[ar].width, i3 + s3);
        this[ar].height = Math.max(this[ar].height, a3 + r3);
        this[ar].children.push(e3);
      }
      [gr]() {
        return this[ar].availableSpace;
      }
      [an](e3) {
        const t3 = toStyle(this, "position"), i3 = { style: t3, id: this[nn], class: ["xfaArea"] };
        isPrintOnly(this) && i3.class.push("xfaPrintOnly");
        this.name && (i3.xfaName = this.name);
        const a3 = [];
        this[ar] = { children: a3, width: 0, height: 0, availableSpace: e3 };
        const s3 = this[Zs]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: true });
        if (!s3.success) {
          if (s3.isBreak())
            return s3;
          delete this[ar];
          return HTMLResult.FAILURE;
        }
        t3.width = measureToString(this[ar].width);
        t3.height = measureToString(this[ar].height);
        const r3 = { name: "div", attributes: i3, children: a3 }, n3 = [this.x, this.y, this[ar].width, this[ar].height];
        delete this[ar];
        return HTMLResult.success(r3, n3);
      }
    };
    Assist = class extends XFAObject {
      constructor(e3) {
        super(Hn, "assist", true);
        this.id = e3.id || "";
        this.role = e3.role || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.speak = null;
        this.toolTip = null;
      }
      [an]() {
        var _a3;
        return ((_a3 = this.toolTip) == null ? void 0 : _a3[er]) || null;
      }
    };
    Barcode = class extends XFAObject {
      constructor(e3) {
        super(Hn, "barcode", true);
        this.charEncoding = getKeyword({ data: e3.charEncoding ? e3.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e4) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e4) || e4.match(/iso-8859-\d{2}/) });
        this.checksum = getStringOption(e3.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
        this.dataColumnCount = getInteger({ data: e3.dataColumnCount, defaultValue: -1, validate: (e4) => e4 >= 0 });
        this.dataLength = getInteger({ data: e3.dataLength, defaultValue: -1, validate: (e4) => e4 >= 0 });
        this.dataPrep = getStringOption(e3.dataPrep, ["none", "flateCompress"]);
        this.dataRowCount = getInteger({ data: e3.dataRowCount, defaultValue: -1, validate: (e4) => e4 >= 0 });
        this.endChar = e3.endChar || "";
        this.errorCorrectionLevel = getInteger({ data: e3.errorCorrectionLevel, defaultValue: -1, validate: (e4) => e4 >= 0 && e4 <= 8 });
        this.id = e3.id || "";
        this.moduleHeight = getMeasurement(e3.moduleHeight, "5mm");
        this.moduleWidth = getMeasurement(e3.moduleWidth, "0.25mm");
        this.printCheckDigit = getInteger({ data: e3.printCheckDigit, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.rowColumnRatio = getRatio(e3.rowColumnRatio);
        this.startChar = e3.startChar || "";
        this.textLocation = getStringOption(e3.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
        this.truncate = getInteger({ data: e3.truncate, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.type = getStringOption(e3.type ? e3.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
        this.upsMode = getStringOption(e3.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.wideNarrowRatio = getRatio(e3.wideNarrowRatio);
        this.encrypt = null;
        this.extras = null;
      }
    };
    Bind = class extends XFAObject {
      constructor(e3) {
        super(Hn, "bind", true);
        this.match = getStringOption(e3.match, ["once", "dataRef", "global", "none"]);
        this.ref = e3.ref || "";
        this.picture = null;
      }
    };
    BindItems = class extends XFAObject {
      constructor(e3) {
        super(Hn, "bindItems");
        this.connection = e3.connection || "";
        this.labelRef = e3.labelRef || "";
        this.ref = e3.ref || "";
        this.valueRef = e3.valueRef || "";
      }
    };
    Bookend = class extends XFAObject {
      constructor(e3) {
        super(Hn, "bookend");
        this.id = e3.id || "";
        this.leader = e3.leader || "";
        this.trailer = e3.trailer || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    BooleanElement = class extends Option01 {
      constructor(e3) {
        super(Hn, "boolean");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [an](e3) {
        return valueToHtml(1 === this[er] ? "1" : "0");
      }
    };
    Border = class extends XFAObject {
      constructor(e3) {
        super(Hn, "border", true);
        this.break = getStringOption(e3.break, ["close", "open"]);
        this.hand = getStringOption(e3.hand, ["even", "left", "right"]);
        this.id = e3.id || "";
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.relevant = getRelevant(e3.relevant);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.corner = new XFAObjectArray(4);
        this.edge = new XFAObjectArray(4);
        this.extras = null;
        this.fill = null;
        this.margin = null;
      }
      [lr]() {
        if (!this[ar]) {
          const e3 = this.edge.children.slice();
          if (e3.length < 4) {
            const t4 = e3.at(-1) || new Edge({});
            for (let i4 = e3.length; i4 < 4; i4++)
              e3.push(t4);
          }
          const t3 = e3.map((e4) => e4.thickness), i3 = [0, 0, 0, 0];
          if (this.margin) {
            i3[0] = this.margin.topInset;
            i3[1] = this.margin.rightInset;
            i3[2] = this.margin.bottomInset;
            i3[3] = this.margin.leftInset;
          }
          this[ar] = { widths: t3, insets: i3, edges: e3 };
        }
        return this[ar];
      }
      [rn]() {
        var _a3;
        const { edges: e3 } = this[lr](), t3 = e3.map((e4) => {
          const t4 = e4[rn]();
          t4.color || (t4.color = "#000000");
          return t4;
        }), i3 = /* @__PURE__ */ Object.create(null);
        this.margin && Object.assign(i3, this.margin[rn]());
        "visible" === ((_a3 = this.fill) == null ? void 0 : _a3.presence) && Object.assign(i3, this.fill[rn]());
        if (this.corner.children.some((e4) => 0 !== e4.radius)) {
          const e4 = this.corner.children.map((e5) => e5[rn]());
          if (2 === e4.length || 3 === e4.length) {
            const t4 = e4.at(-1);
            for (let i4 = e4.length; i4 < 4; i4++)
              e4.push(t4);
          }
          i3.borderRadius = e4.map((e5) => e5.radius).join(" ");
        }
        switch (this.presence) {
          case "invisible":
          case "hidden":
            i3.borderStyle = "";
            break;
          case "inactive":
            i3.borderStyle = "none";
            break;
          default:
            i3.borderStyle = t3.map((e4) => e4.style).join(" ");
        }
        i3.borderWidth = t3.map((e4) => e4.width).join(" ");
        i3.borderColor = t3.map((e4) => e4.color).join(" ");
        return i3;
      }
    };
    Break = class extends XFAObject {
      constructor(e3) {
        super(Hn, "break", true);
        this.after = getStringOption(e3.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
        this.afterTarget = e3.afterTarget || "";
        this.before = getStringOption(e3.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
        this.beforeTarget = e3.beforeTarget || "";
        this.bookendLeader = e3.bookendLeader || "";
        this.bookendTrailer = e3.bookendTrailer || "";
        this.id = e3.id || "";
        this.overflowLeader = e3.overflowLeader || "";
        this.overflowTarget = e3.overflowTarget || "";
        this.overflowTrailer = e3.overflowTrailer || "";
        this.startNew = getInteger({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
      }
    };
    BreakAfter = class extends XFAObject {
      constructor(e3) {
        super(Hn, "breakAfter", true);
        this.id = e3.id || "";
        this.leader = e3.leader || "";
        this.startNew = getInteger({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.target = e3.target || "";
        this.targetType = getStringOption(e3.targetType, ["auto", "contentArea", "pageArea"]);
        this.trailer = e3.trailer || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.script = null;
      }
    };
    BreakBefore = class extends XFAObject {
      constructor(e3) {
        super(Hn, "breakBefore", true);
        this.id = e3.id || "";
        this.leader = e3.leader || "";
        this.startNew = getInteger({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.target = e3.target || "";
        this.targetType = getStringOption(e3.targetType, ["auto", "contentArea", "pageArea"]);
        this.trailer = e3.trailer || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.script = null;
      }
      [an](e3) {
        this[ar] = {};
        return HTMLResult.FAILURE;
      }
    };
    Button = class extends XFAObject {
      constructor(e3) {
        super(Hn, "button", true);
        this.highlight = getStringOption(e3.highlight, ["inverted", "none", "outline", "push"]);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
      }
      [an](e3) {
        const t3 = this[pr]()[pr](), i3 = { name: "button", attributes: { id: this[nn], class: ["xfaButton"], style: {} }, children: [] };
        for (const e4 of t3.event.children) {
          if ("click" !== e4.activity || !e4.script)
            continue;
          const t4 = recoverJsURL(e4.script[er]);
          if (!t4)
            continue;
          const a3 = fixURL(t4.url);
          a3 && i3.children.push({ name: "a", attributes: { id: "link" + this[nn], href: a3, newWindow: t4.newWindow, class: ["xfaLink"], style: {} }, children: [] });
        }
        return HTMLResult.success(i3);
      }
    };
    Calculate = class extends XFAObject {
      constructor(e3) {
        super(Hn, "calculate", true);
        this.id = e3.id || "";
        this.override = getStringOption(e3.override, ["disabled", "error", "ignore", "warning"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.message = null;
        this.script = null;
      }
    };
    Caption = class extends XFAObject {
      constructor(e3) {
        super(Hn, "caption", true);
        this.id = e3.id || "";
        this.placement = getStringOption(e3.placement, ["left", "bottom", "inline", "right", "top"]);
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.reserve = Math.ceil(getMeasurement(e3.reserve));
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.font = null;
        this.margin = null;
        this.para = null;
        this.value = null;
      }
      [$r](e3) {
        _setValue(this, e3);
      }
      [lr](e3) {
        if (!this[ar]) {
          let { width: t3, height: i3 } = e3;
          switch (this.placement) {
            case "left":
            case "right":
            case "inline":
              t3 = this.reserve <= 0 ? t3 : this.reserve;
              break;
            case "top":
            case "bottom":
              i3 = this.reserve <= 0 ? i3 : this.reserve;
          }
          this[ar] = layoutNode(this, { width: t3, height: i3 });
        }
        return this[ar];
      }
      [an](e3) {
        if (!this.value)
          return HTMLResult.EMPTY;
        this[Wr]();
        const t3 = this.value[an](e3).html;
        if (!t3) {
          this[Pr]();
          return HTMLResult.EMPTY;
        }
        const i3 = this.reserve;
        if (this.reserve <= 0) {
          const { w: t4, h: i4 } = this[lr](e3);
          switch (this.placement) {
            case "left":
            case "right":
            case "inline":
              this.reserve = t4;
              break;
            case "top":
            case "bottom":
              this.reserve = i4;
          }
        }
        const a3 = [];
        "string" == typeof t3 ? a3.push({ name: "#text", value: t3 }) : a3.push(t3);
        const s3 = toStyle(this, "font", "margin", "visibility");
        switch (this.placement) {
          case "left":
          case "right":
            this.reserve > 0 && (s3.width = measureToString(this.reserve));
            break;
          case "top":
          case "bottom":
            this.reserve > 0 && (s3.height = measureToString(this.reserve));
        }
        setPara(this, null, t3);
        this[Pr]();
        this.reserve = i3;
        return HTMLResult.success({ name: "div", attributes: { style: s3, class: ["xfaCaption"] }, children: a3 });
      }
    };
    Certificate = class extends StringObject {
      constructor(e3) {
        super(Hn, "certificate");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Certificates = class extends XFAObject {
      constructor(e3) {
        super(Hn, "certificates", true);
        this.credentialServerPolicy = getStringOption(e3.credentialServerPolicy, ["optional", "required"]);
        this.id = e3.id || "";
        this.url = e3.url || "";
        this.urlPolicy = e3.urlPolicy || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.encryption = null;
        this.issuers = null;
        this.keyUsage = null;
        this.oids = null;
        this.signing = null;
        this.subjectDNs = null;
      }
    };
    CheckButton = class extends XFAObject {
      constructor(e3) {
        super(Hn, "checkButton", true);
        this.id = e3.id || "";
        this.mark = getStringOption(e3.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
        this.shape = getStringOption(e3.shape, ["square", "round"]);
        this.size = getMeasurement(e3.size, "10pt");
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
      }
      [an](e3) {
        var _a3, _b2, _c2;
        const t3 = toStyle("margin"), i3 = measureToString(this.size);
        t3.width = t3.height = i3;
        let a3, s3, r3;
        const n3 = this[pr]()[pr](), o3 = n3.items.children.length && n3.items.children[0][an]().html || [], g3 = { on: (void 0 !== o3[0] ? o3[0] : "on").toString(), off: (void 0 !== o3[1] ? o3[1] : "off").toString() }, c3 = (((_a3 = n3.value) == null ? void 0 : _a3[en]()) || "off") === g3.on || void 0, C3 = n3[fr](), h2 = n3[nn];
        let l3;
        if (C3 instanceof ExclGroup) {
          r3 = C3[nn];
          a3 = "radio";
          s3 = "xfaRadio";
          l3 = ((_b2 = C3[tr]) == null ? void 0 : _b2[nn]) || C3[nn];
        } else {
          a3 = "checkbox";
          s3 = "xfaCheckbox";
          l3 = ((_c2 = n3[tr]) == null ? void 0 : _c2[nn]) || n3[nn];
        }
        const Q3 = { name: "input", attributes: { class: [s3], style: t3, fieldId: h2, dataId: l3, type: a3, checked: c3, xfaOn: g3.on, xfaOff: g3.off, "aria-label": ariaLabel(n3), "aria-required": false } };
        r3 && (Q3.attributes.name = r3);
        if (isRequired(n3)) {
          Q3.attributes["aria-required"] = true;
          Q3.attributes.required = true;
        }
        return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [Q3] });
      }
    };
    ChoiceList = class extends XFAObject {
      constructor(e3) {
        super(Hn, "choiceList", true);
        this.commitOn = getStringOption(e3.commitOn, ["select", "exit"]);
        this.id = e3.id || "";
        this.open = getStringOption(e3.open, ["userControl", "always", "multiSelect", "onEntry"]);
        this.textEntry = getInteger({ data: e3.textEntry, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
      }
      [an](e3) {
        var _a3, _b2, _c2;
        const t3 = toStyle(this, "border", "margin"), i3 = this[pr]()[pr](), a3 = { fontSize: `calc(${((_a3 = i3.font) == null ? void 0 : _a3.size) || 10}px * var(--scale-factor))` }, s3 = [];
        if (i3.items.children.length > 0) {
          const e4 = i3.items;
          let t4 = 0, r4 = 0;
          if (2 === e4.children.length) {
            t4 = e4.children[0].save;
            r4 = 1 - t4;
          }
          const n3 = e4.children[t4][an]().html, o3 = e4.children[r4][an]().html;
          let g3 = false;
          const c3 = ((_b2 = i3.value) == null ? void 0 : _b2[en]()) || "";
          for (let e5 = 0, t5 = n3.length; e5 < t5; e5++) {
            const t6 = { name: "option", attributes: { value: o3[e5] || n3[e5], style: a3 }, value: n3[e5] };
            o3[e5] === c3 && (t6.attributes.selected = g3 = true);
            s3.push(t6);
          }
          g3 || s3.splice(0, 0, { name: "option", attributes: { hidden: true, selected: true }, value: " " });
        }
        const r3 = { class: ["xfaSelect"], fieldId: i3[nn], dataId: ((_c2 = i3[tr]) == null ? void 0 : _c2[nn]) || i3[nn], style: t3, "aria-label": ariaLabel(i3), "aria-required": false };
        if (isRequired(i3)) {
          r3["aria-required"] = true;
          r3.required = true;
        }
        "multiSelect" === this.open && (r3.multiple = true);
        return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: s3, attributes: r3 }] });
      }
    };
    Color = class extends XFAObject {
      constructor(e3) {
        super(Hn, "color", true);
        this.cSpace = getStringOption(e3.cSpace, ["SRGB"]);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.value = e3.value ? function getColor(e4, t3 = [0, 0, 0]) {
          let [i3, a3, s3] = t3;
          if (!e4)
            return { r: i3, g: a3, b: s3 };
          const r3 = e4.trim().split(/\s*,\s*/).map((e5) => Math.min(Math.max(0, parseInt(e5.trim(), 10)), 255)).map((e5) => isNaN(e5) ? 0 : e5);
          if (r3.length < 3)
            return { r: i3, g: a3, b: s3 };
          [i3, a3, s3] = r3;
          return { r: i3, g: a3, b: s3 };
        }(e3.value) : "";
        this.extras = null;
      }
      [wr]() {
        return false;
      }
      [rn]() {
        return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
      }
    };
    Comb = class extends XFAObject {
      constructor(e3) {
        super(Hn, "comb");
        this.id = e3.id || "";
        this.numberOfCells = getInteger({ data: e3.numberOfCells, defaultValue: 0, validate: (e4) => e4 >= 0 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Connect = class extends XFAObject {
      constructor(e3) {
        super(Hn, "connect", true);
        this.connection = e3.connection || "";
        this.id = e3.id || "";
        this.ref = e3.ref || "";
        this.usage = getStringOption(e3.usage, ["exportAndImport", "exportOnly", "importOnly"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.picture = null;
      }
    };
    ContentArea = class extends XFAObject {
      constructor(e3) {
        super(Hn, "contentArea", true);
        this.h = getMeasurement(e3.h);
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.relevant = getRelevant(e3.relevant);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.w = getMeasurement(e3.w);
        this.x = getMeasurement(e3.x, "0pt");
        this.y = getMeasurement(e3.y, "0pt");
        this.desc = null;
        this.extras = null;
      }
      [an](e3) {
        const t3 = { left: measureToString(this.x), top: measureToString(this.y), width: measureToString(this.w), height: measureToString(this.h) }, i3 = ["xfaContentarea"];
        isPrintOnly(this) && i3.push("xfaPrintOnly");
        return HTMLResult.success({ name: "div", children: [], attributes: { style: t3, class: i3, id: this[nn] } });
      }
    };
    Corner = class extends XFAObject {
      constructor(e3) {
        super(Hn, "corner", true);
        this.id = e3.id || "";
        this.inverted = getInteger({ data: e3.inverted, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.join = getStringOption(e3.join, ["square", "round"]);
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.radius = getMeasurement(e3.radius);
        this.stroke = getStringOption(e3.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
        this.thickness = getMeasurement(e3.thickness, "0.5pt");
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.color = null;
        this.extras = null;
      }
      [rn]() {
        const e3 = toStyle(this, "visibility");
        e3.radius = measureToString("square" === this.join ? 0 : this.radius);
        return e3;
      }
    };
    DateElement = class extends ContentObject {
      constructor(e3) {
        super(Hn, "date");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [sr]() {
        const e3 = this[er].trim();
        this[er] = e3 ? new Date(e3) : null;
      }
      [an](e3) {
        return valueToHtml(this[er] ? this[er].toString() : "");
      }
    };
    DateTime = class extends ContentObject {
      constructor(e3) {
        super(Hn, "dateTime");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [sr]() {
        const e3 = this[er].trim();
        this[er] = e3 ? new Date(e3) : null;
      }
      [an](e3) {
        return valueToHtml(this[er] ? this[er].toString() : "");
      }
    };
    DateTimeEdit = class extends XFAObject {
      constructor(e3) {
        super(Hn, "dateTimeEdit", true);
        this.hScrollPolicy = getStringOption(e3.hScrollPolicy, ["auto", "off", "on"]);
        this.id = e3.id || "";
        this.picker = getStringOption(e3.picker, ["host", "none"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
      }
      [an](e3) {
        var _a3;
        const t3 = toStyle(this, "border", "font", "margin"), i3 = this[pr]()[pr](), a3 = { name: "input", attributes: { type: "text", fieldId: i3[nn], dataId: ((_a3 = i3[tr]) == null ? void 0 : _a3[nn]) || i3[nn], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(i3), "aria-required": false } };
        if (isRequired(i3)) {
          a3.attributes["aria-required"] = true;
          a3.attributes.required = true;
        }
        return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a3] });
      }
    };
    Decimal = class extends ContentObject {
      constructor(e3) {
        super(Hn, "decimal");
        this.fracDigits = getInteger({ data: e3.fracDigits, defaultValue: 2, validate: (e4) => true });
        this.id = e3.id || "";
        this.leadDigits = getInteger({ data: e3.leadDigits, defaultValue: -1, validate: (e4) => true });
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [sr]() {
        const e3 = parseFloat(this[er].trim());
        this[er] = isNaN(e3) ? null : e3;
      }
      [an](e3) {
        return valueToHtml(null !== this[er] ? this[er].toString() : "");
      }
    };
    DefaultUi = class extends XFAObject {
      constructor(e3) {
        super(Hn, "defaultUi", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
      }
    };
    Desc = class extends XFAObject {
      constructor(e3) {
        super(Hn, "desc", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.boolean = new XFAObjectArray();
        this.date = new XFAObjectArray();
        this.dateTime = new XFAObjectArray();
        this.decimal = new XFAObjectArray();
        this.exData = new XFAObjectArray();
        this.float = new XFAObjectArray();
        this.image = new XFAObjectArray();
        this.integer = new XFAObjectArray();
        this.text = new XFAObjectArray();
        this.time = new XFAObjectArray();
      }
    };
    DigestMethod = class extends OptionObject {
      constructor(e3) {
        super(Hn, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    DigestMethods = class extends XFAObject {
      constructor(e3) {
        super(Hn, "digestMethods", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.digestMethod = new XFAObjectArray();
      }
    };
    Draw = class extends XFAObject {
      constructor(e3) {
        super(Hn, "draw", true);
        this.anchorType = getStringOption(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
        this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
        this.h = e3.h ? getMeasurement(e3.h) : "";
        this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
        this.id = e3.id || "";
        this.locale = e3.locale || "";
        this.maxH = getMeasurement(e3.maxH, "0pt");
        this.maxW = getMeasurement(e3.maxW, "0pt");
        this.minH = getMeasurement(e3.minH, "0pt");
        this.minW = getMeasurement(e3.minW, "0pt");
        this.name = e3.name || "";
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.relevant = getRelevant(e3.relevant);
        this.rotate = getInteger({ data: e3.rotate, defaultValue: 0, validate: (e4) => e4 % 90 == 0 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.w = e3.w ? getMeasurement(e3.w) : "";
        this.x = getMeasurement(e3.x, "0pt");
        this.y = getMeasurement(e3.y, "0pt");
        this.assist = null;
        this.border = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.font = null;
        this.keep = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.ui = null;
        this.value = null;
        this.setProperty = new XFAObjectArray();
      }
      [$r](e3) {
        _setValue(this, e3);
      }
      [an](e3) {
        setTabIndex(this);
        if ("hidden" === this.presence || "inactive" === this.presence)
          return HTMLResult.EMPTY;
        fixDimensions(this);
        this[Wr]();
        const t3 = this.w, i3 = this.h, { w: a3, h: s3, isBroken: r3 } = layoutNode(this, e3);
        if (a3 && "" === this.w) {
          if (r3 && this[fr]()[Ur]()) {
            this[Pr]();
            return HTMLResult.FAILURE;
          }
          this.w = a3;
        }
        s3 && "" === this.h && (this.h = s3);
        setFirstUnsplittable(this);
        if (!checkDimensions(this, e3)) {
          this.w = t3;
          this.h = i3;
          this[Pr]();
          return HTMLResult.FAILURE;
        }
        unsetFirstUnsplittable(this);
        const n3 = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
        setMinMaxDimensions(this, n3);
        if (n3.margin) {
          n3.padding = n3.margin;
          delete n3.margin;
        }
        const o3 = ["xfaDraw"];
        this.font && o3.push("xfaFont");
        isPrintOnly(this) && o3.push("xfaPrintOnly");
        const g3 = { style: n3, id: this[nn], class: o3 };
        this.name && (g3.xfaName = this.name);
        const c3 = { name: "div", attributes: g3, children: [] };
        applyAssist(this, g3);
        const C3 = computeBbox(this, c3, e3), h2 = this.value ? this.value[an](e3).html : null;
        if (null === h2) {
          this.w = t3;
          this.h = i3;
          this[Pr]();
          return HTMLResult.success(createWrapper(this, c3), C3);
        }
        c3.children.push(h2);
        setPara(this, n3, h2);
        this.w = t3;
        this.h = i3;
        this[Pr]();
        return HTMLResult.success(createWrapper(this, c3), C3);
      }
    };
    Edge = class extends XFAObject {
      constructor(e3) {
        super(Hn, "edge", true);
        this.cap = getStringOption(e3.cap, ["square", "butt", "round"]);
        this.id = e3.id || "";
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.stroke = getStringOption(e3.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
        this.thickness = getMeasurement(e3.thickness, "0.5pt");
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.color = null;
        this.extras = null;
      }
      [rn]() {
        const e3 = toStyle(this, "visibility");
        Object.assign(e3, { linecap: this.cap, width: measureToString(this.thickness), color: this.color ? this.color[rn]() : "#000000", style: "" });
        if ("visible" !== this.presence)
          e3.style = "none";
        else
          switch (this.stroke) {
            case "solid":
              e3.style = "solid";
              break;
            case "dashDot":
            case "dashDotDot":
            case "dashed":
              e3.style = "dashed";
              break;
            case "dotted":
              e3.style = "dotted";
              break;
            case "embossed":
              e3.style = "ridge";
              break;
            case "etched":
              e3.style = "groove";
              break;
            case "lowered":
              e3.style = "inset";
              break;
            case "raised":
              e3.style = "outset";
          }
        return e3;
      }
    };
    Encoding = class extends OptionObject {
      constructor(e3) {
        super(Hn, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Encodings = class extends XFAObject {
      constructor(e3) {
        super(Hn, "encodings", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.encoding = new XFAObjectArray();
      }
    };
    Encrypt = class extends XFAObject {
      constructor(e3) {
        super(Hn, "encrypt", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.certificate = null;
      }
    };
    EncryptData = class extends XFAObject {
      constructor(e3) {
        super(Hn, "encryptData", true);
        this.id = e3.id || "";
        this.operation = getStringOption(e3.operation, ["encrypt", "decrypt"]);
        this.target = e3.target || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.filter = null;
        this.manifest = null;
      }
    };
    Encryption = class extends XFAObject {
      constructor(e3) {
        super(Hn, "encryption", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.certificate = new XFAObjectArray();
      }
    };
    EncryptionMethod = class extends OptionObject {
      constructor(e3) {
        super(Hn, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    EncryptionMethods = class extends XFAObject {
      constructor(e3) {
        super(Hn, "encryptionMethods", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.encryptionMethod = new XFAObjectArray();
      }
    };
    Event2 = class extends XFAObject {
      constructor(e3) {
        super(Hn, "event", true);
        this.activity = getStringOption(e3.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
        this.id = e3.id || "";
        this.listen = getStringOption(e3.listen, ["refOnly", "refAndDescendents"]);
        this.name = e3.name || "";
        this.ref = e3.ref || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.encryptData = null;
        this.execute = null;
        this.script = null;
        this.signData = null;
        this.submit = null;
      }
    };
    ExData = class extends ContentObject {
      constructor(e3) {
        super(Hn, "exData");
        this.contentType = e3.contentType || "";
        this.href = e3.href || "";
        this.id = e3.id || "";
        this.maxLength = getInteger({ data: e3.maxLength, defaultValue: -1, validate: (e4) => e4 >= -1 });
        this.name = e3.name || "";
        this.rid = e3.rid || "";
        this.transferEncoding = getStringOption(e3.transferEncoding, ["none", "base64", "package"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [Sr]() {
        return "text/html" === this.contentType;
      }
      [Kr](e3) {
        if ("text/html" === this.contentType && e3[Jr] === gn.xhtml.id) {
          this[er] = e3;
          return true;
        }
        if ("text/xml" === this.contentType) {
          this[er] = e3;
          return true;
        }
        return false;
      }
      [an](e3) {
        return "text/html" === this.contentType && this[er] ? this[er][an](e3) : HTMLResult.EMPTY;
      }
    };
    ExObject = class extends XFAObject {
      constructor(e3) {
        super(Hn, "exObject", true);
        this.archive = e3.archive || "";
        this.classId = e3.classId || "";
        this.codeBase = e3.codeBase || "";
        this.codeType = e3.codeType || "";
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.boolean = new XFAObjectArray();
        this.date = new XFAObjectArray();
        this.dateTime = new XFAObjectArray();
        this.decimal = new XFAObjectArray();
        this.exData = new XFAObjectArray();
        this.exObject = new XFAObjectArray();
        this.float = new XFAObjectArray();
        this.image = new XFAObjectArray();
        this.integer = new XFAObjectArray();
        this.text = new XFAObjectArray();
        this.time = new XFAObjectArray();
      }
    };
    ExclGroup = class extends XFAObject {
      constructor(e3) {
        super(Hn, "exclGroup", true);
        this.access = getStringOption(e3.access, ["open", "nonInteractive", "protected", "readOnly"]);
        this.accessKey = e3.accessKey || "";
        this.anchorType = getStringOption(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
        this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
        this.h = e3.h ? getMeasurement(e3.h) : "";
        this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
        this.id = e3.id || "";
        this.layout = getStringOption(e3.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
        this.maxH = getMeasurement(e3.maxH, "0pt");
        this.maxW = getMeasurement(e3.maxW, "0pt");
        this.minH = getMeasurement(e3.minH, "0pt");
        this.minW = getMeasurement(e3.minW, "0pt");
        this.name = e3.name || "";
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.relevant = getRelevant(e3.relevant);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.w = e3.w ? getMeasurement(e3.w) : "";
        this.x = getMeasurement(e3.x, "0pt");
        this.y = getMeasurement(e3.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.border = null;
        this.calculate = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.validate = null;
        this.connect = new XFAObjectArray();
        this.event = new XFAObjectArray();
        this.field = new XFAObjectArray();
        this.setProperty = new XFAObjectArray();
      }
      [kr]() {
        return true;
      }
      [wr]() {
        return true;
      }
      [$r](e3) {
        for (const t3 of this.field.children) {
          if (!t3.value) {
            const e4 = new Value({});
            t3[Xs](e4);
            t3.value = e4;
          }
          t3.value[$r](e3);
        }
      }
      [Ur]() {
        return this.layout.endsWith("-tb") && 0 === this[ar].attempt && this[ar].numberInLine > 0 || this[pr]()[Ur]();
      }
      [xr]() {
        var _a3;
        const e3 = this[fr]();
        if (!e3[xr]())
          return false;
        if (void 0 !== this[ar]._isSplittable)
          return this[ar]._isSplittable;
        if ("position" === this.layout || this.layout.includes("row")) {
          this[ar]._isSplittable = false;
          return false;
        }
        if (((_a3 = e3.layout) == null ? void 0 : _a3.endsWith("-tb")) && 0 !== e3[ar].numberInLine)
          return false;
        this[ar]._isSplittable = true;
        return true;
      }
      [rr]() {
        return flushHTML(this);
      }
      [js](e3, t3) {
        addHTML(this, e3, t3);
      }
      [gr]() {
        return getAvailableSpace(this);
      }
      [an](e3) {
        setTabIndex(this);
        if ("hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w)
          return HTMLResult.EMPTY;
        fixDimensions(this);
        const t3 = [], i3 = { id: this[nn], class: [] };
        setAccess(this, i3.class);
        this[ar] || (this[ar] = /* @__PURE__ */ Object.create(null));
        Object.assign(this[ar], { children: t3, attributes: i3, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e3.width), height: Math.min(this.h || 1 / 0, e3.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
        const a3 = this[xr]();
        a3 || setFirstUnsplittable(this);
        if (!checkDimensions(this, e3))
          return HTMLResult.FAILURE;
        const s3 = /* @__PURE__ */ new Set(["field"]);
        if (this.layout.includes("row")) {
          const e4 = this[fr]().columnWidths;
          if (Array.isArray(e4) && e4.length > 0) {
            this[ar].columnWidths = e4;
            this[ar].currentColumn = 0;
          }
        }
        const r3 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), n3 = ["xfaExclgroup"], o3 = layoutClass(this);
        o3 && n3.push(o3);
        isPrintOnly(this) && n3.push("xfaPrintOnly");
        i3.style = r3;
        i3.class = n3;
        this.name && (i3.xfaName = this.name);
        this[Wr]();
        const g3 = "lr-tb" === this.layout || "rl-tb" === this.layout, c3 = g3 ? 2 : 1;
        for (; this[ar].attempt < c3; this[ar].attempt++) {
          g3 && 1 === this[ar].attempt && (this[ar].numberInLine = 0);
          const e4 = this[Zs]({ filter: s3, include: true });
          if (e4.success)
            break;
          if (e4.isBreak()) {
            this[Pr]();
            return e4;
          }
          if (g3 && 0 === this[ar].attempt && 0 === this[ar].numberInLine && !this[mr]()[ar].noLayoutFailure) {
            this[ar].attempt = c3;
            break;
          }
        }
        this[Pr]();
        a3 || unsetFirstUnsplittable(this);
        if (this[ar].attempt === c3) {
          a3 || delete this[ar];
          return HTMLResult.FAILURE;
        }
        let C3 = 0, h2 = 0;
        if (this.margin) {
          C3 = this.margin.leftInset + this.margin.rightInset;
          h2 = this.margin.topInset + this.margin.bottomInset;
        }
        const l3 = Math.max(this[ar].width + C3, this.w || 0), Q3 = Math.max(this[ar].height + h2, this.h || 0), E3 = [this.x, this.y, l3, Q3];
        "" === this.w && (r3.width = measureToString(l3));
        "" === this.h && (r3.height = measureToString(Q3));
        const u3 = { name: "div", attributes: i3, children: t3 };
        applyAssist(this, i3);
        delete this[ar];
        return HTMLResult.success(createWrapper(this, u3), E3);
      }
    };
    Execute = class extends XFAObject {
      constructor(e3) {
        super(Hn, "execute");
        this.connection = e3.connection || "";
        this.executeType = getStringOption(e3.executeType, ["import", "remerge"]);
        this.id = e3.id || "";
        this.runAt = getStringOption(e3.runAt, ["client", "both", "server"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Extras = class extends XFAObject {
      constructor(e3) {
        super(Hn, "extras", true);
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.boolean = new XFAObjectArray();
        this.date = new XFAObjectArray();
        this.dateTime = new XFAObjectArray();
        this.decimal = new XFAObjectArray();
        this.exData = new XFAObjectArray();
        this.extras = new XFAObjectArray();
        this.float = new XFAObjectArray();
        this.image = new XFAObjectArray();
        this.integer = new XFAObjectArray();
        this.text = new XFAObjectArray();
        this.time = new XFAObjectArray();
      }
    };
    Field = class extends XFAObject {
      constructor(e3) {
        super(Hn, "field", true);
        this.access = getStringOption(e3.access, ["open", "nonInteractive", "protected", "readOnly"]);
        this.accessKey = e3.accessKey || "";
        this.anchorType = getStringOption(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
        this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
        this.h = e3.h ? getMeasurement(e3.h) : "";
        this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
        this.id = e3.id || "";
        this.locale = e3.locale || "";
        this.maxH = getMeasurement(e3.maxH, "0pt");
        this.maxW = getMeasurement(e3.maxW, "0pt");
        this.minH = getMeasurement(e3.minH, "0pt");
        this.minW = getMeasurement(e3.minW, "0pt");
        this.name = e3.name || "";
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.relevant = getRelevant(e3.relevant);
        this.rotate = getInteger({ data: e3.rotate, defaultValue: 0, validate: (e4) => e4 % 90 == 0 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.w = e3.w ? getMeasurement(e3.w) : "";
        this.x = getMeasurement(e3.x, "0pt");
        this.y = getMeasurement(e3.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.border = null;
        this.calculate = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.font = null;
        this.format = null;
        this.items = new XFAObjectArray(2);
        this.keep = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.ui = null;
        this.validate = null;
        this.value = null;
        this.bindItems = new XFAObjectArray();
        this.connect = new XFAObjectArray();
        this.event = new XFAObjectArray();
        this.setProperty = new XFAObjectArray();
      }
      [kr]() {
        return true;
      }
      [$r](e3) {
        _setValue(this, e3);
      }
      [an](e3) {
        var _a3, _b2, _c2;
        setTabIndex(this);
        if (!this.ui) {
          this.ui = new Ui({});
          this.ui[yr] = this[yr];
          this[Xs](this.ui);
          let e4;
          switch (this.items.children.length) {
            case 0:
              e4 = new TextEdit({});
              this.ui.textEdit = e4;
              break;
            case 1:
              e4 = new CheckButton({});
              this.ui.checkButton = e4;
              break;
            case 2:
              e4 = new ChoiceList({});
              this.ui.choiceList = e4;
          }
          this.ui[Xs](e4);
        }
        if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w)
          return HTMLResult.EMPTY;
        this.caption && delete this.caption[ar];
        this[Wr]();
        const t3 = this.caption ? this.caption[an](e3).html : null, i3 = this.w, a3 = this.h;
        let s3 = 0, r3 = 0;
        if (this.margin) {
          s3 = this.margin.leftInset + this.margin.rightInset;
          r3 = this.margin.topInset + this.margin.bottomInset;
        }
        let n3 = null;
        if ("" === this.w || "" === this.h) {
          let t4 = null, i4 = null, a4 = 0, o4 = 0;
          if (this.ui.checkButton)
            a4 = o4 = this.ui.checkButton.size;
          else {
            const { w: t5, h: i5 } = layoutNode(this, e3);
            if (null !== t5) {
              a4 = t5;
              o4 = i5;
            } else
              o4 = function fonts_getMetrics(e4, t6 = false) {
                let i6 = null;
                if (e4) {
                  const t7 = stripQuotes(e4.typeface), a6 = e4[yr].fontFinder.find(t7);
                  i6 = selectFont(e4, a6);
                }
                if (!i6)
                  return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
                const a5 = e4.size || 10, s4 = i6.lineHeight ? Math.max(t6 ? 0 : 1.2, i6.lineHeight) : 1.2, r4 = void 0 === i6.lineGap ? 0.2 : i6.lineGap;
                return { lineHeight: s4 * a5, lineGap: r4 * a5, lineNoGap: Math.max(1, s4 - r4) * a5 };
              }(this.font, true).lineNoGap;
          }
          n3 = getBorderDims(this.ui[lr]());
          a4 += n3.w;
          o4 += n3.h;
          if (this.caption) {
            const { w: s4, h: r4, isBroken: n4 } = this.caption[lr](e3);
            if (n4 && this[fr]()[Ur]()) {
              this[Pr]();
              return HTMLResult.FAILURE;
            }
            t4 = s4;
            i4 = r4;
            switch (this.caption.placement) {
              case "left":
              case "right":
              case "inline":
                t4 += a4;
                break;
              case "top":
              case "bottom":
                i4 += o4;
            }
          } else {
            t4 = a4;
            i4 = o4;
          }
          if (t4 && "" === this.w) {
            t4 += s3;
            this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t4 ? t4 : this.minW);
          }
          if (i4 && "" === this.h) {
            i4 += r3;
            this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i4 ? i4 : this.minH);
          }
        }
        this[Pr]();
        fixDimensions(this);
        setFirstUnsplittable(this);
        if (!checkDimensions(this, e3)) {
          this.w = i3;
          this.h = a3;
          this[Pr]();
          return HTMLResult.FAILURE;
        }
        unsetFirstUnsplittable(this);
        const o3 = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
        setMinMaxDimensions(this, o3);
        const g3 = ["xfaField"];
        this.font && g3.push("xfaFont");
        isPrintOnly(this) && g3.push("xfaPrintOnly");
        const c3 = { style: o3, id: this[nn], class: g3 };
        if (o3.margin) {
          o3.padding = o3.margin;
          delete o3.margin;
        }
        setAccess(this, g3);
        this.name && (c3.xfaName = this.name);
        const C3 = [], h2 = { name: "div", attributes: c3, children: C3 };
        applyAssist(this, c3);
        const l3 = this.border ? this.border[rn]() : null, Q3 = computeBbox(this, h2, e3), E3 = this.ui[an]().html;
        if (!E3) {
          Object.assign(o3, l3);
          return HTMLResult.success(createWrapper(this, h2), Q3);
        }
        this[An] && (((_a3 = E3.children) == null ? void 0 : _a3[0]) ? E3.children[0].attributes.tabindex = this[An] : E3.attributes.tabindex = this[An]);
        E3.attributes.style || (E3.attributes.style = /* @__PURE__ */ Object.create(null));
        let u3 = null;
        if (this.ui.button) {
          1 === E3.children.length && ([u3] = E3.children.splice(0, 1));
          Object.assign(E3.attributes.style, l3);
        } else
          Object.assign(o3, l3);
        C3.push(E3);
        if (this.value) {
          if (this.ui.imageEdit)
            E3.children.push(this.value[an]().html);
          else if (!this.ui.button) {
            let e4 = "";
            if (this.value.exData)
              e4 = this.value.exData[en]();
            else if (this.value.text)
              e4 = this.value.text[lr]();
            else {
              const t4 = this.value[an]().html;
              null !== t4 && (e4 = t4.children[0].value);
            }
            this.ui.textEdit && ((_b2 = this.value.text) == null ? void 0 : _b2.maxChars) && (E3.children[0].attributes.maxLength = this.value.text.maxChars);
            if (e4) {
              if (this.ui.numericEdit) {
                e4 = parseFloat(e4);
                e4 = isNaN(e4) ? "" : e4.toString();
              }
              "textarea" === E3.children[0].name ? E3.children[0].attributes.textContent = e4 : E3.children[0].attributes.value = e4;
            }
          }
        }
        if (!this.ui.imageEdit && ((_c2 = E3.children) == null ? void 0 : _c2[0]) && this.h) {
          n3 = n3 || getBorderDims(this.ui[lr]());
          let t4 = 0;
          if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
            t4 = this.caption.reserve;
            t4 <= 0 && (t4 = this.caption[lr](e3).h);
            const i4 = this.h - t4 - r3 - n3.h;
            E3.children[0].attributes.style.height = measureToString(i4);
          } else
            E3.children[0].attributes.style.height = "100%";
        }
        u3 && E3.children.push(u3);
        if (!t3) {
          E3.attributes.class && E3.attributes.class.push("xfaLeft");
          this.w = i3;
          this.h = a3;
          return HTMLResult.success(createWrapper(this, h2), Q3);
        }
        if (this.ui.button) {
          o3.padding && delete o3.padding;
          "div" === t3.name && (t3.name = "span");
          E3.children.push(t3);
          return HTMLResult.success(h2, Q3);
        }
        this.ui.checkButton && (t3.attributes.class[0] = "xfaCaptionForCheckButton");
        E3.attributes.class || (E3.attributes.class = []);
        E3.children.splice(0, 0, t3);
        switch (this.caption.placement) {
          case "left":
          case "inline":
            E3.attributes.class.push("xfaLeft");
            break;
          case "right":
            E3.attributes.class.push("xfaRight");
            break;
          case "top":
            E3.attributes.class.push("xfaTop");
            break;
          case "bottom":
            E3.attributes.class.push("xfaBottom");
        }
        this.w = i3;
        this.h = a3;
        return HTMLResult.success(createWrapper(this, h2), Q3);
      }
    };
    Fill = class extends XFAObject {
      constructor(e3) {
        super(Hn, "fill", true);
        this.id = e3.id || "";
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.color = null;
        this.extras = null;
        this.linear = null;
        this.pattern = null;
        this.radial = null;
        this.solid = null;
        this.stipple = null;
      }
      [rn]() {
        var _a3;
        const e3 = this[pr](), t3 = e3[pr]()[pr](), i3 = /* @__PURE__ */ Object.create(null);
        let a3 = "color", s3 = a3;
        if (e3 instanceof Border) {
          a3 = "background-color";
          s3 = "background";
          t3 instanceof Ui && (i3.backgroundColor = "white");
        }
        if (e3 instanceof Rectangle || e3 instanceof Arc) {
          a3 = s3 = "fill";
          i3.fill = "white";
        }
        for (const e4 of Object.getOwnPropertyNames(this)) {
          if ("extras" === e4 || "color" === e4)
            continue;
          const t4 = this[e4];
          if (!(t4 instanceof XFAObject))
            continue;
          const r3 = t4[rn](this.color);
          r3 && (i3[r3.startsWith("#") ? a3 : s3] = r3);
          return i3;
        }
        if ((_a3 = this.color) == null ? void 0 : _a3.value) {
          const e4 = this.color[rn]();
          i3[e4.startsWith("#") ? a3 : s3] = e4;
        }
        return i3;
      }
    };
    Filter = class extends XFAObject {
      constructor(e3) {
        super(Hn, "filter", true);
        this.addRevocationInfo = getStringOption(e3.addRevocationInfo, ["", "required", "optional", "none"]);
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.version = getInteger({ data: this.version, defaultValue: 5, validate: (e4) => e4 >= 1 && e4 <= 5 });
        this.appearanceFilter = null;
        this.certificates = null;
        this.digestMethods = null;
        this.encodings = null;
        this.encryptionMethods = null;
        this.handler = null;
        this.lockDocument = null;
        this.mdp = null;
        this.reasons = null;
        this.timeStamp = null;
      }
    };
    Float = class extends ContentObject {
      constructor(e3) {
        super(Hn, "float");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [sr]() {
        const e3 = parseFloat(this[er].trim());
        this[er] = isNaN(e3) ? null : e3;
      }
      [an](e3) {
        return valueToHtml(null !== this[er] ? this[er].toString() : "");
      }
    };
    template_Font = class extends XFAObject {
      constructor(e3) {
        super(Hn, "font", true);
        this.baselineShift = getMeasurement(e3.baselineShift);
        this.fontHorizontalScale = getFloat({ data: e3.fontHorizontalScale, defaultValue: 100, validate: (e4) => e4 >= 0 });
        this.fontVerticalScale = getFloat({ data: e3.fontVerticalScale, defaultValue: 100, validate: (e4) => e4 >= 0 });
        this.id = e3.id || "";
        this.kerningMode = getStringOption(e3.kerningMode, ["none", "pair"]);
        this.letterSpacing = getMeasurement(e3.letterSpacing, "0");
        this.lineThrough = getInteger({ data: e3.lineThrough, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 });
        this.lineThroughPeriod = getStringOption(e3.lineThroughPeriod, ["all", "word"]);
        this.overline = getInteger({ data: e3.overline, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 });
        this.overlinePeriod = getStringOption(e3.overlinePeriod, ["all", "word"]);
        this.posture = getStringOption(e3.posture, ["normal", "italic"]);
        this.size = getMeasurement(e3.size, "10pt");
        this.typeface = e3.typeface || "Courier";
        this.underline = getInteger({ data: e3.underline, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 });
        this.underlinePeriod = getStringOption(e3.underlinePeriod, ["all", "word"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.weight = getStringOption(e3.weight, ["normal", "bold"]);
        this.extras = null;
        this.fill = null;
      }
      [Vs](e3) {
        super[Vs](e3);
        this[yr].usedTypefaces.add(this.typeface);
      }
      [rn]() {
        const e3 = toStyle(this, "fill"), t3 = e3.color;
        if (t3) {
          if ("#000000" === t3)
            delete e3.color;
          else if (!t3.startsWith("#")) {
            e3.background = t3;
            e3.backgroundClip = "text";
            e3.color = "transparent";
          }
        }
        this.baselineShift && (e3.verticalAlign = measureToString(this.baselineShift));
        e3.fontKerning = "none" === this.kerningMode ? "none" : "normal";
        e3.letterSpacing = measureToString(this.letterSpacing);
        if (0 !== this.lineThrough) {
          e3.textDecoration = "line-through";
          2 === this.lineThrough && (e3.textDecorationStyle = "double");
        }
        if (0 !== this.overline) {
          e3.textDecoration = "overline";
          2 === this.overline && (e3.textDecorationStyle = "double");
        }
        e3.fontStyle = this.posture;
        e3.fontSize = measureToString(0.99 * this.size);
        setFontFamily(this, this, this[yr].fontFinder, e3);
        if (0 !== this.underline) {
          e3.textDecoration = "underline";
          2 === this.underline && (e3.textDecorationStyle = "double");
        }
        e3.fontWeight = this.weight;
        return e3;
      }
    };
    Format = class extends XFAObject {
      constructor(e3) {
        super(Hn, "format", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.picture = null;
      }
    };
    Handler = class extends StringObject {
      constructor(e3) {
        super(Hn, "handler");
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Hyphenation = class extends XFAObject {
      constructor(e3) {
        super(Hn, "hyphenation");
        this.excludeAllCaps = getInteger({ data: e3.excludeAllCaps, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.excludeInitialCap = getInteger({ data: e3.excludeInitialCap, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.hyphenate = getInteger({ data: e3.hyphenate, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.id = e3.id || "";
        this.pushCharacterCount = getInteger({ data: e3.pushCharacterCount, defaultValue: 3, validate: (e4) => e4 >= 0 });
        this.remainCharacterCount = getInteger({ data: e3.remainCharacterCount, defaultValue: 3, validate: (e4) => e4 >= 0 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.wordCharacterCount = getInteger({ data: e3.wordCharacterCount, defaultValue: 7, validate: (e4) => e4 >= 0 });
      }
    };
    Image2 = class extends StringObject {
      constructor(e3) {
        super(Hn, "image");
        this.aspect = getStringOption(e3.aspect, ["fit", "actual", "height", "none", "width"]);
        this.contentType = e3.contentType || "";
        this.href = e3.href || "";
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.transferEncoding = getStringOption(e3.transferEncoding, ["base64", "none", "package"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [an]() {
        if (this.contentType && !vn.has(this.contentType.toLowerCase()))
          return HTMLResult.EMPTY;
        let e3 = this[yr].images && this[yr].images.get(this.href);
        if (!e3 && (this.href || !this[er]))
          return HTMLResult.EMPTY;
        e3 || "base64" !== this.transferEncoding || (e3 = stringToBytes(atob(this[er])));
        if (!e3)
          return HTMLResult.EMPTY;
        if (!this.contentType) {
          for (const [t4, i4] of Kn)
            if (e3.length > t4.length && t4.every((t5, i5) => t5 === e3[i5])) {
              this.contentType = i4;
              break;
            }
          if (!this.contentType)
            return HTMLResult.EMPTY;
        }
        const t3 = new Blob([e3], { type: this.contentType });
        let i3;
        switch (this.aspect) {
          case "fit":
          case "actual":
            break;
          case "height":
            i3 = { height: "100%", objectFit: "fill" };
            break;
          case "none":
            i3 = { width: "100%", height: "100%", objectFit: "fill" };
            break;
          case "width":
            i3 = { width: "100%", objectFit: "fill" };
        }
        const a3 = this[pr]();
        return HTMLResult.success({ name: "img", attributes: { class: ["xfaImage"], style: i3, src: URL.createObjectURL(t3), alt: a3 ? ariaLabel(a3[pr]()) : null } });
      }
    };
    ImageEdit = class extends XFAObject {
      constructor(e3) {
        super(Hn, "imageEdit", true);
        this.data = getStringOption(e3.data, ["link", "embed"]);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
      }
      [an](e3) {
        return "embed" === this.data ? HTMLResult.success({ name: "div", children: [], attributes: {} }) : HTMLResult.EMPTY;
      }
    };
    Integer = class extends ContentObject {
      constructor(e3) {
        super(Hn, "integer");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [sr]() {
        const e3 = parseInt(this[er].trim(), 10);
        this[er] = isNaN(e3) ? null : e3;
      }
      [an](e3) {
        return valueToHtml(null !== this[er] ? this[er].toString() : "");
      }
    };
    Issuers = class extends XFAObject {
      constructor(e3) {
        super(Hn, "issuers", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.certificate = new XFAObjectArray();
      }
    };
    Items = class extends XFAObject {
      constructor(e3) {
        super(Hn, "items", true);
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.ref = e3.ref || "";
        this.save = getInteger({ data: e3.save, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.boolean = new XFAObjectArray();
        this.date = new XFAObjectArray();
        this.dateTime = new XFAObjectArray();
        this.decimal = new XFAObjectArray();
        this.exData = new XFAObjectArray();
        this.float = new XFAObjectArray();
        this.image = new XFAObjectArray();
        this.integer = new XFAObjectArray();
        this.text = new XFAObjectArray();
        this.time = new XFAObjectArray();
      }
      [an]() {
        const e3 = [];
        for (const t3 of this[Er]())
          e3.push(t3[en]());
        return HTMLResult.success(e3);
      }
    };
    Keep = class extends XFAObject {
      constructor(e3) {
        super(Hn, "keep", true);
        this.id = e3.id || "";
        const t3 = ["none", "contentArea", "pageArea"];
        this.intact = getStringOption(e3.intact, t3);
        this.next = getStringOption(e3.next, t3);
        this.previous = getStringOption(e3.previous, t3);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
      }
    };
    KeyUsage = class extends XFAObject {
      constructor(e3) {
        super(Hn, "keyUsage");
        const t3 = ["", "yes", "no"];
        this.crlSign = getStringOption(e3.crlSign, t3);
        this.dataEncipherment = getStringOption(e3.dataEncipherment, t3);
        this.decipherOnly = getStringOption(e3.decipherOnly, t3);
        this.digitalSignature = getStringOption(e3.digitalSignature, t3);
        this.encipherOnly = getStringOption(e3.encipherOnly, t3);
        this.id = e3.id || "";
        this.keyAgreement = getStringOption(e3.keyAgreement, t3);
        this.keyCertSign = getStringOption(e3.keyCertSign, t3);
        this.keyEncipherment = getStringOption(e3.keyEncipherment, t3);
        this.nonRepudiation = getStringOption(e3.nonRepudiation, t3);
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Line = class extends XFAObject {
      constructor(e3) {
        super(Hn, "line", true);
        this.hand = getStringOption(e3.hand, ["even", "left", "right"]);
        this.id = e3.id || "";
        this.slope = getStringOption(e3.slope, ["\\", "/"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.edge = null;
      }
      [an]() {
        const e3 = this[pr]()[pr](), t3 = this.edge || new Edge({}), i3 = t3[rn](), a3 = /* @__PURE__ */ Object.create(null), s3 = "visible" === t3.presence ? t3.thickness : 0;
        a3.strokeWidth = measureToString(s3);
        a3.stroke = i3.color;
        let r3, n3, o3, g3, c3 = "100%", C3 = "100%";
        if (e3.w <= s3) {
          [r3, n3, o3, g3] = ["50%", 0, "50%", "100%"];
          c3 = a3.strokeWidth;
        } else if (e3.h <= s3) {
          [r3, n3, o3, g3] = [0, "50%", "100%", "50%"];
          C3 = a3.strokeWidth;
        } else
          "\\" === this.slope ? [r3, n3, o3, g3] = [0, 0, "100%", "100%"] : [r3, n3, o3, g3] = [0, "100%", "100%", 0];
        const h2 = { name: "svg", children: [{ name: "line", attributes: { xmlns: Jn, x1: r3, y1: n3, x2: o3, y2: g3, style: a3 } }], attributes: { xmlns: Jn, width: c3, height: C3, style: { overflow: "visible" } } };
        if (hasMargin(e3))
          return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [h2] });
        h2.attributes.style.position = "absolute";
        return HTMLResult.success(h2);
      }
    };
    Linear = class extends XFAObject {
      constructor(e3) {
        super(Hn, "linear", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["toRight", "toBottom", "toLeft", "toTop"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.color = null;
        this.extras = null;
      }
      [rn](e3) {
        e3 = e3 ? e3[rn]() : "#FFFFFF";
        return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e3}, ${this.color ? this.color[rn]() : "#000000"})`;
      }
    };
    LockDocument = class extends ContentObject {
      constructor(e3) {
        super(Hn, "lockDocument");
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [sr]() {
        this[er] = getStringOption(this[er], ["auto", "0", "1"]);
      }
    };
    Manifest = class extends XFAObject {
      constructor(e3) {
        super(Hn, "manifest", true);
        this.action = getStringOption(e3.action, ["include", "all", "exclude"]);
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.ref = new XFAObjectArray();
      }
    };
    Margin = class extends XFAObject {
      constructor(e3) {
        super(Hn, "margin", true);
        this.bottomInset = getMeasurement(e3.bottomInset, "0");
        this.id = e3.id || "";
        this.leftInset = getMeasurement(e3.leftInset, "0");
        this.rightInset = getMeasurement(e3.rightInset, "0");
        this.topInset = getMeasurement(e3.topInset, "0");
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
      }
      [rn]() {
        return { margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset) };
      }
    };
    Mdp = class extends XFAObject {
      constructor(e3) {
        super(Hn, "mdp");
        this.id = e3.id || "";
        this.permissions = getInteger({ data: e3.permissions, defaultValue: 2, validate: (e4) => 1 === e4 || 3 === e4 });
        this.signatureType = getStringOption(e3.signatureType, ["filler", "author"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Medium = class extends XFAObject {
      constructor(e3) {
        super(Hn, "medium");
        this.id = e3.id || "";
        this.imagingBBox = function getBBox(e4) {
          const t3 = -1;
          if (!e4)
            return { x: t3, y: t3, width: t3, height: t3 };
          const i3 = e4.trim().split(/\s*,\s*/).map((e5) => getMeasurement(e5, "-1"));
          if (i3.length < 4 || i3[2] < 0 || i3[3] < 0)
            return { x: t3, y: t3, width: t3, height: t3 };
          const [a3, s3, r3, n3] = i3;
          return { x: a3, y: s3, width: r3, height: n3 };
        }(e3.imagingBBox);
        this.long = getMeasurement(e3.long);
        this.orientation = getStringOption(e3.orientation, ["portrait", "landscape"]);
        this.short = getMeasurement(e3.short);
        this.stock = e3.stock || "";
        this.trayIn = getStringOption(e3.trayIn, ["auto", "delegate", "pageFront"]);
        this.trayOut = getStringOption(e3.trayOut, ["auto", "delegate"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Message = class extends XFAObject {
      constructor(e3) {
        super(Hn, "message", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.text = new XFAObjectArray();
      }
    };
    NumericEdit = class extends XFAObject {
      constructor(e3) {
        super(Hn, "numericEdit", true);
        this.hScrollPolicy = getStringOption(e3.hScrollPolicy, ["auto", "off", "on"]);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
      }
      [an](e3) {
        var _a3;
        const t3 = toStyle(this, "border", "font", "margin"), i3 = this[pr]()[pr](), a3 = { name: "input", attributes: { type: "text", fieldId: i3[nn], dataId: ((_a3 = i3[tr]) == null ? void 0 : _a3[nn]) || i3[nn], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(i3), "aria-required": false } };
        if (isRequired(i3)) {
          a3.attributes["aria-required"] = true;
          a3.attributes.required = true;
        }
        return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a3] });
      }
    };
    Occur = class extends XFAObject {
      constructor(e3) {
        super(Hn, "occur", true);
        this.id = e3.id || "";
        this.initial = "" !== e3.initial ? getInteger({ data: e3.initial, defaultValue: "", validate: (e4) => true }) : "";
        this.max = "" !== e3.max ? getInteger({ data: e3.max, defaultValue: 1, validate: (e4) => true }) : "";
        this.min = "" !== e3.min ? getInteger({ data: e3.min, defaultValue: 1, validate: (e4) => true }) : "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
      }
      [Vs]() {
        const e3 = this[pr](), t3 = this.min;
        "" === this.min && (this.min = e3 instanceof PageArea || e3 instanceof PageSet ? 0 : 1);
        "" === this.max && (this.max = "" === t3 ? e3 instanceof PageArea || e3 instanceof PageSet ? -1 : 1 : this.min);
        -1 !== this.max && this.max < this.min && (this.max = this.min);
        "" === this.initial && (this.initial = e3 instanceof Template ? 1 : this.min);
      }
    };
    Oid = class extends StringObject {
      constructor(e3) {
        super(Hn, "oid");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Oids = class extends XFAObject {
      constructor(e3) {
        super(Hn, "oids", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.oid = new XFAObjectArray();
      }
    };
    Overflow = class extends XFAObject {
      constructor(e3) {
        super(Hn, "overflow");
        this.id = e3.id || "";
        this.leader = e3.leader || "";
        this.target = e3.target || "";
        this.trailer = e3.trailer || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [lr]() {
        if (!this[ar]) {
          const e3 = this[pr](), t3 = this[mr](), i3 = t3[Vr](this.target, e3), a3 = t3[Vr](this.leader, e3), s3 = t3[Vr](this.trailer, e3);
          this[ar] = { target: (i3 == null ? void 0 : i3[0]) || null, leader: (a3 == null ? void 0 : a3[0]) || null, trailer: (s3 == null ? void 0 : s3[0]) || null, addLeader: false, addTrailer: false };
        }
        return this[ar];
      }
    };
    PageArea = class extends XFAObject {
      constructor(e3) {
        super(Hn, "pageArea", true);
        this.blankOrNotBlank = getStringOption(e3.blankOrNotBlank, ["any", "blank", "notBlank"]);
        this.id = e3.id || "";
        this.initialNumber = getInteger({ data: e3.initialNumber, defaultValue: 1, validate: (e4) => true });
        this.name = e3.name || "";
        this.numbered = getInteger({ data: e3.numbered, defaultValue: 1, validate: (e4) => true });
        this.oddOrEven = getStringOption(e3.oddOrEven, ["any", "even", "odd"]);
        this.pagePosition = getStringOption(e3.pagePosition, ["any", "first", "last", "only", "rest"]);
        this.relevant = getRelevant(e3.relevant);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.desc = null;
        this.extras = null;
        this.medium = null;
        this.occur = null;
        this.area = new XFAObjectArray();
        this.contentArea = new XFAObjectArray();
        this.draw = new XFAObjectArray();
        this.exclGroup = new XFAObjectArray();
        this.field = new XFAObjectArray();
        this.subform = new XFAObjectArray();
      }
      [Lr]() {
        if (!this[ar]) {
          this[ar] = { numberOfUse: 0 };
          return true;
        }
        return !this.occur || -1 === this.occur.max || this[ar].numberOfUse < this.occur.max;
      }
      [zs]() {
        delete this[ar];
      }
      [dr]() {
        this[ar] || (this[ar] = { numberOfUse: 0 });
        const e3 = this[pr]();
        if ("orderedOccurrence" === e3.relation && this[Lr]()) {
          this[ar].numberOfUse += 1;
          return this;
        }
        return e3[dr]();
      }
      [gr]() {
        return this[ar].space || { width: 0, height: 0 };
      }
      [an]() {
        this[ar] || (this[ar] = { numberOfUse: 1 });
        const e3 = [];
        this[ar].children = e3;
        const t3 = /* @__PURE__ */ Object.create(null);
        if (this.medium && this.medium.short && this.medium.long) {
          t3.width = measureToString(this.medium.short);
          t3.height = measureToString(this.medium.long);
          this[ar].space = { width: this.medium.short, height: this.medium.long };
          if ("landscape" === this.medium.orientation) {
            const e4 = t3.width;
            t3.width = t3.height;
            t3.height = e4;
            this[ar].space = { width: this.medium.long, height: this.medium.short };
          }
        } else
          warn("XFA - No medium specified in pageArea: please file a bug.");
        this[Zs]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: true });
        this[Zs]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: true });
        return HTMLResult.success({ name: "div", children: e3, attributes: { class: ["xfaPage"], id: this[nn], style: t3, xfaName: this.name } });
      }
    };
    PageSet = class _PageSet extends XFAObject {
      constructor(e3) {
        super(Hn, "pageSet", true);
        this.duplexImposition = getStringOption(e3.duplexImposition, ["longEdge", "shortEdge"]);
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.relation = getStringOption(e3.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
        this.relevant = getRelevant(e3.relevant);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.occur = null;
        this.pageArea = new XFAObjectArray();
        this.pageSet = new XFAObjectArray();
      }
      [zs]() {
        for (const e3 of this.pageArea.children)
          e3[zs]();
        for (const e3 of this.pageSet.children)
          e3[zs]();
      }
      [Lr]() {
        return !this.occur || -1 === this.occur.max || this[ar].numberOfUse < this.occur.max;
      }
      [dr]() {
        this[ar] || (this[ar] = { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 });
        if ("orderedOccurrence" === this.relation) {
          if (this[ar].pageIndex + 1 < this.pageArea.children.length) {
            this[ar].pageIndex += 1;
            return this.pageArea.children[this[ar].pageIndex][dr]();
          }
          if (this[ar].pageSetIndex + 1 < this.pageSet.children.length) {
            this[ar].pageSetIndex += 1;
            return this.pageSet.children[this[ar].pageSetIndex][dr]();
          }
          if (this[Lr]()) {
            this[ar].numberOfUse += 1;
            this[ar].pageIndex = -1;
            this[ar].pageSetIndex = -1;
            return this[dr]();
          }
          const e4 = this[pr]();
          if (e4 instanceof _PageSet)
            return e4[dr]();
          this[zs]();
          return this[dr]();
        }
        const e3 = this[mr]()[ar].pageNumber, t3 = e3 % 2 == 0 ? "even" : "odd", i3 = 0 === e3 ? "first" : "rest";
        let a3 = this.pageArea.children.find((e4) => e4.oddOrEven === t3 && e4.pagePosition === i3);
        if (a3)
          return a3;
        a3 = this.pageArea.children.find((e4) => "any" === e4.oddOrEven && e4.pagePosition === i3);
        if (a3)
          return a3;
        a3 = this.pageArea.children.find((e4) => "any" === e4.oddOrEven && "any" === e4.pagePosition);
        return a3 || this.pageArea.children[0];
      }
    };
    Para = class extends XFAObject {
      constructor(e3) {
        super(Hn, "para", true);
        this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
        this.id = e3.id || "";
        this.lineHeight = e3.lineHeight ? getMeasurement(e3.lineHeight, "0pt") : "";
        this.marginLeft = e3.marginLeft ? getMeasurement(e3.marginLeft, "0pt") : "";
        this.marginRight = e3.marginRight ? getMeasurement(e3.marginRight, "0pt") : "";
        this.orphans = getInteger({ data: e3.orphans, defaultValue: 0, validate: (e4) => e4 >= 0 });
        this.preserve = e3.preserve || "";
        this.radixOffset = e3.radixOffset ? getMeasurement(e3.radixOffset, "0pt") : "";
        this.spaceAbove = e3.spaceAbove ? getMeasurement(e3.spaceAbove, "0pt") : "";
        this.spaceBelow = e3.spaceBelow ? getMeasurement(e3.spaceBelow, "0pt") : "";
        this.tabDefault = e3.tabDefault ? getMeasurement(this.tabDefault) : "";
        this.tabStops = (e3.tabStops || "").trim().split(/\s+/).map((e4, t3) => t3 % 2 == 1 ? getMeasurement(e4) : e4);
        this.textIndent = e3.textIndent ? getMeasurement(e3.textIndent, "0pt") : "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.vAlign = getStringOption(e3.vAlign, ["top", "bottom", "middle"]);
        this.widows = getInteger({ data: e3.widows, defaultValue: 0, validate: (e4) => e4 >= 0 });
        this.hyphenation = null;
      }
      [rn]() {
        const e3 = toStyle(this, "hAlign");
        "" !== this.marginLeft && (e3.paddingLeft = measureToString(this.marginLeft));
        "" !== this.marginRight && (e3.paddingight = measureToString(this.marginRight));
        "" !== this.spaceAbove && (e3.paddingTop = measureToString(this.spaceAbove));
        "" !== this.spaceBelow && (e3.paddingBottom = measureToString(this.spaceBelow));
        if ("" !== this.textIndent) {
          e3.textIndent = measureToString(this.textIndent);
          fixTextIndent(e3);
        }
        this.lineHeight > 0 && (e3.lineHeight = measureToString(this.lineHeight));
        "" !== this.tabDefault && (e3.tabSize = measureToString(this.tabDefault));
        this.tabStops.length;
        this.hyphenatation && Object.assign(e3, this.hyphenatation[rn]());
        return e3;
      }
    };
    PasswordEdit = class extends XFAObject {
      constructor(e3) {
        super(Hn, "passwordEdit", true);
        this.hScrollPolicy = getStringOption(e3.hScrollPolicy, ["auto", "off", "on"]);
        this.id = e3.id || "";
        this.passwordChar = e3.passwordChar || "*";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
      }
    };
    template_Pattern = class extends XFAObject {
      constructor(e3) {
        super(Hn, "pattern", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.color = null;
        this.extras = null;
      }
      [rn](e3) {
        e3 = e3 ? e3[rn]() : "#FFFFFF";
        const t3 = this.color ? this.color[rn]() : "#000000", i3 = "repeating-linear-gradient", a3 = `${e3},${e3} 5px,${t3} 5px,${t3} 10px`;
        switch (this.type) {
          case "crossHatch":
            return `${i3}(to top,${a3}) ${i3}(to right,${a3})`;
          case "crossDiagonal":
            return `${i3}(45deg,${a3}) ${i3}(-45deg,${a3})`;
          case "diagonalLeft":
            return `${i3}(45deg,${a3})`;
          case "diagonalRight":
            return `${i3}(-45deg,${a3})`;
          case "horizontal":
            return `${i3}(to top,${a3})`;
          case "vertical":
            return `${i3}(to right,${a3})`;
        }
        return "";
      }
    };
    Picture = class extends StringObject {
      constructor(e3) {
        super(Hn, "picture");
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Proto = class extends XFAObject {
      constructor(e3) {
        super(Hn, "proto", true);
        this.appearanceFilter = new XFAObjectArray();
        this.arc = new XFAObjectArray();
        this.area = new XFAObjectArray();
        this.assist = new XFAObjectArray();
        this.barcode = new XFAObjectArray();
        this.bindItems = new XFAObjectArray();
        this.bookend = new XFAObjectArray();
        this.boolean = new XFAObjectArray();
        this.border = new XFAObjectArray();
        this.break = new XFAObjectArray();
        this.breakAfter = new XFAObjectArray();
        this.breakBefore = new XFAObjectArray();
        this.button = new XFAObjectArray();
        this.calculate = new XFAObjectArray();
        this.caption = new XFAObjectArray();
        this.certificate = new XFAObjectArray();
        this.certificates = new XFAObjectArray();
        this.checkButton = new XFAObjectArray();
        this.choiceList = new XFAObjectArray();
        this.color = new XFAObjectArray();
        this.comb = new XFAObjectArray();
        this.connect = new XFAObjectArray();
        this.contentArea = new XFAObjectArray();
        this.corner = new XFAObjectArray();
        this.date = new XFAObjectArray();
        this.dateTime = new XFAObjectArray();
        this.dateTimeEdit = new XFAObjectArray();
        this.decimal = new XFAObjectArray();
        this.defaultUi = new XFAObjectArray();
        this.desc = new XFAObjectArray();
        this.digestMethod = new XFAObjectArray();
        this.digestMethods = new XFAObjectArray();
        this.draw = new XFAObjectArray();
        this.edge = new XFAObjectArray();
        this.encoding = new XFAObjectArray();
        this.encodings = new XFAObjectArray();
        this.encrypt = new XFAObjectArray();
        this.encryptData = new XFAObjectArray();
        this.encryption = new XFAObjectArray();
        this.encryptionMethod = new XFAObjectArray();
        this.encryptionMethods = new XFAObjectArray();
        this.event = new XFAObjectArray();
        this.exData = new XFAObjectArray();
        this.exObject = new XFAObjectArray();
        this.exclGroup = new XFAObjectArray();
        this.execute = new XFAObjectArray();
        this.extras = new XFAObjectArray();
        this.field = new XFAObjectArray();
        this.fill = new XFAObjectArray();
        this.filter = new XFAObjectArray();
        this.float = new XFAObjectArray();
        this.font = new XFAObjectArray();
        this.format = new XFAObjectArray();
        this.handler = new XFAObjectArray();
        this.hyphenation = new XFAObjectArray();
        this.image = new XFAObjectArray();
        this.imageEdit = new XFAObjectArray();
        this.integer = new XFAObjectArray();
        this.issuers = new XFAObjectArray();
        this.items = new XFAObjectArray();
        this.keep = new XFAObjectArray();
        this.keyUsage = new XFAObjectArray();
        this.line = new XFAObjectArray();
        this.linear = new XFAObjectArray();
        this.lockDocument = new XFAObjectArray();
        this.manifest = new XFAObjectArray();
        this.margin = new XFAObjectArray();
        this.mdp = new XFAObjectArray();
        this.medium = new XFAObjectArray();
        this.message = new XFAObjectArray();
        this.numericEdit = new XFAObjectArray();
        this.occur = new XFAObjectArray();
        this.oid = new XFAObjectArray();
        this.oids = new XFAObjectArray();
        this.overflow = new XFAObjectArray();
        this.pageArea = new XFAObjectArray();
        this.pageSet = new XFAObjectArray();
        this.para = new XFAObjectArray();
        this.passwordEdit = new XFAObjectArray();
        this.pattern = new XFAObjectArray();
        this.picture = new XFAObjectArray();
        this.radial = new XFAObjectArray();
        this.reason = new XFAObjectArray();
        this.reasons = new XFAObjectArray();
        this.rectangle = new XFAObjectArray();
        this.ref = new XFAObjectArray();
        this.script = new XFAObjectArray();
        this.setProperty = new XFAObjectArray();
        this.signData = new XFAObjectArray();
        this.signature = new XFAObjectArray();
        this.signing = new XFAObjectArray();
        this.solid = new XFAObjectArray();
        this.speak = new XFAObjectArray();
        this.stipple = new XFAObjectArray();
        this.subform = new XFAObjectArray();
        this.subformSet = new XFAObjectArray();
        this.subjectDN = new XFAObjectArray();
        this.subjectDNs = new XFAObjectArray();
        this.submit = new XFAObjectArray();
        this.text = new XFAObjectArray();
        this.textEdit = new XFAObjectArray();
        this.time = new XFAObjectArray();
        this.timeStamp = new XFAObjectArray();
        this.toolTip = new XFAObjectArray();
        this.traversal = new XFAObjectArray();
        this.traverse = new XFAObjectArray();
        this.ui = new XFAObjectArray();
        this.validate = new XFAObjectArray();
        this.value = new XFAObjectArray();
        this.variables = new XFAObjectArray();
      }
    };
    Radial = class extends XFAObject {
      constructor(e3) {
        super(Hn, "radial", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["toEdge", "toCenter"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.color = null;
        this.extras = null;
      }
      [rn](e3) {
        e3 = e3 ? e3[rn]() : "#FFFFFF";
        const t3 = this.color ? this.color[rn]() : "#000000";
        return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e3},${t3}` : `${t3},${e3}`})`;
      }
    };
    Reason = class extends StringObject {
      constructor(e3) {
        super(Hn, "reason");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Reasons = class extends XFAObject {
      constructor(e3) {
        super(Hn, "reasons", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.reason = new XFAObjectArray();
      }
    };
    Rectangle = class extends XFAObject {
      constructor(e3) {
        super(Hn, "rectangle", true);
        this.hand = getStringOption(e3.hand, ["even", "left", "right"]);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.corner = new XFAObjectArray(4);
        this.edge = new XFAObjectArray(4);
        this.fill = null;
      }
      [an]() {
        var _a3;
        const e3 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t3 = e3[rn](), i3 = /* @__PURE__ */ Object.create(null);
        "visible" === ((_a3 = this.fill) == null ? void 0 : _a3.presence) ? Object.assign(i3, this.fill[rn]()) : i3.fill = "transparent";
        i3.strokeWidth = measureToString("visible" === e3.presence ? e3.thickness : 0);
        i3.stroke = t3.color;
        const a3 = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[rn](), s3 = { name: "svg", children: [{ name: "rect", attributes: { xmlns: Jn, width: "100%", height: "100%", x: 0, y: 0, rx: a3.radius, ry: a3.radius, style: i3 } }], attributes: { xmlns: Jn, style: { overflow: "visible" }, width: "100%", height: "100%" } };
        if (hasMargin(this[pr]()[pr]()))
          return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [s3] });
        s3.attributes.style.position = "absolute";
        return HTMLResult.success(s3);
      }
    };
    RefElement = class extends StringObject {
      constructor(e3) {
        super(Hn, "ref");
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Script = class extends StringObject {
      constructor(e3) {
        super(Hn, "script");
        this.binding = e3.binding || "";
        this.contentType = e3.contentType || "";
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.runAt = getStringOption(e3.runAt, ["client", "both", "server"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    SetProperty = class extends XFAObject {
      constructor(e3) {
        super(Hn, "setProperty");
        this.connection = e3.connection || "";
        this.ref = e3.ref || "";
        this.target = e3.target || "";
      }
    };
    SignData = class extends XFAObject {
      constructor(e3) {
        super(Hn, "signData", true);
        this.id = e3.id || "";
        this.operation = getStringOption(e3.operation, ["sign", "clear", "verify"]);
        this.ref = e3.ref || "";
        this.target = e3.target || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.filter = null;
        this.manifest = null;
      }
    };
    Signature = class extends XFAObject {
      constructor(e3) {
        super(Hn, "signature", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["PDF1.3", "PDF1.6"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.border = null;
        this.extras = null;
        this.filter = null;
        this.manifest = null;
        this.margin = null;
      }
    };
    Signing = class extends XFAObject {
      constructor(e3) {
        super(Hn, "signing", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.certificate = new XFAObjectArray();
      }
    };
    Solid = class extends XFAObject {
      constructor(e3) {
        super(Hn, "solid", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
      }
      [rn](e3) {
        return e3 ? e3[rn]() : "#FFFFFF";
      }
    };
    Speak = class extends StringObject {
      constructor(e3) {
        super(Hn, "speak");
        this.disable = getInteger({ data: e3.disable, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.id = e3.id || "";
        this.priority = getStringOption(e3.priority, ["custom", "caption", "name", "toolTip"]);
        this.rid = e3.rid || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Stipple = class extends XFAObject {
      constructor(e3) {
        super(Hn, "stipple", true);
        this.id = e3.id || "";
        this.rate = getInteger({ data: e3.rate, defaultValue: 50, validate: (e4) => e4 >= 0 && e4 <= 100 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.color = null;
        this.extras = null;
      }
      [rn](e3) {
        const t3 = this.rate / 100;
        return Util.makeHexColor(Math.round(e3.value.r * (1 - t3) + this.value.r * t3), Math.round(e3.value.g * (1 - t3) + this.value.g * t3), Math.round(e3.value.b * (1 - t3) + this.value.b * t3));
      }
    };
    Subform = class extends XFAObject {
      constructor(e3) {
        super(Hn, "subform", true);
        this.access = getStringOption(e3.access, ["open", "nonInteractive", "protected", "readOnly"]);
        this.allowMacro = getInteger({ data: e3.allowMacro, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.anchorType = getStringOption(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
        this.colSpan = getInteger({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
        this.columnWidths = (e3.columnWidths || "").trim().split(/\s+/).map((e4) => "-1" === e4 ? -1 : getMeasurement(e4));
        this.h = e3.h ? getMeasurement(e3.h) : "";
        this.hAlign = getStringOption(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
        this.id = e3.id || "";
        this.layout = getStringOption(e3.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
        this.locale = e3.locale || "";
        this.maxH = getMeasurement(e3.maxH, "0pt");
        this.maxW = getMeasurement(e3.maxW, "0pt");
        this.mergeMode = getStringOption(e3.mergeMode, ["consumeData", "matchTemplate"]);
        this.minH = getMeasurement(e3.minH, "0pt");
        this.minW = getMeasurement(e3.minW, "0pt");
        this.name = e3.name || "";
        this.presence = getStringOption(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
        this.relevant = getRelevant(e3.relevant);
        this.restoreState = getStringOption(e3.restoreState, ["manual", "auto"]);
        this.scope = getStringOption(e3.scope, ["name", "none"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.w = e3.w ? getMeasurement(e3.w) : "";
        this.x = getMeasurement(e3.x, "0pt");
        this.y = getMeasurement(e3.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.bookend = null;
        this.border = null;
        this.break = null;
        this.calculate = null;
        this.desc = null;
        this.extras = null;
        this.keep = null;
        this.margin = null;
        this.occur = null;
        this.overflow = null;
        this.pageSet = null;
        this.para = null;
        this.traversal = null;
        this.validate = null;
        this.variables = null;
        this.area = new XFAObjectArray();
        this.breakAfter = new XFAObjectArray();
        this.breakBefore = new XFAObjectArray();
        this.connect = new XFAObjectArray();
        this.draw = new XFAObjectArray();
        this.event = new XFAObjectArray();
        this.exObject = new XFAObjectArray();
        this.exclGroup = new XFAObjectArray();
        this.field = new XFAObjectArray();
        this.proto = new XFAObjectArray();
        this.setProperty = new XFAObjectArray();
        this.subform = new XFAObjectArray();
        this.subformSet = new XFAObjectArray();
      }
      [fr]() {
        const e3 = this[pr]();
        return e3 instanceof SubformSet ? e3[fr]() : e3;
      }
      [kr]() {
        return true;
      }
      [Ur]() {
        return this.layout.endsWith("-tb") && 0 === this[ar].attempt && this[ar].numberInLine > 0 || this[pr]()[Ur]();
      }
      *[ur]() {
        yield* getContainedChildren(this);
      }
      [rr]() {
        return flushHTML(this);
      }
      [js](e3, t3) {
        addHTML(this, e3, t3);
      }
      [gr]() {
        return getAvailableSpace(this);
      }
      [xr]() {
        var _a3;
        const e3 = this[fr]();
        if (!e3[xr]())
          return false;
        if (void 0 !== this[ar]._isSplittable)
          return this[ar]._isSplittable;
        if ("position" === this.layout || this.layout.includes("row")) {
          this[ar]._isSplittable = false;
          return false;
        }
        if (this.keep && "none" !== this.keep.intact) {
          this[ar]._isSplittable = false;
          return false;
        }
        if (((_a3 = e3.layout) == null ? void 0 : _a3.endsWith("-tb")) && 0 !== e3[ar].numberInLine)
          return false;
        this[ar]._isSplittable = true;
        return true;
      }
      [an](e3) {
        var _a3;
        setTabIndex(this);
        if (this.break) {
          if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
            const e4 = new BreakAfter({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
            e4[yr] = this[yr];
            this[Xs](e4);
            this.breakAfter.push(e4);
          }
          if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
            const e4 = new BreakBefore({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
            e4[yr] = this[yr];
            this[Xs](e4);
            this.breakBefore.push(e4);
          }
          if ("" !== this.break.overflowTarget) {
            const e4 = new Overflow({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
            e4[yr] = this[yr];
            this[Xs](e4);
            this.overflow.push(e4);
          }
          this[jr](this.break);
          this.break = null;
        }
        if ("hidden" === this.presence || "inactive" === this.presence)
          return HTMLResult.EMPTY;
        (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
        if (this.breakBefore.children.length >= 1) {
          const e4 = this.breakBefore.children[0];
          if (handleBreak(e4))
            return HTMLResult.breakNode(e4);
        }
        if ((_a3 = this[ar]) == null ? void 0 : _a3.afterBreakAfter)
          return HTMLResult.EMPTY;
        fixDimensions(this);
        const t3 = [], i3 = { id: this[nn], class: [] };
        setAccess(this, i3.class);
        this[ar] || (this[ar] = /* @__PURE__ */ Object.create(null));
        Object.assign(this[ar], { children: t3, line: null, attributes: i3, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e3.width), height: Math.min(this.h || 1 / 0, e3.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
        const a3 = this[mr](), s3 = a3[ar].noLayoutFailure, r3 = this[xr]();
        r3 || setFirstUnsplittable(this);
        if (!checkDimensions(this, e3))
          return HTMLResult.FAILURE;
        const n3 = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
        if (this.layout.includes("row")) {
          const e4 = this[fr]().columnWidths;
          if (Array.isArray(e4) && e4.length > 0) {
            this[ar].columnWidths = e4;
            this[ar].currentColumn = 0;
          }
        }
        const o3 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), g3 = ["xfaSubform"], c3 = layoutClass(this);
        c3 && g3.push(c3);
        i3.style = o3;
        i3.class = g3;
        this.name && (i3.xfaName = this.name);
        if (this.overflow) {
          const t4 = this.overflow[lr]();
          if (t4.addLeader) {
            t4.addLeader = false;
            handleOverflow(this, t4.leader, e3);
          }
        }
        this[Wr]();
        const C3 = "lr-tb" === this.layout || "rl-tb" === this.layout, h2 = C3 ? 2 : 1;
        for (; this[ar].attempt < h2; this[ar].attempt++) {
          C3 && 1 === this[ar].attempt && (this[ar].numberInLine = 0);
          const e4 = this[Zs]({ filter: n3, include: true });
          if (e4.success)
            break;
          if (e4.isBreak()) {
            this[Pr]();
            return e4;
          }
          if (C3 && 0 === this[ar].attempt && 0 === this[ar].numberInLine && !a3[ar].noLayoutFailure) {
            this[ar].attempt = h2;
            break;
          }
        }
        this[Pr]();
        r3 || unsetFirstUnsplittable(this);
        a3[ar].noLayoutFailure = s3;
        if (this[ar].attempt === h2) {
          this.overflow && (this[mr]()[ar].overflowNode = this.overflow);
          r3 || delete this[ar];
          return HTMLResult.FAILURE;
        }
        if (this.overflow) {
          const t4 = this.overflow[lr]();
          if (t4.addTrailer) {
            t4.addTrailer = false;
            handleOverflow(this, t4.trailer, e3);
          }
        }
        let l3 = 0, Q3 = 0;
        if (this.margin) {
          l3 = this.margin.leftInset + this.margin.rightInset;
          Q3 = this.margin.topInset + this.margin.bottomInset;
        }
        const E3 = Math.max(this[ar].width + l3, this.w || 0), u3 = Math.max(this[ar].height + Q3, this.h || 0), d3 = [this.x, this.y, E3, u3];
        "" === this.w && (o3.width = measureToString(E3));
        "" === this.h && (o3.height = measureToString(u3));
        if (("0px" === o3.width || "0px" === o3.height) && 0 === t3.length)
          return HTMLResult.EMPTY;
        const f2 = { name: "div", attributes: i3, children: t3 };
        applyAssist(this, i3);
        const p2 = HTMLResult.success(createWrapper(this, f2), d3);
        if (this.breakAfter.children.length >= 1) {
          const e4 = this.breakAfter.children[0];
          if (handleBreak(e4)) {
            this[ar].afterBreakAfter = p2;
            return HTMLResult.breakNode(e4);
          }
        }
        delete this[ar];
        return p2;
      }
    };
    SubformSet = class extends XFAObject {
      constructor(e3) {
        super(Hn, "subformSet", true);
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.relation = getStringOption(e3.relation, ["ordered", "choice", "unordered"]);
        this.relevant = getRelevant(e3.relevant);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.bookend = null;
        this.break = null;
        this.desc = null;
        this.extras = null;
        this.occur = null;
        this.overflow = null;
        this.breakAfter = new XFAObjectArray();
        this.breakBefore = new XFAObjectArray();
        this.subform = new XFAObjectArray();
        this.subformSet = new XFAObjectArray();
      }
      *[ur]() {
        yield* getContainedChildren(this);
      }
      [fr]() {
        let e3 = this[pr]();
        for (; !(e3 instanceof Subform); )
          e3 = e3[pr]();
        return e3;
      }
      [kr]() {
        return true;
      }
    };
    SubjectDN = class extends ContentObject {
      constructor(e3) {
        super(Hn, "subjectDN");
        this.delimiter = e3.delimiter || ",";
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [sr]() {
        this[er] = new Map(this[er].split(this.delimiter).map((e3) => {
          (e3 = e3.split("=", 2))[0] = e3[0].trim();
          return e3;
        }));
      }
    };
    SubjectDNs = class extends XFAObject {
      constructor(e3) {
        super(Hn, "subjectDNs", true);
        this.id = e3.id || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.subjectDN = new XFAObjectArray();
      }
    };
    Submit = class extends XFAObject {
      constructor(e3) {
        super(Hn, "submit", true);
        this.embedPDF = getInteger({ data: e3.embedPDF, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.format = getStringOption(e3.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
        this.id = e3.id || "";
        this.target = e3.target || "";
        this.textEncoding = getKeyword({ data: e3.textEncoding ? e3.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e4) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e4) || e4.match(/iso-8859-\d{2}/) });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.xdpContent = e3.xdpContent || "";
        this.encrypt = null;
        this.encryptData = new XFAObjectArray();
        this.signData = new XFAObjectArray();
      }
    };
    Template = class extends XFAObject {
      constructor(e3) {
        super(Hn, "template", true);
        this.baseProfile = getStringOption(e3.baseProfile, ["full", "interactiveForms"]);
        this.extras = null;
        this.subform = new XFAObjectArray();
      }
      [sr]() {
        0 === this.subform.children.length && warn("XFA - No subforms in template node.");
        this.subform.children.length >= 2 && warn("XFA - Several subforms in template node: please file a bug.");
        this[An] = 5e3;
      }
      [xr]() {
        return true;
      }
      [Vr](e3, t3) {
        return e3.startsWith("#") ? [this[br].get(e3.slice(1))] : searchNode(this, t3, e3, true, true);
      }
      *[tn]() {
        var _a3, _b2, _c2;
        if (!this.subform.children.length)
          return HTMLResult.success({ name: "div", children: [] });
        this[ar] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: false, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
        const e3 = this.subform.children[0];
        e3.pageSet[zs]();
        const t3 = e3.pageSet.pageArea.children, i3 = { name: "div", children: [] };
        let a3 = null, s3 = null, r3 = null;
        if (e3.breakBefore.children.length >= 1) {
          s3 = e3.breakBefore.children[0];
          r3 = s3.target;
        } else if (e3.subform.children.length >= 1 && e3.subform.children[0].breakBefore.children.length >= 1) {
          s3 = e3.subform.children[0].breakBefore.children[0];
          r3 = s3.target;
        } else if ((_a3 = e3.break) == null ? void 0 : _a3.beforeTarget) {
          s3 = e3.break;
          r3 = s3.beforeTarget;
        } else if (e3.subform.children.length >= 1 && ((_b2 = e3.subform.children[0].break) == null ? void 0 : _b2.beforeTarget)) {
          s3 = e3.subform.children[0].break;
          r3 = s3.beforeTarget;
        }
        if (s3) {
          const e4 = this[Vr](r3, s3[pr]());
          if (e4 instanceof PageArea) {
            a3 = e4;
            s3[ar] = {};
          }
        }
        a3 || (a3 = t3[0]);
        a3[ar] = { numberOfUse: 1 };
        const n3 = a3[pr]();
        n3[ar] = { numberOfUse: 1, pageIndex: n3.pageArea.children.indexOf(a3), pageSetIndex: 0 };
        let o3, g3 = null, c3 = null, C3 = true, h2 = 0, l3 = 0;
        for (; ; ) {
          if (C3)
            h2 = 0;
          else {
            i3.children.pop();
            if (3 == ++h2) {
              warn("XFA - Something goes wrong: please file a bug.");
              return i3;
            }
          }
          o3 = null;
          this[ar].currentPageArea = a3;
          const t4 = a3[an]().html;
          i3.children.push(t4);
          if (g3) {
            this[ar].noLayoutFailure = true;
            t4.children.push(g3[an](a3[ar].space).html);
            g3 = null;
          }
          if (c3) {
            this[ar].noLayoutFailure = true;
            t4.children.push(c3[an](a3[ar].space).html);
            c3 = null;
          }
          const s4 = a3.contentArea.children, r4 = t4.children.filter((e4) => e4.attributes.class.includes("xfaContentarea"));
          C3 = false;
          this[ar].firstUnsplittable = null;
          this[ar].noLayoutFailure = false;
          const flush = (t5) => {
            var _a4;
            const i4 = e3[rr]();
            if (i4) {
              C3 || (C3 = ((_a4 = i4.children) == null ? void 0 : _a4.length) > 0);
              r4[t5].children.push(i4);
            }
          };
          for (let t5 = l3, a4 = s4.length; t5 < a4; t5++) {
            const a5 = this[ar].currentContentArea = s4[t5], n4 = { width: a5.w, height: a5.h };
            l3 = 0;
            if (g3) {
              r4[t5].children.push(g3[an](n4).html);
              g3 = null;
            }
            if (c3) {
              r4[t5].children.push(c3[an](n4).html);
              c3 = null;
            }
            const h3 = e3[an](n4);
            if (h3.success) {
              if (h3.html) {
                C3 || (C3 = ((_c2 = h3.html.children) == null ? void 0 : _c2.length) > 0);
                r4[t5].children.push(h3.html);
              } else
                !C3 && i3.children.length > 1 && i3.children.pop();
              return i3;
            }
            if (h3.isBreak()) {
              const e4 = h3.breakNode;
              flush(t5);
              if ("auto" === e4.targetType)
                continue;
              if (e4.leader) {
                g3 = this[Vr](e4.leader, e4[pr]());
                g3 = g3 ? g3[0] : null;
              }
              if (e4.trailer) {
                c3 = this[Vr](e4.trailer, e4[pr]());
                c3 = c3 ? c3[0] : null;
              }
              if ("pageArea" === e4.targetType) {
                o3 = e4[ar].target;
                t5 = 1 / 0;
              } else if (e4[ar].target) {
                o3 = e4[ar].target;
                l3 = e4[ar].index + 1;
                t5 = 1 / 0;
              } else
                t5 = e4[ar].index;
            } else if (this[ar].overflowNode) {
              const e4 = this[ar].overflowNode;
              this[ar].overflowNode = null;
              const i4 = e4[lr](), a6 = i4.target;
              i4.addLeader = null !== i4.leader;
              i4.addTrailer = null !== i4.trailer;
              flush(t5);
              const r5 = t5;
              t5 = 1 / 0;
              if (a6 instanceof PageArea)
                o3 = a6;
              else if (a6 instanceof ContentArea) {
                const e5 = s4.indexOf(a6);
                if (-1 !== e5)
                  e5 > r5 ? t5 = e5 - 1 : l3 = e5;
                else {
                  o3 = a6[pr]();
                  l3 = o3.contentArea.children.indexOf(a6);
                }
              }
            } else
              flush(t5);
          }
          this[ar].pageNumber += 1;
          o3 && (o3[Lr]() ? o3[ar].numberOfUse += 1 : o3 = null);
          a3 = o3 || a3[dr]();
          yield null;
        }
      }
    };
    Text = class extends ContentObject {
      constructor(e3) {
        super(Hn, "text");
        this.id = e3.id || "";
        this.maxChars = getInteger({ data: e3.maxChars, defaultValue: 0, validate: (e4) => e4 >= 0 });
        this.name = e3.name || "";
        this.rid = e3.rid || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [Ws]() {
        return true;
      }
      [Kr](e3) {
        if (e3[Jr] === gn.xhtml.id) {
          this[er] = e3;
          return true;
        }
        warn(`XFA - Invalid content in Text: ${e3[Yr]}.`);
        return false;
      }
      [qr](e3) {
        this[er] instanceof XFAObject || super[qr](e3);
      }
      [sr]() {
        "string" == typeof this[er] && (this[er] = this[er].replaceAll("\r\n", "\n"));
      }
      [lr]() {
        return "string" == typeof this[er] ? this[er].split(/[\u2029\u2028\n]/).reduce((e3, t3) => {
          t3 && e3.push(t3);
          return e3;
        }, []).join("\n") : this[er][en]();
      }
      [an](e3) {
        if ("string" == typeof this[er]) {
          const e4 = valueToHtml(this[er]).html;
          if (this[er].includes("\u2029")) {
            e4.name = "div";
            e4.children = [];
            this[er].split("\u2029").map((e5) => e5.split(/[\u2028\n]/).reduce((e6, t3) => {
              e6.push({ name: "span", value: t3 }, { name: "br" });
              return e6;
            }, [])).forEach((t3) => {
              e4.children.push({ name: "p", children: t3 });
            });
          } else if (/[\u2028\n]/.test(this[er])) {
            e4.name = "div";
            e4.children = [];
            this[er].split(/[\u2028\n]/).forEach((t3) => {
              e4.children.push({ name: "span", value: t3 }, { name: "br" });
            });
          }
          return HTMLResult.success(e4);
        }
        return this[er][an](e3);
      }
    };
    TextEdit = class extends XFAObject {
      constructor(e3) {
        super(Hn, "textEdit", true);
        this.allowRichText = getInteger({ data: e3.allowRichText, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.hScrollPolicy = getStringOption(e3.hScrollPolicy, ["auto", "off", "on"]);
        this.id = e3.id || "";
        this.multiLine = getInteger({ data: e3.multiLine, defaultValue: "", validate: (e4) => 0 === e4 || 1 === e4 });
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.vScrollPolicy = getStringOption(e3.vScrollPolicy, ["auto", "off", "on"]);
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
      }
      [an](e3) {
        var _a3, _b2;
        const t3 = toStyle(this, "border", "font", "margin");
        let i3;
        const a3 = this[pr]()[pr]();
        "" === this.multiLine && (this.multiLine = a3 instanceof Draw ? 1 : 0);
        i3 = 1 === this.multiLine ? { name: "textarea", attributes: { dataId: ((_a3 = a3[tr]) == null ? void 0 : _a3[nn]) || a3[nn], fieldId: a3[nn], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(a3), "aria-required": false } } : { name: "input", attributes: { type: "text", dataId: ((_b2 = a3[tr]) == null ? void 0 : _b2[nn]) || a3[nn], fieldId: a3[nn], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(a3), "aria-required": false } };
        if (isRequired(a3)) {
          i3.attributes["aria-required"] = true;
          i3.attributes.required = true;
        }
        return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [i3] });
      }
    };
    Time = class extends StringObject {
      constructor(e3) {
        super(Hn, "time");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
      [sr]() {
        const e3 = this[er].trim();
        this[er] = e3 ? new Date(e3) : null;
      }
      [an](e3) {
        return valueToHtml(this[er] ? this[er].toString() : "");
      }
    };
    TimeStamp = class extends XFAObject {
      constructor(e3) {
        super(Hn, "timeStamp");
        this.id = e3.id || "";
        this.server = e3.server || "";
        this.type = getStringOption(e3.type, ["optional", "required"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    ToolTip = class extends StringObject {
      constructor(e3) {
        super(Hn, "toolTip");
        this.id = e3.id || "";
        this.rid = e3.rid || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Traversal = class extends XFAObject {
      constructor(e3) {
        super(Hn, "traversal", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.traverse = new XFAObjectArray();
      }
    };
    Traverse = class extends XFAObject {
      constructor(e3) {
        super(Hn, "traverse", true);
        this.id = e3.id || "";
        this.operation = getStringOption(e3.operation, ["next", "back", "down", "first", "left", "right", "up"]);
        this.ref = e3.ref || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.script = null;
      }
      get name() {
        return this.operation;
      }
      [Mr]() {
        return false;
      }
    };
    Ui = class extends XFAObject {
      constructor(e3) {
        super(Hn, "ui", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.picture = null;
        this.barcode = null;
        this.button = null;
        this.checkButton = null;
        this.choiceList = null;
        this.dateTimeEdit = null;
        this.defaultUi = null;
        this.imageEdit = null;
        this.numericEdit = null;
        this.passwordEdit = null;
        this.signature = null;
        this.textEdit = null;
      }
      [lr]() {
        if (void 0 === this[ar]) {
          for (const e3 of Object.getOwnPropertyNames(this)) {
            if ("extras" === e3 || "picture" === e3)
              continue;
            const t3 = this[e3];
            if (t3 instanceof XFAObject) {
              this[ar] = t3;
              return t3;
            }
          }
          this[ar] = null;
        }
        return this[ar];
      }
      [an](e3) {
        const t3 = this[lr]();
        return t3 ? t3[an](e3) : HTMLResult.EMPTY;
      }
    };
    Validate = class extends XFAObject {
      constructor(e3) {
        super(Hn, "validate", true);
        this.formatTest = getStringOption(e3.formatTest, ["warning", "disabled", "error"]);
        this.id = e3.id || "";
        this.nullTest = getStringOption(e3.nullTest, ["disabled", "error", "warning"]);
        this.scriptTest = getStringOption(e3.scriptTest, ["error", "disabled", "warning"]);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.extras = null;
        this.message = null;
        this.picture = null;
        this.script = null;
      }
    };
    Value = class extends XFAObject {
      constructor(e3) {
        super(Hn, "value", true);
        this.id = e3.id || "";
        this.override = getInteger({ data: e3.override, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.relevant = getRelevant(e3.relevant);
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.arc = null;
        this.boolean = null;
        this.date = null;
        this.dateTime = null;
        this.decimal = null;
        this.exData = null;
        this.float = null;
        this.image = null;
        this.integer = null;
        this.line = null;
        this.rectangle = null;
        this.text = null;
        this.time = null;
      }
      [$r](e3) {
        var _a3;
        const t3 = this[pr]();
        if (t3 instanceof Field && ((_a3 = t3.ui) == null ? void 0 : _a3.imageEdit)) {
          if (!this.image) {
            this.image = new Image2({});
            this[Xs](this.image);
          }
          this.image[er] = e3[er];
          return;
        }
        const i3 = e3[Yr];
        if (null === this[i3]) {
          for (const e4 of Object.getOwnPropertyNames(this)) {
            const t4 = this[e4];
            if (t4 instanceof XFAObject) {
              this[e4] = null;
              this[jr](t4);
            }
          }
          this[e3[Yr]] = e3;
          this[Xs](e3);
        } else
          this[i3][er] = e3[er];
      }
      [en]() {
        if (this.exData)
          return "string" == typeof this.exData[er] ? this.exData[er].trim() : this.exData[er][en]().trim();
        for (const e3 of Object.getOwnPropertyNames(this)) {
          if ("image" === e3)
            continue;
          const t3 = this[e3];
          if (t3 instanceof XFAObject)
            return (t3[er] || "").toString().trim();
        }
        return null;
      }
      [an](e3) {
        for (const t3 of Object.getOwnPropertyNames(this)) {
          const i3 = this[t3];
          if (i3 instanceof XFAObject)
            return i3[an](e3);
        }
        return HTMLResult.EMPTY;
      }
    };
    Variables = class extends XFAObject {
      constructor(e3) {
        super(Hn, "variables", true);
        this.id = e3.id || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
        this.boolean = new XFAObjectArray();
        this.date = new XFAObjectArray();
        this.dateTime = new XFAObjectArray();
        this.decimal = new XFAObjectArray();
        this.exData = new XFAObjectArray();
        this.float = new XFAObjectArray();
        this.image = new XFAObjectArray();
        this.integer = new XFAObjectArray();
        this.manifest = new XFAObjectArray();
        this.script = new XFAObjectArray();
        this.text = new XFAObjectArray();
        this.time = new XFAObjectArray();
      }
      [Mr]() {
        return true;
      }
    };
    TemplateNamespace = class _TemplateNamespace {
      static [on](e3, t3) {
        if (_TemplateNamespace.hasOwnProperty(e3)) {
          const i3 = _TemplateNamespace[e3](t3);
          i3[_r2](t3);
          return i3;
        }
      }
      static appearanceFilter(e3) {
        return new AppearanceFilter(e3);
      }
      static arc(e3) {
        return new Arc(e3);
      }
      static area(e3) {
        return new Area(e3);
      }
      static assist(e3) {
        return new Assist(e3);
      }
      static barcode(e3) {
        return new Barcode(e3);
      }
      static bind(e3) {
        return new Bind(e3);
      }
      static bindItems(e3) {
        return new BindItems(e3);
      }
      static bookend(e3) {
        return new Bookend(e3);
      }
      static boolean(e3) {
        return new BooleanElement(e3);
      }
      static border(e3) {
        return new Border(e3);
      }
      static break(e3) {
        return new Break(e3);
      }
      static breakAfter(e3) {
        return new BreakAfter(e3);
      }
      static breakBefore(e3) {
        return new BreakBefore(e3);
      }
      static button(e3) {
        return new Button(e3);
      }
      static calculate(e3) {
        return new Calculate(e3);
      }
      static caption(e3) {
        return new Caption(e3);
      }
      static certificate(e3) {
        return new Certificate(e3);
      }
      static certificates(e3) {
        return new Certificates(e3);
      }
      static checkButton(e3) {
        return new CheckButton(e3);
      }
      static choiceList(e3) {
        return new ChoiceList(e3);
      }
      static color(e3) {
        return new Color(e3);
      }
      static comb(e3) {
        return new Comb(e3);
      }
      static connect(e3) {
        return new Connect(e3);
      }
      static contentArea(e3) {
        return new ContentArea(e3);
      }
      static corner(e3) {
        return new Corner(e3);
      }
      static date(e3) {
        return new DateElement(e3);
      }
      static dateTime(e3) {
        return new DateTime(e3);
      }
      static dateTimeEdit(e3) {
        return new DateTimeEdit(e3);
      }
      static decimal(e3) {
        return new Decimal(e3);
      }
      static defaultUi(e3) {
        return new DefaultUi(e3);
      }
      static desc(e3) {
        return new Desc(e3);
      }
      static digestMethod(e3) {
        return new DigestMethod(e3);
      }
      static digestMethods(e3) {
        return new DigestMethods(e3);
      }
      static draw(e3) {
        return new Draw(e3);
      }
      static edge(e3) {
        return new Edge(e3);
      }
      static encoding(e3) {
        return new Encoding(e3);
      }
      static encodings(e3) {
        return new Encodings(e3);
      }
      static encrypt(e3) {
        return new Encrypt(e3);
      }
      static encryptData(e3) {
        return new EncryptData(e3);
      }
      static encryption(e3) {
        return new Encryption(e3);
      }
      static encryptionMethod(e3) {
        return new EncryptionMethod(e3);
      }
      static encryptionMethods(e3) {
        return new EncryptionMethods(e3);
      }
      static event(e3) {
        return new Event2(e3);
      }
      static exData(e3) {
        return new ExData(e3);
      }
      static exObject(e3) {
        return new ExObject(e3);
      }
      static exclGroup(e3) {
        return new ExclGroup(e3);
      }
      static execute(e3) {
        return new Execute(e3);
      }
      static extras(e3) {
        return new Extras(e3);
      }
      static field(e3) {
        return new Field(e3);
      }
      static fill(e3) {
        return new Fill(e3);
      }
      static filter(e3) {
        return new Filter(e3);
      }
      static float(e3) {
        return new Float(e3);
      }
      static font(e3) {
        return new template_Font(e3);
      }
      static format(e3) {
        return new Format(e3);
      }
      static handler(e3) {
        return new Handler(e3);
      }
      static hyphenation(e3) {
        return new Hyphenation(e3);
      }
      static image(e3) {
        return new Image2(e3);
      }
      static imageEdit(e3) {
        return new ImageEdit(e3);
      }
      static integer(e3) {
        return new Integer(e3);
      }
      static issuers(e3) {
        return new Issuers(e3);
      }
      static items(e3) {
        return new Items(e3);
      }
      static keep(e3) {
        return new Keep(e3);
      }
      static keyUsage(e3) {
        return new KeyUsage(e3);
      }
      static line(e3) {
        return new Line(e3);
      }
      static linear(e3) {
        return new Linear(e3);
      }
      static lockDocument(e3) {
        return new LockDocument(e3);
      }
      static manifest(e3) {
        return new Manifest(e3);
      }
      static margin(e3) {
        return new Margin(e3);
      }
      static mdp(e3) {
        return new Mdp(e3);
      }
      static medium(e3) {
        return new Medium(e3);
      }
      static message(e3) {
        return new Message(e3);
      }
      static numericEdit(e3) {
        return new NumericEdit(e3);
      }
      static occur(e3) {
        return new Occur(e3);
      }
      static oid(e3) {
        return new Oid(e3);
      }
      static oids(e3) {
        return new Oids(e3);
      }
      static overflow(e3) {
        return new Overflow(e3);
      }
      static pageArea(e3) {
        return new PageArea(e3);
      }
      static pageSet(e3) {
        return new PageSet(e3);
      }
      static para(e3) {
        return new Para(e3);
      }
      static passwordEdit(e3) {
        return new PasswordEdit(e3);
      }
      static pattern(e3) {
        return new template_Pattern(e3);
      }
      static picture(e3) {
        return new Picture(e3);
      }
      static proto(e3) {
        return new Proto(e3);
      }
      static radial(e3) {
        return new Radial(e3);
      }
      static reason(e3) {
        return new Reason(e3);
      }
      static reasons(e3) {
        return new Reasons(e3);
      }
      static rectangle(e3) {
        return new Rectangle(e3);
      }
      static ref(e3) {
        return new RefElement(e3);
      }
      static script(e3) {
        return new Script(e3);
      }
      static setProperty(e3) {
        return new SetProperty(e3);
      }
      static signData(e3) {
        return new SignData(e3);
      }
      static signature(e3) {
        return new Signature(e3);
      }
      static signing(e3) {
        return new Signing(e3);
      }
      static solid(e3) {
        return new Solid(e3);
      }
      static speak(e3) {
        return new Speak(e3);
      }
      static stipple(e3) {
        return new Stipple(e3);
      }
      static subform(e3) {
        return new Subform(e3);
      }
      static subformSet(e3) {
        return new SubformSet(e3);
      }
      static subjectDN(e3) {
        return new SubjectDN(e3);
      }
      static subjectDNs(e3) {
        return new SubjectDNs(e3);
      }
      static submit(e3) {
        return new Submit(e3);
      }
      static template(e3) {
        return new Template(e3);
      }
      static text(e3) {
        return new Text(e3);
      }
      static textEdit(e3) {
        return new TextEdit(e3);
      }
      static time(e3) {
        return new Time(e3);
      }
      static timeStamp(e3) {
        return new TimeStamp(e3);
      }
      static toolTip(e3) {
        return new ToolTip(e3);
      }
      static traversal(e3) {
        return new Traversal(e3);
      }
      static traverse(e3) {
        return new Traverse(e3);
      }
      static ui(e3) {
        return new Ui(e3);
      }
      static validate(e3) {
        return new Validate(e3);
      }
      static value(e3) {
        return new Value(e3);
      }
      static variables(e3) {
        return new Variables(e3);
      }
    };
    Tn = gn.datasets.id;
    Binder = class {
      constructor(e3) {
        var _a3;
        this.root = e3;
        this.datasets = e3.datasets;
        this.data = ((_a3 = e3.datasets) == null ? void 0 : _a3.data) || new XmlObject(gn.datasets.id, "data");
        this.emptyMerge = 0 === this.data[Er]().length;
        this.root.form = this.form = e3.template[$s]();
      }
      _isConsumeData() {
        return !this.emptyMerge && this._mergeMode;
      }
      _isMatchTemplate() {
        return !this._isConsumeData();
      }
      bind() {
        this._bindElement(this.form, this.data);
        return this.form;
      }
      getData() {
        return this.data;
      }
      _bindValue(e3, t3, i3) {
        var _a3, _b2;
        e3[tr] = t3;
        if (e3[wr]())
          if (t3[Nr]()) {
            const i4 = t3[hr]();
            e3[$r](createText(i4));
          } else if (e3 instanceof Field && "multiSelect" === ((_b2 = (_a3 = e3.ui) == null ? void 0 : _a3.choiceList) == null ? void 0 : _b2.open)) {
            const i4 = t3[Er]().map((e4) => e4[er].trim()).join("\n");
            e3[$r](createText(i4));
          } else
            this._isConsumeData() && warn("XFA - Nodes haven't the same type.");
        else
          !t3[Nr]() || this._isMatchTemplate() ? this._bindElement(e3, t3) : warn("XFA - Nodes haven't the same type.");
      }
      _findDataByNameToConsume(e3, t3, i3, a3) {
        if (!e3)
          return null;
        let s3, r3;
        for (let a4 = 0; a4 < 3; a4++) {
          s3 = i3[Qr](e3, false, true);
          for (; ; ) {
            r3 = s3.next().value;
            if (!r3)
              break;
            if (t3 === r3[Nr]())
              return r3;
          }
          if (i3[Jr] === gn.datasets.id && "data" === i3[Yr])
            break;
          i3 = i3[pr]();
        }
        if (!a3)
          return null;
        s3 = this.data[Qr](e3, true, false);
        r3 = s3.next().value;
        if (r3)
          return r3;
        s3 = this.data[nr](e3, true);
        r3 = s3.next().value;
        return (r3 == null ? void 0 : r3[Nr]()) ? r3 : null;
      }
      _setProperties(e3, t3) {
        if (e3.hasOwnProperty("setProperty"))
          for (const { ref: i3, target: a3, connection: s3 } of e3.setProperty.children) {
            if (s3)
              continue;
            if (!i3)
              continue;
            const r3 = searchNode(this.root, t3, i3, false, false);
            if (!r3) {
              warn(`XFA - Invalid reference: ${i3}.`);
              continue;
            }
            const [n3] = r3;
            if (!n3[Rr](this.data)) {
              warn("XFA - Invalid node: must be a data node.");
              continue;
            }
            const o3 = searchNode(this.root, e3, a3, false, false);
            if (!o3) {
              warn(`XFA - Invalid target: ${a3}.`);
              continue;
            }
            const [g3] = o3;
            if (!g3[Rr](e3)) {
              warn("XFA - Invalid target: must be a property or subproperty.");
              continue;
            }
            const c3 = g3[pr]();
            if (g3 instanceof SetProperty || c3 instanceof SetProperty) {
              warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");
              continue;
            }
            if (g3 instanceof BindItems || c3 instanceof BindItems) {
              warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");
              continue;
            }
            const C3 = n3[en](), h2 = g3[Yr];
            if (g3 instanceof XFAAttribute) {
              const e4 = /* @__PURE__ */ Object.create(null);
              e4[h2] = C3;
              const t4 = Reflect.construct(Object.getPrototypeOf(c3).constructor, [e4]);
              c3[h2] = t4[h2];
            } else if (g3.hasOwnProperty(er)) {
              g3[tr] = n3;
              g3[er] = C3;
              g3[sr]();
            } else
              warn("XFA - Invalid node to use in setProperty");
          }
      }
      _bindItems(e3, t3) {
        if (!e3.hasOwnProperty("items") || !e3.hasOwnProperty("bindItems") || e3.bindItems.isEmpty())
          return;
        for (const t4 of e3.items.children)
          e3[jr](t4);
        e3.items.clear();
        const i3 = new Items({}), a3 = new Items({});
        e3[Xs](i3);
        e3.items.push(i3);
        e3[Xs](a3);
        e3.items.push(a3);
        for (const { ref: s3, labelRef: r3, valueRef: n3, connection: o3 } of e3.bindItems.children) {
          if (o3)
            continue;
          if (!s3)
            continue;
          const e4 = searchNode(this.root, t3, s3, false, false);
          if (e4)
            for (const t4 of e4) {
              if (!t4[Rr](this.datasets)) {
                warn(`XFA - Invalid ref (${s3}): must be a datasets child.`);
                continue;
              }
              const e5 = searchNode(this.root, t4, r3, true, false);
              if (!e5) {
                warn(`XFA - Invalid label: ${r3}.`);
                continue;
              }
              const [o4] = e5;
              if (!o4[Rr](this.datasets)) {
                warn("XFA - Invalid label: must be a datasets child.");
                continue;
              }
              const g3 = searchNode(this.root, t4, n3, true, false);
              if (!g3) {
                warn(`XFA - Invalid value: ${n3}.`);
                continue;
              }
              const [c3] = g3;
              if (!c3[Rr](this.datasets)) {
                warn("XFA - Invalid value: must be a datasets child.");
                continue;
              }
              const C3 = createText(o4[en]()), h2 = createText(c3[en]());
              i3[Xs](C3);
              i3.text.push(C3);
              a3[Xs](h2);
              a3.text.push(h2);
            }
          else
            warn(`XFA - Invalid reference: ${s3}.`);
        }
      }
      _bindOccurrences(e3, t3, i3) {
        let a3;
        if (t3.length > 1) {
          a3 = e3[$s]();
          a3[jr](a3.occur);
          a3.occur = null;
        }
        this._bindValue(e3, t3[0], i3);
        this._setProperties(e3, t3[0]);
        this._bindItems(e3, t3[0]);
        if (1 === t3.length)
          return;
        const s3 = e3[pr](), r3 = e3[Yr], n3 = s3[Dr](e3);
        for (let e4 = 1, o3 = t3.length; e4 < o3; e4++) {
          const o4 = t3[e4], g3 = a3[$s]();
          s3[r3].push(g3);
          s3[Fr](n3 + e4, g3);
          this._bindValue(g3, o4, i3);
          this._setProperties(g3, o4);
          this._bindItems(g3, o4);
        }
      }
      _createOccurrences(e3) {
        if (!this.emptyMerge)
          return;
        const { occur: t3 } = e3;
        if (!t3 || t3.initial <= 1)
          return;
        const i3 = e3[pr](), a3 = e3[Yr];
        if (!(i3[a3] instanceof XFAObjectArray))
          return;
        let s3;
        s3 = e3.name ? i3[a3].children.filter((t4) => t4.name === e3.name).length : i3[a3].children.length;
        const r3 = i3[Dr](e3) + 1, n3 = t3.initial - s3;
        if (n3) {
          const t4 = e3[$s]();
          t4[jr](t4.occur);
          t4.occur = null;
          i3[a3].push(t4);
          i3[Fr](r3, t4);
          for (let e4 = 1; e4 < n3; e4++) {
            const s4 = t4[$s]();
            i3[a3].push(s4);
            i3[Fr](r3 + e4, s4);
          }
        }
      }
      _getOccurInfo(e3) {
        const { name: t3, occur: i3 } = e3;
        if (!i3 || !t3)
          return [1, 1];
        const a3 = -1 === i3.max ? 1 / 0 : i3.max;
        return [i3.min, a3];
      }
      _setAndBind(e3, t3) {
        this._setProperties(e3, t3);
        this._bindItems(e3, t3);
        this._bindElement(e3, t3);
      }
      _bindElement(e3, t3) {
        const i3 = [];
        this._createOccurrences(e3);
        for (const a3 of e3[Er]()) {
          if (a3[tr])
            continue;
          if (void 0 === this._mergeMode && "subform" === a3[Yr]) {
            this._mergeMode = "consumeData" === a3.mergeMode;
            const e5 = t3[Er]();
            if (e5.length > 0)
              this._bindOccurrences(a3, [e5[0]], null);
            else if (this.emptyMerge) {
              const e6 = t3[Jr] === Tn ? -1 : t3[Jr], i4 = a3[tr] = new XmlObject(e6, a3.name || "root");
              t3[Xs](i4);
              this._bindElement(a3, i4);
            }
            continue;
          }
          if (!a3[kr]())
            continue;
          let e4 = false, s3 = null, r3 = null, n3 = null;
          if (a3.bind) {
            switch (a3.bind.match) {
              case "none":
                this._setAndBind(a3, t3);
                continue;
              case "global":
                e4 = true;
                break;
              case "dataRef":
                if (!a3.bind.ref) {
                  warn(`XFA - ref is empty in node ${a3[Yr]}.`);
                  this._setAndBind(a3, t3);
                  continue;
                }
                r3 = a3.bind.ref;
            }
            a3.bind.picture && (s3 = a3.bind.picture[er]);
          }
          const [o3, g3] = this._getOccurInfo(a3);
          if (r3) {
            n3 = searchNode(this.root, t3, r3, true, false);
            if (null === n3) {
              n3 = createDataNode(this.data, t3, r3);
              if (!n3)
                continue;
              this._isConsumeData() && (n3[Ar] = true);
              this._setAndBind(a3, n3);
              continue;
            }
            this._isConsumeData() && (n3 = n3.filter((e5) => !e5[Ar]));
            n3.length > g3 ? n3 = n3.slice(0, g3) : 0 === n3.length && (n3 = null);
            n3 && this._isConsumeData() && n3.forEach((e5) => {
              e5[Ar] = true;
            });
          } else {
            if (!a3.name) {
              this._setAndBind(a3, t3);
              continue;
            }
            if (this._isConsumeData()) {
              const i4 = [];
              for (; i4.length < g3; ) {
                const s4 = this._findDataByNameToConsume(a3.name, a3[wr](), t3, e4);
                if (!s4)
                  break;
                s4[Ar] = true;
                i4.push(s4);
              }
              n3 = i4.length > 0 ? i4 : null;
            } else {
              n3 = t3[Qr](a3.name, false, this.emptyMerge).next().value;
              if (!n3) {
                if (0 === o3) {
                  i3.push(a3);
                  continue;
                }
                const e5 = t3[Jr] === Tn ? -1 : t3[Jr];
                n3 = a3[tr] = new XmlObject(e5, a3.name);
                this.emptyMerge && (n3[Ar] = true);
                t3[Xs](n3);
                this._setAndBind(a3, n3);
                continue;
              }
              this.emptyMerge && (n3[Ar] = true);
              n3 = [n3];
            }
          }
          n3 ? this._bindOccurrences(a3, n3, s3) : o3 > 0 ? this._setAndBind(a3, t3) : i3.push(a3);
        }
        i3.forEach((e4) => e4[pr]()[jr](e4));
      }
    };
    DataHandler = class {
      constructor(e3, t3) {
        this.data = t3;
        this.dataset = e3.datasets || null;
      }
      serialize(e3) {
        const t3 = [[-1, this.data[Er]()]];
        for (; t3.length > 0; ) {
          const i4 = t3.at(-1), [a3, s3] = i4;
          if (a3 + 1 === s3.length) {
            t3.pop();
            continue;
          }
          const r3 = s3[++i4[0]], n3 = e3.get(r3[nn]);
          if (n3)
            r3[$r](n3);
          else {
            const t4 = r3[or]();
            for (const i5 of t4.values()) {
              const t5 = e3.get(i5[nn]);
              if (t5) {
                i5[$r](t5);
                break;
              }
            }
          }
          const o3 = r3[Er]();
          o3.length > 0 && t3.push([-1, o3]);
        }
        const i3 = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
        if (this.dataset)
          for (const e4 of this.dataset[Er]())
            "data" !== e4[Yr] && e4[sn](i3);
        this.data[sn](i3);
        i3.push("</xfa:datasets>");
        return i3.join("");
      }
    };
    qn = gn.config.id;
    Acrobat = class extends XFAObject {
      constructor(e3) {
        super(qn, "acrobat", true);
        this.acrobat7 = null;
        this.autoSave = null;
        this.common = null;
        this.validate = null;
        this.validateApprovalSignatures = null;
        this.submitUrl = new XFAObjectArray();
      }
    };
    Acrobat7 = class extends XFAObject {
      constructor(e3) {
        super(qn, "acrobat7", true);
        this.dynamicRender = null;
      }
    };
    ADBE_JSConsole = class extends OptionObject {
      constructor(e3) {
        super(qn, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
      }
    };
    ADBE_JSDebugger = class extends OptionObject {
      constructor(e3) {
        super(qn, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
      }
    };
    AddSilentPrint = class extends Option01 {
      constructor(e3) {
        super(qn, "addSilentPrint");
      }
    };
    AddViewerPreferences = class extends Option01 {
      constructor(e3) {
        super(qn, "addViewerPreferences");
      }
    };
    AdjustData = class extends Option10 {
      constructor(e3) {
        super(qn, "adjustData");
      }
    };
    AdobeExtensionLevel = class extends IntegerObject {
      constructor(e3) {
        super(qn, "adobeExtensionLevel", 0, (e4) => e4 >= 1 && e4 <= 8);
      }
    };
    Agent = class extends XFAObject {
      constructor(e3) {
        super(qn, "agent", true);
        this.name = e3.name ? e3.name.trim() : "";
        this.common = new XFAObjectArray();
      }
    };
    AlwaysEmbed = class extends ContentObject {
      constructor(e3) {
        super(qn, "alwaysEmbed");
      }
    };
    Amd = class extends StringObject {
      constructor(e3) {
        super(qn, "amd");
      }
    };
    config_Area = class extends XFAObject {
      constructor(e3) {
        super(qn, "area");
        this.level = getInteger({ data: e3.level, defaultValue: 0, validate: (e4) => e4 >= 1 && e4 <= 3 });
        this.name = getStringOption(e3.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
      }
    };
    Attributes = class extends OptionObject {
      constructor(e3) {
        super(qn, "attributes", ["preserve", "delegate", "ignore"]);
      }
    };
    AutoSave = class extends OptionObject {
      constructor(e3) {
        super(qn, "autoSave", ["disabled", "enabled"]);
      }
    };
    Base = class extends StringObject {
      constructor(e3) {
        super(qn, "base");
      }
    };
    BatchOutput = class extends XFAObject {
      constructor(e3) {
        super(qn, "batchOutput");
        this.format = getStringOption(e3.format, ["none", "concat", "zip", "zipCompress"]);
      }
    };
    BehaviorOverride = class extends ContentObject {
      constructor(e3) {
        super(qn, "behaviorOverride");
      }
      [sr]() {
        this[er] = new Map(this[er].trim().split(/\s+/).filter((e3) => e3.includes(":")).map((e3) => e3.split(":", 2)));
      }
    };
    Cache = class extends XFAObject {
      constructor(e3) {
        super(qn, "cache", true);
        this.templateCache = null;
      }
    };
    Change = class extends Option01 {
      constructor(e3) {
        super(qn, "change");
      }
    };
    Common = class extends XFAObject {
      constructor(e3) {
        super(qn, "common", true);
        this.data = null;
        this.locale = null;
        this.localeSet = null;
        this.messaging = null;
        this.suppressBanner = null;
        this.template = null;
        this.validationMessaging = null;
        this.versionControl = null;
        this.log = new XFAObjectArray();
      }
    };
    Compress = class extends XFAObject {
      constructor(e3) {
        super(qn, "compress");
        this.scope = getStringOption(e3.scope, ["imageOnly", "document"]);
      }
    };
    CompressLogicalStructure = class extends Option01 {
      constructor(e3) {
        super(qn, "compressLogicalStructure");
      }
    };
    CompressObjectStream = class extends Option10 {
      constructor(e3) {
        super(qn, "compressObjectStream");
      }
    };
    Compression = class extends XFAObject {
      constructor(e3) {
        super(qn, "compression", true);
        this.compressLogicalStructure = null;
        this.compressObjectStream = null;
        this.level = null;
        this.type = null;
      }
    };
    Config = class extends XFAObject {
      constructor(e3) {
        super(qn, "config", true);
        this.acrobat = null;
        this.present = null;
        this.trace = null;
        this.agent = new XFAObjectArray();
      }
    };
    Conformance = class extends OptionObject {
      constructor(e3) {
        super(qn, "conformance", ["A", "B"]);
      }
    };
    ContentCopy = class extends Option01 {
      constructor(e3) {
        super(qn, "contentCopy");
      }
    };
    Copies = class extends IntegerObject {
      constructor(e3) {
        super(qn, "copies", 1, (e4) => e4 >= 1);
      }
    };
    Creator = class extends StringObject {
      constructor(e3) {
        super(qn, "creator");
      }
    };
    CurrentPage = class extends IntegerObject {
      constructor(e3) {
        super(qn, "currentPage", 0, (e4) => e4 >= 0);
      }
    };
    Data = class extends XFAObject {
      constructor(e3) {
        super(qn, "data", true);
        this.adjustData = null;
        this.attributes = null;
        this.incrementalLoad = null;
        this.outputXSL = null;
        this.range = null;
        this.record = null;
        this.startNode = null;
        this.uri = null;
        this.window = null;
        this.xsl = null;
        this.excludeNS = new XFAObjectArray();
        this.transform = new XFAObjectArray();
      }
    };
    Debug = class extends XFAObject {
      constructor(e3) {
        super(qn, "debug", true);
        this.uri = null;
      }
    };
    DefaultTypeface = class extends ContentObject {
      constructor(e3) {
        super(qn, "defaultTypeface");
        this.writingScript = getStringOption(e3.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
      }
    };
    Destination = class extends OptionObject {
      constructor(e3) {
        super(qn, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
      }
    };
    DocumentAssembly = class extends Option01 {
      constructor(e3) {
        super(qn, "documentAssembly");
      }
    };
    Driver = class extends XFAObject {
      constructor(e3) {
        super(qn, "driver", true);
        this.name = e3.name ? e3.name.trim() : "";
        this.fontInfo = null;
        this.xdc = null;
      }
    };
    DuplexOption = class extends OptionObject {
      constructor(e3) {
        super(qn, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
      }
    };
    DynamicRender = class extends OptionObject {
      constructor(e3) {
        super(qn, "dynamicRender", ["forbidden", "required"]);
      }
    };
    Embed = class extends Option01 {
      constructor(e3) {
        super(qn, "embed");
      }
    };
    config_Encrypt = class extends Option01 {
      constructor(e3) {
        super(qn, "encrypt");
      }
    };
    config_Encryption = class extends XFAObject {
      constructor(e3) {
        super(qn, "encryption", true);
        this.encrypt = null;
        this.encryptionLevel = null;
        this.permissions = null;
      }
    };
    EncryptionLevel = class extends OptionObject {
      constructor(e3) {
        super(qn, "encryptionLevel", ["40bit", "128bit"]);
      }
    };
    Enforce = class extends StringObject {
      constructor(e3) {
        super(qn, "enforce");
      }
    };
    Equate = class extends XFAObject {
      constructor(e3) {
        super(qn, "equate");
        this.force = getInteger({ data: e3.force, defaultValue: 1, validate: (e4) => 0 === e4 });
        this.from = e3.from || "";
        this.to = e3.to || "";
      }
    };
    EquateRange = class extends XFAObject {
      constructor(e3) {
        super(qn, "equateRange");
        this.from = e3.from || "";
        this.to = e3.to || "";
        this._unicodeRange = e3.unicodeRange || "";
      }
      get unicodeRange() {
        const e3 = [], t3 = /U\+([0-9a-fA-F]+)/, i3 = this._unicodeRange;
        for (let a3 of i3.split(",").map((e4) => e4.trim()).filter((e4) => !!e4)) {
          a3 = a3.split("-", 2).map((e4) => {
            const i4 = e4.match(t3);
            return i4 ? parseInt(i4[1], 16) : 0;
          });
          1 === a3.length && a3.push(a3[0]);
          e3.push(a3);
        }
        return shadow(this, "unicodeRange", e3);
      }
    };
    Exclude = class extends ContentObject {
      constructor(e3) {
        super(qn, "exclude");
      }
      [sr]() {
        this[er] = this[er].trim().split(/\s+/).filter((e3) => e3 && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e3));
      }
    };
    ExcludeNS = class extends StringObject {
      constructor(e3) {
        super(qn, "excludeNS");
      }
    };
    FlipLabel = class extends OptionObject {
      constructor(e3) {
        super(qn, "flipLabel", ["usePrinterSetting", "on", "off"]);
      }
    };
    config_FontInfo = class extends XFAObject {
      constructor(e3) {
        super(qn, "fontInfo", true);
        this.embed = null;
        this.map = null;
        this.subsetBelow = null;
        this.alwaysEmbed = new XFAObjectArray();
        this.defaultTypeface = new XFAObjectArray();
        this.neverEmbed = new XFAObjectArray();
      }
    };
    FormFieldFilling = class extends Option01 {
      constructor(e3) {
        super(qn, "formFieldFilling");
      }
    };
    GroupParent = class extends StringObject {
      constructor(e3) {
        super(qn, "groupParent");
      }
    };
    IfEmpty = class extends OptionObject {
      constructor(e3) {
        super(qn, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
      }
    };
    IncludeXDPContent = class extends StringObject {
      constructor(e3) {
        super(qn, "includeXDPContent");
      }
    };
    IncrementalLoad = class extends OptionObject {
      constructor(e3) {
        super(qn, "incrementalLoad", ["none", "forwardOnly"]);
      }
    };
    IncrementalMerge = class extends Option01 {
      constructor(e3) {
        super(qn, "incrementalMerge");
      }
    };
    Interactive = class extends Option01 {
      constructor(e3) {
        super(qn, "interactive");
      }
    };
    Jog = class extends OptionObject {
      constructor(e3) {
        super(qn, "jog", ["usePrinterSetting", "none", "pageSet"]);
      }
    };
    LabelPrinter = class extends XFAObject {
      constructor(e3) {
        super(qn, "labelPrinter", true);
        this.name = getStringOption(e3.name, ["zpl", "dpl", "ipl", "tcpl"]);
        this.batchOutput = null;
        this.flipLabel = null;
        this.fontInfo = null;
        this.xdc = null;
      }
    };
    Layout = class extends OptionObject {
      constructor(e3) {
        super(qn, "layout", ["paginate", "panel"]);
      }
    };
    Level = class extends IntegerObject {
      constructor(e3) {
        super(qn, "level", 0, (e4) => e4 > 0);
      }
    };
    Linearized = class extends Option01 {
      constructor(e3) {
        super(qn, "linearized");
      }
    };
    Locale = class extends StringObject {
      constructor(e3) {
        super(qn, "locale");
      }
    };
    LocaleSet = class extends StringObject {
      constructor(e3) {
        super(qn, "localeSet");
      }
    };
    Log = class extends XFAObject {
      constructor(e3) {
        super(qn, "log", true);
        this.mode = null;
        this.threshold = null;
        this.to = null;
        this.uri = null;
      }
    };
    MapElement = class extends XFAObject {
      constructor(e3) {
        super(qn, "map", true);
        this.equate = new XFAObjectArray();
        this.equateRange = new XFAObjectArray();
      }
    };
    MediumInfo = class extends XFAObject {
      constructor(e3) {
        super(qn, "mediumInfo", true);
        this.map = null;
      }
    };
    config_Message = class extends XFAObject {
      constructor(e3) {
        super(qn, "message", true);
        this.msgId = null;
        this.severity = null;
      }
    };
    Messaging = class extends XFAObject {
      constructor(e3) {
        super(qn, "messaging", true);
        this.message = new XFAObjectArray();
      }
    };
    Mode = class extends OptionObject {
      constructor(e3) {
        super(qn, "mode", ["append", "overwrite"]);
      }
    };
    ModifyAnnots = class extends Option01 {
      constructor(e3) {
        super(qn, "modifyAnnots");
      }
    };
    MsgId = class extends IntegerObject {
      constructor(e3) {
        super(qn, "msgId", 1, (e4) => e4 >= 1);
      }
    };
    NameAttr = class extends StringObject {
      constructor(e3) {
        super(qn, "nameAttr");
      }
    };
    NeverEmbed = class extends ContentObject {
      constructor(e3) {
        super(qn, "neverEmbed");
      }
    };
    NumberOfCopies = class extends IntegerObject {
      constructor(e3) {
        super(qn, "numberOfCopies", null, (e4) => e4 >= 2 && e4 <= 5);
      }
    };
    OpenAction = class extends XFAObject {
      constructor(e3) {
        super(qn, "openAction", true);
        this.destination = null;
      }
    };
    Output = class extends XFAObject {
      constructor(e3) {
        super(qn, "output", true);
        this.to = null;
        this.type = null;
        this.uri = null;
      }
    };
    OutputBin = class extends StringObject {
      constructor(e3) {
        super(qn, "outputBin");
      }
    };
    OutputXSL = class extends XFAObject {
      constructor(e3) {
        super(qn, "outputXSL", true);
        this.uri = null;
      }
    };
    Overprint = class extends OptionObject {
      constructor(e3) {
        super(qn, "overprint", ["none", "both", "draw", "field"]);
      }
    };
    Packets = class extends StringObject {
      constructor(e3) {
        super(qn, "packets");
      }
      [sr]() {
        "*" !== this[er] && (this[er] = this[er].trim().split(/\s+/).filter((e3) => ["config", "datasets", "template", "xfdf", "xslt"].includes(e3)));
      }
    };
    PageOffset = class extends XFAObject {
      constructor(e3) {
        super(qn, "pageOffset");
        this.x = getInteger({ data: e3.x, defaultValue: "useXDCSetting", validate: (e4) => true });
        this.y = getInteger({ data: e3.y, defaultValue: "useXDCSetting", validate: (e4) => true });
      }
    };
    PageRange = class extends StringObject {
      constructor(e3) {
        super(qn, "pageRange");
      }
      [sr]() {
        const e3 = this[er].trim().split(/\s+/).map((e4) => parseInt(e4, 10)), t3 = [];
        for (let i3 = 0, a3 = e3.length; i3 < a3; i3 += 2)
          t3.push(e3.slice(i3, i3 + 2));
        this[er] = t3;
      }
    };
    Pagination = class extends OptionObject {
      constructor(e3) {
        super(qn, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
      }
    };
    PaginationOverride = class extends OptionObject {
      constructor(e3) {
        super(qn, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
      }
    };
    Part = class extends IntegerObject {
      constructor(e3) {
        super(qn, "part", 1, (e4) => false);
      }
    };
    Pcl = class extends XFAObject {
      constructor(e3) {
        super(qn, "pcl", true);
        this.name = e3.name || "";
        this.batchOutput = null;
        this.fontInfo = null;
        this.jog = null;
        this.mediumInfo = null;
        this.outputBin = null;
        this.pageOffset = null;
        this.staple = null;
        this.xdc = null;
      }
    };
    Pdf = class extends XFAObject {
      constructor(e3) {
        super(qn, "pdf", true);
        this.name = e3.name || "";
        this.adobeExtensionLevel = null;
        this.batchOutput = null;
        this.compression = null;
        this.creator = null;
        this.encryption = null;
        this.fontInfo = null;
        this.interactive = null;
        this.linearized = null;
        this.openAction = null;
        this.pdfa = null;
        this.producer = null;
        this.renderPolicy = null;
        this.scriptModel = null;
        this.silentPrint = null;
        this.submitFormat = null;
        this.tagged = null;
        this.version = null;
        this.viewerPreferences = null;
        this.xdc = null;
      }
    };
    Pdfa = class extends XFAObject {
      constructor(e3) {
        super(qn, "pdfa", true);
        this.amd = null;
        this.conformance = null;
        this.includeXDPContent = null;
        this.part = null;
      }
    };
    Permissions = class extends XFAObject {
      constructor(e3) {
        super(qn, "permissions", true);
        this.accessibleContent = null;
        this.change = null;
        this.contentCopy = null;
        this.documentAssembly = null;
        this.formFieldFilling = null;
        this.modifyAnnots = null;
        this.plaintextMetadata = null;
        this.print = null;
        this.printHighQuality = null;
      }
    };
    PickTrayByPDFSize = class extends Option01 {
      constructor(e3) {
        super(qn, "pickTrayByPDFSize");
      }
    };
    config_Picture = class extends StringObject {
      constructor(e3) {
        super(qn, "picture");
      }
    };
    PlaintextMetadata = class extends Option01 {
      constructor(e3) {
        super(qn, "plaintextMetadata");
      }
    };
    Presence = class extends OptionObject {
      constructor(e3) {
        super(qn, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
      }
    };
    Present = class extends XFAObject {
      constructor(e3) {
        super(qn, "present", true);
        this.behaviorOverride = null;
        this.cache = null;
        this.common = null;
        this.copies = null;
        this.destination = null;
        this.incrementalMerge = null;
        this.layout = null;
        this.output = null;
        this.overprint = null;
        this.pagination = null;
        this.paginationOverride = null;
        this.script = null;
        this.validate = null;
        this.xdp = null;
        this.driver = new XFAObjectArray();
        this.labelPrinter = new XFAObjectArray();
        this.pcl = new XFAObjectArray();
        this.pdf = new XFAObjectArray();
        this.ps = new XFAObjectArray();
        this.submitUrl = new XFAObjectArray();
        this.webClient = new XFAObjectArray();
        this.zpl = new XFAObjectArray();
      }
    };
    Print = class extends Option01 {
      constructor(e3) {
        super(qn, "print");
      }
    };
    PrintHighQuality = class extends Option01 {
      constructor(e3) {
        super(qn, "printHighQuality");
      }
    };
    PrintScaling = class extends OptionObject {
      constructor(e3) {
        super(qn, "printScaling", ["appdefault", "noScaling"]);
      }
    };
    PrinterName = class extends StringObject {
      constructor(e3) {
        super(qn, "printerName");
      }
    };
    Producer = class extends StringObject {
      constructor(e3) {
        super(qn, "producer");
      }
    };
    Ps = class extends XFAObject {
      constructor(e3) {
        super(qn, "ps", true);
        this.name = e3.name || "";
        this.batchOutput = null;
        this.fontInfo = null;
        this.jog = null;
        this.mediumInfo = null;
        this.outputBin = null;
        this.staple = null;
        this.xdc = null;
      }
    };
    Range = class extends ContentObject {
      constructor(e3) {
        super(qn, "range");
      }
      [sr]() {
        this[er] = this[er].trim().split(/\s*,\s*/, 2).map((e3) => e3.split("-").map((e4) => parseInt(e4.trim(), 10))).filter((e3) => e3.every((e4) => !isNaN(e4))).map((e3) => {
          1 === e3.length && e3.push(e3[0]);
          return e3;
        });
      }
    };
    Record = class extends ContentObject {
      constructor(e3) {
        super(qn, "record");
      }
      [sr]() {
        this[er] = this[er].trim();
        const e3 = parseInt(this[er], 10);
        !isNaN(e3) && e3 >= 0 && (this[er] = e3);
      }
    };
    Relevant = class extends ContentObject {
      constructor(e3) {
        super(qn, "relevant");
      }
      [sr]() {
        this[er] = this[er].trim().split(/\s+/);
      }
    };
    Rename = class extends ContentObject {
      constructor(e3) {
        super(qn, "rename");
      }
      [sr]() {
        this[er] = this[er].trim();
        (this[er].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[er])) && warn("XFA - Rename: invalid XFA name");
      }
    };
    RenderPolicy = class extends OptionObject {
      constructor(e3) {
        super(qn, "renderPolicy", ["server", "client"]);
      }
    };
    RunScripts = class extends OptionObject {
      constructor(e3) {
        super(qn, "runScripts", ["both", "client", "none", "server"]);
      }
    };
    config_Script = class extends XFAObject {
      constructor(e3) {
        super(qn, "script", true);
        this.currentPage = null;
        this.exclude = null;
        this.runScripts = null;
      }
    };
    ScriptModel = class extends OptionObject {
      constructor(e3) {
        super(qn, "scriptModel", ["XFA", "none"]);
      }
    };
    Severity = class extends OptionObject {
      constructor(e3) {
        super(qn, "severity", ["ignore", "error", "information", "trace", "warning"]);
      }
    };
    SilentPrint = class extends XFAObject {
      constructor(e3) {
        super(qn, "silentPrint", true);
        this.addSilentPrint = null;
        this.printerName = null;
      }
    };
    Staple = class extends XFAObject {
      constructor(e3) {
        super(qn, "staple");
        this.mode = getStringOption(e3.mode, ["usePrinterSetting", "on", "off"]);
      }
    };
    StartNode = class extends StringObject {
      constructor(e3) {
        super(qn, "startNode");
      }
    };
    StartPage = class extends IntegerObject {
      constructor(e3) {
        super(qn, "startPage", 0, (e4) => true);
      }
    };
    SubmitFormat = class extends OptionObject {
      constructor(e3) {
        super(qn, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
      }
    };
    SubmitUrl = class extends StringObject {
      constructor(e3) {
        super(qn, "submitUrl");
      }
    };
    SubsetBelow = class extends IntegerObject {
      constructor(e3) {
        super(qn, "subsetBelow", 100, (e4) => e4 >= 0 && e4 <= 100);
      }
    };
    SuppressBanner = class extends Option01 {
      constructor(e3) {
        super(qn, "suppressBanner");
      }
    };
    Tagged = class extends Option01 {
      constructor(e3) {
        super(qn, "tagged");
      }
    };
    config_Template = class extends XFAObject {
      constructor(e3) {
        super(qn, "template", true);
        this.base = null;
        this.relevant = null;
        this.startPage = null;
        this.uri = null;
        this.xsl = null;
      }
    };
    Threshold = class extends OptionObject {
      constructor(e3) {
        super(qn, "threshold", ["trace", "error", "information", "warning"]);
      }
    };
    To = class extends OptionObject {
      constructor(e3) {
        super(qn, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
      }
    };
    TemplateCache = class extends XFAObject {
      constructor(e3) {
        super(qn, "templateCache");
        this.maxEntries = getInteger({ data: e3.maxEntries, defaultValue: 5, validate: (e4) => e4 >= 0 });
      }
    };
    Trace = class extends XFAObject {
      constructor(e3) {
        super(qn, "trace", true);
        this.area = new XFAObjectArray();
      }
    };
    Transform = class extends XFAObject {
      constructor(e3) {
        super(qn, "transform", true);
        this.groupParent = null;
        this.ifEmpty = null;
        this.nameAttr = null;
        this.picture = null;
        this.presence = null;
        this.rename = null;
        this.whitespace = null;
      }
    };
    Type = class extends OptionObject {
      constructor(e3) {
        super(qn, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
      }
    };
    Uri = class extends StringObject {
      constructor(e3) {
        super(qn, "uri");
      }
    };
    config_Validate = class extends OptionObject {
      constructor(e3) {
        super(qn, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
      }
    };
    ValidateApprovalSignatures = class extends ContentObject {
      constructor(e3) {
        super(qn, "validateApprovalSignatures");
      }
      [sr]() {
        this[er] = this[er].trim().split(/\s+/).filter((e3) => ["docReady", "postSign"].includes(e3));
      }
    };
    ValidationMessaging = class extends OptionObject {
      constructor(e3) {
        super(qn, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
      }
    };
    Version = class extends OptionObject {
      constructor(e3) {
        super(qn, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
      }
    };
    VersionControl = class extends XFAObject {
      constructor(e3) {
        super(qn, "VersionControl");
        this.outputBelow = getStringOption(e3.outputBelow, ["warn", "error", "update"]);
        this.sourceAbove = getStringOption(e3.sourceAbove, ["warn", "error"]);
        this.sourceBelow = getStringOption(e3.sourceBelow, ["update", "maintain"]);
      }
    };
    ViewerPreferences = class extends XFAObject {
      constructor(e3) {
        super(qn, "viewerPreferences", true);
        this.ADBE_JSConsole = null;
        this.ADBE_JSDebugger = null;
        this.addViewerPreferences = null;
        this.duplexOption = null;
        this.enforce = null;
        this.numberOfCopies = null;
        this.pageRange = null;
        this.pickTrayByPDFSize = null;
        this.printScaling = null;
      }
    };
    WebClient = class extends XFAObject {
      constructor(e3) {
        super(qn, "webClient", true);
        this.name = e3.name ? e3.name.trim() : "";
        this.fontInfo = null;
        this.xdc = null;
      }
    };
    Whitespace = class extends OptionObject {
      constructor(e3) {
        super(qn, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
      }
    };
    Window = class extends ContentObject {
      constructor(e3) {
        super(qn, "window");
      }
      [sr]() {
        const e3 = this[er].trim().split(/\s*,\s*/, 2).map((e4) => parseInt(e4, 10));
        if (e3.some((e4) => isNaN(e4)))
          this[er] = [0, 0];
        else {
          1 === e3.length && e3.push(e3[0]);
          this[er] = e3;
        }
      }
    };
    Xdc = class extends XFAObject {
      constructor(e3) {
        super(qn, "xdc", true);
        this.uri = new XFAObjectArray();
        this.xsl = new XFAObjectArray();
      }
    };
    Xdp = class extends XFAObject {
      constructor(e3) {
        super(qn, "xdp", true);
        this.packets = null;
      }
    };
    Xsl = class extends XFAObject {
      constructor(e3) {
        super(qn, "xsl", true);
        this.debug = null;
        this.uri = null;
      }
    };
    Zpl = class extends XFAObject {
      constructor(e3) {
        super(qn, "zpl", true);
        this.name = e3.name ? e3.name.trim() : "";
        this.batchOutput = null;
        this.flipLabel = null;
        this.fontInfo = null;
        this.xdc = null;
      }
    };
    ConfigNamespace = class _ConfigNamespace {
      static [on](e3, t3) {
        if (_ConfigNamespace.hasOwnProperty(e3))
          return _ConfigNamespace[e3](t3);
      }
      static acrobat(e3) {
        return new Acrobat(e3);
      }
      static acrobat7(e3) {
        return new Acrobat7(e3);
      }
      static ADBE_JSConsole(e3) {
        return new ADBE_JSConsole(e3);
      }
      static ADBE_JSDebugger(e3) {
        return new ADBE_JSDebugger(e3);
      }
      static addSilentPrint(e3) {
        return new AddSilentPrint(e3);
      }
      static addViewerPreferences(e3) {
        return new AddViewerPreferences(e3);
      }
      static adjustData(e3) {
        return new AdjustData(e3);
      }
      static adobeExtensionLevel(e3) {
        return new AdobeExtensionLevel(e3);
      }
      static agent(e3) {
        return new Agent(e3);
      }
      static alwaysEmbed(e3) {
        return new AlwaysEmbed(e3);
      }
      static amd(e3) {
        return new Amd(e3);
      }
      static area(e3) {
        return new config_Area(e3);
      }
      static attributes(e3) {
        return new Attributes(e3);
      }
      static autoSave(e3) {
        return new AutoSave(e3);
      }
      static base(e3) {
        return new Base(e3);
      }
      static batchOutput(e3) {
        return new BatchOutput(e3);
      }
      static behaviorOverride(e3) {
        return new BehaviorOverride(e3);
      }
      static cache(e3) {
        return new Cache(e3);
      }
      static change(e3) {
        return new Change(e3);
      }
      static common(e3) {
        return new Common(e3);
      }
      static compress(e3) {
        return new Compress(e3);
      }
      static compressLogicalStructure(e3) {
        return new CompressLogicalStructure(e3);
      }
      static compressObjectStream(e3) {
        return new CompressObjectStream(e3);
      }
      static compression(e3) {
        return new Compression(e3);
      }
      static config(e3) {
        return new Config(e3);
      }
      static conformance(e3) {
        return new Conformance(e3);
      }
      static contentCopy(e3) {
        return new ContentCopy(e3);
      }
      static copies(e3) {
        return new Copies(e3);
      }
      static creator(e3) {
        return new Creator(e3);
      }
      static currentPage(e3) {
        return new CurrentPage(e3);
      }
      static data(e3) {
        return new Data(e3);
      }
      static debug(e3) {
        return new Debug(e3);
      }
      static defaultTypeface(e3) {
        return new DefaultTypeface(e3);
      }
      static destination(e3) {
        return new Destination(e3);
      }
      static documentAssembly(e3) {
        return new DocumentAssembly(e3);
      }
      static driver(e3) {
        return new Driver(e3);
      }
      static duplexOption(e3) {
        return new DuplexOption(e3);
      }
      static dynamicRender(e3) {
        return new DynamicRender(e3);
      }
      static embed(e3) {
        return new Embed(e3);
      }
      static encrypt(e3) {
        return new config_Encrypt(e3);
      }
      static encryption(e3) {
        return new config_Encryption(e3);
      }
      static encryptionLevel(e3) {
        return new EncryptionLevel(e3);
      }
      static enforce(e3) {
        return new Enforce(e3);
      }
      static equate(e3) {
        return new Equate(e3);
      }
      static equateRange(e3) {
        return new EquateRange(e3);
      }
      static exclude(e3) {
        return new Exclude(e3);
      }
      static excludeNS(e3) {
        return new ExcludeNS(e3);
      }
      static flipLabel(e3) {
        return new FlipLabel(e3);
      }
      static fontInfo(e3) {
        return new config_FontInfo(e3);
      }
      static formFieldFilling(e3) {
        return new FormFieldFilling(e3);
      }
      static groupParent(e3) {
        return new GroupParent(e3);
      }
      static ifEmpty(e3) {
        return new IfEmpty(e3);
      }
      static includeXDPContent(e3) {
        return new IncludeXDPContent(e3);
      }
      static incrementalLoad(e3) {
        return new IncrementalLoad(e3);
      }
      static incrementalMerge(e3) {
        return new IncrementalMerge(e3);
      }
      static interactive(e3) {
        return new Interactive(e3);
      }
      static jog(e3) {
        return new Jog(e3);
      }
      static labelPrinter(e3) {
        return new LabelPrinter(e3);
      }
      static layout(e3) {
        return new Layout(e3);
      }
      static level(e3) {
        return new Level(e3);
      }
      static linearized(e3) {
        return new Linearized(e3);
      }
      static locale(e3) {
        return new Locale(e3);
      }
      static localeSet(e3) {
        return new LocaleSet(e3);
      }
      static log(e3) {
        return new Log(e3);
      }
      static map(e3) {
        return new MapElement(e3);
      }
      static mediumInfo(e3) {
        return new MediumInfo(e3);
      }
      static message(e3) {
        return new config_Message(e3);
      }
      static messaging(e3) {
        return new Messaging(e3);
      }
      static mode(e3) {
        return new Mode(e3);
      }
      static modifyAnnots(e3) {
        return new ModifyAnnots(e3);
      }
      static msgId(e3) {
        return new MsgId(e3);
      }
      static nameAttr(e3) {
        return new NameAttr(e3);
      }
      static neverEmbed(e3) {
        return new NeverEmbed(e3);
      }
      static numberOfCopies(e3) {
        return new NumberOfCopies(e3);
      }
      static openAction(e3) {
        return new OpenAction(e3);
      }
      static output(e3) {
        return new Output(e3);
      }
      static outputBin(e3) {
        return new OutputBin(e3);
      }
      static outputXSL(e3) {
        return new OutputXSL(e3);
      }
      static overprint(e3) {
        return new Overprint(e3);
      }
      static packets(e3) {
        return new Packets(e3);
      }
      static pageOffset(e3) {
        return new PageOffset(e3);
      }
      static pageRange(e3) {
        return new PageRange(e3);
      }
      static pagination(e3) {
        return new Pagination(e3);
      }
      static paginationOverride(e3) {
        return new PaginationOverride(e3);
      }
      static part(e3) {
        return new Part(e3);
      }
      static pcl(e3) {
        return new Pcl(e3);
      }
      static pdf(e3) {
        return new Pdf(e3);
      }
      static pdfa(e3) {
        return new Pdfa(e3);
      }
      static permissions(e3) {
        return new Permissions(e3);
      }
      static pickTrayByPDFSize(e3) {
        return new PickTrayByPDFSize(e3);
      }
      static picture(e3) {
        return new config_Picture(e3);
      }
      static plaintextMetadata(e3) {
        return new PlaintextMetadata(e3);
      }
      static presence(e3) {
        return new Presence(e3);
      }
      static present(e3) {
        return new Present(e3);
      }
      static print(e3) {
        return new Print(e3);
      }
      static printHighQuality(e3) {
        return new PrintHighQuality(e3);
      }
      static printScaling(e3) {
        return new PrintScaling(e3);
      }
      static printerName(e3) {
        return new PrinterName(e3);
      }
      static producer(e3) {
        return new Producer(e3);
      }
      static ps(e3) {
        return new Ps(e3);
      }
      static range(e3) {
        return new Range(e3);
      }
      static record(e3) {
        return new Record(e3);
      }
      static relevant(e3) {
        return new Relevant(e3);
      }
      static rename(e3) {
        return new Rename(e3);
      }
      static renderPolicy(e3) {
        return new RenderPolicy(e3);
      }
      static runScripts(e3) {
        return new RunScripts(e3);
      }
      static script(e3) {
        return new config_Script(e3);
      }
      static scriptModel(e3) {
        return new ScriptModel(e3);
      }
      static severity(e3) {
        return new Severity(e3);
      }
      static silentPrint(e3) {
        return new SilentPrint(e3);
      }
      static staple(e3) {
        return new Staple(e3);
      }
      static startNode(e3) {
        return new StartNode(e3);
      }
      static startPage(e3) {
        return new StartPage(e3);
      }
      static submitFormat(e3) {
        return new SubmitFormat(e3);
      }
      static submitUrl(e3) {
        return new SubmitUrl(e3);
      }
      static subsetBelow(e3) {
        return new SubsetBelow(e3);
      }
      static suppressBanner(e3) {
        return new SuppressBanner(e3);
      }
      static tagged(e3) {
        return new Tagged(e3);
      }
      static template(e3) {
        return new config_Template(e3);
      }
      static templateCache(e3) {
        return new TemplateCache(e3);
      }
      static threshold(e3) {
        return new Threshold(e3);
      }
      static to(e3) {
        return new To(e3);
      }
      static trace(e3) {
        return new Trace(e3);
      }
      static transform(e3) {
        return new Transform(e3);
      }
      static type(e3) {
        return new Type(e3);
      }
      static uri(e3) {
        return new Uri(e3);
      }
      static validate(e3) {
        return new config_Validate(e3);
      }
      static validateApprovalSignatures(e3) {
        return new ValidateApprovalSignatures(e3);
      }
      static validationMessaging(e3) {
        return new ValidationMessaging(e3);
      }
      static version(e3) {
        return new Version(e3);
      }
      static versionControl(e3) {
        return new VersionControl(e3);
      }
      static viewerPreferences(e3) {
        return new ViewerPreferences(e3);
      }
      static webClient(e3) {
        return new WebClient(e3);
      }
      static whitespace(e3) {
        return new Whitespace(e3);
      }
      static window(e3) {
        return new Window(e3);
      }
      static xdc(e3) {
        return new Xdc(e3);
      }
      static xdp(e3) {
        return new Xdp(e3);
      }
      static xsl(e3) {
        return new Xsl(e3);
      }
      static zpl(e3) {
        return new Zpl(e3);
      }
    };
    On = gn.connectionSet.id;
    ConnectionSet = class extends XFAObject {
      constructor(e3) {
        super(On, "connectionSet", true);
        this.wsdlConnection = new XFAObjectArray();
        this.xmlConnection = new XFAObjectArray();
        this.xsdConnection = new XFAObjectArray();
      }
    };
    EffectiveInputPolicy = class extends XFAObject {
      constructor(e3) {
        super(On, "effectiveInputPolicy");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    EffectiveOutputPolicy = class extends XFAObject {
      constructor(e3) {
        super(On, "effectiveOutputPolicy");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    Operation = class extends StringObject {
      constructor(e3) {
        super(On, "operation");
        this.id = e3.id || "";
        this.input = e3.input || "";
        this.name = e3.name || "";
        this.output = e3.output || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    RootElement = class extends StringObject {
      constructor(e3) {
        super(On, "rootElement");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    SoapAction = class extends StringObject {
      constructor(e3) {
        super(On, "soapAction");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    SoapAddress = class extends StringObject {
      constructor(e3) {
        super(On, "soapAddress");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    connection_set_Uri = class extends StringObject {
      constructor(e3) {
        super(On, "uri");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    WsdlAddress = class extends StringObject {
      constructor(e3) {
        super(On, "wsdlAddress");
        this.id = e3.id || "";
        this.name = e3.name || "";
        this.use = e3.use || "";
        this.usehref = e3.usehref || "";
      }
    };
    WsdlConnection = class extends XFAObject {
      constructor(e3) {
        super(On, "wsdlConnection", true);
        this.dataDescription = e3.dataDescription || "";
        this.name = e3.name || "";
        this.effectiveInputPolicy = null;
        this.effectiveOutputPolicy = null;
        this.operation = null;
        this.soapAction = null;
        this.soapAddress = null;
        this.wsdlAddress = null;
      }
    };
    XmlConnection = class extends XFAObject {
      constructor(e3) {
        super(On, "xmlConnection", true);
        this.dataDescription = e3.dataDescription || "";
        this.name = e3.name || "";
        this.uri = null;
      }
    };
    XsdConnection = class extends XFAObject {
      constructor(e3) {
        super(On, "xsdConnection", true);
        this.dataDescription = e3.dataDescription || "";
        this.name = e3.name || "";
        this.rootElement = null;
        this.uri = null;
      }
    };
    ConnectionSetNamespace = class _ConnectionSetNamespace {
      static [on](e3, t3) {
        if (_ConnectionSetNamespace.hasOwnProperty(e3))
          return _ConnectionSetNamespace[e3](t3);
      }
      static connectionSet(e3) {
        return new ConnectionSet(e3);
      }
      static effectiveInputPolicy(e3) {
        return new EffectiveInputPolicy(e3);
      }
      static effectiveOutputPolicy(e3) {
        return new EffectiveOutputPolicy(e3);
      }
      static operation(e3) {
        return new Operation(e3);
      }
      static rootElement(e3) {
        return new RootElement(e3);
      }
      static soapAction(e3) {
        return new SoapAction(e3);
      }
      static soapAddress(e3) {
        return new SoapAddress(e3);
      }
      static uri(e3) {
        return new connection_set_Uri(e3);
      }
      static wsdlAddress(e3) {
        return new WsdlAddress(e3);
      }
      static wsdlConnection(e3) {
        return new WsdlConnection(e3);
      }
      static xmlConnection(e3) {
        return new XmlConnection(e3);
      }
      static xsdConnection(e3) {
        return new XsdConnection(e3);
      }
    };
    Pn = gn.datasets.id;
    datasets_Data = class extends XmlObject {
      constructor(e3) {
        super(Pn, "data", e3);
      }
      [Gr]() {
        return true;
      }
    };
    Datasets = class extends XFAObject {
      constructor(e3) {
        super(Pn, "datasets", true);
        this.data = null;
        this.Signature = null;
      }
      [Kr](e3) {
        const t3 = e3[Yr];
        ("data" === t3 && e3[Jr] === Pn || "Signature" === t3 && e3[Jr] === gn.signature.id) && (this[t3] = e3);
        this[Xs](e3);
      }
    };
    DatasetsNamespace = class _DatasetsNamespace {
      static [on](e3, t3) {
        if (_DatasetsNamespace.hasOwnProperty(e3))
          return _DatasetsNamespace[e3](t3);
      }
      static datasets(e3) {
        return new Datasets(e3);
      }
      static data(e3) {
        return new datasets_Data(e3);
      }
    };
    Wn = gn.localeSet.id;
    CalendarSymbols = class extends XFAObject {
      constructor(e3) {
        super(Wn, "calendarSymbols", true);
        this.name = "gregorian";
        this.dayNames = new XFAObjectArray(2);
        this.eraNames = null;
        this.meridiemNames = null;
        this.monthNames = new XFAObjectArray(2);
      }
    };
    CurrencySymbol = class extends StringObject {
      constructor(e3) {
        super(Wn, "currencySymbol");
        this.name = getStringOption(e3.name, ["symbol", "isoname", "decimal"]);
      }
    };
    CurrencySymbols = class extends XFAObject {
      constructor(e3) {
        super(Wn, "currencySymbols", true);
        this.currencySymbol = new XFAObjectArray(3);
      }
    };
    DatePattern = class extends StringObject {
      constructor(e3) {
        super(Wn, "datePattern");
        this.name = getStringOption(e3.name, ["full", "long", "med", "short"]);
      }
    };
    DatePatterns = class extends XFAObject {
      constructor(e3) {
        super(Wn, "datePatterns", true);
        this.datePattern = new XFAObjectArray(4);
      }
    };
    DateTimeSymbols = class extends ContentObject {
      constructor(e3) {
        super(Wn, "dateTimeSymbols");
      }
    };
    Day = class extends StringObject {
      constructor(e3) {
        super(Wn, "day");
      }
    };
    DayNames = class extends XFAObject {
      constructor(e3) {
        super(Wn, "dayNames", true);
        this.abbr = getInteger({ data: e3.abbr, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.day = new XFAObjectArray(7);
      }
    };
    Era = class extends StringObject {
      constructor(e3) {
        super(Wn, "era");
      }
    };
    EraNames = class extends XFAObject {
      constructor(e3) {
        super(Wn, "eraNames", true);
        this.era = new XFAObjectArray(2);
      }
    };
    locale_set_Locale = class extends XFAObject {
      constructor(e3) {
        super(Wn, "locale", true);
        this.desc = e3.desc || "";
        this.name = "isoname";
        this.calendarSymbols = null;
        this.currencySymbols = null;
        this.datePatterns = null;
        this.dateTimeSymbols = null;
        this.numberPatterns = null;
        this.numberSymbols = null;
        this.timePatterns = null;
        this.typeFaces = null;
      }
    };
    locale_set_LocaleSet = class extends XFAObject {
      constructor(e3) {
        super(Wn, "localeSet", true);
        this.locale = new XFAObjectArray();
      }
    };
    Meridiem = class extends StringObject {
      constructor(e3) {
        super(Wn, "meridiem");
      }
    };
    MeridiemNames = class extends XFAObject {
      constructor(e3) {
        super(Wn, "meridiemNames", true);
        this.meridiem = new XFAObjectArray(2);
      }
    };
    Month = class extends StringObject {
      constructor(e3) {
        super(Wn, "month");
      }
    };
    MonthNames = class extends XFAObject {
      constructor(e3) {
        super(Wn, "monthNames", true);
        this.abbr = getInteger({ data: e3.abbr, defaultValue: 0, validate: (e4) => 1 === e4 });
        this.month = new XFAObjectArray(12);
      }
    };
    NumberPattern = class extends StringObject {
      constructor(e3) {
        super(Wn, "numberPattern");
        this.name = getStringOption(e3.name, ["full", "long", "med", "short"]);
      }
    };
    NumberPatterns = class extends XFAObject {
      constructor(e3) {
        super(Wn, "numberPatterns", true);
        this.numberPattern = new XFAObjectArray(4);
      }
    };
    NumberSymbol = class extends StringObject {
      constructor(e3) {
        super(Wn, "numberSymbol");
        this.name = getStringOption(e3.name, ["decimal", "grouping", "percent", "minus", "zero"]);
      }
    };
    NumberSymbols = class extends XFAObject {
      constructor(e3) {
        super(Wn, "numberSymbols", true);
        this.numberSymbol = new XFAObjectArray(5);
      }
    };
    TimePattern = class extends StringObject {
      constructor(e3) {
        super(Wn, "timePattern");
        this.name = getStringOption(e3.name, ["full", "long", "med", "short"]);
      }
    };
    TimePatterns = class extends XFAObject {
      constructor(e3) {
        super(Wn, "timePatterns", true);
        this.timePattern = new XFAObjectArray(4);
      }
    };
    TypeFace = class extends XFAObject {
      constructor(e3) {
        super(Wn, "typeFace", true);
        this.name = "" | e3.name;
      }
    };
    TypeFaces = class extends XFAObject {
      constructor(e3) {
        super(Wn, "typeFaces", true);
        this.typeFace = new XFAObjectArray();
      }
    };
    LocaleSetNamespace = class _LocaleSetNamespace {
      static [on](e3, t3) {
        if (_LocaleSetNamespace.hasOwnProperty(e3))
          return _LocaleSetNamespace[e3](t3);
      }
      static calendarSymbols(e3) {
        return new CalendarSymbols(e3);
      }
      static currencySymbol(e3) {
        return new CurrencySymbol(e3);
      }
      static currencySymbols(e3) {
        return new CurrencySymbols(e3);
      }
      static datePattern(e3) {
        return new DatePattern(e3);
      }
      static datePatterns(e3) {
        return new DatePatterns(e3);
      }
      static dateTimeSymbols(e3) {
        return new DateTimeSymbols(e3);
      }
      static day(e3) {
        return new Day(e3);
      }
      static dayNames(e3) {
        return new DayNames(e3);
      }
      static era(e3) {
        return new Era(e3);
      }
      static eraNames(e3) {
        return new EraNames(e3);
      }
      static locale(e3) {
        return new locale_set_Locale(e3);
      }
      static localeSet(e3) {
        return new locale_set_LocaleSet(e3);
      }
      static meridiem(e3) {
        return new Meridiem(e3);
      }
      static meridiemNames(e3) {
        return new MeridiemNames(e3);
      }
      static month(e3) {
        return new Month(e3);
      }
      static monthNames(e3) {
        return new MonthNames(e3);
      }
      static numberPattern(e3) {
        return new NumberPattern(e3);
      }
      static numberPatterns(e3) {
        return new NumberPatterns(e3);
      }
      static numberSymbol(e3) {
        return new NumberSymbol(e3);
      }
      static numberSymbols(e3) {
        return new NumberSymbols(e3);
      }
      static timePattern(e3) {
        return new TimePattern(e3);
      }
      static timePatterns(e3) {
        return new TimePatterns(e3);
      }
      static typeFace(e3) {
        return new TypeFace(e3);
      }
      static typeFaces(e3) {
        return new TypeFaces(e3);
      }
    };
    jn = gn.signature.id;
    signature_Signature = class extends XFAObject {
      constructor(e3) {
        super(jn, "signature", true);
      }
    };
    SignatureNamespace = class _SignatureNamespace {
      static [on](e3, t3) {
        if (_SignatureNamespace.hasOwnProperty(e3))
          return _SignatureNamespace[e3](t3);
      }
      static signature(e3) {
        return new signature_Signature(e3);
      }
    };
    Xn = gn.stylesheet.id;
    Stylesheet = class extends XFAObject {
      constructor(e3) {
        super(Xn, "stylesheet", true);
      }
    };
    StylesheetNamespace = class _StylesheetNamespace {
      static [on](e3, t3) {
        if (_StylesheetNamespace.hasOwnProperty(e3))
          return _StylesheetNamespace[e3](t3);
      }
      static stylesheet(e3) {
        return new Stylesheet(e3);
      }
    };
    Zn = gn.xdp.id;
    xdp_Xdp = class extends XFAObject {
      constructor(e3) {
        super(Zn, "xdp", true);
        this.uuid = e3.uuid || "";
        this.timeStamp = e3.timeStamp || "";
        this.config = null;
        this.connectionSet = null;
        this.datasets = null;
        this.localeSet = null;
        this.stylesheet = new XFAObjectArray();
        this.template = null;
      }
      [Tr](e3) {
        const t3 = gn[e3[Yr]];
        return t3 && e3[Jr] === t3.id;
      }
    };
    XdpNamespace = class _XdpNamespace {
      static [on](e3, t3) {
        if (_XdpNamespace.hasOwnProperty(e3))
          return _XdpNamespace[e3](t3);
      }
      static xdp(e3) {
        return new xdp_Xdp(e3);
      }
    };
    Vn = gn.xhtml.id;
    zn = Symbol();
    _n2 = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
    $n = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (e3) => "none" === e3 ? "none" : "normal"], ["xfa-font-horizontal-scale", (e3) => `scaleX(${Math.max(0, Math.min(parseInt(e3) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (e3) => `scaleY(${Math.max(0, Math.min(parseInt(e3) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e3, t3) => measureToString(0.99 * (e3 = t3.fontSize = getMeasurement(e3)))], ["letter-spacing", (e3) => measureToString(getMeasurement(e3))], ["line-height", (e3) => measureToString(getMeasurement(e3))], ["margin", (e3) => measureToString(getMeasurement(e3))], ["margin-bottom", (e3) => measureToString(getMeasurement(e3))], ["margin-left", (e3) => measureToString(getMeasurement(e3))], ["margin-right", (e3) => measureToString(getMeasurement(e3))], ["margin-top", (e3) => measureToString(getMeasurement(e3))], ["text-indent", (e3) => measureToString(getMeasurement(e3))], ["font-family", (e3) => e3], ["vertical-align", (e3) => measureToString(getMeasurement(e3))]]);
    Ao = /\s+/g;
    eo = /[\r\n]+/g;
    to = /\r\n?/g;
    io = /* @__PURE__ */ new Set(["body", "html"]);
    XhtmlObject = class extends XmlObject {
      constructor(e3, t3) {
        super(Vn, t3);
        this[zn] = false;
        this.style = e3.style || "";
      }
      [Vs](e3) {
        super[Vs](e3);
        this.style = function checkStyle(e4) {
          return e4.style ? e4.style.trim().split(/\s*;\s*/).filter((e5) => !!e5).map((e5) => e5.split(/\s*:\s*/, 2)).filter(([t3, i3]) => {
            "font-family" === t3 && e4[yr].usedTypefaces.add(i3);
            return _n2.has(t3);
          }).map((e5) => e5.join(":")).join(";") : "";
        }(this);
      }
      [Ws]() {
        return !io.has(this[Yr]);
      }
      [qr](e3, t3 = false) {
        if (t3)
          this[zn] = true;
        else {
          e3 = e3.replaceAll(eo, "");
          this.style.includes("xfa-spacerun:yes") || (e3 = e3.replaceAll(Ao, " "));
        }
        e3 && (this[er] += e3);
      }
      [Or](e3, t3 = true) {
        const i3 = /* @__PURE__ */ Object.create(null), a3 = { top: NaN, bottom: NaN, left: NaN, right: NaN };
        let s3 = null;
        for (const [e4, t4] of this.style.split(";").map((e5) => e5.split(":", 2)))
          switch (e4) {
            case "font-family":
              i3.typeface = stripQuotes(t4);
              break;
            case "font-size":
              i3.size = getMeasurement(t4);
              break;
            case "font-weight":
              i3.weight = t4;
              break;
            case "font-style":
              i3.posture = t4;
              break;
            case "letter-spacing":
              i3.letterSpacing = getMeasurement(t4);
              break;
            case "margin":
              const e5 = t4.split(/ \t/).map((e6) => getMeasurement(e6));
              switch (e5.length) {
                case 1:
                  a3.top = a3.bottom = a3.left = a3.right = e5[0];
                  break;
                case 2:
                  a3.top = a3.bottom = e5[0];
                  a3.left = a3.right = e5[1];
                  break;
                case 3:
                  a3.top = e5[0];
                  a3.bottom = e5[2];
                  a3.left = a3.right = e5[1];
                  break;
                case 4:
                  a3.top = e5[0];
                  a3.left = e5[1];
                  a3.bottom = e5[2];
                  a3.right = e5[3];
              }
              break;
            case "margin-top":
              a3.top = getMeasurement(t4);
              break;
            case "margin-bottom":
              a3.bottom = getMeasurement(t4);
              break;
            case "margin-left":
              a3.left = getMeasurement(t4);
              break;
            case "margin-right":
              a3.right = getMeasurement(t4);
              break;
            case "line-height":
              s3 = getMeasurement(t4);
          }
        e3.pushData(i3, a3, s3);
        if (this[er])
          e3.addString(this[er]);
        else
          for (const t4 of this[Er]())
            "#text" !== t4[Yr] ? t4[Or](e3) : e3.addString(t4[er]);
        t3 && e3.popFont();
      }
      [an](e3) {
        const t3 = [];
        this[ar] = { children: t3 };
        this[Zs]({});
        if (0 === t3.length && !this[er])
          return HTMLResult.EMPTY;
        let i3;
        i3 = this[zn] ? this[er] ? this[er].replaceAll(to, "\n") : void 0 : this[er] || void 0;
        return HTMLResult.success({ name: this[Yr], attributes: { href: this.href, style: mapStyle(this.style, this, this[zn]) }, children: t3, value: i3 });
      }
    };
    A2 = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "a");
        this.href = fixURL(e3.href) || "";
      }
    };
    B2 = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "b");
      }
      [Or](e3) {
        e3.pushFont({ weight: "bold" });
        super[Or](e3);
        e3.popFont();
      }
    };
    Body = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "body");
      }
      [an](e3) {
        const t3 = super[an](e3), { html: i3 } = t3;
        if (!i3)
          return HTMLResult.EMPTY;
        i3.name = "div";
        i3.attributes.class = ["xfaRich"];
        return t3;
      }
    };
    Br = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "br");
      }
      [en]() {
        return "\n";
      }
      [Or](e3) {
        e3.addString("\n");
      }
      [an](e3) {
        return HTMLResult.success({ name: "br" });
      }
    };
    Html = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "html");
      }
      [an](e3) {
        var _a3;
        const t3 = [];
        this[ar] = { children: t3 };
        this[Zs]({});
        if (0 === t3.length)
          return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[er] || "" });
        if (1 === t3.length) {
          const e4 = t3[0];
          if ((_a3 = e4.attributes) == null ? void 0 : _a3.class.includes("xfaRich"))
            return HTMLResult.success(e4);
        }
        return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: t3 });
      }
    };
    I2 = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "i");
      }
      [Or](e3) {
        e3.pushFont({ posture: "italic" });
        super[Or](e3);
        e3.popFont();
      }
    };
    Li = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "li");
      }
    };
    Ol = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "ol");
      }
    };
    P2 = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "p");
      }
      [Or](e3) {
        super[Or](e3, false);
        e3.addString("\n");
        e3.addPara();
        e3.popFont();
      }
      [en]() {
        return this[pr]()[Er]().at(-1) === this ? super[en]() : super[en]() + "\n";
      }
    };
    Span = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "span");
      }
    };
    Sub = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "sub");
      }
    };
    Sup = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "sup");
      }
    };
    Ul = class extends XhtmlObject {
      constructor(e3) {
        super(e3, "ul");
      }
    };
    XhtmlNamespace = class _XhtmlNamespace {
      static [on](e3, t3) {
        if (_XhtmlNamespace.hasOwnProperty(e3))
          return _XhtmlNamespace[e3](t3);
      }
      static a(e3) {
        return new A2(e3);
      }
      static b(e3) {
        return new B2(e3);
      }
      static body(e3) {
        return new Body(e3);
      }
      static br(e3) {
        return new Br(e3);
      }
      static html(e3) {
        return new Html(e3);
      }
      static i(e3) {
        return new I2(e3);
      }
      static li(e3) {
        return new Li(e3);
      }
      static ol(e3) {
        return new Ol(e3);
      }
      static p(e3) {
        return new P2(e3);
      }
      static span(e3) {
        return new Span(e3);
      }
      static sub(e3) {
        return new Sub(e3);
      }
      static sup(e3) {
        return new Sup(e3);
      }
      static ul(e3) {
        return new Ul(e3);
      }
    };
    ao = { config: ConfigNamespace, connection: ConnectionSetNamespace, datasets: DatasetsNamespace, localeSet: LocaleSetNamespace, signature: SignatureNamespace, stylesheet: StylesheetNamespace, template: TemplateNamespace, xdp: XdpNamespace, xhtml: XhtmlNamespace };
    UnknownNamespace = class {
      constructor(e3) {
        this.namespaceId = e3;
      }
      [on](e3, t3) {
        return new XmlObject(this.namespaceId, e3, t3);
      }
    };
    Root = class extends XFAObject {
      constructor(e3) {
        super(-1, "root", /* @__PURE__ */ Object.create(null));
        this.element = null;
        this[br] = e3;
      }
      [Kr](e3) {
        this.element = e3;
        return true;
      }
      [sr]() {
        super[sr]();
        if (this.element.template instanceof Template) {
          this[br].set(Xr, this.element);
          this.element.template[Zr](this[br]);
          this.element.template[br] = this[br];
        }
      }
    };
    Empty = class extends XFAObject {
      constructor() {
        super(-1, "", /* @__PURE__ */ Object.create(null));
      }
      [Kr](e3) {
        return false;
      }
    };
    Builder = class {
      constructor(e3 = null) {
        this._namespaceStack = [];
        this._nsAgnosticLevel = 0;
        this._namespacePrefixes = /* @__PURE__ */ new Map();
        this._namespaces = /* @__PURE__ */ new Map();
        this._nextNsId = Math.max(...Object.values(gn).map(({ id: e4 }) => e4));
        this._currentNamespace = e3 || new UnknownNamespace(++this._nextNsId);
      }
      buildRoot(e3) {
        return new Root(e3);
      }
      build({ nsPrefix: e3, name: t3, attributes: i3, namespace: a3, prefixes: s3 }) {
        const r3 = null !== a3;
        if (r3) {
          this._namespaceStack.push(this._currentNamespace);
          this._currentNamespace = this._searchNamespace(a3);
        }
        s3 && this._addNamespacePrefix(s3);
        if (i3.hasOwnProperty(vr)) {
          const e4 = ao.datasets, t4 = i3[vr];
          let a4 = null;
          for (const [i4, s4] of Object.entries(t4)) {
            if (this._getNamespaceToUse(i4) === e4) {
              a4 = { xfa: s4 };
              break;
            }
          }
          a4 ? i3[vr] = a4 : delete i3[vr];
        }
        const n3 = this._getNamespaceToUse(e3), o3 = (n3 == null ? void 0 : n3[on](t3, i3)) || new Empty();
        o3[Gr]() && this._nsAgnosticLevel++;
        (r3 || s3 || o3[Gr]()) && (o3[_s2] = { hasNamespace: r3, prefixes: s3, nsAgnostic: o3[Gr]() });
        return o3;
      }
      isNsAgnostic() {
        return this._nsAgnosticLevel > 0;
      }
      _searchNamespace(e3) {
        let t3 = this._namespaces.get(e3);
        if (t3)
          return t3;
        for (const [i3, { check: a3 }] of Object.entries(gn))
          if (a3(e3)) {
            t3 = ao[i3];
            if (t3) {
              this._namespaces.set(e3, t3);
              return t3;
            }
            break;
          }
        t3 = new UnknownNamespace(++this._nextNsId);
        this._namespaces.set(e3, t3);
        return t3;
      }
      _addNamespacePrefix(e3) {
        for (const { prefix: t3, value: i3 } of e3) {
          const e4 = this._searchNamespace(i3);
          let a3 = this._namespacePrefixes.get(t3);
          if (!a3) {
            a3 = [];
            this._namespacePrefixes.set(t3, a3);
          }
          a3.push(e4);
        }
      }
      _getNamespaceToUse(e3) {
        if (!e3)
          return this._currentNamespace;
        const t3 = this._namespacePrefixes.get(e3);
        if ((t3 == null ? void 0 : t3.length) > 0)
          return t3.at(-1);
        warn(`Unknown namespace prefix: ${e3}.`);
        return null;
      }
      clean(e3) {
        const { hasNamespace: t3, prefixes: i3, nsAgnostic: a3 } = e3;
        t3 && (this._currentNamespace = this._namespaceStack.pop());
        i3 && i3.forEach(({ prefix: e4 }) => {
          this._namespacePrefixes.get(e4).pop();
        });
        a3 && this._nsAgnosticLevel--;
      }
    };
    XFAParser = class _XFAParser extends XMLParserBase {
      constructor(e3 = null, t3 = false) {
        super();
        this._builder = new Builder(e3);
        this._stack = [];
        this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() };
        this._ids = /* @__PURE__ */ new Map();
        this._current = this._builder.buildRoot(this._ids);
        this._errorCode = Ns;
        this._whiteRegex = /^\s+$/;
        this._nbsps = /\xa0+/g;
        this._richText = t3;
      }
      parse(e3) {
        this.parseXml(e3);
        if (this._errorCode === Ns) {
          this._current[sr]();
          return this._current.element;
        }
      }
      onText(e3) {
        e3 = e3.replace(this._nbsps, (e4) => e4.slice(1) + " ");
        this._richText || this._current[Ws]() ? this._current[qr](e3, this._richText) : this._whiteRegex.test(e3) || this._current[qr](e3.trim());
      }
      onCdata(e3) {
        this._current[qr](e3);
      }
      _mkAttributes(e3, t3) {
        let i3 = null, a3 = null;
        const s3 = /* @__PURE__ */ Object.create({});
        for (const { name: r3, value: n3 } of e3)
          if ("xmlns" === r3)
            i3 ? warn(`XFA - multiple namespace definition in <${t3}>`) : i3 = n3;
          else if (r3.startsWith("xmlns:")) {
            const e4 = r3.substring(6);
            a3 || (a3 = []);
            a3.push({ prefix: e4, value: n3 });
          } else {
            const e4 = r3.indexOf(":");
            if (-1 === e4)
              s3[r3] = n3;
            else {
              let t4 = s3[vr];
              t4 || (t4 = s3[vr] = /* @__PURE__ */ Object.create(null));
              const [i4, a4] = [r3.slice(0, e4), r3.slice(e4 + 1)];
              (t4[i4] || (t4[i4] = /* @__PURE__ */ Object.create(null)))[a4] = n3;
            }
          }
        return [i3, a3, s3];
      }
      _getNameAndPrefix(e3, t3) {
        const i3 = e3.indexOf(":");
        return -1 === i3 ? [e3, null] : [e3.substring(i3 + 1), t3 ? "" : e3.substring(0, i3)];
      }
      onBeginElement(e3, t3, i3) {
        const [a3, s3, r3] = this._mkAttributes(t3, e3), [n3, o3] = this._getNameAndPrefix(e3, this._builder.isNsAgnostic()), g3 = this._builder.build({ nsPrefix: o3, name: n3, attributes: r3, namespace: a3, prefixes: s3 });
        g3[yr] = this._globalData;
        if (i3) {
          g3[sr]();
          this._current[Kr](g3) && g3[zr](this._ids);
          g3[Vs](this._builder);
        } else {
          this._stack.push(this._current);
          this._current = g3;
        }
      }
      onEndElement(e3) {
        const t3 = this._current;
        if (t3[Sr]() && "string" == typeof t3[er]) {
          const e4 = new _XFAParser();
          e4._globalData = this._globalData;
          const i3 = e4.parse(t3[er]);
          t3[er] = null;
          t3[Kr](i3);
        }
        t3[sr]();
        this._current = this._stack.pop();
        this._current[Kr](t3) && t3[zr](this._ids);
        t3[Vs](this._builder);
      }
      onError(e3) {
        this._errorCode = e3;
      }
    };
    XFAFactory = class _XFAFactory {
      constructor(e3) {
        try {
          this.root = new XFAParser().parse(_XFAFactory._createDocument(e3));
          const t3 = new Binder(this.root);
          this.form = t3.bind();
          this.dataHandler = new DataHandler(this.root, t3.getData());
          this.form[yr].template = this.form;
        } catch (e4) {
          warn(`XFA - an error occurred during parsing and binding: ${e4}`);
        }
      }
      isValid() {
        return this.root && this.form;
      }
      _createPagesHelper() {
        const e3 = this.form[tn]();
        return new Promise((t3, i3) => {
          const nextIteration = () => {
            try {
              const i4 = e3.next();
              i4.done ? t3(i4.value) : setTimeout(nextIteration, 0);
            } catch (e4) {
              i3(e4);
            }
          };
          setTimeout(nextIteration, 0);
        });
      }
      async _createPages() {
        try {
          this.pages = await this._createPagesHelper();
          this.dims = this.pages.children.map((e3) => {
            const { width: t3, height: i3 } = e3.attributes.style;
            return [0, 0, parseInt(t3), parseInt(i3)];
          });
        } catch (e3) {
          warn(`XFA - an error occurred during layout: ${e3}`);
        }
      }
      getBoundingBox(e3) {
        return this.dims[e3];
      }
      async getNumPages() {
        this.pages || await this._createPages();
        return this.dims.length;
      }
      setImages(e3) {
        this.form[yr].images = e3;
      }
      setFonts(e3) {
        this.form[yr].fontFinder = new FontFinder(e3);
        const t3 = [];
        for (let e4 of this.form[yr].usedTypefaces) {
          e4 = stripQuotes(e4);
          this.form[yr].fontFinder.find(e4) || t3.push(e4);
        }
        return t3.length > 0 ? t3 : null;
      }
      appendFonts(e3, t3) {
        this.form[yr].fontFinder.add(e3, t3);
      }
      async getPages() {
        this.pages || await this._createPages();
        const e3 = this.pages;
        this.pages = null;
        return e3;
      }
      serializeData(e3) {
        return this.dataHandler.serialize(e3);
      }
      static _createDocument(e3) {
        return e3["/xdp:xdp"] ? Object.values(e3).join("") : e3["xdp:xdp"];
      }
      static getRichTextAsHtml(e3) {
        if (!e3 || "string" != typeof e3)
          return null;
        try {
          let t3 = new XFAParser(XhtmlNamespace, true).parse(e3);
          if (!["body", "xhtml"].includes(t3[Yr])) {
            const e4 = XhtmlNamespace.body({});
            e4[Xs](t3);
            t3 = e4;
          }
          const i3 = t3[an]();
          if (!i3.success)
            return null;
          const { html: a3 } = i3, { attributes: s3 } = a3;
          if (s3) {
            s3.class && (s3.class = s3.class.filter((e4) => !e4.startsWith("xfa")));
            s3.dir = "auto";
          }
          return { html: a3, str: t3[en]() };
        } catch (e4) {
          warn(`XFA - an error occurred during parsing of rich text: ${e4}`);
        }
        return null;
      }
    };
    AnnotationFactory = class {
      static createGlobals(e3) {
        return Promise.all([e3.ensureCatalog("acroForm"), e3.ensureDoc("xfaDatasets"), e3.ensureCatalog("structTreeRoot"), e3.ensureCatalog("baseUrl"), e3.ensureCatalog("attachments")]).then(([t3, i3, a3, s3, r3]) => ({ pdfManager: e3, acroForm: t3 instanceof Dict ? t3 : Dict.empty, xfaDatasets: i3, structTreeRoot: a3, baseUrl: s3, attachments: r3 }), (e4) => {
          warn(`createGlobals: "${e4}".`);
          return null;
        });
      }
      static async create(e3, t3, i3, a3, s3, r3) {
        const n3 = s3 ? await this._getPageIndex(e3, t3, i3.pdfManager) : null;
        return i3.pdfManager.ensure(this, "_create", [e3, t3, i3, a3, s3, n3, r3]);
      }
      static _create(e3, t3, i3, a3, s3 = false, r3 = null, n3 = null) {
        const o3 = e3.fetchIfRef(t3);
        if (!(o3 instanceof Dict))
          return;
        const { acroForm: g3, pdfManager: c3 } = i3, C3 = t3 instanceof Ref ? t3.toString() : `annot_${a3.createObjId()}`;
        let h2 = o3.get("Subtype");
        h2 = h2 instanceof Name ? h2.name : null;
        const l3 = { xref: e3, ref: t3, dict: o3, subtype: h2, id: C3, annotationGlobals: i3, collectFields: s3, needAppearances: !s3 && true === g3.get("NeedAppearances"), pageIndex: r3, evaluatorOptions: c3.evaluatorOptions, pageRef: n3 };
        switch (h2) {
          case "Link":
            return new LinkAnnotation(l3);
          case "Text":
            return new TextAnnotation(l3);
          case "Widget":
            let e4 = getInheritableProperty({ dict: o3, key: "FT" });
            e4 = e4 instanceof Name ? e4.name : null;
            switch (e4) {
              case "Tx":
                return new TextWidgetAnnotation(l3);
              case "Btn":
                return new ButtonWidgetAnnotation(l3);
              case "Ch":
                return new ChoiceWidgetAnnotation(l3);
              case "Sig":
                return new SignatureWidgetAnnotation(l3);
            }
            warn(`Unimplemented widget field type "${e4}", falling back to base field type.`);
            return new WidgetAnnotation(l3);
          case "Popup":
            return new PopupAnnotation(l3);
          case "FreeText":
            return new FreeTextAnnotation(l3);
          case "Line":
            return new LineAnnotation(l3);
          case "Square":
            return new SquareAnnotation(l3);
          case "Circle":
            return new CircleAnnotation(l3);
          case "PolyLine":
            return new PolylineAnnotation(l3);
          case "Polygon":
            return new PolygonAnnotation(l3);
          case "Caret":
            return new CaretAnnotation(l3);
          case "Ink":
            return new InkAnnotation(l3);
          case "Highlight":
            return new HighlightAnnotation(l3);
          case "Underline":
            return new UnderlineAnnotation(l3);
          case "Squiggly":
            return new SquigglyAnnotation(l3);
          case "StrikeOut":
            return new StrikeOutAnnotation(l3);
          case "Stamp":
            return new StampAnnotation(l3);
          case "FileAttachment":
            return new FileAttachmentAnnotation(l3);
          default:
            s3 || warn(h2 ? `Unimplemented annotation type "${h2}", falling back to base annotation.` : "Annotation is missing the required /Subtype.");
            return new Annotation(l3);
        }
      }
      static async _getPageIndex(e3, t3, i3) {
        try {
          const a3 = await e3.fetchIfRefAsync(t3);
          if (!(a3 instanceof Dict))
            return -1;
          const s3 = a3.getRaw("P");
          if (s3 instanceof Ref)
            try {
              return await i3.ensureCatalog("getPageIndex", [s3]);
            } catch (e4) {
              info(`_getPageIndex -- not a valid page reference: "${e4}".`);
            }
          if (a3.has("Kids"))
            return -1;
          const r3 = await i3.ensureDoc("numPages");
          for (let e4 = 0; e4 < r3; e4++) {
            const a4 = await i3.getPage(e4), s4 = await i3.ensure(a4, "annotations");
            for (const i4 of s4)
              if (i4 instanceof Ref && isRefsEqual(i4, t3))
                return e4;
          }
        } catch (e4) {
          warn(`_getPageIndex: "${e4}".`);
        }
        return -1;
      }
      static generateImages(e3, t3, i3) {
        if (!i3) {
          warn("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
          return null;
        }
        let a3;
        for (const { bitmapId: i4, bitmap: s3 } of e3)
          if (s3) {
            a3 || (a3 = /* @__PURE__ */ new Map());
            a3.set(i4, StampAnnotation.createImage(s3, t3));
          }
        return a3;
      }
      static async saveNewAnnotations(e3, t3, i3, a3) {
        const s3 = e3.xref;
        let r3;
        const n3 = [], o3 = [], { isOffscreenCanvasSupported: g3 } = e3.options;
        for (const c3 of i3)
          if (!c3.deleted)
            switch (c3.annotationType) {
              case u2:
                if (!r3) {
                  const e4 = new Dict(s3);
                  e4.set("BaseFont", Name.get("Helvetica"));
                  e4.set("Type", Name.get("Font"));
                  e4.set("Subtype", Name.get("Type1"));
                  e4.set("Encoding", Name.get("WinAnsiEncoding"));
                  const t4 = [];
                  r3 = s3.getNewTemporaryRef();
                  await writeObject(r3, e4, t4, s3);
                  n3.push({ ref: r3, data: t4.join("") });
                }
                o3.push(FreeTextAnnotation.createNewAnnotation(s3, c3, n3, { evaluator: e3, task: t3, baseFontRef: r3 }));
                break;
              case d2:
                c3.quadPoints ? o3.push(HighlightAnnotation.createNewAnnotation(s3, c3, n3)) : o3.push(InkAnnotation.createNewAnnotation(s3, c3, n3));
                break;
              case p:
                o3.push(InkAnnotation.createNewAnnotation(s3, c3, n3));
                break;
              case f:
                if (!g3)
                  break;
                const i4 = await a3.get(c3.bitmapId);
                if (i4.imageStream) {
                  const { imageStream: e4, smaskStream: t4 } = i4, a4 = [];
                  if (t4) {
                    const i5 = s3.getNewTemporaryRef();
                    await writeObject(i5, t4, a4, s3);
                    n3.push({ ref: i5, data: a4.join("") });
                    e4.dict.set("SMask", i5);
                    a4.length = 0;
                  }
                  const r4 = i4.imageRef = s3.getNewTemporaryRef();
                  await writeObject(r4, e4, a4, s3);
                  n3.push({ ref: r4, data: a4.join("") });
                  i4.imageStream = i4.smaskStream = null;
                }
                o3.push(StampAnnotation.createNewAnnotation(s3, c3, n3, { image: i4 }));
            }
        return { annotations: await Promise.all(o3), dependencies: n3 };
      }
      static async printNewAnnotations(e3, t3, i3, a3, s3) {
        if (!a3)
          return null;
        const { options: r3, xref: n3 } = t3, o3 = [];
        for (const g3 of a3)
          if (!g3.deleted)
            switch (g3.annotationType) {
              case u2:
                o3.push(FreeTextAnnotation.createNewPrintAnnotation(e3, n3, g3, { evaluator: t3, task: i3, evaluatorOptions: r3 }));
                break;
              case d2:
                g3.quadPoints ? o3.push(HighlightAnnotation.createNewPrintAnnotation(e3, n3, g3, { evaluatorOptions: r3 })) : o3.push(InkAnnotation.createNewPrintAnnotation(e3, n3, g3, { evaluatorOptions: r3 }));
                break;
              case p:
                o3.push(InkAnnotation.createNewPrintAnnotation(e3, n3, g3, { evaluatorOptions: r3 }));
                break;
              case f:
                if (!r3.isOffscreenCanvasSupported)
                  break;
                const a4 = await s3.get(g3.bitmapId);
                if (a4.imageStream) {
                  const { imageStream: e4, smaskStream: t4 } = a4;
                  t4 && e4.dict.set("SMask", t4);
                  a4.imageRef = new JpegStream(e4, e4.length);
                  a4.imageStream = a4.smaskStream = null;
                }
                o3.push(StampAnnotation.createNewPrintAnnotation(e3, n3, g3, { image: a4, evaluatorOptions: r3 }));
            }
        return Promise.all(o3);
      }
    };
    Annotation = class {
      constructor(e3) {
        const { dict: t3, xref: i3, annotationGlobals: a3 } = e3;
        this.setTitle(t3.get("T"));
        this.setContents(t3.get("Contents"));
        this.setModificationDate(t3.get("M"));
        this.setFlags(t3.get("F"));
        this.setRectangle(t3.getArray("Rect"));
        this.setColor(t3.getArray("C"));
        this.setBorderStyle(t3);
        this.setAppearance(t3);
        this.setOptionalContent(t3);
        const s3 = t3.get("MK");
        this.setBorderAndBackgroundColors(s3);
        this.setRotation(s3, t3);
        this.ref = e3.ref instanceof Ref ? e3.ref : null;
        this._streams = [];
        this.appearance && this._streams.push(this.appearance);
        const r3 = !!(this.flags & AA), n3 = !!(this.flags & eA);
        if (a3.structTreeRoot) {
          let i4 = t3.get("StructParent");
          i4 = Number.isInteger(i4) && i4 >= 0 ? i4 : -1;
          a3.structTreeRoot.addAnnotationIdToPage(e3.pageRef, i4);
        }
        this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: e3.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: e3.subtype, hasOwnCanvas: false, noRotate: !!(this.flags & _2), noHTML: r3 && n3 };
        if (e3.collectFields) {
          const a4 = t3.get("Kids");
          if (Array.isArray(a4)) {
            const e4 = [];
            for (const t4 of a4)
              t4 instanceof Ref && e4.push(t4.toString());
            0 !== e4.length && (this.data.kidIds = e4);
          }
          this.data.actions = collectActions(i3, t3, uA);
          this.data.fieldName = this._constructFieldName(t3);
          this.data.pageIndex = e3.pageIndex;
        }
        this._isOffscreenCanvasSupported = e3.evaluatorOptions.isOffscreenCanvasSupported;
        this._fallbackFontDict = null;
        this._needAppearances = false;
      }
      _hasFlag(e3, t3) {
        return !!(e3 & t3);
      }
      _isViewable(e3) {
        return !this._hasFlag(e3, Z2) && !this._hasFlag(e3, $2);
      }
      _isPrintable(e3) {
        return this._hasFlag(e3, z2) && !this._hasFlag(e3, V2) && !this._hasFlag(e3, Z2);
      }
      mustBeViewed(e3, t3) {
        var _a3;
        const i3 = (_a3 = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a3.noView;
        return void 0 !== i3 ? !i3 : this.viewable && !this._hasFlag(this.flags, V2);
      }
      mustBePrinted(e3) {
        var _a3;
        const t3 = (_a3 = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a3.noPrint;
        return void 0 !== t3 ? !t3 : this.printable;
      }
      get viewable() {
        return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
      }
      get printable() {
        return null !== this.data.quadPoints && (0 !== this.flags && this._isPrintable(this.flags));
      }
      _parseStringHelper(e3) {
        const t3 = "string" == typeof e3 ? stringToPDFString(e3) : "";
        return { str: t3, dir: t3 && "rtl" === bidi(t3).dir ? "rtl" : "ltr" };
      }
      setDefaultAppearance(e3) {
        const { dict: t3, annotationGlobals: i3 } = e3, a3 = getInheritableProperty({ dict: t3, key: "DA" }) || i3.acroForm.get("DA");
        this._defaultAppearance = "string" == typeof a3 ? a3 : "";
        this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
      }
      setTitle(e3) {
        this._title = this._parseStringHelper(e3);
      }
      setContents(e3) {
        this._contents = this._parseStringHelper(e3);
      }
      setModificationDate(e3) {
        this.modificationDate = "string" == typeof e3 ? e3 : null;
      }
      setFlags(e3) {
        this.flags = Number.isInteger(e3) && e3 > 0 ? e3 : 0;
        this.flags & Z2 && "Annotation" !== this.constructor.name && (this.flags ^= Z2);
      }
      hasFlag(e3) {
        return this._hasFlag(this.flags, e3);
      }
      setRectangle(e3) {
        this.rectangle = Array.isArray(e3) && 4 === e3.length ? Util.normalizeRect(e3) : [0, 0, 0, 0];
      }
      setColor(e3) {
        this.color = getRgbColor(e3);
      }
      setLineEndings(e3) {
        this.lineEndings = ["None", "None"];
        if (Array.isArray(e3) && 2 === e3.length)
          for (let t3 = 0; t3 < 2; t3++) {
            const i3 = e3[t3];
            if (i3 instanceof Name)
              switch (i3.name) {
                case "None":
                  continue;
                case "Square":
                case "Circle":
                case "Diamond":
                case "OpenArrow":
                case "ClosedArrow":
                case "Butt":
                case "ROpenArrow":
                case "RClosedArrow":
                case "Slash":
                  this.lineEndings[t3] = i3.name;
                  continue;
              }
            warn(`Ignoring invalid lineEnding: ${i3}`);
          }
      }
      setRotation(e3, t3) {
        this.rotation = 0;
        let i3 = e3 instanceof Dict ? e3.get("R") || 0 : t3.get("Rotate") || 0;
        if (Number.isInteger(i3) && 0 !== i3) {
          i3 %= 360;
          i3 < 0 && (i3 += 360);
          i3 % 90 == 0 && (this.rotation = i3);
        }
      }
      setBorderAndBackgroundColors(e3) {
        if (e3 instanceof Dict) {
          this.borderColor = getRgbColor(e3.getArray("BC"), null);
          this.backgroundColor = getRgbColor(e3.getArray("BG"), null);
        } else
          this.borderColor = this.backgroundColor = null;
      }
      setBorderStyle(e3) {
        this.borderStyle = new AnnotationBorderStyle();
        if (e3 instanceof Dict)
          if (e3.has("BS")) {
            const t3 = e3.get("BS");
            if (t3 instanceof Dict) {
              const e4 = t3.get("Type");
              if (!e4 || isName(e4, "Border")) {
                this.borderStyle.setWidth(t3.get("W"), this.rectangle);
                this.borderStyle.setStyle(t3.get("S"));
                this.borderStyle.setDashArray(t3.getArray("D"));
              }
            }
          } else if (e3.has("Border")) {
            const t3 = e3.getArray("Border");
            if (Array.isArray(t3) && t3.length >= 3) {
              this.borderStyle.setHorizontalCornerRadius(t3[0]);
              this.borderStyle.setVerticalCornerRadius(t3[1]);
              this.borderStyle.setWidth(t3[2], this.rectangle);
              4 === t3.length && this.borderStyle.setDashArray(t3[3], true);
            }
          } else
            this.borderStyle.setWidth(0);
      }
      setAppearance(e3) {
        this.appearance = null;
        const t3 = e3.get("AP");
        if (!(t3 instanceof Dict))
          return;
        const i3 = t3.get("N");
        if (i3 instanceof BaseStream) {
          this.appearance = i3;
          return;
        }
        if (!(i3 instanceof Dict))
          return;
        const a3 = e3.get("AS");
        if (!(a3 instanceof Name && i3.has(a3.name)))
          return;
        const s3 = i3.get(a3.name);
        s3 instanceof BaseStream && (this.appearance = s3);
      }
      setOptionalContent(e3) {
        this.oc = null;
        const t3 = e3.get("OC");
        t3 instanceof Name ? warn("setOptionalContent: Support for /Name-entry is not implemented.") : t3 instanceof Dict && (this.oc = t3);
      }
      loadResources(e3, t3) {
        return t3.dict.getAsync("Resources").then((t4) => {
          if (!t4)
            return;
          return new ObjectLoader(t4, e3, t4.xref).load().then(function() {
            return t4;
          });
        });
      }
      async getOperatorList(e3, t3, i3, a3, s3) {
        const { hasOwnCanvas: r3, id: n3, rect: o3 } = this.data;
        let c3 = this.appearance;
        const C3 = !!(r3 && i3 & g2);
        if (C3 && (o3[0] === o3[2] || o3[1] === o3[3])) {
          this.data.hasOwnCanvas = false;
          return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
        }
        if (!c3) {
          if (!C3)
            return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
          c3 = new StringStream("");
          c3.dict = new Dict();
        }
        const h2 = c3.dict, l3 = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], c3), Q3 = h2.getArray("BBox") || [0, 0, 1, 1], E3 = h2.getArray("Matrix") || [1, 0, 0, 1, 0, 0], u3 = getTransformMatrix(o3, Q3, E3), d3 = new OperatorList();
        let f2;
        this.oc && (f2 = await e3.parseMarkedContentProps(this.oc, null));
        void 0 !== f2 && d3.addOp(Je2, ["OC", f2]);
        d3.addOp(We2, [n3, o3, u3, E3, C3]);
        await e3.getOperatorList({ stream: c3, task: t3, resources: l3, operatorList: d3, fallbackFontDict: this._fallbackFontDict });
        d3.addOp(je2, []);
        void 0 !== f2 && d3.addOp(Ye2, []);
        this.reset();
        return { opList: d3, separateForm: false, separateCanvas: C3 };
      }
      async save(e3, t3, i3) {
        return null;
      }
      get hasTextContent() {
        return false;
      }
      async extractTextContent(e3, t3, i3) {
        if (!this.appearance)
          return;
        const a3 = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), s3 = [], r3 = [];
        let n3 = null;
        const o3 = { desiredSize: Math.Infinity, ready: true, enqueue(e4, t4) {
          for (const t5 of e4.items)
            if (void 0 !== t5.str) {
              n3 || (n3 = t5.transform.slice(-2));
              r3.push(t5.str);
              if (t5.hasEOL) {
                s3.push(r3.join("").trimEnd());
                r3.length = 0;
              }
            }
        } };
        await e3.getTextContent({ stream: this.appearance, task: t3, resources: a3, includeMarkedContent: true, keepWhiteSpace: true, sink: o3, viewBox: i3 });
        this.reset();
        r3.length && s3.push(r3.join("").trimEnd());
        if (s3.length > 1 || s3[0]) {
          const e4 = this.appearance.dict;
          this.data.textPosition = this._transformPoint(n3, e4.getArray("BBox"), e4.getArray("Matrix"));
          this.data.textContent = s3;
        }
      }
      _transformPoint(e3, t3, i3) {
        const { rect: a3 } = this.data;
        t3 || (t3 = [0, 0, 1, 1]);
        i3 || (i3 = [1, 0, 0, 1, 0, 0]);
        const s3 = getTransformMatrix(a3, t3, i3);
        s3[4] -= a3[0];
        s3[5] -= a3[1];
        e3 = Util.applyTransform(e3, s3);
        return Util.applyTransform(e3, i3);
      }
      getFieldObject() {
        return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
      }
      reset() {
        for (const e3 of this._streams)
          e3.reset();
      }
      _constructFieldName(e3) {
        if (!e3.has("T") && !e3.has("Parent")) {
          warn("Unknown field name, falling back to empty field name.");
          return "";
        }
        if (!e3.has("Parent"))
          return stringToPDFString(e3.get("T"));
        const t3 = [];
        e3.has("T") && t3.unshift(stringToPDFString(e3.get("T")));
        let i3 = e3;
        const a3 = new RefSet();
        e3.objId && a3.put(e3.objId);
        for (; i3.has("Parent"); ) {
          i3 = i3.get("Parent");
          if (!(i3 instanceof Dict) || i3.objId && a3.has(i3.objId))
            break;
          i3.objId && a3.put(i3.objId);
          i3.has("T") && t3.unshift(stringToPDFString(i3.get("T")));
        }
        return t3.join(".");
      }
    };
    AnnotationBorderStyle = class {
      constructor() {
        this.width = 1;
        this.style = hA;
        this.dashArray = [3];
        this.horizontalCornerRadius = 0;
        this.verticalCornerRadius = 0;
      }
      setWidth(e3, t3 = [0, 0, 0, 0]) {
        if (e3 instanceof Name)
          this.width = 0;
        else if ("number" == typeof e3) {
          if (e3 > 0) {
            const i3 = (t3[2] - t3[0]) / 2, a3 = (t3[3] - t3[1]) / 2;
            if (i3 > 0 && a3 > 0 && (e3 > i3 || e3 > a3)) {
              warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e3}`);
              e3 = 1;
            }
          }
          this.width = e3;
        }
      }
      setStyle(e3) {
        if (e3 instanceof Name)
          switch (e3.name) {
            case "S":
              this.style = hA;
              break;
            case "D":
              this.style = lA;
              break;
            case "B":
              this.style = BA;
              break;
            case "I":
              this.style = QA;
              break;
            case "U":
              this.style = EA;
          }
      }
      setDashArray(e3, t3 = false) {
        if (Array.isArray(e3)) {
          let i3 = true, a3 = true;
          for (const t4 of e3) {
            if (!(+t4 >= 0)) {
              i3 = false;
              break;
            }
            t4 > 0 && (a3 = false);
          }
          if (0 === e3.length || i3 && !a3) {
            this.dashArray = e3;
            t3 && this.setStyle(Name.get("D"));
          } else
            this.width = 0;
        } else
          e3 && (this.width = 0);
      }
      setHorizontalCornerRadius(e3) {
        Number.isInteger(e3) && (this.horizontalCornerRadius = e3);
      }
      setVerticalCornerRadius(e3) {
        Number.isInteger(e3) && (this.verticalCornerRadius = e3);
      }
    };
    MarkupAnnotation = class extends Annotation {
      constructor(e3) {
        super(e3);
        const { dict: t3 } = e3;
        if (t3.has("IRT")) {
          const e4 = t3.getRaw("IRT");
          this.data.inReplyTo = e4 instanceof Ref ? e4.toString() : null;
          const i4 = t3.get("RT");
          this.data.replyType = i4 instanceof Name ? i4.name : X2;
        }
        let i3 = null;
        if (this.data.replyType === j2) {
          const e4 = t3.get("IRT");
          this.setTitle(e4.get("T"));
          this.data.titleObj = this._title;
          this.setContents(e4.get("Contents"));
          this.data.contentsObj = this._contents;
          if (e4.has("CreationDate")) {
            this.setCreationDate(e4.get("CreationDate"));
            this.data.creationDate = this.creationDate;
          } else
            this.data.creationDate = null;
          if (e4.has("M")) {
            this.setModificationDate(e4.get("M"));
            this.data.modificationDate = this.modificationDate;
          } else
            this.data.modificationDate = null;
          i3 = e4.getRaw("Popup");
          if (e4.has("C")) {
            this.setColor(e4.getArray("C"));
            this.data.color = this.color;
          } else
            this.data.color = null;
        } else {
          this.data.titleObj = this._title;
          this.setCreationDate(t3.get("CreationDate"));
          this.data.creationDate = this.creationDate;
          i3 = t3.getRaw("Popup");
          t3.has("C") || (this.data.color = null);
        }
        this.data.popupRef = i3 instanceof Ref ? i3.toString() : null;
        t3.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t3.get("RC")));
      }
      setCreationDate(e3) {
        this.creationDate = "string" == typeof e3 ? e3 : null;
      }
      _setDefaultAppearance({ xref: e3, extra: t3, strokeColor: i3, fillColor: a3, blendMode: s3, strokeAlpha: r3, fillAlpha: n3, pointsCallback: o3 }) {
        let g3 = Number.MAX_VALUE, c3 = Number.MAX_VALUE, C3 = Number.MIN_VALUE, h2 = Number.MIN_VALUE;
        const l3 = ["q"];
        t3 && l3.push(t3);
        i3 && l3.push(`${i3[0]} ${i3[1]} ${i3[2]} RG`);
        a3 && l3.push(`${a3[0]} ${a3[1]} ${a3[2]} rg`);
        let Q3 = this.data.quadPoints;
        Q3 || (Q3 = [[{ x: this.rectangle[0], y: this.rectangle[3] }, { x: this.rectangle[2], y: this.rectangle[3] }, { x: this.rectangle[0], y: this.rectangle[1] }, { x: this.rectangle[2], y: this.rectangle[1] }]]);
        for (const e4 of Q3) {
          const [t4, i4, a4, s4] = o3(l3, e4);
          g3 = Math.min(g3, t4);
          C3 = Math.max(C3, i4);
          c3 = Math.min(c3, a4);
          h2 = Math.max(h2, s4);
        }
        l3.push("Q");
        const E3 = new Dict(e3), u3 = new Dict(e3);
        u3.set("Subtype", Name.get("Form"));
        const d3 = new StringStream(l3.join(" "));
        d3.dict = u3;
        E3.set("Fm0", d3);
        const f2 = new Dict(e3);
        s3 && f2.set("BM", Name.get(s3));
        "number" == typeof r3 && f2.set("CA", r3);
        "number" == typeof n3 && f2.set("ca", n3);
        const p2 = new Dict(e3);
        p2.set("GS0", f2);
        const m3 = new Dict(e3);
        m3.set("ExtGState", p2);
        m3.set("XObject", E3);
        const y3 = new Dict(e3);
        y3.set("Resources", m3);
        const w3 = this.data.rect = [g3, c3, C3, h2];
        y3.set("BBox", w3);
        this.appearance = new StringStream("/GS0 gs /Fm0 Do");
        this.appearance.dict = y3;
        this._streams.push(this.appearance, d3);
      }
      static async createNewAnnotation(e3, t3, i3, a3) {
        const s3 = t3.ref || (t3.ref = e3.getNewTemporaryRef()), r3 = await this.createNewAppearanceStream(t3, e3, a3), n3 = [];
        let o3;
        if (r3) {
          const a4 = e3.getNewTemporaryRef();
          o3 = this.createNewDict(t3, e3, { apRef: a4 });
          await writeObject(a4, r3, n3, e3);
          i3.push({ ref: a4, data: n3.join("") });
        } else
          o3 = this.createNewDict(t3, e3, {});
        Number.isInteger(t3.parentTreeId) && o3.set("StructParent", t3.parentTreeId);
        n3.length = 0;
        await writeObject(s3, o3, n3, e3);
        return { ref: s3, data: n3.join("") };
      }
      static async createNewPrintAnnotation(e3, t3, i3, a3) {
        const s3 = await this.createNewAppearanceStream(i3, t3, a3), r3 = this.createNewDict(i3, t3, { ap: s3 }), n3 = new this.prototype.constructor({ dict: r3, xref: t3, annotationGlobals: e3, evaluatorOptions: a3.evaluatorOptions });
        i3.ref && (n3.ref = n3.refToReplace = i3.ref);
        return n3;
      }
    };
    WidgetAnnotation = class _WidgetAnnotation extends Annotation {
      constructor(e3) {
        var _a3;
        super(e3);
        const { dict: t3, xref: i3, annotationGlobals: a3 } = e3, s3 = this.data;
        this._needAppearances = e3.needAppearances;
        s3.annotationType = W2;
        void 0 === s3.fieldName && (s3.fieldName = this._constructFieldName(t3));
        void 0 === s3.actions && (s3.actions = collectActions(i3, t3, uA));
        let r3 = getInheritableProperty({ dict: t3, key: "V", getArray: true });
        s3.fieldValue = this._decodeFormValue(r3);
        const n3 = getInheritableProperty({ dict: t3, key: "DV", getArray: true });
        s3.defaultFieldValue = this._decodeFormValue(n3);
        if (void 0 === r3 && a3.xfaDatasets) {
          const e4 = this._title.str;
          if (e4) {
            this._hasValueFromXFA = true;
            s3.fieldValue = r3 = a3.xfaDatasets.getValue(e4);
          }
        }
        void 0 === r3 && null !== s3.defaultFieldValue && (s3.fieldValue = s3.defaultFieldValue);
        s3.alternativeText = stringToPDFString(t3.get("TU") || "");
        this.setDefaultAppearance(e3);
        s3.hasAppearance || (s3.hasAppearance = this._needAppearances && void 0 !== s3.fieldValue && null !== s3.fieldValue);
        const o3 = getInheritableProperty({ dict: t3, key: "FT" });
        s3.fieldType = o3 instanceof Name ? o3.name : null;
        const g3 = getInheritableProperty({ dict: t3, key: "DR" }), c3 = a3.acroForm.get("DR"), C3 = (_a3 = this.appearance) == null ? void 0 : _a3.dict.get("Resources");
        this._fieldResources = { localResources: g3, acroFormResources: c3, appearanceResources: C3, mergedResources: Dict.merge({ xref: i3, dictArray: [g3, C3, c3], mergeSubDicts: true }) };
        s3.fieldFlags = getInheritableProperty({ dict: t3, key: "Ff" });
        (!Number.isInteger(s3.fieldFlags) || s3.fieldFlags < 0) && (s3.fieldFlags = 0);
        s3.readOnly = this.hasFieldFlag(tA);
        s3.required = this.hasFieldFlag(iA);
        s3.hidden = this._hasFlag(s3.annotationFlags, V2) || this._hasFlag(s3.annotationFlags, $2);
      }
      _decodeFormValue(e3) {
        return Array.isArray(e3) ? e3.filter((e4) => "string" == typeof e4).map((e4) => stringToPDFString(e4)) : e3 instanceof Name ? stringToPDFString(e3.name) : "string" == typeof e3 ? stringToPDFString(e3) : null;
      }
      hasFieldFlag(e3) {
        return !!(this.data.fieldFlags & e3);
      }
      _isViewable(e3) {
        return true;
      }
      mustBeViewed(e3, t3) {
        return t3 ? this.viewable : super.mustBeViewed(e3, t3) && !this._hasFlag(this.flags, $2);
      }
      getRotationMatrix(e3) {
        var _a3;
        let t3 = (_a3 = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a3.rotation;
        void 0 === t3 && (t3 = this.rotation);
        if (0 === t3)
          return i2;
        return getRotationMatrix(t3, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]);
      }
      getBorderAndBackgroundAppearances(e3) {
        var _a3;
        let t3 = (_a3 = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a3.rotation;
        void 0 === t3 && (t3 = this.rotation);
        if (!this.backgroundColor && !this.borderColor)
          return "";
        const i3 = this.data.rect[2] - this.data.rect[0], a3 = this.data.rect[3] - this.data.rect[1], s3 = 0 === t3 || 180 === t3 ? `0 0 ${i3} ${a3} re` : `0 0 ${a3} ${i3} re`;
        let r3 = "";
        this.backgroundColor && (r3 = `${getPdfColor(this.backgroundColor, true)} ${s3} f `);
        if (this.borderColor) {
          r3 += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, false)} ${s3} S `;
        }
        return r3;
      }
      async getOperatorList(e3, t3, i3, a3, s3) {
        if (a3 && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas)
          return { opList: new OperatorList(), separateForm: true, separateCanvas: false };
        if (!this._hasText)
          return super.getOperatorList(e3, t3, i3, a3, s3);
        const r3 = await this._getAppearance(e3, t3, i3, s3);
        if (this.appearance && null === r3)
          return super.getOperatorList(e3, t3, i3, a3, s3);
        const n3 = new OperatorList();
        if (!this._defaultAppearance || null === r3)
          return { opList: n3, separateForm: false, separateCanvas: false };
        const o3 = !!(this.data.hasOwnCanvas && i3 & g2), c3 = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], C3 = getTransformMatrix(this.data.rect, c3, [1, 0, 0, 1, 0, 0]);
        let h2;
        this.oc && (h2 = await e3.parseMarkedContentProps(this.oc, null));
        void 0 !== h2 && n3.addOp(Je2, ["OC", h2]);
        n3.addOp(We2, [this.data.id, this.data.rect, C3, this.getRotationMatrix(s3), o3]);
        const l3 = new StringStream(r3);
        await e3.getOperatorList({ stream: l3, task: t3, resources: this._fieldResources.mergedResources, operatorList: n3 });
        n3.addOp(je2, []);
        void 0 !== h2 && n3.addOp(Ye2, []);
        return { opList: n3, separateForm: false, separateCanvas: o3 };
      }
      _getMKDict(e3) {
        const t3 = new Dict(null);
        e3 && t3.set("R", e3);
        this.borderColor && t3.set("BC", getPdfColorArray(this.borderColor));
        this.backgroundColor && t3.set("BG", getPdfColorArray(this.backgroundColor));
        return t3.size > 0 ? t3 : null;
      }
      amendSavedDict(e3, t3) {
      }
      async save(e3, t3, a3) {
        const s3 = a3 == null ? void 0 : a3.get(this.data.id);
        let r3 = s3 == null ? void 0 : s3.value, n3 = s3 == null ? void 0 : s3.rotation;
        if (r3 === this.data.fieldValue || void 0 === r3) {
          if (!this._hasValueFromXFA && void 0 === n3)
            return null;
          r3 || (r3 = this.data.fieldValue);
        }
        if (void 0 === n3 && !this._hasValueFromXFA && Array.isArray(r3) && Array.isArray(this.data.fieldValue) && r3.length === this.data.fieldValue.length && r3.every((e4, t4) => e4 === this.data.fieldValue[t4]))
          return null;
        void 0 === n3 && (n3 = this.rotation);
        let o3 = null;
        if (!this._needAppearances) {
          o3 = await this._getAppearance(e3, t3, C2, a3);
          if (null === o3)
            return null;
        }
        let g3 = false;
        if (o3 == null ? void 0 : o3.needAppearances) {
          g3 = true;
          o3 = null;
        }
        const { xref: c3 } = e3, h2 = c3.fetchIfRef(this.ref);
        if (!(h2 instanceof Dict))
          return null;
        const l3 = new Dict(c3);
        for (const e4 of h2.getKeys())
          "AP" !== e4 && l3.set(e4, h2.getRaw(e4));
        const Q3 = { path: this.data.fieldName, value: r3 }, encoder = (e4) => isAscii(e4) ? e4 : stringToUTF16String(e4, true);
        l3.set("V", Array.isArray(r3) ? r3.map(encoder) : encoder(r3));
        this.amendSavedDict(a3, l3);
        const E3 = this._getMKDict(n3);
        E3 && l3.set("MK", E3);
        const u3 = [], d3 = [{ ref: this.ref, data: "", xfa: Q3, needAppearances: g3 }];
        if (null !== o3) {
          const e4 = c3.getNewTemporaryRef(), t4 = new Dict(c3);
          l3.set("AP", t4);
          t4.set("N", e4);
          const s4 = this._getSaveFieldResources(c3), r4 = new StringStream(o3), n4 = r4.dict = new Dict(c3);
          n4.set("Subtype", Name.get("Form"));
          n4.set("Resources", s4);
          n4.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
          const g4 = this.getRotationMatrix(a3);
          g4 !== i2 && n4.set("Matrix", g4);
          await writeObject(e4, r4, u3, c3);
          d3.push({ ref: e4, data: u3.join(""), xfa: null, needAppearances: false });
          u3.length = 0;
        }
        l3.set("M", `D:${getModificationDate()}`);
        await writeObject(this.ref, l3, u3, c3);
        d3[0].data = u3.join("");
        return d3;
      }
      async _getAppearance(e3, t3, i3, a3) {
        if (this.hasFieldFlag(sA))
          return null;
        const s3 = a3 == null ? void 0 : a3.get(this.data.id);
        let r3, o3;
        if (s3) {
          r3 = s3.formattedValue || s3.value;
          o3 = s3.rotation;
        }
        if (void 0 === o3 && void 0 === r3 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance))
          return null;
        const g3 = this.getBorderAndBackgroundAppearances(a3);
        if (void 0 === r3) {
          r3 = this.data.fieldValue;
          if (!r3)
            return `/Tx BMC q ${g3}Q EMC`;
        }
        Array.isArray(r3) && 1 === r3.length && (r3 = r3[0]);
        assert("string" == typeof r3, "Expected `value` to be a string.");
        r3 = r3.trim();
        if (this.data.combo) {
          const e4 = this.data.options.find(({ exportValue: e5 }) => r3 === e5);
          r3 = (e4 == null ? void 0 : e4.displayValue) || r3;
        }
        if ("" === r3)
          return `/Tx BMC q ${g3}Q EMC`;
        void 0 === o3 && (o3 = this.rotation);
        let c3, h2 = -1;
        if (this.data.multiLine) {
          c3 = r3.split(/\r\n?|\n/).map((e4) => e4.normalize("NFC"));
          h2 = c3.length;
        } else
          c3 = [r3.replace(/\r\n?|\n/, "").normalize("NFC")];
        let l3 = this.data.rect[3] - this.data.rect[1], Q3 = this.data.rect[2] - this.data.rect[0];
        90 !== o3 && 270 !== o3 || ([Q3, l3] = [l3, Q3]);
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        let E3, u3, d3, f2 = await _WidgetAnnotation._getFontData(e3, t3, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        const p2 = [];
        let m3 = false;
        for (const e4 of c3) {
          const t4 = f2.encodeString(e4);
          t4.length > 1 && (m3 = true);
          p2.push(t4.join(""));
        }
        if (m3 && i3 & C2)
          return { needAppearances: true };
        if (m3 && this._isOffscreenCanvasSupported) {
          const i4 = this.data.comb ? "monospace" : "sans-serif", a4 = new FakeUnicodeFont(e3.xref, i4), s4 = a4.createFontResources(c3.join("")), n3 = s4.getRaw("Font");
          if (this._fieldResources.mergedResources.has("Font")) {
            const e4 = this._fieldResources.mergedResources.get("Font");
            for (const t4 of n3.getKeys())
              e4.set(t4, n3.getRaw(t4));
          } else
            this._fieldResources.mergedResources.set("Font", n3);
          const o4 = a4.fontName.name;
          f2 = await _WidgetAnnotation._getFontData(e3, t3, { fontName: o4, fontSize: 0 }, s4);
          for (let e4 = 0, t4 = p2.length; e4 < t4; e4++)
            p2[e4] = stringToUTF16String(c3[e4]);
          const g4 = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
          this.data.defaultAppearanceData.fontSize = 0;
          this.data.defaultAppearanceData.fontName = o4;
          [E3, u3, d3] = this._computeFontSize(l3 - 2, Q3 - 4, r3, f2, h2);
          this.data.defaultAppearanceData = g4;
        } else {
          this._isOffscreenCanvasSupported || warn("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
          [E3, u3, d3] = this._computeFontSize(l3 - 2, Q3 - 4, r3, f2, h2);
        }
        let y3 = f2.descent;
        y3 = isNaN(y3) ? n2 * d3 : Math.max(n2 * d3, Math.abs(y3) * u3);
        const w3 = Math.min(Math.floor((l3 - u3) / 2), 1), b3 = this.data.textAlignment;
        if (this.data.multiLine)
          return this._getMultilineAppearance(E3, p2, f2, u3, Q3, l3, b3, 2, w3, y3, d3, a3);
        if (this.data.comb)
          return this._getCombAppearance(E3, f2, p2[0], u3, Q3, l3, 2, w3, y3, d3, a3);
        const D3 = w3 + y3;
        if (0 === b3 || b3 > 2)
          return `/Tx BMC q ${g3}BT ` + E3 + ` 1 0 0 1 ${numberToString(2)} ${numberToString(D3)} Tm (${escapeString(p2[0])}) Tj ET Q EMC`;
        return `/Tx BMC q ${g3}BT ` + E3 + ` 1 0 0 1 0 0 Tm ${this._renderText(p2[0], f2, u3, Q3, b3, { shift: 0 }, 2, D3)} ET Q EMC`;
      }
      static async _getFontData(e3, t3, i3, a3) {
        const s3 = new OperatorList(), r3 = { font: null, clone() {
          return this;
        } }, { fontName: n3, fontSize: o3 } = i3;
        await e3.handleSetFont(a3, [n3 && Name.get(n3), o3], null, s3, t3, r3, null);
        return r3.font;
      }
      _getTextWidth(e3, t3) {
        return t3.charsToGlyphs(e3).reduce((e4, t4) => e4 + t4.width, 0) / 1e3;
      }
      _computeFontSize(e3, t3, i3, a3, r3) {
        let { fontSize: n3 } = this.data.defaultAppearanceData, o3 = (n3 || 12) * s2, g3 = Math.round(e3 / o3);
        if (!n3) {
          const roundWithTwoDigits = (e4) => Math.floor(100 * e4) / 100;
          if (-1 === r3) {
            const r4 = this._getTextWidth(i3, a3);
            n3 = roundWithTwoDigits(Math.min(e3 / s2, r4 > t3 ? t3 / r4 : 1 / 0));
            g3 = 1;
          } else {
            const c4 = i3.split(/\r\n?|\n/), C4 = [];
            for (const e4 of c4) {
              const t4 = a3.encodeString(e4).join(""), i4 = a3.charsToGlyphs(t4), s3 = a3.getCharPositions(t4);
              C4.push({ line: t4, glyphs: i4, positions: s3 });
            }
            const isTooBig = (i4) => {
              let s3 = 0;
              for (const r4 of C4) {
                s3 += this._splitLine(null, a3, i4, t3, r4).length * i4;
                if (s3 > e3)
                  return true;
              }
              return false;
            };
            g3 = Math.max(g3, r3);
            for (; ; ) {
              o3 = e3 / g3;
              n3 = roundWithTwoDigits(o3 / s2);
              if (!isTooBig(n3))
                break;
              g3++;
            }
          }
          const { fontName: c3, fontColor: C3 } = this.data.defaultAppearanceData;
          this._defaultAppearance = function createDefaultAppearance({ fontSize: e4, fontName: t4, fontColor: i4 }) {
            return `/${escapePDFName(t4)} ${e4} Tf ${getPdfColor(i4, true)}`;
          }({ fontSize: n3, fontName: c3, fontColor: C3 });
        }
        return [this._defaultAppearance, n3, e3 / g3];
      }
      _renderText(e3, t3, i3, a3, s3, r3, n3, o3) {
        let g3;
        if (1 === s3) {
          g3 = (a3 - this._getTextWidth(e3, t3) * i3) / 2;
        } else if (2 === s3) {
          g3 = a3 - this._getTextWidth(e3, t3) * i3 - n3;
        } else
          g3 = n3;
        const c3 = numberToString(g3 - r3.shift);
        r3.shift = g3;
        return `${c3} ${o3 = numberToString(o3)} Td (${escapeString(e3)}) Tj`;
      }
      _getSaveFieldResources(e3) {
        var _a3;
        const { localResources: t3, appearanceResources: i3, acroFormResources: a3 } = this._fieldResources, s3 = (_a3 = this.data.defaultAppearanceData) == null ? void 0 : _a3.fontName;
        if (!s3)
          return t3 || Dict.empty;
        for (const e4 of [t3, i3])
          if (e4 instanceof Dict) {
            const t4 = e4.get("Font");
            if (t4 instanceof Dict && t4.has(s3))
              return e4;
          }
        if (a3 instanceof Dict) {
          const i4 = a3.get("Font");
          if (i4 instanceof Dict && i4.has(s3)) {
            const a4 = new Dict(e3);
            a4.set(s3, i4.getRaw(s3));
            const r3 = new Dict(e3);
            r3.set("Font", a4);
            return Dict.merge({ xref: e3, dictArray: [r3, t3], mergeSubDicts: true });
          }
        }
        return t3 || Dict.empty;
      }
      getFieldObject() {
        return null;
      }
    };
    TextWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e3) {
        super(e3);
        this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
        this._hasText = true;
        const t3 = e3.dict;
        "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
        let i3 = getInheritableProperty({ dict: t3, key: "Q" });
        (!Number.isInteger(i3) || i3 < 0 || i3 > 2) && (i3 = null);
        this.data.textAlignment = i3;
        let a3 = getInheritableProperty({ dict: t3, key: "MaxLen" });
        (!Number.isInteger(a3) || a3 < 0) && (a3 = 0);
        this.data.maxLen = a3;
        this.data.multiLine = this.hasFieldFlag(aA);
        this.data.comb = this.hasFieldFlag(CA) && !this.hasFieldFlag(aA) && !this.hasFieldFlag(sA) && !this.hasFieldFlag(gA) && 0 !== this.data.maxLen;
        this.data.doNotScroll = this.hasFieldFlag(cA);
      }
      get hasTextContent() {
        return !!this.appearance && !this._needAppearances;
      }
      _getCombAppearance(e3, t3, i3, a3, s3, r3, n3, o3, g3, c3, C3) {
        const h2 = s3 / this.data.maxLen, l3 = this.getBorderAndBackgroundAppearances(C3), Q3 = [], E3 = t3.getCharPositions(i3);
        for (const [e4, t4] of E3)
          Q3.push(`(${escapeString(i3.substring(e4, t4))}) Tj`);
        const u3 = Q3.join(` ${numberToString(h2)} 0 Td `);
        return `/Tx BMC q ${l3}BT ` + e3 + ` 1 0 0 1 ${numberToString(n3)} ${numberToString(o3 + g3)} Tm ${u3} ET Q EMC`;
      }
      _getMultilineAppearance(e3, t3, i3, a3, s3, r3, n3, o3, g3, c3, C3, h2) {
        const l3 = [], Q3 = s3 - 2 * o3, E3 = { shift: 0 };
        for (let e4 = 0, r4 = t3.length; e4 < r4; e4++) {
          const r5 = t3[e4], h3 = this._splitLine(r5, i3, a3, Q3);
          for (let t4 = 0, r6 = h3.length; t4 < r6; t4++) {
            const r7 = h3[t4], Q4 = 0 === e4 && 0 === t4 ? -g3 - (C3 - c3) : -C3;
            l3.push(this._renderText(r7, i3, a3, s3, n3, E3, o3, Q4));
          }
        }
        const u3 = this.getBorderAndBackgroundAppearances(h2), d3 = l3.join("\n");
        return `/Tx BMC q ${u3}BT ` + e3 + ` 1 0 0 1 0 ${numberToString(r3)} Tm ${d3} ET Q EMC`;
      }
      _splitLine(e3, t3, i3, a3, s3 = {}) {
        e3 = s3.line || e3;
        const r3 = s3.glyphs || t3.charsToGlyphs(e3);
        if (r3.length <= 1)
          return [e3];
        const n3 = s3.positions || t3.getCharPositions(e3), o3 = i3 / 1e3, g3 = [];
        let c3 = -1, C3 = -1, h2 = -1, l3 = 0, Q3 = 0;
        for (let t4 = 0, i4 = r3.length; t4 < i4; t4++) {
          const [i5, s4] = n3[t4], E3 = r3[t4], u3 = E3.width * o3;
          if (" " === E3.unicode)
            if (Q3 + u3 > a3) {
              g3.push(e3.substring(l3, i5));
              l3 = i5;
              Q3 = u3;
              c3 = -1;
              h2 = -1;
            } else {
              Q3 += u3;
              c3 = i5;
              C3 = s4;
              h2 = t4;
            }
          else if (Q3 + u3 > a3)
            if (-1 !== c3) {
              g3.push(e3.substring(l3, C3));
              l3 = C3;
              t4 = h2 + 1;
              c3 = -1;
              Q3 = 0;
            } else {
              g3.push(e3.substring(l3, i5));
              l3 = i5;
              Q3 = u3;
            }
          else
            Q3 += u3;
        }
        l3 < e3.length && g3.push(e3.substring(l3, e3.length));
        return g3;
      }
      getFieldObject() {
        return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.hasFieldFlag(sA), charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: "text" };
      }
    };
    ButtonWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e3) {
        super(e3);
        this.checkedAppearance = null;
        this.uncheckedAppearance = null;
        this.data.checkBox = !this.hasFieldFlag(rA) && !this.hasFieldFlag(nA);
        this.data.radioButton = this.hasFieldFlag(rA) && !this.hasFieldFlag(nA);
        this.data.pushButton = this.hasFieldFlag(nA);
        this.data.isTooltipOnly = false;
        if (this.data.checkBox)
          this._processCheckBox(e3);
        else if (this.data.radioButton)
          this._processRadioButton(e3);
        else if (this.data.pushButton) {
          this.data.hasOwnCanvas = true;
          this.data.noHTML = false;
          this._processPushButton(e3);
        } else
          warn("Invalid field flags for button widget annotation");
      }
      async getOperatorList(e3, t3, a3, s3, r3) {
        if (this.data.pushButton)
          return super.getOperatorList(e3, t3, a3, false, r3);
        let n3 = null, o3 = null;
        if (r3) {
          const e4 = r3.get(this.data.id);
          n3 = e4 ? e4.value : null;
          o3 = e4 ? e4.rotation : null;
        }
        if (null === n3 && this.appearance)
          return super.getOperatorList(e3, t3, a3, s3, r3);
        null == n3 && (n3 = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
        const g3 = n3 ? this.checkedAppearance : this.uncheckedAppearance;
        if (g3) {
          const n4 = this.appearance, c3 = g3.dict.getArray("Matrix") || i2;
          o3 && g3.dict.set("Matrix", this.getRotationMatrix(r3));
          this.appearance = g3;
          const C3 = super.getOperatorList(e3, t3, a3, s3, r3);
          this.appearance = n4;
          g3.dict.set("Matrix", c3);
          return C3;
        }
        return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
      }
      async save(e3, t3, i3) {
        return this.data.checkBox ? this._saveCheckbox(e3, t3, i3) : this.data.radioButton ? this._saveRadioButton(e3, t3, i3) : null;
      }
      async _saveCheckbox(e3, t3, i3) {
        if (!i3)
          return null;
        const a3 = i3.get(this.data.id);
        let s3 = a3 == null ? void 0 : a3.rotation, r3 = a3 == null ? void 0 : a3.value;
        if (void 0 === s3) {
          if (void 0 === r3)
            return null;
          if (this.data.fieldValue === this.data.exportValue === r3)
            return null;
        }
        const n3 = e3.xref.fetchIfRef(this.ref);
        if (!(n3 instanceof Dict))
          return null;
        void 0 === s3 && (s3 = this.rotation);
        void 0 === r3 && (r3 = this.data.fieldValue === this.data.exportValue);
        const o3 = { path: this.data.fieldName, value: r3 ? this.data.exportValue : "" }, g3 = Name.get(r3 ? this.data.exportValue : "Off");
        n3.set("V", g3);
        n3.set("AS", g3);
        n3.set("M", `D:${getModificationDate()}`);
        const c3 = this._getMKDict(s3);
        c3 && n3.set("MK", c3);
        const C3 = [];
        await writeObject(this.ref, n3, C3, e3.xref);
        return [{ ref: this.ref, data: C3.join(""), xfa: o3 }];
      }
      async _saveRadioButton(e3, t3, i3) {
        if (!i3)
          return null;
        const a3 = i3.get(this.data.id);
        let s3 = a3 == null ? void 0 : a3.rotation, r3 = a3 == null ? void 0 : a3.value;
        if (void 0 === s3) {
          if (void 0 === r3)
            return null;
          if (this.data.fieldValue === this.data.buttonValue === r3)
            return null;
        }
        const n3 = e3.xref.fetchIfRef(this.ref);
        if (!(n3 instanceof Dict))
          return null;
        void 0 === r3 && (r3 = this.data.fieldValue === this.data.buttonValue);
        void 0 === s3 && (s3 = this.rotation);
        const o3 = { path: this.data.fieldName, value: r3 ? this.data.buttonValue : "" }, g3 = Name.get(r3 ? this.data.buttonValue : "Off"), c3 = [];
        let C3 = null;
        if (r3)
          if (this.parent instanceof Ref) {
            const t4 = e3.xref.fetch(this.parent);
            t4.set("V", g3);
            await writeObject(this.parent, t4, c3, e3.xref);
            C3 = c3.join("");
            c3.length = 0;
          } else
            this.parent instanceof Dict && this.parent.set("V", g3);
        n3.set("AS", g3);
        n3.set("M", `D:${getModificationDate()}`);
        const h2 = this._getMKDict(s3);
        h2 && n3.set("MK", h2);
        await writeObject(this.ref, n3, c3, e3.xref);
        const l3 = [{ ref: this.ref, data: c3.join(""), xfa: o3 }];
        C3 && l3.push({ ref: this.parent, data: C3, xfa: null });
        return l3;
      }
      _getDefaultCheckedAppearance(e3, t3) {
        const i3 = this.data.rect[2] - this.data.rect[0], a3 = this.data.rect[3] - this.data.rect[1], s3 = [0, 0, i3, a3], r3 = 0.8 * Math.min(i3, a3);
        let n3, o3;
        if ("check" === t3) {
          n3 = { width: 0.755 * r3, height: 0.705 * r3 };
          o3 = "3";
        } else if ("disc" === t3) {
          n3 = { width: 0.791 * r3, height: 0.705 * r3 };
          o3 = "l";
        } else
          unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t3}`);
        const g3 = `q BT /PdfJsZaDb ${r3} Tf 0 g ${numberToString((i3 - n3.width) / 2)} ${numberToString((a3 - n3.height) / 2)} Td (${o3}) Tj ET Q`, c3 = new Dict(e3.xref);
        c3.set("FormType", 1);
        c3.set("Subtype", Name.get("Form"));
        c3.set("Type", Name.get("XObject"));
        c3.set("BBox", s3);
        c3.set("Matrix", [1, 0, 0, 1, 0, 0]);
        c3.set("Length", g3.length);
        const C3 = new Dict(e3.xref), h2 = new Dict(e3.xref);
        h2.set("PdfJsZaDb", this.fallbackFontDict);
        C3.set("Font", h2);
        c3.set("Resources", C3);
        this.checkedAppearance = new StringStream(g3);
        this.checkedAppearance.dict = c3;
        this._streams.push(this.checkedAppearance);
      }
      _processCheckBox(e3) {
        const t3 = e3.dict.get("AP");
        if (!(t3 instanceof Dict))
          return;
        const i3 = t3.get("N");
        if (!(i3 instanceof Dict))
          return;
        const a3 = this._decodeFormValue(e3.dict.get("AS"));
        "string" == typeof a3 && (this.data.fieldValue = a3);
        const s3 = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", r3 = i3.getKeys();
        if (0 === r3.length)
          r3.push("Off", s3);
        else if (1 === r3.length)
          "Off" === r3[0] ? r3.push(s3) : r3.unshift("Off");
        else if (r3.includes(s3)) {
          r3.length = 0;
          r3.push("Off", s3);
        } else {
          const e4 = r3.find((e5) => "Off" !== e5);
          r3.length = 0;
          r3.push("Off", e4);
        }
        r3.includes(this.data.fieldValue) || (this.data.fieldValue = "Off");
        this.data.exportValue = r3[1];
        const n3 = i3.get(this.data.exportValue);
        this.checkedAppearance = n3 instanceof BaseStream ? n3 : null;
        const o3 = i3.get("Off");
        this.uncheckedAppearance = o3 instanceof BaseStream ? o3 : null;
        this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e3, "check");
        this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
        this._fallbackFontDict = this.fallbackFontDict;
        null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
      }
      _processRadioButton(e3) {
        this.data.buttonValue = null;
        const t3 = e3.dict.get("Parent");
        if (t3 instanceof Dict) {
          this.parent = e3.dict.getRaw("Parent");
          const i4 = t3.get("V");
          i4 instanceof Name && (this.data.fieldValue = this._decodeFormValue(i4));
        }
        const i3 = e3.dict.get("AP");
        if (!(i3 instanceof Dict))
          return;
        const a3 = i3.get("N");
        if (!(a3 instanceof Dict))
          return;
        for (const e4 of a3.getKeys())
          if ("Off" !== e4) {
            this.data.buttonValue = this._decodeFormValue(e4);
            break;
          }
        const s3 = a3.get(this.data.buttonValue);
        this.checkedAppearance = s3 instanceof BaseStream ? s3 : null;
        const r3 = a3.get("Off");
        this.uncheckedAppearance = r3 instanceof BaseStream ? r3 : null;
        this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e3, "disc");
        this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
        this._fallbackFontDict = this.fallbackFontDict;
        null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
      }
      _processPushButton(e3) {
        const { dict: t3, annotationGlobals: i3 } = e3;
        if (t3.has("A") || t3.has("AA") || this.data.alternativeText) {
          this.data.isTooltipOnly = !t3.has("A") && !t3.has("AA");
          Catalog.parseDestDictionary({ destDict: t3, resultObj: this.data, docBaseUrl: i3.baseUrl, docAttachments: i3.attachments });
        } else
          warn("Push buttons without action dictionaries are not supported");
      }
      getFieldObject() {
        let e3, t3 = "button";
        if (this.data.checkBox) {
          t3 = "checkbox";
          e3 = this.data.exportValue;
        } else if (this.data.radioButton) {
          t3 = "radiobutton";
          e3 = this.data.buttonValue;
        }
        return { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: e3, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: t3 };
      }
      get fallbackFontDict() {
        const e3 = new Dict();
        e3.set("BaseFont", Name.get("ZapfDingbats"));
        e3.set("Type", Name.get("FallbackType"));
        e3.set("Subtype", Name.get("FallbackType"));
        e3.set("Encoding", Name.get("ZapfDingbatsEncoding"));
        return shadow(this, "fallbackFontDict", e3);
      }
    };
    ChoiceWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.indices = t3.getArray("I");
        this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
        this.data.options = [];
        const a3 = getInheritableProperty({ dict: t3, key: "Opt" });
        if (Array.isArray(a3))
          for (let e4 = 0, t4 = a3.length; e4 < t4; e4++) {
            const t5 = i3.fetchIfRef(a3[e4]), s3 = Array.isArray(t5);
            this.data.options[e4] = { exportValue: this._decodeFormValue(s3 ? i3.fetchIfRef(t5[0]) : t5), displayValue: this._decodeFormValue(s3 ? i3.fetchIfRef(t5[1]) : t5) };
          }
        if (this.hasIndices) {
          this.data.fieldValue = [];
          const e4 = this.data.options.length;
          for (const t4 of this.indices)
            Number.isInteger(t4) && t4 >= 0 && t4 < e4 && this.data.fieldValue.push(this.data.options[t4].exportValue);
        } else
          "string" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
        this.data.combo = this.hasFieldFlag(oA);
        this.data.multiSelect = this.hasFieldFlag(IA);
        this._hasText = true;
      }
      getFieldObject() {
        const e3 = this.data.combo ? "combobox" : "listbox", t3 = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
        return { id: this.data.id, value: t3, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e3 };
      }
      amendSavedDict(e3, t3) {
        var _a3;
        if (!this.hasIndices)
          return;
        let i3 = (_a3 = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a3.value;
        Array.isArray(i3) || (i3 = [i3]);
        const a3 = [], { options: s3 } = this.data;
        for (let e4 = 0, t4 = 0, r3 = s3.length; e4 < r3; e4++)
          if (s3[e4].exportValue === i3[t4]) {
            a3.push(e4);
            t4 += 1;
          }
        t3.set("I", a3);
      }
      async _getAppearance(e3, t3, i3, a3) {
        if (this.data.combo)
          return super._getAppearance(e3, t3, i3, a3);
        let r3, n3;
        const o3 = a3 == null ? void 0 : a3.get(this.data.id);
        if (o3) {
          n3 = o3.rotation;
          r3 = o3.value;
        }
        if (void 0 === n3 && void 0 === r3 && !this._needAppearances)
          return null;
        void 0 === r3 ? r3 = this.data.fieldValue : Array.isArray(r3) || (r3 = [r3]);
        let g3 = this.data.rect[3] - this.data.rect[1], c3 = this.data.rect[2] - this.data.rect[0];
        90 !== n3 && 270 !== n3 || ([c3, g3] = [g3, c3]);
        const C3 = this.data.options.length, h2 = [];
        for (let e4 = 0; e4 < C3; e4++) {
          const { exportValue: t4 } = this.data.options[e4];
          r3.includes(t4) && h2.push(e4);
        }
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        const l3 = await WidgetAnnotation._getFontData(e3, t3, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        let Q3, { fontSize: E3 } = this.data.defaultAppearanceData;
        if (E3)
          Q3 = this._defaultAppearance;
        else {
          const e4 = (g3 - 1) / C3;
          let t4, i4 = -1;
          for (const { displayValue: e5 } of this.data.options) {
            const a4 = this._getTextWidth(e5, l3);
            if (a4 > i4) {
              i4 = a4;
              t4 = e5;
            }
          }
          [Q3, E3] = this._computeFontSize(e4, c3 - 4, t4, l3, -1);
        }
        const u3 = E3 * s2, d3 = (u3 - E3) / 2, f2 = Math.floor(g3 / u3);
        let p2 = 0;
        if (h2.length > 0) {
          const e4 = Math.min(...h2), t4 = Math.max(...h2);
          p2 = Math.max(0, t4 - f2 + 1);
          p2 > e4 && (p2 = e4);
        }
        const m3 = Math.min(p2 + f2 + 1, C3), y3 = ["/Tx BMC q", `1 1 ${c3} ${g3} re W n`];
        if (h2.length) {
          y3.push("0.600006 0.756866 0.854904 rg");
          for (const e4 of h2)
            p2 <= e4 && e4 < m3 && y3.push(`1 ${g3 - (e4 - p2 + 1) * u3} ${c3} ${u3} re f`);
        }
        y3.push("BT", Q3, `1 0 0 1 0 ${g3} Tm`);
        const w3 = { shift: 0 };
        for (let e4 = p2; e4 < m3; e4++) {
          const { displayValue: t4 } = this.data.options[e4], i4 = e4 === p2 ? d3 : 0;
          y3.push(this._renderText(t4, l3, E3, c3, 0, w3, 2, -u3 + i4));
        }
        y3.push("ET Q EMC");
        return y3.join("\n");
      }
    };
    SignatureWidgetAnnotation = class extends WidgetAnnotation {
      constructor(e3) {
        super(e3);
        this.data.fieldValue = null;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !this.data.hasOwnCanvas;
      }
      getFieldObject() {
        return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
      }
    };
    TextAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        this.data.noRotate = true;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = false;
        const { dict: t3 } = e3;
        this.data.annotationType = S2;
        if (this.data.hasAppearance)
          this.data.name = "NoIcon";
        else {
          this.data.rect[1] = this.data.rect[3] - 22;
          this.data.rect[2] = this.data.rect[0] + 22;
          this.data.name = t3.has("Name") ? t3.get("Name").name : "Note";
        }
        if (t3.has("State")) {
          this.data.state = t3.get("State") || null;
          this.data.stateModel = t3.get("StateModel") || null;
        } else {
          this.data.state = null;
          this.data.stateModel = null;
        }
      }
    };
    LinkAnnotation = class extends Annotation {
      constructor(e3) {
        var _a3;
        super(e3);
        const { dict: t3, annotationGlobals: i3 } = e3;
        this.data.annotationType = k2;
        this.data.noHTML = false;
        const a3 = getQuadPoints(t3, this.rectangle);
        a3 && (this.data.quadPoints = a3);
        (_a3 = this.data).borderColor || (_a3.borderColor = this.data.color);
        Catalog.parseDestDictionary({ destDict: t3, resultObj: this.data, docBaseUrl: i3.baseUrl, docAttachments: i3.attachments });
      }
    };
    PopupAnnotation = class extends Annotation {
      constructor(e3) {
        super(e3);
        const { dict: t3 } = e3;
        this.data.annotationType = q2;
        this.data.noHTML = false;
        this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);
        let i3 = t3.get("Parent");
        if (!i3) {
          warn("Popup annotation has a missing or invalid parent annotation.");
          return;
        }
        const a3 = i3.getArray("Rect");
        this.data.parentRect = Array.isArray(a3) && 4 === a3.length ? Util.normalizeRect(a3) : null;
        isName(i3.get("RT"), j2) && (i3 = i3.get("IRT"));
        if (i3.has("M")) {
          this.setModificationDate(i3.get("M"));
          this.data.modificationDate = this.modificationDate;
        } else
          this.data.modificationDate = null;
        if (i3.has("C")) {
          this.setColor(i3.getArray("C"));
          this.data.color = this.color;
        } else
          this.data.color = null;
        if (!this.viewable) {
          const e4 = i3.get("F");
          this._isViewable(e4) && this.setFlags(e4);
        }
        this.setTitle(i3.get("T"));
        this.data.titleObj = this._title;
        this.setContents(i3.get("Contents"));
        this.data.contentsObj = this._contents;
        i3.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(i3.get("RC")));
        this.data.open = !!t3.get("Open");
      }
    };
    FreeTextAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        var _a3;
        super(e3);
        this.data.hasOwnCanvas = !this.data.noHTML;
        this.data.noHTML = false;
        const { evaluatorOptions: t3, xref: i3 } = e3;
        this.data.annotationType = N2;
        this.setDefaultAppearance(e3);
        this._hasAppearance = !!this.appearance;
        if (this._hasAppearance) {
          const { fontColor: e4, fontSize: a3 } = function parseAppearanceStream(e5, t4, i4) {
            return new AppearanceStreamEvaluator(e5, t4, i4).parse();
          }(this.appearance, t3, i3);
          this.data.defaultAppearanceData.fontColor = e4;
          this.data.defaultAppearanceData.fontSize = a3 || 10;
        } else {
          (_a3 = this.data.defaultAppearanceData).fontSize || (_a3.fontSize = 10);
          const { fontColor: t4, fontSize: a3 } = this.data.defaultAppearanceData;
          if (this._contents.str) {
            this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e5) => e5.trimEnd());
            const { coords: e4, bbox: t5, matrix: i4 } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, a3);
            this.data.textPosition = this._transformPoint(e4, t5, i4);
          }
          if (this._isOffscreenCanvasSupported) {
            const s3 = e3.dict.get("CA"), r3 = new FakeUnicodeFont(i3, "sans-serif");
            this.appearance = r3.createAppearance(this._contents.str, this.rectangle, this.rotation, a3, t4, s3);
            this._streams.push(this.appearance);
          } else
            warn("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
        }
      }
      get hasTextContent() {
        return this._hasAppearance;
      }
      static createNewDict(e3, t3, { apRef: i3, ap: a3 }) {
        const { color: s3, fontSize: r3, rect: n3, rotation: o3, user: g3, value: c3 } = e3, C3 = new Dict(t3);
        C3.set("Type", Name.get("Annot"));
        C3.set("Subtype", Name.get("FreeText"));
        C3.set("CreationDate", `D:${getModificationDate()}`);
        C3.set("Rect", n3);
        const h2 = `/Helv ${r3} Tf ${getPdfColor(s3, true)}`;
        C3.set("DA", h2);
        C3.set("Contents", isAscii(c3) ? c3 : stringToUTF16String(c3, true));
        C3.set("F", 4);
        C3.set("Border", [0, 0, 0]);
        C3.set("Rotate", o3);
        g3 && C3.set("T", isAscii(g3) ? g3 : stringToUTF16String(g3, true));
        if (i3 || a3) {
          const e4 = new Dict(t3);
          C3.set("AP", e4);
          i3 ? e4.set("N", i3) : e4.set("N", a3);
        }
        return C3;
      }
      static async createNewAppearanceStream(e3, t3, i3) {
        const { baseFontRef: a3, evaluator: r3, task: n3 } = i3, { color: o3, fontSize: g3, rect: c3, rotation: C3, value: h2 } = e3, l3 = new Dict(t3), Q3 = new Dict(t3);
        if (a3)
          Q3.set("Helv", a3);
        else {
          const e4 = new Dict(t3);
          e4.set("BaseFont", Name.get("Helvetica"));
          e4.set("Type", Name.get("Font"));
          e4.set("Subtype", Name.get("Type1"));
          e4.set("Encoding", Name.get("WinAnsiEncoding"));
          Q3.set("Helv", e4);
        }
        l3.set("Font", Q3);
        const E3 = await WidgetAnnotation._getFontData(r3, n3, { fontName: "Helv", fontSize: g3 }, l3), [u3, d3, f2, p2] = c3;
        let m3 = f2 - u3, y3 = p2 - d3;
        C3 % 180 != 0 && ([m3, y3] = [y3, m3]);
        const w3 = h2.split("\n"), b3 = g3 / 1e3;
        let D3 = -1 / 0;
        const F3 = [];
        for (let e4 of w3) {
          const t4 = E3.encodeString(e4);
          if (t4.length > 1)
            return null;
          e4 = t4.join("");
          F3.push(e4);
          let i4 = 0;
          const a4 = E3.charsToGlyphs(e4);
          for (const e5 of a4)
            i4 += e5.width * b3;
          D3 = Math.max(D3, i4);
        }
        let S3 = 1;
        D3 > m3 && (S3 = m3 / D3);
        let k3 = 1;
        const N3 = s2 * g3, R3 = 1 * g3, G3 = N3 * w3.length;
        G3 > y3 && (k3 = y3 / G3);
        const x3 = g3 * Math.min(S3, k3);
        let U3, M3, L3;
        switch (C3) {
          case 0:
            L3 = [1, 0, 0, 1];
            M3 = [c3[0], c3[1], m3, y3];
            U3 = [c3[0], c3[3] - R3];
            break;
          case 90:
            L3 = [0, 1, -1, 0];
            M3 = [c3[1], -c3[2], m3, y3];
            U3 = [c3[1], -c3[0] - R3];
            break;
          case 180:
            L3 = [-1, 0, 0, -1];
            M3 = [-c3[2], -c3[3], m3, y3];
            U3 = [-c3[2], -c3[1] - R3];
            break;
          case 270:
            L3 = [0, -1, 1, 0];
            M3 = [-c3[3], c3[0], m3, y3];
            U3 = [-c3[3], c3[2] - R3];
        }
        const H3 = ["q", `${L3.join(" ")} 0 0 cm`, `${M3.join(" ")} re W n`, "BT", `${getPdfColor(o3, true)}`, `0 Tc /Helv ${numberToString(x3)} Tf`];
        H3.push(`${U3.join(" ")} Td (${escapeString(F3[0])}) Tj`);
        const J3 = numberToString(N3);
        for (let e4 = 1, t4 = F3.length; e4 < t4; e4++) {
          const t5 = F3[e4];
          H3.push(`0 -${J3} Td (${escapeString(t5)}) Tj`);
        }
        H3.push("ET", "Q");
        const Y3 = H3.join("\n"), v3 = new Dict(t3);
        v3.set("FormType", 1);
        v3.set("Subtype", Name.get("Form"));
        v3.set("Type", Name.get("XObject"));
        v3.set("BBox", c3);
        v3.set("Resources", l3);
        v3.set("Matrix", [1, 0, 0, 1, -c3[0], -c3[1]]);
        const K3 = new StringStream(Y3);
        K3.dict = v3;
        return K3;
      }
    };
    LineAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = R2;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = false;
        const a3 = t3.getArray("L");
        this.data.lineCoordinates = Util.normalizeRect(a3);
        this.setLineEndings(t3.getArray("LE"));
        this.data.lineEndings = this.lineEndings;
        if (!this.appearance) {
          const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], s3 = t3.get("CA"), r3 = getRgbColor(t3.getArray("IC"), null), n3 = r3 ? getPdfColorArray(r3) : null, o3 = n3 ? s3 : null, g3 = this.borderStyle.width || 1, c3 = 2 * g3, C3 = [this.data.lineCoordinates[0] - c3, this.data.lineCoordinates[1] - c3, this.data.lineCoordinates[2] + c3, this.data.lineCoordinates[3] + c3];
          Util.intersect(this.rectangle, C3) || (this.rectangle = C3);
          this._setDefaultAppearance({ xref: i3, extra: `${g3} w`, strokeColor: e4, fillColor: n3, strokeAlpha: s3, fillAlpha: o3, pointsCallback: (e5, t4) => {
            e5.push(`${a3[0]} ${a3[1]} m`, `${a3[2]} ${a3[3]} l`, "S");
            return [t4[0].x - g3, t4[1].x + g3, t4[3].y - g3, t4[1].y + g3];
          } });
        }
      }
    };
    SquareAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = G2;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = false;
        if (!this.appearance) {
          const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA"), s3 = getRgbColor(t3.getArray("IC"), null), r3 = s3 ? getPdfColorArray(s3) : null, n3 = r3 ? a3 : null;
          if (0 === this.borderStyle.width && !r3)
            return;
          this._setDefaultAppearance({ xref: i3, extra: `${this.borderStyle.width} w`, strokeColor: e4, fillColor: r3, strokeAlpha: a3, fillAlpha: n3, pointsCallback: (e5, t4) => {
            const i4 = t4[2].x + this.borderStyle.width / 2, a4 = t4[2].y + this.borderStyle.width / 2, s4 = t4[3].x - t4[2].x - this.borderStyle.width, n4 = t4[1].y - t4[3].y - this.borderStyle.width;
            e5.push(`${i4} ${a4} ${s4} ${n4} re`);
            r3 ? e5.push("B") : e5.push("S");
            return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
          } });
        }
      }
    };
    CircleAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = x2;
        if (!this.appearance) {
          const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA"), s3 = getRgbColor(t3.getArray("IC"), null), r3 = s3 ? getPdfColorArray(s3) : null, n3 = r3 ? a3 : null;
          if (0 === this.borderStyle.width && !r3)
            return;
          const o3 = 4 / 3 * Math.tan(Math.PI / 8);
          this._setDefaultAppearance({ xref: i3, extra: `${this.borderStyle.width} w`, strokeColor: e4, fillColor: r3, strokeAlpha: a3, fillAlpha: n3, pointsCallback: (e5, t4) => {
            const i4 = t4[0].x + this.borderStyle.width / 2, a4 = t4[0].y - this.borderStyle.width / 2, s4 = t4[3].x - this.borderStyle.width / 2, n4 = t4[3].y + this.borderStyle.width / 2, g3 = i4 + (s4 - i4) / 2, c3 = a4 + (n4 - a4) / 2, C3 = (s4 - i4) / 2 * o3, h2 = (n4 - a4) / 2 * o3;
            e5.push(`${g3} ${n4} m`, `${g3 + C3} ${n4} ${s4} ${c3 + h2} ${s4} ${c3} c`, `${s4} ${c3 - h2} ${g3 + C3} ${a4} ${g3} ${a4} c`, `${g3 - C3} ${a4} ${i4} ${c3 - h2} ${i4} ${c3} c`, `${i4} ${c3 + h2} ${g3 - C3} ${n4} ${g3} ${n4} c`, "h");
            r3 ? e5.push("B") : e5.push("S");
            return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
          } });
        }
      }
    };
    PolylineAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = M2;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = false;
        this.data.vertices = [];
        if (!(this instanceof PolygonAnnotation)) {
          this.setLineEndings(t3.getArray("LE"));
          this.data.lineEndings = this.lineEndings;
        }
        const a3 = t3.getArray("Vertices");
        if (Array.isArray(a3)) {
          for (let e4 = 0, t4 = a3.length; e4 < t4; e4 += 2)
            this.data.vertices.push({ x: a3[e4], y: a3[e4 + 1] });
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a4 = t3.get("CA"), s3 = this.borderStyle.width || 1, r3 = 2 * s3, n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (const e5 of this.data.vertices) {
              n3[0] = Math.min(n3[0], e5.x - r3);
              n3[1] = Math.min(n3[1], e5.y - r3);
              n3[2] = Math.max(n3[2], e5.x + r3);
              n3[3] = Math.max(n3[3], e5.y + r3);
            }
            Util.intersect(this.rectangle, n3) || (this.rectangle = n3);
            this._setDefaultAppearance({ xref: i3, extra: `${s3} w`, strokeColor: e4, strokeAlpha: a4, pointsCallback: (e5, t4) => {
              const i4 = this.data.vertices;
              for (let t5 = 0, a5 = i4.length; t5 < a5; t5++)
                e5.push(`${i4[t5].x} ${i4[t5].y} ${0 === t5 ? "m" : "l"}`);
              e5.push("S");
              return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
            } });
          }
        }
      }
    };
    PolygonAnnotation = class extends PolylineAnnotation {
      constructor(e3) {
        super(e3);
        this.data.annotationType = U2;
      }
    };
    CaretAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        this.data.annotationType = K2;
      }
    };
    InkAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = false;
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = T2;
        this.data.inkLists = [];
        const a3 = t3.getArray("InkList");
        if (Array.isArray(a3)) {
          for (let e4 = 0, t4 = a3.length; e4 < t4; ++e4) {
            this.data.inkLists.push([]);
            for (let t5 = 0, s3 = a3[e4].length; t5 < s3; t5 += 2)
              this.data.inkLists[e4].push({ x: i3.fetchIfRef(a3[e4][t5]), y: i3.fetchIfRef(a3[e4][t5 + 1]) });
          }
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a4 = t3.get("CA"), s3 = this.borderStyle.width || 1, r3 = 2 * s3, n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (const e5 of this.data.inkLists)
              for (const t4 of e5) {
                n3[0] = Math.min(n3[0], t4.x - r3);
                n3[1] = Math.min(n3[1], t4.y - r3);
                n3[2] = Math.max(n3[2], t4.x + r3);
                n3[3] = Math.max(n3[3], t4.y + r3);
              }
            Util.intersect(this.rectangle, n3) || (this.rectangle = n3);
            this._setDefaultAppearance({ xref: i3, extra: `${s3} w`, strokeColor: e4, strokeAlpha: a4, pointsCallback: (e5, t4) => {
              for (const t5 of this.data.inkLists) {
                for (let i4 = 0, a5 = t5.length; i4 < a5; i4++)
                  e5.push(`${t5[i4].x} ${t5[i4].y} ${0 === i4 ? "m" : "l"}`);
                e5.push("S");
              }
              return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
            } });
          }
        }
      }
      static createNewDict(e3, t3, { apRef: i3, ap: a3 }) {
        const { color: s3, opacity: r3, paths: n3, outlines: o3, rect: g3, rotation: c3, thickness: C3 } = e3, h2 = new Dict(t3);
        h2.set("Type", Name.get("Annot"));
        h2.set("Subtype", Name.get("Ink"));
        h2.set("CreationDate", `D:${getModificationDate()}`);
        h2.set("Rect", g3);
        h2.set("InkList", (o3 == null ? void 0 : o3.points) || n3.map((e4) => e4.points));
        h2.set("F", 4);
        h2.set("Rotate", c3);
        o3 && h2.set("IT", Name.get("InkHighlight"));
        const l3 = new Dict(t3);
        h2.set("BS", l3);
        l3.set("W", C3);
        h2.set("C", Array.from(s3, (e4) => e4 / 255));
        h2.set("CA", r3);
        const Q3 = new Dict(t3);
        h2.set("AP", Q3);
        i3 ? Q3.set("N", i3) : Q3.set("N", a3);
        return h2;
      }
      static async createNewAppearanceStream(e3, t3, i3) {
        if (e3.outlines)
          return this.createNewAppearanceStreamForHighlight(e3, t3, i3);
        const { color: a3, rect: s3, paths: r3, thickness: n3, opacity: o3 } = e3, g3 = [`${n3} w 1 J 1 j`, `${getPdfColor(a3, false)}`];
        1 !== o3 && g3.push("/R0 gs");
        const c3 = [];
        for (const { bezier: e4 } of r3) {
          c3.length = 0;
          c3.push(`${numberToString(e4[0])} ${numberToString(e4[1])} m`);
          if (2 === e4.length)
            c3.push(`${numberToString(e4[0])} ${numberToString(e4[1])} l S`);
          else {
            for (let t4 = 2, i4 = e4.length; t4 < i4; t4 += 6) {
              const i5 = e4.slice(t4, t4 + 6).map(numberToString).join(" ");
              c3.push(`${i5} c`);
            }
            c3.push("S");
          }
          g3.push(c3.join("\n"));
        }
        const C3 = g3.join("\n"), h2 = new Dict(t3);
        h2.set("FormType", 1);
        h2.set("Subtype", Name.get("Form"));
        h2.set("Type", Name.get("XObject"));
        h2.set("BBox", s3);
        h2.set("Length", C3.length);
        if (1 !== o3) {
          const e4 = new Dict(t3), i4 = new Dict(t3), a4 = new Dict(t3);
          a4.set("CA", o3);
          a4.set("Type", Name.get("ExtGState"));
          i4.set("R0", a4);
          e4.set("ExtGState", i4);
          h2.set("Resources", e4);
        }
        const l3 = new StringStream(C3);
        l3.dict = h2;
        return l3;
      }
      static async createNewAppearanceStreamForHighlight(e3, t3, i3) {
        const { color: a3, rect: s3, outlines: { outline: r3 }, opacity: n3 } = e3, o3 = [`${getPdfColor(a3, true)}`, "/R0 gs"];
        o3.push(`${numberToString(r3[4])} ${numberToString(r3[5])} m`);
        for (let e4 = 6, t4 = r3.length; e4 < t4; e4 += 6)
          if (isNaN(r3[e4]) || null === r3[e4])
            o3.push(`${numberToString(r3[e4 + 4])} ${numberToString(r3[e4 + 5])} l`);
          else {
            const t5 = r3.slice(e4, e4 + 6).map(numberToString).join(" ");
            o3.push(`${t5} c`);
          }
        o3.push("h f");
        const g3 = o3.join("\n"), c3 = new Dict(t3);
        c3.set("FormType", 1);
        c3.set("Subtype", Name.get("Form"));
        c3.set("Type", Name.get("XObject"));
        c3.set("BBox", s3);
        c3.set("Length", g3.length);
        const C3 = new Dict(t3), h2 = new Dict(t3);
        C3.set("ExtGState", h2);
        c3.set("Resources", C3);
        const l3 = new Dict(t3);
        h2.set("R0", l3);
        l3.set("BM", Name.get("Multiply"));
        if (1 !== n3) {
          l3.set("ca", n3);
          l3.set("Type", Name.get("ExtGState"));
        }
        const Q3 = new StringStream(g3);
        Q3.dict = c3;
        return Q3;
      }
    };
    HighlightAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        var _a3;
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = L2;
        if (this.data.quadPoints = getQuadPoints(t3, null)) {
          const e4 = (_a3 = this.appearance) == null ? void 0 : _a3.dict.get("Resources");
          if (!this.appearance || !(e4 == null ? void 0 : e4.has("ExtGState"))) {
            this.appearance && warn("HighlightAnnotation - ignoring built-in appearance stream.");
            const e5 = this.color ? getPdfColorArray(this.color) : [1, 1, 0], a3 = t3.get("CA");
            this._setDefaultAppearance({ xref: i3, fillColor: e5, blendMode: "Multiply", fillAlpha: a3, pointsCallback: (e6, t4) => {
              e6.push(`${t4[0].x} ${t4[0].y} m`, `${t4[1].x} ${t4[1].y} l`, `${t4[3].x} ${t4[3].y} l`, `${t4[2].x} ${t4[2].y} l`, "f");
              return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
            } });
          }
        } else
          this.data.popupRef = null;
      }
      static createNewDict(e3, t3, { apRef: i3, ap: a3 }) {
        const { color: s3, opacity: r3, rect: n3, rotation: o3, user: g3, quadPoints: c3 } = e3, C3 = new Dict(t3);
        C3.set("Type", Name.get("Annot"));
        C3.set("Subtype", Name.get("Highlight"));
        C3.set("CreationDate", `D:${getModificationDate()}`);
        C3.set("Rect", n3);
        C3.set("F", 4);
        C3.set("Border", [0, 0, 0]);
        C3.set("Rotate", o3);
        C3.set("QuadPoints", c3);
        C3.set("C", Array.from(s3, (e4) => e4 / 255));
        C3.set("CA", r3);
        g3 && C3.set("T", isAscii(g3) ? g3 : stringToUTF16String(g3, true));
        if (i3 || a3) {
          const e4 = new Dict(t3);
          C3.set("AP", e4);
          e4.set("N", i3 || a3);
        }
        return C3;
      }
      static async createNewAppearanceStream(e3, t3, i3) {
        const { color: a3, rect: s3, outlines: r3, opacity: n3 } = e3, o3 = [`${getPdfColor(a3, true)}`, "/R0 gs"], g3 = [];
        for (const e4 of r3) {
          g3.length = 0;
          g3.push(`${numberToString(e4[0])} ${numberToString(e4[1])} m`);
          for (let t4 = 2, i4 = e4.length; t4 < i4; t4 += 2)
            g3.push(`${numberToString(e4[t4])} ${numberToString(e4[t4 + 1])} l`);
          g3.push("h");
          o3.push(g3.join("\n"));
        }
        o3.push("f*");
        const c3 = o3.join("\n"), C3 = new Dict(t3);
        C3.set("FormType", 1);
        C3.set("Subtype", Name.get("Form"));
        C3.set("Type", Name.get("XObject"));
        C3.set("BBox", s3);
        C3.set("Length", c3.length);
        const h2 = new Dict(t3), l3 = new Dict(t3);
        h2.set("ExtGState", l3);
        C3.set("Resources", h2);
        const Q3 = new Dict(t3);
        l3.set("R0", Q3);
        Q3.set("BM", Name.get("Multiply"));
        if (1 !== n3) {
          Q3.set("ca", n3);
          Q3.set("Type", Name.get("ExtGState"));
        }
        const E3 = new StringStream(c3);
        E3.dict = C3;
        return E3;
      }
    };
    UnderlineAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = H2;
        if (this.data.quadPoints = getQuadPoints(t3, null)) {
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA");
            this._setDefaultAppearance({ xref: i3, extra: "[] 0 d 0.571 w", strokeColor: e4, strokeAlpha: a3, pointsCallback: (e5, t4) => {
              e5.push(`${t4[2].x} ${t4[2].y + 1.3} m`, `${t4[3].x} ${t4[3].y + 1.3} l`, "S");
              return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
            } });
          }
        } else
          this.data.popupRef = null;
      }
    };
    SquigglyAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = J2;
        if (this.data.quadPoints = getQuadPoints(t3, null)) {
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA");
            this._setDefaultAppearance({ xref: i3, extra: "[] 0 d 1 w", strokeColor: e4, strokeAlpha: a3, pointsCallback: (e5, t4) => {
              const i4 = (t4[0].y - t4[2].y) / 6;
              let a4 = i4, s3 = t4[2].x;
              const r3 = t4[2].y, n3 = t4[3].x;
              e5.push(`${s3} ${r3 + a4} m`);
              do {
                s3 += 2;
                a4 = 0 === a4 ? i4 : 0;
                e5.push(`${s3} ${r3 + a4} l`);
              } while (s3 < n3);
              e5.push("S");
              return [t4[2].x, n3, r3 - 2 * i4, r3 + 2 * i4];
            } });
          }
        } else
          this.data.popupRef = null;
      }
    };
    StrikeOutAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3;
        this.data.annotationType = Y2;
        if (this.data.quadPoints = getQuadPoints(t3, null)) {
          if (!this.appearance) {
            const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], a3 = t3.get("CA");
            this._setDefaultAppearance({ xref: i3, extra: "[] 0 d 1 w", strokeColor: e4, strokeAlpha: a3, pointsCallback: (e5, t4) => {
              e5.push((t4[0].x + t4[2].x) / 2 + " " + (t4[0].y + t4[2].y) / 2 + " m", (t4[1].x + t4[3].x) / 2 + " " + (t4[1].y + t4[3].y) / 2 + " l", "S");
              return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
            } });
          }
        } else
          this.data.popupRef = null;
      }
    };
    StampAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        this.data.annotationType = v2;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = false;
      }
      static async createImage(e3, t3) {
        const { width: i3, height: a3 } = e3, s3 = new OffscreenCanvas(i3, a3), r3 = s3.getContext("2d", { alpha: true });
        r3.drawImage(e3, 0, 0);
        const n3 = r3.getImageData(0, 0, i3, a3).data, o3 = new Uint32Array(n3.buffer), g3 = o3.some(FeatureTest.isLittleEndian ? (e4) => e4 >>> 24 != 255 : (e4) => 255 != (255 & e4));
        if (g3) {
          r3.fillStyle = "white";
          r3.fillRect(0, 0, i3, a3);
          r3.drawImage(e3, 0, 0);
        }
        const c3 = s3.convertToBlob({ type: "image/jpeg", quality: 1 }).then((e4) => e4.arrayBuffer()), C3 = Name.get("XObject"), h2 = Name.get("Image"), l3 = new Dict(t3);
        l3.set("Type", C3);
        l3.set("Subtype", h2);
        l3.set("BitsPerComponent", 8);
        l3.set("ColorSpace", Name.get("DeviceRGB"));
        l3.set("Filter", Name.get("DCTDecode"));
        l3.set("BBox", [0, 0, i3, a3]);
        l3.set("Width", i3);
        l3.set("Height", a3);
        let Q3 = null;
        if (g3) {
          const e4 = new Uint8Array(o3.length);
          if (FeatureTest.isLittleEndian)
            for (let t4 = 0, i4 = o3.length; t4 < i4; t4++)
              e4[t4] = o3[t4] >>> 24;
          else
            for (let t4 = 0, i4 = o3.length; t4 < i4; t4++)
              e4[t4] = 255 & o3[t4];
          const s4 = new Dict(t3);
          s4.set("Type", C3);
          s4.set("Subtype", h2);
          s4.set("BitsPerComponent", 8);
          s4.set("ColorSpace", Name.get("DeviceGray"));
          s4.set("Width", i3);
          s4.set("Height", a3);
          Q3 = new Stream(e4, 0, 0, s4);
        }
        return { imageStream: new Stream(await c3, 0, 0, l3), smaskStream: Q3, width: i3, height: a3 };
      }
      static createNewDict(e3, t3, { apRef: i3, ap: a3 }) {
        const { rect: s3, rotation: r3, user: n3 } = e3, o3 = new Dict(t3);
        o3.set("Type", Name.get("Annot"));
        o3.set("Subtype", Name.get("Stamp"));
        o3.set("CreationDate", `D:${getModificationDate()}`);
        o3.set("Rect", s3);
        o3.set("F", 4);
        o3.set("Border", [0, 0, 0]);
        o3.set("Rotate", r3);
        n3 && o3.set("T", isAscii(n3) ? n3 : stringToUTF16String(n3, true));
        if (i3 || a3) {
          const e4 = new Dict(t3);
          o3.set("AP", e4);
          i3 ? e4.set("N", i3) : e4.set("N", a3);
        }
        return o3;
      }
      static async createNewAppearanceStream(e3, t3, i3) {
        const { rotation: a3 } = e3, { imageRef: s3, width: r3, height: n3 } = i3.image, o3 = new Dict(t3), g3 = new Dict(t3);
        o3.set("XObject", g3);
        g3.set("Im0", s3);
        const c3 = `q ${r3} 0 0 ${n3} 0 0 cm /Im0 Do Q`, C3 = new Dict(t3);
        C3.set("FormType", 1);
        C3.set("Subtype", Name.get("Form"));
        C3.set("Type", Name.get("XObject"));
        C3.set("BBox", [0, 0, r3, n3]);
        C3.set("Resources", o3);
        if (a3) {
          const e4 = getRotationMatrix(a3, r3, n3);
          C3.set("Matrix", e4);
        }
        const h2 = new StringStream(c3);
        h2.dict = C3;
        return h2;
      }
    };
    FileAttachmentAnnotation = class extends MarkupAnnotation {
      constructor(e3) {
        super(e3);
        const { dict: t3, xref: i3 } = e3, a3 = new FileSpec(t3.get("FS"), i3);
        this.data.annotationType = O2;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = false;
        this.data.file = a3.serializable;
        const s3 = t3.get("Name");
        this.data.name = s3 instanceof Name ? stringToPDFString(s3.name) : "PushPin";
        const r3 = t3.get("ca");
        this.data.fillAlpha = "number" == typeof r3 && r3 >= 0 && r3 <= 1 ? r3 : null;
      }
    };
    DatasetXMLParser = class extends SimpleXMLParser {
      constructor(e3) {
        super(e3);
        this.node = null;
      }
      onEndElement(e3) {
        const t3 = super.onEndElement(e3);
        if (t3 && "xfa:datasets" === e3) {
          this.node = t3;
          throw new Error("Aborting DatasetXMLParser.");
        }
      }
    };
    DatasetReader = class {
      constructor(e3) {
        if (e3.datasets)
          this.node = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e3.datasets).documentElement;
        else {
          const t3 = new DatasetXMLParser({ hasAttributes: true });
          try {
            t3.parseFromString(e3["xdp:xdp"]);
          } catch {
          }
          this.node = t3.node;
        }
      }
      getValue(e3) {
        if (!this.node || !e3)
          return "";
        const t3 = this.node.searchNode(parseXFAPath(e3), 0);
        if (!t3)
          return "";
        const i3 = t3.firstChild;
        return "value" === (i3 == null ? void 0 : i3.nodeName) ? t3.children.map((e4) => decodeString(e4.textContent)) : decodeString(t3.textContent);
      }
    };
    XRef = class {
      constructor(e3, t3) {
        __privateAdd(this, _H, null);
        this.stream = e3;
        this.pdfManager = t3;
        this.entries = [];
        this._xrefStms = /* @__PURE__ */ new Set();
        this._cacheMap = /* @__PURE__ */ new Map();
        this._pendingRefs = new RefSet();
        this._newPersistentRefNum = null;
        this._newTemporaryRefNum = null;
        this._persistentRefsCache = null;
      }
      getNewPersistentRef(e3) {
        null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
        const t3 = this._newPersistentRefNum++;
        this._cacheMap.set(t3, e3);
        return Ref.get(t3, 0);
      }
      getNewTemporaryRef() {
        if (null === this._newTemporaryRefNum) {
          this._newTemporaryRefNum = this.entries.length || 1;
          if (this._newPersistentRefNum) {
            this._persistentRefsCache = /* @__PURE__ */ new Map();
            for (let e3 = this._newTemporaryRefNum; e3 < this._newPersistentRefNum; e3++) {
              this._persistentRefsCache.set(e3, this._cacheMap.get(e3));
              this._cacheMap.delete(e3);
            }
          }
        }
        return Ref.get(this._newTemporaryRefNum++, 0);
      }
      resetNewTemporaryRef() {
        this._newTemporaryRefNum = null;
        if (this._persistentRefsCache)
          for (const [e3, t3] of this._persistentRefsCache)
            this._cacheMap.set(e3, t3);
        this._persistentRefsCache = null;
      }
      setStartXRef(e3) {
        this.startXRefQueue = [e3];
      }
      parse(e3 = false) {
        let t3, i3, a3;
        if (e3) {
          warn("Indexing all PDF objects");
          t3 = this.indexObjects();
        } else
          t3 = this.readXRef();
        t3.assignXref(this);
        this.trailer = t3;
        try {
          i3 = t3.get("Encrypt");
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn(`XRef.parse - Invalid "Encrypt" reference: "${e4}".`);
        }
        if (i3 instanceof Dict) {
          const e4 = t3.get("ID"), a4 = (e4 == null ? void 0 : e4.length) ? e4[0] : "";
          i3.suppressEncryption = true;
          this.encrypt = new CipherTransformFactory(i3, a4, this.pdfManager.password);
        }
        try {
          a3 = t3.get("Root");
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn(`XRef.parse - Invalid "Root" reference: "${e4}".`);
        }
        if (a3 instanceof Dict)
          try {
            if (a3.get("Pages") instanceof Dict) {
              this.root = a3;
              return;
            }
          } catch (e4) {
            if (e4 instanceof MissingDataException)
              throw e4;
            warn(`XRef.parse - Invalid "Pages" reference: "${e4}".`);
          }
        if (!e3)
          throw new XRefParseException();
        throw new InvalidPDFException("Invalid Root reference.");
      }
      processXRefTable(e3) {
        "tableState" in this || (this.tableState = { entryNum: 0, streamPos: e3.lexer.stream.pos, parserBuf1: e3.buf1, parserBuf2: e3.buf2 });
        if (!isCmd(this.readXRefTable(e3), "trailer"))
          throw new FormatError("Invalid XRef table: could not find trailer dictionary");
        let t3 = e3.getObj();
        t3 instanceof Dict || !t3.dict || (t3 = t3.dict);
        if (!(t3 instanceof Dict))
          throw new FormatError("Invalid XRef table: could not parse trailer dictionary");
        delete this.tableState;
        return t3;
      }
      readXRefTable(e3) {
        const t3 = e3.lexer.stream, i3 = this.tableState;
        t3.pos = i3.streamPos;
        e3.buf1 = i3.parserBuf1;
        e3.buf2 = i3.parserBuf2;
        let a3;
        for (; ; ) {
          if (!("firstEntryNum" in i3) || !("entryCount" in i3)) {
            if (isCmd(a3 = e3.getObj(), "trailer"))
              break;
            i3.firstEntryNum = a3;
            i3.entryCount = e3.getObj();
          }
          let s3 = i3.firstEntryNum;
          const r3 = i3.entryCount;
          if (!Number.isInteger(s3) || !Number.isInteger(r3))
            throw new FormatError("Invalid XRef table: wrong types in subsection header");
          for (let a4 = i3.entryNum; a4 < r3; a4++) {
            i3.streamPos = t3.pos;
            i3.entryNum = a4;
            i3.parserBuf1 = e3.buf1;
            i3.parserBuf2 = e3.buf2;
            const n3 = {};
            n3.offset = e3.getObj();
            n3.gen = e3.getObj();
            const o3 = e3.getObj();
            if (o3 instanceof Cmd)
              switch (o3.cmd) {
                case "f":
                  n3.free = true;
                  break;
                case "n":
                  n3.uncompressed = true;
              }
            if (!Number.isInteger(n3.offset) || !Number.isInteger(n3.gen) || !n3.free && !n3.uncompressed)
              throw new FormatError(`Invalid entry in XRef subsection: ${s3}, ${r3}`);
            0 === a4 && n3.free && 1 === s3 && (s3 = 0);
            this.entries[a4 + s3] || (this.entries[a4 + s3] = n3);
          }
          i3.entryNum = 0;
          i3.streamPos = t3.pos;
          i3.parserBuf1 = e3.buf1;
          i3.parserBuf2 = e3.buf2;
          delete i3.firstEntryNum;
          delete i3.entryCount;
        }
        if (this.entries[0] && !this.entries[0].free)
          throw new FormatError("Invalid XRef table: unexpected first object");
        return a3;
      }
      processXRefStream(e3) {
        if (!("streamState" in this)) {
          const t3 = e3.dict, i3 = t3.get("W");
          let a3 = t3.get("Index");
          a3 || (a3 = [0, t3.get("Size")]);
          this.streamState = { entryRanges: a3, byteWidths: i3, entryNum: 0, streamPos: e3.pos };
        }
        this.readXRefStream(e3);
        delete this.streamState;
        return e3.dict;
      }
      readXRefStream(e3) {
        const t3 = this.streamState;
        e3.pos = t3.streamPos;
        const [i3, a3, s3] = t3.byteWidths, r3 = t3.entryRanges;
        for (; r3.length > 0; ) {
          const [n3, o3] = r3;
          if (!Number.isInteger(n3) || !Number.isInteger(o3))
            throw new FormatError(`Invalid XRef range fields: ${n3}, ${o3}`);
          if (!Number.isInteger(i3) || !Number.isInteger(a3) || !Number.isInteger(s3))
            throw new FormatError(`Invalid XRef entry fields length: ${n3}, ${o3}`);
          for (let r4 = t3.entryNum; r4 < o3; ++r4) {
            t3.entryNum = r4;
            t3.streamPos = e3.pos;
            let o4 = 0, g3 = 0, c3 = 0;
            for (let t4 = 0; t4 < i3; ++t4) {
              const t5 = e3.getByte();
              if (-1 === t5)
                throw new FormatError("Invalid XRef byteWidths 'type'.");
              o4 = o4 << 8 | t5;
            }
            0 === i3 && (o4 = 1);
            for (let t4 = 0; t4 < a3; ++t4) {
              const t5 = e3.getByte();
              if (-1 === t5)
                throw new FormatError("Invalid XRef byteWidths 'offset'.");
              g3 = g3 << 8 | t5;
            }
            for (let t4 = 0; t4 < s3; ++t4) {
              const t5 = e3.getByte();
              if (-1 === t5)
                throw new FormatError("Invalid XRef byteWidths 'generation'.");
              c3 = c3 << 8 | t5;
            }
            const C3 = {};
            C3.offset = g3;
            C3.gen = c3;
            switch (o4) {
              case 0:
                C3.free = true;
                break;
              case 1:
                C3.uncompressed = true;
                break;
              case 2:
                break;
              default:
                throw new FormatError(`Invalid XRef entry type: ${o4}`);
            }
            this.entries[n3 + r4] || (this.entries[n3 + r4] = C3);
          }
          t3.entryNum = 0;
          t3.streamPos = e3.pos;
          r3.splice(0, 2);
        }
      }
      indexObjects() {
        function readToken(e4, t4) {
          let i4 = "", a4 = e4[t4];
          for (; 10 !== a4 && 13 !== a4 && 60 !== a4 && !(++t4 >= e4.length); ) {
            i4 += String.fromCharCode(a4);
            a4 = e4[t4];
          }
          return i4;
        }
        function skipUntil(e4, t4, i4) {
          const a4 = i4.length, s4 = e4.length;
          let r4 = 0;
          for (; t4 < s4; ) {
            let s5 = 0;
            for (; s5 < a4 && e4[t4 + s5] === i4[s5]; )
              ++s5;
            if (s5 >= a4)
              break;
            t4++;
            r4++;
          }
          return r4;
        }
        const e3 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t3 = /\b(startxref|\d+\s+\d+\s+obj)\b/g, i3 = /^(\d+)\s+(\d+)\s+obj\b/, a3 = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), s3 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), r3 = new Uint8Array([47, 88, 82, 101, 102]);
        this.entries.length = 0;
        this._cacheMap.clear();
        const n3 = this.stream;
        n3.pos = 0;
        const o3 = n3.getBytes(), g3 = bytesToString(o3), c3 = o3.length;
        let C3 = n3.start;
        const h2 = [], l3 = [];
        for (; C3 < c3; ) {
          let Q4 = o3[C3];
          if (9 === Q4 || 10 === Q4 || 13 === Q4 || 32 === Q4) {
            ++C3;
            continue;
          }
          if (37 === Q4) {
            do {
              ++C3;
              if (C3 >= c3)
                break;
              Q4 = o3[C3];
            } while (10 !== Q4 && 13 !== Q4);
            continue;
          }
          const E4 = readToken(o3, C3);
          let u4;
          if (E4.startsWith("xref") && (4 === E4.length || /\s/.test(E4[4]))) {
            C3 += skipUntil(o3, C3, a3);
            h2.push(C3);
            C3 += skipUntil(o3, C3, s3);
          } else if (u4 = i3.exec(E4)) {
            const t4 = 0 | u4[1], i4 = 0 | u4[2], a4 = C3 + E4.length;
            let s4, h3 = false;
            if (this.entries[t4]) {
              if (this.entries[t4].gen === i4)
                try {
                  new Parser({ lexer: new Lexer(n3.makeSubStream(a4)) }).getObj();
                  h3 = true;
                } catch (e4) {
                  e4 instanceof ParserEOFException ? warn(`indexObjects -- checking object (${E4}): "${e4}".`) : h3 = true;
                }
            } else
              h3 = true;
            h3 && (this.entries[t4] = { offset: C3 - n3.start, gen: i4, uncompressed: true });
            e3.lastIndex = a4;
            const Q5 = e3.exec(g3);
            if (Q5) {
              s4 = e3.lastIndex + 1 - C3;
              if ("endobj" !== Q5[1]) {
                warn(`indexObjects: Found "${Q5[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);
                s4 -= Q5[1].length + 1;
              }
            } else
              s4 = c3 - C3;
            const d4 = o3.subarray(C3, C3 + s4), f2 = skipUntil(d4, 0, r3);
            if (f2 < s4 && d4[f2 + 5] < 64) {
              l3.push(C3 - n3.start);
              this._xrefStms.add(C3 - n3.start);
            }
            C3 += s4;
          } else if (E4.startsWith("trailer") && (7 === E4.length || /\s/.test(E4[7]))) {
            h2.push(C3);
            const e4 = C3 + E4.length;
            let i4;
            t3.lastIndex = e4;
            const a4 = t3.exec(g3);
            if (a4) {
              i4 = t3.lastIndex + 1 - C3;
              if ("startxref" !== a4[1]) {
                warn(`indexObjects: Found "${a4[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);
                i4 -= a4[1].length + 1;
              }
            } else
              i4 = c3 - C3;
            C3 += i4;
          } else
            C3 += E4.length + 1;
        }
        for (const e4 of l3) {
          this.startXRefQueue.push(e4);
          this.readXRef(true);
        }
        const Q3 = [];
        let E3, u3, d3 = false;
        for (const e4 of h2) {
          n3.pos = e4;
          const t4 = new Parser({ lexer: new Lexer(n3), xref: this, allowStreams: true, recoveryMode: true });
          if (!isCmd(t4.getObj(), "trailer"))
            continue;
          const i4 = t4.getObj();
          if (i4 instanceof Dict) {
            Q3.push(i4);
            i4.has("Encrypt") && (d3 = true);
          }
        }
        for (const e4 of [...Q3, "genFallback", ...Q3]) {
          if ("genFallback" === e4) {
            if (!u3)
              break;
            this._generationFallback = true;
            continue;
          }
          let t4 = false;
          try {
            const i4 = e4.get("Root");
            if (!(i4 instanceof Dict))
              continue;
            const a4 = i4.get("Pages");
            if (!(a4 instanceof Dict))
              continue;
            const s4 = a4.get("Count");
            Number.isInteger(s4) && (t4 = true);
          } catch (e5) {
            u3 = e5;
            continue;
          }
          if (t4 && (!d3 || e4.has("Encrypt")) && e4.has("ID"))
            return e4;
          E3 = e4;
        }
        if (E3)
          return E3;
        if (this.topDict)
          return this.topDict;
        throw new InvalidPDFException("Invalid PDF structure.");
      }
      readXRef(e3 = false) {
        const t3 = this.stream, i3 = /* @__PURE__ */ new Set();
        for (; this.startXRefQueue.length; ) {
          try {
            const e4 = this.startXRefQueue[0];
            if (i3.has(e4)) {
              warn("readXRef - skipping XRef table since it was already parsed.");
              this.startXRefQueue.shift();
              continue;
            }
            i3.add(e4);
            t3.pos = e4 + t3.start;
            const a3 = new Parser({ lexer: new Lexer(t3), xref: this, allowStreams: true });
            let s3, r3 = a3.getObj();
            if (isCmd(r3, "xref")) {
              s3 = this.processXRefTable(a3);
              this.topDict || (this.topDict = s3);
              r3 = s3.get("XRefStm");
              if (Number.isInteger(r3) && !this._xrefStms.has(r3)) {
                this._xrefStms.add(r3);
                this.startXRefQueue.push(r3);
                __privateGet(this, _H) ?? __privateSet(this, _H, r3);
              }
            } else {
              if (!Number.isInteger(r3))
                throw new FormatError("Invalid XRef stream header");
              if (!(Number.isInteger(a3.getObj()) && isCmd(a3.getObj(), "obj") && (r3 = a3.getObj()) instanceof BaseStream))
                throw new FormatError("Invalid XRef stream");
              s3 = this.processXRefStream(r3);
              this.topDict || (this.topDict = s3);
              if (!s3)
                throw new FormatError("Failed to read XRef stream");
            }
            r3 = s3.get("Prev");
            Number.isInteger(r3) ? this.startXRefQueue.push(r3) : r3 instanceof Ref && this.startXRefQueue.push(r3.num);
          } catch (e4) {
            if (e4 instanceof MissingDataException)
              throw e4;
            info("(while reading XRef): " + e4);
          }
          this.startXRefQueue.shift();
        }
        if (this.topDict)
          return this.topDict;
        if (!e3)
          throw new XRefParseException();
      }
      get lastXRefStreamPos() {
        return __privateGet(this, _H) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
      }
      getEntry(e3) {
        const t3 = this.entries[e3];
        return t3 && !t3.free && t3.offset ? t3 : null;
      }
      fetchIfRef(e3, t3 = false) {
        return e3 instanceof Ref ? this.fetch(e3, t3) : e3;
      }
      fetch(e3, t3 = false) {
        if (!(e3 instanceof Ref))
          throw new Error("ref object is not a reference");
        const i3 = e3.num, a3 = this._cacheMap.get(i3);
        if (void 0 !== a3) {
          a3 instanceof Dict && !a3.objId && (a3.objId = e3.toString());
          return a3;
        }
        let s3 = this.getEntry(i3);
        if (null === s3) {
          this._cacheMap.set(i3, s3);
          return s3;
        }
        if (this._pendingRefs.has(e3)) {
          this._pendingRefs.remove(e3);
          warn(`Ignoring circular reference: ${e3}.`);
          return ft;
        }
        this._pendingRefs.put(e3);
        try {
          s3 = s3.uncompressed ? this.fetchUncompressed(e3, s3, t3) : this.fetchCompressed(e3, s3, t3);
          this._pendingRefs.remove(e3);
        } catch (t4) {
          this._pendingRefs.remove(e3);
          throw t4;
        }
        s3 instanceof Dict ? s3.objId = e3.toString() : s3 instanceof BaseStream && (s3.dict.objId = e3.toString());
        return s3;
      }
      fetchUncompressed(e3, t3, i3 = false) {
        const a3 = e3.gen;
        let s3 = e3.num;
        if (t3.gen !== a3) {
          const r4 = `Inconsistent generation in XRef: ${e3}`;
          if (this._generationFallback && t3.gen < a3) {
            warn(r4);
            return this.fetchUncompressed(Ref.get(s3, t3.gen), t3, i3);
          }
          throw new XRefEntryException(r4);
        }
        const r3 = this.stream.makeSubStream(t3.offset + this.stream.start), n3 = new Parser({ lexer: new Lexer(r3), xref: this, allowStreams: true }), o3 = n3.getObj(), g3 = n3.getObj(), c3 = n3.getObj();
        if (o3 !== s3 || g3 !== a3 || !(c3 instanceof Cmd))
          throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e3}`);
        if ("obj" !== c3.cmd) {
          if (c3.cmd.startsWith("obj")) {
            s3 = parseInt(c3.cmd.substring(3), 10);
            if (!Number.isNaN(s3))
              return s3;
          }
          throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e3}`);
        }
        (t3 = this.encrypt && !i3 ? n3.getObj(this.encrypt.createCipherTransform(s3, a3)) : n3.getObj()) instanceof BaseStream || this._cacheMap.set(s3, t3);
        return t3;
      }
      fetchCompressed(e3, t3, i3 = false) {
        const a3 = t3.offset, s3 = this.fetch(Ref.get(a3, 0));
        if (!(s3 instanceof BaseStream))
          throw new FormatError("bad ObjStm stream");
        const r3 = s3.dict.get("First"), n3 = s3.dict.get("N");
        if (!Number.isInteger(r3) || !Number.isInteger(n3))
          throw new FormatError("invalid first and n parameters for ObjStm stream");
        let o3 = new Parser({ lexer: new Lexer(s3), xref: this, allowStreams: true });
        const g3 = new Array(n3), c3 = new Array(n3);
        for (let e4 = 0; e4 < n3; ++e4) {
          const t4 = o3.getObj();
          if (!Number.isInteger(t4))
            throw new FormatError(`invalid object number in the ObjStm stream: ${t4}`);
          const i4 = o3.getObj();
          if (!Number.isInteger(i4))
            throw new FormatError(`invalid object offset in the ObjStm stream: ${i4}`);
          g3[e4] = t4;
          c3[e4] = i4;
        }
        const C3 = (s3.start || 0) + r3, h2 = new Array(n3);
        for (let e4 = 0; e4 < n3; ++e4) {
          const t4 = e4 < n3 - 1 ? c3[e4 + 1] - c3[e4] : void 0;
          if (t4 < 0)
            throw new FormatError("Invalid offset in the ObjStm stream.");
          o3 = new Parser({ lexer: new Lexer(s3.makeSubStream(C3 + c3[e4], t4, s3.dict)), xref: this, allowStreams: true });
          const i4 = o3.getObj();
          h2[e4] = i4;
          if (i4 instanceof BaseStream)
            continue;
          const r4 = g3[e4], l3 = this.entries[r4];
          l3 && l3.offset === a3 && l3.gen === e4 && this._cacheMap.set(r4, i4);
        }
        if (void 0 === (t3 = h2[t3.gen]))
          throw new XRefEntryException(`Bad (compressed) XRef entry: ${e3}`);
        return t3;
      }
      async fetchIfRefAsync(e3, t3) {
        return e3 instanceof Ref ? this.fetchAsync(e3, t3) : e3;
      }
      async fetchAsync(e3, t3) {
        try {
          return this.fetch(e3, t3);
        } catch (i3) {
          if (!(i3 instanceof MissingDataException))
            throw i3;
          await this.pdfManager.requestRange(i3.begin, i3.end);
          return this.fetchAsync(e3, t3);
        }
      }
      getCatalogObj() {
        return this.root;
      }
    };
    _H = new WeakMap();
    so = [0, 0, 612, 792];
    Page = class {
      constructor({ pdfManager: e3, xref: t3, pageIndex: i3, pageDict: a3, ref: s3, globalIdFactory: r3, fontCache: n3, builtInCMapCache: o3, standardFontDataCache: g3, globalImageCache: c3, systemFontCache: C3, nonBlendModesSet: h2, xfaFactory: l3 }) {
        __privateAdd(this, _J);
        this.pdfManager = e3;
        this.pageIndex = i3;
        this.pageDict = a3;
        this.xref = t3;
        this.ref = s3;
        this.fontCache = n3;
        this.builtInCMapCache = o3;
        this.standardFontDataCache = g3;
        this.globalImageCache = c3;
        this.systemFontCache = C3;
        this.nonBlendModesSet = h2;
        this.evaluatorOptions = e3.evaluatorOptions;
        this.resourcesPromise = null;
        this.xfaFactory = l3;
        const Q3 = { obj: 0 };
        this._localIdFactory = class extends r3 {
          static createObjId() {
            return `p${i3}_${++Q3.obj}`;
          }
          static getPageObjId() {
            return `p${s3.toString()}`;
          }
        };
      }
      _getInheritableProperty(e3, t3 = false) {
        const i3 = getInheritableProperty({ dict: this.pageDict, key: e3, getArray: t3, stopWhenFound: false });
        return Array.isArray(i3) ? 1 !== i3.length && i3[0] instanceof Dict ? Dict.merge({ xref: this.xref, dictArray: i3 }) : i3[0] : i3;
      }
      get content() {
        return this.pageDict.getArray("Contents");
      }
      get resources() {
        const e3 = this._getInheritableProperty("Resources");
        return shadow(this, "resources", e3 instanceof Dict ? e3 : Dict.empty);
      }
      _getBoundingBox(e3) {
        if (this.xfaData)
          return this.xfaData.bbox;
        let t3 = this._getInheritableProperty(e3, true);
        if (Array.isArray(t3) && 4 === t3.length) {
          t3 = Util.normalizeRect(t3);
          if (t3[2] - t3[0] > 0 && t3[3] - t3[1] > 0)
            return t3;
          warn(`Empty, or invalid, /${e3} entry.`);
        }
        return null;
      }
      get mediaBox() {
        return shadow(this, "mediaBox", this._getBoundingBox("MediaBox") || so);
      }
      get cropBox() {
        return shadow(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
      }
      get userUnit() {
        let e3 = this.pageDict.get("UserUnit");
        ("number" != typeof e3 || e3 <= 0) && (e3 = 1);
        return shadow(this, "userUnit", e3);
      }
      get view() {
        const { cropBox: e3, mediaBox: t3 } = this;
        if (e3 !== t3 && !isArrayEqual(e3, t3)) {
          const i3 = Util.intersect(e3, t3);
          if (i3 && i3[2] - i3[0] > 0 && i3[3] - i3[1] > 0)
            return shadow(this, "view", i3);
          warn("Empty /CropBox and /MediaBox intersection.");
        }
        return shadow(this, "view", t3);
      }
      get rotate() {
        let e3 = this._getInheritableProperty("Rotate") || 0;
        e3 % 90 != 0 ? e3 = 0 : e3 >= 360 ? e3 %= 360 : e3 < 0 && (e3 = (e3 % 360 + 360) % 360);
        return shadow(this, "rotate", e3);
      }
      _onSubStreamError(e3, t3) {
        if (!this.evaluatorOptions.ignoreErrors)
          throw e3;
        warn(`getContentStream - ignoring sub-stream (${t3}): "${e3}".`);
      }
      getContentStream() {
        return this.pdfManager.ensure(this, "content").then((e3) => e3 instanceof BaseStream ? e3 : Array.isArray(e3) ? new StreamsSequenceStream(e3, this._onSubStreamError.bind(this)) : new NullStream());
      }
      get xfaData() {
        return shadow(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
      }
      async saveNewAnnotations(e3, t3, i3, a3) {
        if (this.xfaFactory)
          throw new Error("XFA: Cannot save new annotations.");
        const s3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), r3 = new RefSetCache(), n3 = new RefSet();
        __privateMethod(this, _J, J_fn).call(this, i3, r3, n3);
        const o3 = this.pageDict, g3 = this.annotations.filter((e4) => !(e4 instanceof Ref && r3.has(e4))), c3 = await AnnotationFactory.saveNewAnnotations(s3, t3, i3, a3);
        for (const { ref: e4 } of c3.annotations)
          e4 instanceof Ref && !n3.has(e4) && g3.push(e4);
        const C3 = o3.get("Annots");
        o3.set("Annots", g3);
        const h2 = [];
        await writeObject(this.ref, o3, h2, this.xref);
        C3 && o3.set("Annots", C3);
        const l3 = c3.dependencies;
        l3.push({ ref: this.ref, data: h2.join("") }, ...c3.annotations);
        for (const e4 of r3)
          l3.push({ ref: e4, data: null });
        return l3;
      }
      save(e3, t3, i3) {
        const a3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
        return this._parsedAnnotations.then(function(e4) {
          const s3 = [];
          for (const r3 of e4)
            r3.mustBePrinted(i3) && s3.push(r3.save(a3, t3, i3).catch(function(e5) {
              warn(`save - ignoring annotation data during "${t3.name}" task: "${e5}".`);
              return null;
            }));
          return Promise.all(s3).then(function(e5) {
            return e5.filter((e6) => !!e6);
          });
        });
      }
      loadResources(e3) {
        this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources"));
        return this.resourcesPromise.then(() => new ObjectLoader(this.resources, e3, this.xref).load());
      }
      getOperatorList({ handler: e3, sink: t3, task: i3, intent: a3, cacheKey: s3, annotationStorage: r3 = null }) {
        const n3 = this.getContentStream(), C3 = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), Q3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), u3 = this.xfaFactory ? null : getNewAnnotationsMap(r3);
        let d3 = null, f2 = Promise.resolve(null);
        if (u3) {
          const e4 = u3.get(this.pageIndex);
          if (e4) {
            const t4 = this.pdfManager.ensureDoc("annotationGlobals");
            let a4;
            const s4 = /* @__PURE__ */ new Set();
            for (const { bitmapId: t5, bitmap: i4 } of e4)
              !t5 || i4 || s4.has(t5) || s4.add(t5);
            const { isOffscreenCanvasSupported: n4 } = this.evaluatorOptions;
            if (s4.size > 0) {
              const t5 = e4.slice();
              for (const [e5, i4] of r3)
                e5.startsWith(E2) && i4.bitmap && s4.has(i4.bitmapId) && t5.push(i4);
              a4 = AnnotationFactory.generateImages(t5, this.xref, n4);
            } else
              a4 = AnnotationFactory.generateImages(e4, this.xref, n4);
            d3 = new RefSet();
            __privateMethod(this, _J, J_fn).call(this, e4, d3, null);
            f2 = t4.then((t5) => t5 ? AnnotationFactory.printNewAnnotations(t5, Q3, i3, e4, a4) : null);
          }
        }
        const p2 = Promise.all([n3, C3]).then(([r4]) => {
          const n4 = new OperatorList(a3, t3);
          e3.send("StartRenderPage", { transparency: Q3.hasBlendModes(this.resources, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: s3 });
          return Q3.getOperatorList({ stream: r4, task: i3, resources: this.resources, operatorList: n4 }).then(function() {
            return n4;
          });
        });
        return Promise.all([p2, this._parsedAnnotations, f2]).then(function([e4, t4, s4]) {
          if (s4) {
            t4 = t4.filter((e5) => !(e5.ref && d3.has(e5.ref)));
            for (let e5 = 0, i4 = s4.length; e5 < i4; e5++) {
              const a4 = s4[e5];
              if (a4.refToReplace) {
                const r4 = t4.findIndex((e6) => e6.ref && isRefsEqual(e6.ref, a4.refToReplace));
                if (r4 >= 0) {
                  t4.splice(r4, 1, a4);
                  s4.splice(e5--, 1);
                  i4--;
                }
              }
            }
            t4 = t4.concat(s4);
          }
          if (0 === t4.length || a3 & l2) {
            e4.flush(true);
            return { length: e4.totalLength };
          }
          const n4 = !!(a3 & h), C4 = !!(a3 & o2), E3 = !!(a3 & g2), u4 = !!(a3 & c2), f3 = [];
          for (const e5 of t4)
            (C4 || E3 && e5.mustBeViewed(r3, n4) || u4 && e5.mustBePrinted(r3)) && f3.push(e5.getOperatorList(Q3, i3, a3, n4, r3).catch(function(e6) {
              warn(`getOperatorList - ignoring annotation data during "${i3.name}" task: "${e6}".`);
              return { opList: null, separateForm: false, separateCanvas: false };
            }));
          return Promise.all(f3).then(function(t5) {
            let i4 = false, a4 = false;
            for (const { opList: s5, separateForm: r4, separateCanvas: n5 } of t5) {
              e4.addOpList(s5);
              i4 || (i4 = r4);
              a4 || (a4 = n5);
            }
            e4.flush(true, { form: i4, canvas: a4 });
            return { length: e4.totalLength };
          });
        });
      }
      extractTextContent({ handler: e3, task: t3, includeMarkedContent: i3, disableNormalization: a3, sink: s3 }) {
        const r3 = this.getContentStream(), n3 = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
        return Promise.all([r3, n3]).then(([r4]) => new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }).getTextContent({ stream: r4, task: t3, resources: this.resources, includeMarkedContent: i3, disableNormalization: a3, sink: s3, viewBox: this.view }));
      }
      async getStructTree() {
        const e3 = await this.pdfManager.ensureCatalog("structTreeRoot");
        if (!e3)
          return null;
        await this._parsedAnnotations;
        return (await this.pdfManager.ensure(this, "_parseStructTree", [e3])).serializable;
      }
      _parseStructTree(e3) {
        const t3 = new StructTreePage(e3, this.pageDict);
        t3.parse(this.ref);
        return t3;
      }
      async getAnnotationsData(e3, t3, i3) {
        const a3 = await this._parsedAnnotations;
        if (0 === a3.length)
          return a3;
        const s3 = [], r3 = [];
        let n3;
        const C3 = !!(i3 & o2), h2 = !!(i3 & g2), l3 = !!(i3 & c2);
        for (const i4 of a3) {
          const a4 = C3 || h2 && i4.viewable;
          (a4 || l3 && i4.printable) && s3.push(i4.data);
          if (i4.hasTextContent && a4) {
            n3 || (n3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }));
            r3.push(i4.extractTextContent(n3, t3, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(e4) {
              warn(`getAnnotationsData - ignoring textContent during "${t3.name}" task: "${e4}".`);
            }));
          }
        }
        await Promise.all(r3);
        return s3;
      }
      get annotations() {
        const e3 = this._getInheritableProperty("Annots");
        return shadow(this, "annotations", Array.isArray(e3) ? e3 : []);
      }
      get _parsedAnnotations() {
        return shadow(this, "_parsedAnnotations", this.pdfManager.ensure(this, "annotations").then(async (e3) => {
          if (0 === e3.length)
            return e3;
          const t3 = await this.pdfManager.ensureDoc("annotationGlobals");
          if (!t3)
            return [];
          const i3 = [];
          for (const a4 of e3)
            i3.push(AnnotationFactory.create(this.xref, a4, t3, this._localIdFactory, false, this.ref).catch(function(e4) {
              warn(`_parsedAnnotations: "${e4}".`);
              return null;
            }));
          const a3 = [];
          let s3, r3;
          for (const e4 of await Promise.all(i3))
            e4 && (e4 instanceof WidgetAnnotation ? (r3 || (r3 = [])).push(e4) : e4 instanceof PopupAnnotation ? (s3 || (s3 = [])).push(e4) : a3.push(e4));
          r3 && a3.push(...r3);
          s3 && a3.push(...s3);
          return a3;
        }));
      }
      get jsActions() {
        return shadow(this, "jsActions", collectActions(this.xref, this.pageDict, fA));
      }
    };
    _J = new WeakSet();
    J_fn = function(e3, t3, i3) {
      for (const a3 of e3)
        if (a3.id) {
          const e4 = Ref.fromString(a3.id);
          if (!e4) {
            warn(`A non-linked annotation cannot be modified: ${a3.id}`);
            continue;
          }
          if (a3.deleted) {
            t3.put(e4, e4);
            continue;
          }
          i3 == null ? void 0 : i3.put(e4);
          a3.ref = e4;
          delete a3.id;
        }
    };
    ro = new Uint8Array([37, 80, 68, 70, 45]);
    no = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
    oo = new Uint8Array([101, 110, 100, 111, 98, 106]);
    PDFDocument = class {
      constructor(e3, t3) {
        __privateAdd(this, _Y);
        if (t3.length <= 0)
          throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
        this.pdfManager = e3;
        this.stream = t3;
        this.xref = new XRef(t3, e3);
        this._pagePromises = /* @__PURE__ */ new Map();
        this._version = null;
        const i3 = { font: 0 };
        this._globalIdFactory = class {
          static getDocId() {
            return `g_${e3.docId}`;
          }
          static createFontId() {
            return "f" + ++i3.font;
          }
          static createObjId() {
            unreachable("Abstract method `createObjId` called.");
          }
          static getPageObjId() {
            unreachable("Abstract method `getPageObjId` called.");
          }
        };
      }
      parse(e3) {
        this.xref.parse(e3);
        this.catalog = new Catalog(this.pdfManager, this.xref);
      }
      get linearization() {
        let e3 = null;
        try {
          e3 = Linearization.create(this.stream);
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          info(e4);
        }
        return shadow(this, "linearization", e3);
      }
      get startXRef() {
        const e3 = this.stream;
        let t3 = 0;
        if (this.linearization) {
          e3.reset();
          if (find(e3, oo)) {
            e3.skip(6);
            let i3 = e3.peekByte();
            for (; isWhiteSpace(i3); ) {
              e3.pos++;
              i3 = e3.peekByte();
            }
            t3 = e3.pos - e3.start;
          }
        } else {
          const i3 = 1024, a3 = no.length;
          let s3 = false, r3 = e3.end;
          for (; !s3 && r3 > 0; ) {
            r3 -= i3 - a3;
            r3 < 0 && (r3 = 0);
            e3.pos = r3;
            s3 = find(e3, no, i3, true);
          }
          if (s3) {
            e3.skip(9);
            let i4;
            do {
              i4 = e3.getByte();
            } while (isWhiteSpace(i4));
            let a4 = "";
            for (; i4 >= 32 && i4 <= 57; ) {
              a4 += String.fromCharCode(i4);
              i4 = e3.getByte();
            }
            t3 = parseInt(a4, 10);
            isNaN(t3) && (t3 = 0);
          }
        }
        return shadow(this, "startXRef", t3);
      }
      checkHeader() {
        const e3 = this.stream;
        e3.reset();
        if (!find(e3, ro))
          return;
        e3.moveStart();
        e3.skip(ro.length);
        let t3, i3 = "";
        for (; (t3 = e3.getByte()) > 32 && i3.length < 7; )
          i3 += String.fromCharCode(t3);
        Dt.test(i3) ? this._version = i3 : warn(`Invalid PDF header version: ${i3}`);
      }
      parseStartXRef() {
        this.xref.setStartXRef(this.startXRef);
      }
      get numPages() {
        let e3 = 0;
        e3 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;
        return shadow(this, "numPages", e3);
      }
      _hasOnlyDocumentSignatures(e3, t3 = 0) {
        return !!Array.isArray(e3) && e3.every((e4) => {
          if (!((e4 = this.xref.fetchIfRef(e4)) instanceof Dict))
            return false;
          if (e4.has("Kids")) {
            if (++t3 > 10) {
              warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");
              return false;
            }
            return this._hasOnlyDocumentSignatures(e4.get("Kids"), t3);
          }
          const i3 = isName(e4.get("FT"), "Sig"), a3 = e4.get("Rect"), s3 = Array.isArray(a3) && a3.every((e5) => 0 === e5);
          return i3 && s3;
        });
      }
      get _xfaStreams() {
        const e3 = this.catalog.acroForm;
        if (!e3)
          return null;
        const t3 = e3.get("XFA"), i3 = { "xdp:xdp": "", template: "", datasets: "", config: "", connectionSet: "", localeSet: "", stylesheet: "", "/xdp:xdp": "" };
        if (t3 instanceof BaseStream && !t3.isEmpty) {
          i3["xdp:xdp"] = t3;
          return i3;
        }
        if (!Array.isArray(t3) || 0 === t3.length)
          return null;
        for (let e4 = 0, a3 = t3.length; e4 < a3; e4 += 2) {
          let s3;
          s3 = 0 === e4 ? "xdp:xdp" : e4 === a3 - 2 ? "/xdp:xdp" : t3[e4];
          if (!i3.hasOwnProperty(s3))
            continue;
          const r3 = this.xref.fetchIfRef(t3[e4 + 1]);
          r3 instanceof BaseStream && !r3.isEmpty && (i3[s3] = r3);
        }
        return i3;
      }
      get xfaDatasets() {
        const e3 = this._xfaStreams;
        if (!e3)
          return shadow(this, "xfaDatasets", null);
        for (const t3 of ["datasets", "xdp:xdp"]) {
          const i3 = e3[t3];
          if (i3)
            try {
              const e4 = stringToUTF8String(i3.getString());
              return shadow(this, "xfaDatasets", new DatasetReader({ [t3]: e4 }));
            } catch {
              warn("XFA - Invalid utf-8 string.");
              break;
            }
        }
        return shadow(this, "xfaDatasets", null);
      }
      get xfaData() {
        const e3 = this._xfaStreams;
        if (!e3)
          return null;
        const t3 = /* @__PURE__ */ Object.create(null);
        for (const [i3, a3] of Object.entries(e3))
          if (a3)
            try {
              t3[i3] = stringToUTF8String(a3.getString());
            } catch {
              warn("XFA - Invalid utf-8 string.");
              return null;
            }
        return t3;
      }
      get xfaFactory() {
        let e3;
        this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e3 = this.xfaData);
        return shadow(this, "xfaFactory", e3 ? new XFAFactory(e3) : null);
      }
      get isPureXfa() {
        return !!this.xfaFactory && this.xfaFactory.isValid();
      }
      get htmlForXfa() {
        return this.xfaFactory ? this.xfaFactory.getPages() : null;
      }
      async loadXfaImages() {
        const e3 = await this.pdfManager.ensureCatalog("xfaImages");
        if (!e3)
          return;
        const t3 = e3.getKeys(), i3 = new ObjectLoader(e3, t3, this.xref);
        await i3.load();
        const a3 = /* @__PURE__ */ new Map();
        for (const i4 of t3) {
          const t4 = e3.get(i4);
          t4 instanceof BaseStream && a3.set(i4, t4.getBytes());
        }
        this.xfaFactory.setImages(a3);
      }
      async loadXfaFonts(e3, t3) {
        const i3 = await this.pdfManager.ensureCatalog("acroForm");
        if (!i3)
          return;
        const a3 = await i3.getAsync("DR");
        if (!(a3 instanceof Dict))
          return;
        const s3 = new ObjectLoader(a3, ["Font"], this.xref);
        await s3.load();
        const r3 = a3.get("Font");
        if (!(r3 instanceof Dict))
          return;
        const n3 = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
        n3.useSystemFonts = false;
        const o3 = new PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: this.catalog.fontCache, builtInCMapCache: this.catalog.builtInCMapCache, standardFontDataCache: this.catalog.standardFontDataCache, options: n3 }), g3 = new OperatorList(), c3 = [], C3 = { get font() {
          return c3.at(-1);
        }, set font(e4) {
          c3.push(e4);
        }, clone() {
          return this;
        } }, h2 = /* @__PURE__ */ new Map();
        r3.forEach((e4, t4) => {
          h2.set(e4, t4);
        });
        const l3 = [];
        for (const [e4, i4] of h2) {
          const s4 = i4.get("FontDescriptor");
          if (!(s4 instanceof Dict))
            continue;
          let r4 = s4.get("FontFamily");
          r4 = r4.replaceAll(/[ ]+(\d)/g, "$1");
          const n4 = { fontFamily: r4, fontWeight: s4.get("FontWeight"), italicAngle: -s4.get("ItalicAngle") };
          validateCSSFont(n4) && l3.push(o3.handleSetFont(a3, [Name.get(e4), 1], null, g3, t3, C3, null, n4).catch(function(e5) {
            warn(`loadXfaFonts: "${e5}".`);
            return null;
          }));
        }
        await Promise.all(l3);
        const Q3 = this.xfaFactory.setFonts(c3);
        if (!Q3)
          return;
        n3.ignoreErrors = true;
        l3.length = 0;
        c3.length = 0;
        const E3 = /* @__PURE__ */ new Set();
        for (const e4 of Q3)
          getXfaFontName(`${e4}-Regular`) || E3.add(e4);
        E3.size && Q3.push("PdfJS-Fallback");
        for (const e4 of Q3)
          if (!E3.has(e4))
            for (const i4 of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
              const s4 = `${e4}-${i4.name}`, r4 = getXfaFontDict(s4);
              l3.push(o3.handleSetFont(a3, [Name.get(s4), 1], null, g3, t3, C3, r4, { fontFamily: e4, fontWeight: i4.fontWeight, italicAngle: i4.italicAngle }).catch(function(e5) {
                warn(`loadXfaFonts: "${e5}".`);
                return null;
              }));
            }
        await Promise.all(l3);
        this.xfaFactory.appendFonts(c3, E3);
      }
      async serializeXfaData(e3) {
        return this.xfaFactory ? this.xfaFactory.serializeData(e3) : null;
      }
      get version() {
        return this.catalog.version || this._version;
      }
      get formInfo() {
        const e3 = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }, t3 = this.catalog.acroForm;
        if (!t3)
          return shadow(this, "formInfo", e3);
        try {
          const i3 = t3.get("Fields"), a3 = Array.isArray(i3) && i3.length > 0;
          e3.hasFields = a3;
          const s3 = t3.get("XFA");
          e3.hasXfa = Array.isArray(s3) && s3.length > 0 || s3 instanceof BaseStream && !s3.isEmpty;
          const r3 = !!(1 & t3.get("SigFlags")), n3 = r3 && this._hasOnlyDocumentSignatures(i3);
          e3.hasAcroForm = a3 && !n3;
          e3.hasSignatures = r3;
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          warn(`Cannot fetch form information: "${e4}".`);
        }
        return shadow(this, "formInfo", e3);
      }
      get documentInfo() {
        const e3 = { PDFFormatVersion: this.version, Language: this.catalog.lang, EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null, IsLinearized: !!this.linearization, IsAcroFormPresent: this.formInfo.hasAcroForm, IsXFAPresent: this.formInfo.hasXfa, IsCollectionPresent: !!this.catalog.collection, IsSignaturesPresent: this.formInfo.hasSignatures };
        let t3;
        try {
          t3 = this.xref.trailer.get("Info");
        } catch (e4) {
          if (e4 instanceof MissingDataException)
            throw e4;
          info("The document information dictionary is invalid.");
        }
        if (!(t3 instanceof Dict))
          return shadow(this, "documentInfo", e3);
        for (const i3 of t3.getKeys()) {
          const a3 = t3.get(i3);
          switch (i3) {
            case "Title":
            case "Author":
            case "Subject":
            case "Keywords":
            case "Creator":
            case "Producer":
            case "CreationDate":
            case "ModDate":
              if ("string" == typeof a3) {
                e3[i3] = stringToPDFString(a3);
                continue;
              }
              break;
            case "Trapped":
              if (a3 instanceof Name) {
                e3[i3] = a3;
                continue;
              }
              break;
            default:
              let t4;
              switch (typeof a3) {
                case "string":
                  t4 = stringToPDFString(a3);
                  break;
                case "number":
                case "boolean":
                  t4 = a3;
                  break;
                default:
                  a3 instanceof Name && (t4 = a3);
              }
              if (void 0 === t4) {
                warn(`Bad value, for custom key "${i3}", in Info: ${a3}.`);
                continue;
              }
              e3.Custom || (e3.Custom = /* @__PURE__ */ Object.create(null));
              e3.Custom[i3] = t4;
              continue;
          }
          warn(`Bad value, for key "${i3}", in Info: ${a3}.`);
        }
        return shadow(this, "documentInfo", e3);
      }
      get fingerprints() {
        function validate(e4) {
          return "string" == typeof e4 && e4.length > 0 && "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" !== e4;
        }
        function hexString(e4) {
          const t4 = [];
          for (const i4 of e4) {
            const e5 = i4.toString(16);
            t4.push(e5.padStart(2, "0"));
          }
          return t4.join("");
        }
        const e3 = this.xref.trailer.get("ID");
        let t3, i3;
        if (Array.isArray(e3) && validate(e3[0])) {
          t3 = stringToBytes(e3[0]);
          e3[1] !== e3[0] && validate(e3[1]) && (i3 = stringToBytes(e3[1]));
        } else
          t3 = Hs(this.stream.getByteRange(0, 1024), 0, 1024);
        return shadow(this, "fingerprints", [hexString(t3), i3 ? hexString(i3) : null]);
      }
      async _getLinearizationPage(e3) {
        const { catalog: t3, linearization: i3, xref: a3 } = this, s3 = Ref.get(i3.objectNumberFirst, 0);
        try {
          const e4 = await a3.fetchAsync(s3);
          if (e4 instanceof Dict) {
            let i4 = e4.getRaw("Type");
            i4 instanceof Ref && (i4 = await a3.fetchAsync(i4));
            if (isName(i4, "Page") || !e4.has("Type") && !e4.has("Kids")) {
              t3.pageKidsCountCache.has(s3) || t3.pageKidsCountCache.put(s3, 1);
              t3.pageIndexCache.has(s3) || t3.pageIndexCache.put(s3, 0);
              return [e4, s3];
            }
          }
          throw new FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
        } catch (i4) {
          warn(`_getLinearizationPage: "${i4.message}".`);
          return t3.getPageDict(e3);
        }
      }
      getPage(e3) {
        const t3 = this._pagePromises.get(e3);
        if (t3)
          return t3;
        const { catalog: i3, linearization: a3, xfaFactory: s3 } = this;
        let r3;
        r3 = s3 ? Promise.resolve([Dict.empty, null]) : (a3 == null ? void 0 : a3.pageFirst) === e3 ? this._getLinearizationPage(e3) : i3.getPageDict(e3);
        r3 = r3.then(([t4, a4]) => new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: e3, pageDict: t4, ref: a4, globalIdFactory: this._globalIdFactory, fontCache: i3.fontCache, builtInCMapCache: i3.builtInCMapCache, standardFontDataCache: i3.standardFontDataCache, globalImageCache: i3.globalImageCache, systemFontCache: i3.systemFontCache, nonBlendModesSet: i3.nonBlendModesSet, xfaFactory: s3 }));
        this._pagePromises.set(e3, r3);
        return r3;
      }
      async checkFirstPage(e3 = false) {
        if (!e3)
          try {
            await this.getPage(0);
          } catch (e4) {
            if (e4 instanceof XRefEntryException) {
              this._pagePromises.delete(0);
              await this.cleanup();
              throw new XRefParseException();
            }
          }
      }
      async checkLastPage(e3 = false) {
        const { catalog: t3, pdfManager: i3 } = this;
        t3.setActualNumPages();
        let a3;
        try {
          await Promise.all([i3.ensureDoc("xfaFactory"), i3.ensureDoc("linearization"), i3.ensureCatalog("numPages")]);
          if (this.xfaFactory)
            return;
          a3 = this.linearization ? this.linearization.numPages : t3.numPages;
          if (!Number.isInteger(a3))
            throw new FormatError("Page count is not an integer.");
          if (a3 <= 1)
            return;
          await this.getPage(a3 - 1);
        } catch (s3) {
          this._pagePromises.delete(a3 - 1);
          await this.cleanup();
          if (s3 instanceof XRefEntryException && !e3)
            throw new XRefParseException();
          warn(`checkLastPage - invalid /Pages tree /Count: ${a3}.`);
          let r3;
          try {
            r3 = await t3.getAllPageDicts(e3);
          } catch (i4) {
            if (i4 instanceof XRefEntryException && !e3)
              throw new XRefParseException();
            t3.setActualNumPages(1);
            return;
          }
          for (const [e4, [a4, s4]] of r3) {
            let r4;
            if (a4 instanceof Error) {
              r4 = Promise.reject(a4);
              r4.catch(() => {
              });
            } else
              r4 = Promise.resolve(new Page({ pdfManager: i3, xref: this.xref, pageIndex: e4, pageDict: a4, ref: s4, globalIdFactory: this._globalIdFactory, fontCache: t3.fontCache, builtInCMapCache: t3.builtInCMapCache, standardFontDataCache: t3.standardFontDataCache, globalImageCache: t3.globalImageCache, systemFontCache: t3.systemFontCache, nonBlendModesSet: t3.nonBlendModesSet, xfaFactory: null }));
            this._pagePromises.set(e4, r4);
          }
          t3.setActualNumPages(r3.size);
        }
      }
      fontFallback(e3, t3) {
        return this.catalog.fontFallback(e3, t3);
      }
      async cleanup(e3 = false) {
        return this.catalog ? this.catalog.cleanup(e3) : clearGlobalCaches();
      }
      get fieldObjects() {
        if (!this.formInfo.hasFields)
          return shadow(this, "fieldObjects", Promise.resolve(null));
        return shadow(this, "fieldObjects", Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureCatalog("acroForm")]).then(async ([e3, t3]) => {
          if (!e3)
            return null;
          const i3 = new RefSet(), a3 = /* @__PURE__ */ Object.create(null), s3 = /* @__PURE__ */ new Map();
          for (const a4 of await t3.getAsync("Fields"))
            await __privateMethod(this, _Y, Y_fn).call(this, "", a4, s3, e3, i3);
          const r3 = [];
          for (const [e4, t4] of s3)
            r3.push(Promise.all(t4).then((t5) => {
              (t5 = t5.filter((e5) => !!e5)).length > 0 && (a3[e4] = t5);
            }));
          await Promise.all(r3);
          return a3;
        }));
      }
      get hasJSActions() {
        return shadow(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
      }
      async _parseHasJSActions() {
        const [e3, t3] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
        return !!e3 || !!t3 && Object.values(t3).some((e4) => e4.some((e5) => null !== e5.actions));
      }
      get calculationOrderIds() {
        const e3 = this.catalog.acroForm;
        if (!(e3 == null ? void 0 : e3.has("CO")))
          return shadow(this, "calculationOrderIds", null);
        const t3 = e3.get("CO");
        if (!Array.isArray(t3) || 0 === t3.length)
          return shadow(this, "calculationOrderIds", null);
        const i3 = [];
        for (const e4 of t3)
          e4 instanceof Ref && i3.push(e4.toString());
        return 0 === i3.length ? shadow(this, "calculationOrderIds", null) : shadow(this, "calculationOrderIds", i3);
      }
      get annotationGlobals() {
        return shadow(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
      }
    };
    _Y = new WeakSet();
    Y_fn = async function(e3, t3, i3, a3, s3) {
      const { xref: r3 } = this;
      if (!(t3 instanceof Ref) || s3.has(t3))
        return;
      s3.put(t3);
      const n3 = await r3.fetchAsync(t3);
      if (!(n3 instanceof Dict))
        return;
      if (n3.has("T")) {
        const t4 = stringToPDFString(await n3.getAsync("T"));
        e3 = "" === e3 ? t4 : `${e3}.${t4}`;
      } else {
        let t4 = n3;
        for (; ; ) {
          t4 = t4.getRaw("Parent");
          if (t4 instanceof Ref) {
            if (s3.has(t4))
              break;
            t4 = await r3.fetchAsync(t4);
          }
          if (!(t4 instanceof Dict))
            break;
          if (t4.has("T")) {
            const i4 = stringToPDFString(await t4.getAsync("T"));
            e3 = "" === e3 ? i4 : `${e3}.${i4}`;
            break;
          }
        }
      }
      i3.has(e3) || i3.set(e3, []);
      i3.get(e3).push(AnnotationFactory.create(r3, t3, a3, null, true, null).then((e4) => e4 == null ? void 0 : e4.getFieldObject()).catch(function(e4) {
        warn(`#collectFieldObjects: "${e4}".`);
        return null;
      }));
      if (!n3.has("Kids"))
        return;
      const o3 = await n3.getAsync("Kids");
      if (Array.isArray(o3))
        for (const t4 of o3)
          await __privateMethod(this, _Y, Y_fn).call(this, e3, t4, i3, a3, s3);
    };
    BasePdfManager = class _BasePdfManager {
      constructor(e3) {
        var _a3;
        this.constructor === _BasePdfManager && unreachable("Cannot initialize BasePdfManager.");
        this._docBaseUrl = function parseDocBaseUrl(e4) {
          if (e4) {
            const t3 = createValidAbsoluteUrl(e4);
            if (t3)
              return t3.href;
            warn(`Invalid absolute docBaseUrl: "${e4}".`);
          }
          return null;
        }(e3.docBaseUrl);
        this._docId = e3.docId;
        this._password = e3.password;
        this.enableXfa = e3.enableXfa;
        (_a3 = e3.evaluatorOptions).isOffscreenCanvasSupported && (_a3.isOffscreenCanvasSupported = FeatureTest.isOffscreenCanvasSupported);
        this.evaluatorOptions = e3.evaluatorOptions;
      }
      get docId() {
        return this._docId;
      }
      get password() {
        return this._password;
      }
      get docBaseUrl() {
        return this._docBaseUrl;
      }
      get catalog() {
        return this.pdfDocument.catalog;
      }
      ensureDoc(e3, t3) {
        return this.ensure(this.pdfDocument, e3, t3);
      }
      ensureXRef(e3, t3) {
        return this.ensure(this.pdfDocument.xref, e3, t3);
      }
      ensureCatalog(e3, t3) {
        return this.ensure(this.pdfDocument.catalog, e3, t3);
      }
      getPage(e3) {
        return this.pdfDocument.getPage(e3);
      }
      fontFallback(e3, t3) {
        return this.pdfDocument.fontFallback(e3, t3);
      }
      loadXfaFonts(e3, t3) {
        return this.pdfDocument.loadXfaFonts(e3, t3);
      }
      loadXfaImages() {
        return this.pdfDocument.loadXfaImages();
      }
      serializeXfaData(e3) {
        return this.pdfDocument.serializeXfaData(e3);
      }
      cleanup(e3 = false) {
        return this.pdfDocument.cleanup(e3);
      }
      async ensure(e3, t3, i3) {
        unreachable("Abstract method `ensure` called");
      }
      requestRange(e3, t3) {
        unreachable("Abstract method `requestRange` called");
      }
      requestLoadedStream(e3 = false) {
        unreachable("Abstract method `requestLoadedStream` called");
      }
      sendProgressiveData(e3) {
        unreachable("Abstract method `sendProgressiveData` called");
      }
      updatePassword(e3) {
        this._password = e3;
      }
      terminate(e3) {
        unreachable("Abstract method `terminate` called");
      }
    };
    LocalPdfManager = class extends BasePdfManager {
      constructor(e3) {
        super(e3);
        const t3 = new Stream(e3.source);
        this.pdfDocument = new PDFDocument(this, t3);
        this._loadedStreamPromise = Promise.resolve(t3);
      }
      async ensure(e3, t3, i3) {
        const a3 = e3[t3];
        return "function" == typeof a3 ? a3.apply(e3, i3) : a3;
      }
      requestRange(e3, t3) {
        return Promise.resolve();
      }
      requestLoadedStream(e3 = false) {
        return this._loadedStreamPromise;
      }
      terminate(e3) {
      }
    };
    NetworkPdfManager = class extends BasePdfManager {
      constructor(e3) {
        super(e3);
        this.streamManager = new ChunkedStreamManager(e3.source, { msgHandler: e3.handler, length: e3.length, disableAutoFetch: e3.disableAutoFetch, rangeChunkSize: e3.rangeChunkSize });
        this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
      }
      async ensure(e3, t3, i3) {
        try {
          const a3 = e3[t3];
          return "function" == typeof a3 ? a3.apply(e3, i3) : a3;
        } catch (a3) {
          if (!(a3 instanceof MissingDataException))
            throw a3;
          await this.requestRange(a3.begin, a3.end);
          return this.ensure(e3, t3, i3);
        }
      }
      requestRange(e3, t3) {
        return this.streamManager.requestRange(e3, t3);
      }
      requestLoadedStream(e3 = false) {
        return this.streamManager.requestAllChunks(e3);
      }
      sendProgressiveData(e3) {
        this.streamManager.onReceiveData({ chunk: e3 });
      }
      terminate(e3) {
        this.streamManager.abort(e3);
      }
    };
    go = 1;
    Io = 2;
    co = 1;
    Co = 2;
    ho = 3;
    lo = 4;
    Bo = 5;
    Qo = 6;
    Eo = 7;
    uo = 8;
    MessageHandler = class {
      constructor(e3, t3, i3) {
        __privateAdd(this, _K);
        __privateAdd(this, _v);
        __privateAdd(this, _T);
        this.sourceName = e3;
        this.targetName = t3;
        this.comObj = i3;
        this.callbackId = 1;
        this.streamId = 1;
        this.streamSinks = /* @__PURE__ */ Object.create(null);
        this.streamControllers = /* @__PURE__ */ Object.create(null);
        this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
        this.actionHandler = /* @__PURE__ */ Object.create(null);
        this._onComObjOnMessage = (e4) => {
          const t4 = e4.data;
          if (t4.targetName !== this.sourceName)
            return;
          if (t4.stream) {
            __privateMethod(this, _v, v_fn).call(this, t4);
            return;
          }
          if (t4.callback) {
            const e5 = t4.callbackId, i4 = this.callbackCapabilities[e5];
            if (!i4)
              throw new Error(`Cannot resolve callback ${e5}`);
            delete this.callbackCapabilities[e5];
            if (t4.callback === go)
              i4.resolve(t4.data);
            else {
              if (t4.callback !== Io)
                throw new Error("Unexpected callback case");
              i4.reject(wrapReason(t4.reason));
            }
            return;
          }
          const a3 = this.actionHandler[t4.action];
          if (!a3)
            throw new Error(`Unknown action from worker: ${t4.action}`);
          if (t4.callbackId) {
            const e5 = this.sourceName, s3 = t4.sourceName;
            new Promise(function(e6) {
              e6(a3(t4.data));
            }).then(function(a4) {
              i3.postMessage({ sourceName: e5, targetName: s3, callback: go, callbackId: t4.callbackId, data: a4 });
            }, function(a4) {
              i3.postMessage({ sourceName: e5, targetName: s3, callback: Io, callbackId: t4.callbackId, reason: wrapReason(a4) });
            });
          } else
            t4.streamId ? __privateMethod(this, _K, K_fn).call(this, t4) : a3(t4.data);
        };
        i3.addEventListener("message", this._onComObjOnMessage);
      }
      on(e3, t3) {
        const i3 = this.actionHandler;
        if (i3[e3])
          throw new Error(`There is already an actionName called "${e3}"`);
        i3[e3] = t3;
      }
      send(e3, t3, i3) {
        this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e3, data: t3 }, i3);
      }
      sendWithPromise(e3, t3, i3) {
        const a3 = this.callbackId++, s3 = Promise.withResolvers();
        this.callbackCapabilities[a3] = s3;
        try {
          this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e3, callbackId: a3, data: t3 }, i3);
        } catch (e4) {
          s3.reject(e4);
        }
        return s3.promise;
      }
      sendWithStream(e3, t3, i3, a3) {
        const s3 = this.streamId++, r3 = this.sourceName, n3 = this.targetName, o3 = this.comObj;
        return new ReadableStream({ start: (i4) => {
          const g3 = Promise.withResolvers();
          this.streamControllers[s3] = { controller: i4, startCall: g3, pullCall: null, cancelCall: null, isClosed: false };
          o3.postMessage({ sourceName: r3, targetName: n3, action: e3, streamId: s3, data: t3, desiredSize: i4.desiredSize }, a3);
          return g3.promise;
        }, pull: (e4) => {
          const t4 = Promise.withResolvers();
          this.streamControllers[s3].pullCall = t4;
          o3.postMessage({ sourceName: r3, targetName: n3, stream: Qo, streamId: s3, desiredSize: e4.desiredSize });
          return t4.promise;
        }, cancel: (e4) => {
          assert(e4 instanceof Error, "cancel must have a valid reason");
          const t4 = Promise.withResolvers();
          this.streamControllers[s3].cancelCall = t4;
          this.streamControllers[s3].isClosed = true;
          o3.postMessage({ sourceName: r3, targetName: n3, stream: co, streamId: s3, reason: wrapReason(e4) });
          return t4.promise;
        } }, i3);
      }
      destroy() {
        this.comObj.removeEventListener("message", this._onComObjOnMessage);
      }
    };
    _K = new WeakSet();
    K_fn = function(e3) {
      const t3 = e3.streamId, i3 = this.sourceName, a3 = e3.sourceName, s3 = this.comObj, r3 = this, n3 = this.actionHandler[e3.action], o3 = { enqueue(e4, r4 = 1, n4) {
        if (this.isCancelled)
          return;
        const o4 = this.desiredSize;
        this.desiredSize -= r4;
        if (o4 > 0 && this.desiredSize <= 0) {
          this.sinkCapability = Promise.withResolvers();
          this.ready = this.sinkCapability.promise;
        }
        s3.postMessage({ sourceName: i3, targetName: a3, stream: lo, streamId: t3, chunk: e4 }, n4);
      }, close() {
        if (!this.isCancelled) {
          this.isCancelled = true;
          s3.postMessage({ sourceName: i3, targetName: a3, stream: ho, streamId: t3 });
          delete r3.streamSinks[t3];
        }
      }, error(e4) {
        assert(e4 instanceof Error, "error must have a valid reason");
        if (!this.isCancelled) {
          this.isCancelled = true;
          s3.postMessage({ sourceName: i3, targetName: a3, stream: Bo, streamId: t3, reason: wrapReason(e4) });
        }
      }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e3.desiredSize, ready: null };
      o3.sinkCapability.resolve();
      o3.ready = o3.sinkCapability.promise;
      this.streamSinks[t3] = o3;
      new Promise(function(t4) {
        t4(n3(e3.data, o3));
      }).then(function() {
        s3.postMessage({ sourceName: i3, targetName: a3, stream: uo, streamId: t3, success: true });
      }, function(e4) {
        s3.postMessage({ sourceName: i3, targetName: a3, stream: uo, streamId: t3, reason: wrapReason(e4) });
      });
    };
    _v = new WeakSet();
    v_fn = function(e3) {
      const t3 = e3.streamId, i3 = this.sourceName, a3 = e3.sourceName, s3 = this.comObj, r3 = this.streamControllers[t3], n3 = this.streamSinks[t3];
      switch (e3.stream) {
        case uo:
          e3.success ? r3.startCall.resolve() : r3.startCall.reject(wrapReason(e3.reason));
          break;
        case Eo:
          e3.success ? r3.pullCall.resolve() : r3.pullCall.reject(wrapReason(e3.reason));
          break;
        case Qo:
          if (!n3) {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: Eo, streamId: t3, success: true });
            break;
          }
          n3.desiredSize <= 0 && e3.desiredSize > 0 && n3.sinkCapability.resolve();
          n3.desiredSize = e3.desiredSize;
          new Promise(function(e4) {
            var _a3;
            e4((_a3 = n3.onPull) == null ? void 0 : _a3.call(n3));
          }).then(function() {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: Eo, streamId: t3, success: true });
          }, function(e4) {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: Eo, streamId: t3, reason: wrapReason(e4) });
          });
          break;
        case lo:
          assert(r3, "enqueue should have stream controller");
          if (r3.isClosed)
            break;
          r3.controller.enqueue(e3.chunk);
          break;
        case ho:
          assert(r3, "close should have stream controller");
          if (r3.isClosed)
            break;
          r3.isClosed = true;
          r3.controller.close();
          __privateMethod(this, _T, T_fn).call(this, r3, t3);
          break;
        case Bo:
          assert(r3, "error should have stream controller");
          r3.controller.error(wrapReason(e3.reason));
          __privateMethod(this, _T, T_fn).call(this, r3, t3);
          break;
        case Co:
          e3.success ? r3.cancelCall.resolve() : r3.cancelCall.reject(wrapReason(e3.reason));
          __privateMethod(this, _T, T_fn).call(this, r3, t3);
          break;
        case co:
          if (!n3)
            break;
          new Promise(function(t4) {
            var _a3;
            t4((_a3 = n3.onCancel) == null ? void 0 : _a3.call(n3, wrapReason(e3.reason)));
          }).then(function() {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: Co, streamId: t3, success: true });
          }, function(e4) {
            s3.postMessage({ sourceName: i3, targetName: a3, stream: Co, streamId: t3, reason: wrapReason(e4) });
          });
          n3.sinkCapability.reject(wrapReason(e3.reason));
          n3.isCancelled = true;
          delete this.streamSinks[t3];
          break;
        default:
          throw new Error("Unexpected stream case");
      }
    };
    _T = new WeakSet();
    T_fn = async function(e3, t3) {
      var _a3, _b2, _c2;
      await Promise.allSettled([(_a3 = e3.startCall) == null ? void 0 : _a3.promise, (_b2 = e3.pullCall) == null ? void 0 : _b2.promise, (_c2 = e3.cancelCall) == null ? void 0 : _c2.promise]);
      delete this.streamControllers[t3];
    };
    PDFWorkerStream = class {
      constructor(e3) {
        this._msgHandler = e3;
        this._contentLength = null;
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
      }
      getFullReader() {
        assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
        return this._fullRequestReader;
      }
      getRangeReader(e3, t3) {
        const i3 = new PDFWorkerStreamRangeReader(e3, t3, this._msgHandler);
        this._rangeRequestReaders.push(i3);
        return i3;
      }
      cancelAllRequests(e3) {
        var _a3;
        (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(e3);
        for (const t3 of this._rangeRequestReaders.slice(0))
          t3.cancel(e3);
      }
    };
    PDFWorkerStreamReader = class {
      constructor(e3) {
        this._msgHandler = e3;
        this.onProgress = null;
        this._contentLength = null;
        this._isRangeSupported = false;
        this._isStreamingSupported = false;
        const t3 = this._msgHandler.sendWithStream("GetReader");
        this._reader = t3.getReader();
        this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e4) => {
          this._isStreamingSupported = e4.isStreamingSupported;
          this._isRangeSupported = e4.isRangeSupported;
          this._contentLength = e4.contentLength;
        });
      }
      get headersReady() {
        return this._headersReady;
      }
      get contentLength() {
        return this._contentLength;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      async read() {
        const { value: e3, done: t3 } = await this._reader.read();
        return t3 ? { value: void 0, done: true } : { value: e3.buffer, done: false };
      }
      cancel(e3) {
        this._reader.cancel(e3);
      }
    };
    PDFWorkerStreamRangeReader = class {
      constructor(e3, t3, i3) {
        this._msgHandler = i3;
        this.onProgress = null;
        const a3 = this._msgHandler.sendWithStream("GetRangeReader", { begin: e3, end: t3 });
        this._reader = a3.getReader();
      }
      get isStreamingSupported() {
        return false;
      }
      async read() {
        const { value: e3, done: t3 } = await this._reader.read();
        return t3 ? { value: void 0, done: true } : { value: e3.buffer, done: false };
      }
      cancel(e3) {
        this._reader.cancel(e3);
      }
    };
    WorkerTask = class {
      constructor(e3) {
        this.name = e3;
        this.terminated = false;
        this._capability = Promise.withResolvers();
      }
      get finished() {
        return this._capability.promise;
      }
      finish() {
        this._capability.resolve();
      }
      terminate() {
        this.terminated = true;
      }
      ensureNotTerminated() {
        if (this.terminated)
          throw new Error("Worker task was terminated");
      }
    };
    WorkerMessageHandler = class _WorkerMessageHandler {
      static setup(e3, t3) {
        let i3 = false;
        e3.on("test", function(t4) {
          if (!i3) {
            i3 = true;
            e3.send("test", t4 instanceof Uint8Array);
          }
        });
        e3.on("configure", function(e4) {
          !function setVerbosityLevel(e5) {
            Number.isInteger(e5) && (st = e5);
          }(e4.verbosity);
        });
        e3.on("GetDocRequest", function(e4) {
          return _WorkerMessageHandler.createDocumentHandler(e4, t3);
        });
      }
      static createDocumentHandler(e3, t3) {
        let i3, a3 = false, s3 = null;
        const r3 = /* @__PURE__ */ new Set(), n3 = getVerbosityLevel(), { docId: o3, apiVersion: g3 } = e3, c3 = "4.2.67";
        if (g3 !== c3)
          throw new Error(`The API version "${g3}" does not match the Worker version "${c3}".`);
        const C3 = [];
        for (const e4 in [])
          C3.push(e4);
        if (C3.length)
          throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + C3.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
        const h2 = o3 + "_worker";
        let l3 = new MessageHandler(h2, o3, t3);
        function ensureNotTerminated() {
          if (a3)
            throw new Error("Worker was terminated");
        }
        function startWorkerTask(e4) {
          r3.add(e4);
        }
        function finishWorkerTask(e4) {
          e4.finish();
          r3.delete(e4);
        }
        async function loadDocument(e4) {
          await i3.ensureDoc("checkHeader");
          await i3.ensureDoc("parseStartXRef");
          await i3.ensureDoc("parse", [e4]);
          await i3.ensureDoc("checkFirstPage", [e4]);
          await i3.ensureDoc("checkLastPage", [e4]);
          const t4 = await i3.ensureDoc("isPureXfa");
          if (t4) {
            const e5 = new WorkerTask("loadXfaFonts");
            startWorkerTask(e5);
            await Promise.all([i3.loadXfaFonts(l3, e5).catch((e6) => {
            }).then(() => finishWorkerTask(e5)), i3.loadXfaImages()]);
          }
          const [a4, s4] = await Promise.all([i3.ensureDoc("numPages"), i3.ensureDoc("fingerprints")]);
          return { numPages: a4, fingerprints: s4, htmlForXfa: t4 ? await i3.ensureDoc("htmlForXfa") : null };
        }
        function getPdfManager({ data: e4, password: t4, disableAutoFetch: i4, rangeChunkSize: a4, length: r4, docBaseUrl: n4, enableXfa: g4, evaluatorOptions: c4 }) {
          const C4 = { source: null, disableAutoFetch: i4, docBaseUrl: n4, docId: o3, enableXfa: g4, evaluatorOptions: c4, handler: l3, length: r4, password: t4, rangeChunkSize: a4 }, h3 = Promise.withResolvers();
          let Q3;
          if (e4) {
            try {
              C4.source = e4;
              Q3 = new LocalPdfManager(C4);
              h3.resolve(Q3);
            } catch (e5) {
              h3.reject(e5);
            }
            return h3.promise;
          }
          let E3, u3 = [];
          try {
            E3 = new PDFWorkerStream(l3);
          } catch (e5) {
            h3.reject(e5);
            return h3.promise;
          }
          const d3 = E3.getFullReader();
          d3.headersReady.then(function() {
            if (d3.isRangeSupported) {
              C4.source = E3;
              C4.length = d3.contentLength;
              C4.disableAutoFetch || (C4.disableAutoFetch = d3.isStreamingSupported);
              Q3 = new NetworkPdfManager(C4);
              for (const e5 of u3)
                Q3.sendProgressiveData(e5);
              u3 = [];
              h3.resolve(Q3);
              s3 = null;
            }
          }).catch(function(e5) {
            h3.reject(e5);
            s3 = null;
          });
          let f2 = 0;
          new Promise(function(e5, t5) {
            const readChunk = function({ value: e6, done: i5 }) {
              try {
                ensureNotTerminated();
                if (i5) {
                  Q3 || function() {
                    const e7 = arrayBuffersToBytes(u3);
                    r4 && e7.length !== r4 && warn("reported HTTP length is different from actual");
                    try {
                      C4.source = e7;
                      Q3 = new LocalPdfManager(C4);
                      h3.resolve(Q3);
                    } catch (e8) {
                      h3.reject(e8);
                    }
                    u3 = [];
                  }();
                  s3 = null;
                  return;
                }
                f2 += e6.byteLength;
                d3.isStreamingSupported || l3.send("DocProgress", { loaded: f2, total: Math.max(f2, d3.contentLength || 0) });
                Q3 ? Q3.sendProgressiveData(e6) : u3.push(e6);
                d3.read().then(readChunk, t5);
              } catch (e7) {
                t5(e7);
              }
            };
            d3.read().then(readChunk, t5);
          }).catch(function(e5) {
            h3.reject(e5);
            s3 = null;
          });
          s3 = function(e5) {
            E3.cancelAllRequests(e5);
          };
          return h3.promise;
        }
        l3.on("GetPage", function(e4) {
          return i3.getPage(e4.pageIndex).then(function(e5) {
            return Promise.all([i3.ensure(e5, "rotate"), i3.ensure(e5, "ref"), i3.ensure(e5, "userUnit"), i3.ensure(e5, "view")]).then(function([e6, t4, i4, a4]) {
              return { rotate: e6, ref: t4, refStr: (t4 == null ? void 0 : t4.toString()) ?? null, userUnit: i4, view: a4 };
            });
          });
        });
        l3.on("GetPageIndex", function(e4) {
          const t4 = Ref.get(e4.num, e4.gen);
          return i3.ensureCatalog("getPageIndex", [t4]);
        });
        l3.on("GetDestinations", function(e4) {
          return i3.ensureCatalog("destinations");
        });
        l3.on("GetDestination", function(e4) {
          return i3.ensureCatalog("getDestination", [e4.id]);
        });
        l3.on("GetPageLabels", function(e4) {
          return i3.ensureCatalog("pageLabels");
        });
        l3.on("GetPageLayout", function(e4) {
          return i3.ensureCatalog("pageLayout");
        });
        l3.on("GetPageMode", function(e4) {
          return i3.ensureCatalog("pageMode");
        });
        l3.on("GetViewerPreferences", function(e4) {
          return i3.ensureCatalog("viewerPreferences");
        });
        l3.on("GetOpenAction", function(e4) {
          return i3.ensureCatalog("openAction");
        });
        l3.on("GetAttachments", function(e4) {
          return i3.ensureCatalog("attachments");
        });
        l3.on("GetDocJSActions", function(e4) {
          return i3.ensureCatalog("jsActions");
        });
        l3.on("GetPageJSActions", function({ pageIndex: e4 }) {
          return i3.getPage(e4).then(function(e5) {
            return i3.ensure(e5, "jsActions");
          });
        });
        l3.on("GetOutline", function(e4) {
          return i3.ensureCatalog("documentOutline");
        });
        l3.on("GetOptionalContentConfig", function(e4) {
          return i3.ensureCatalog("optionalContentConfig");
        });
        l3.on("GetPermissions", function(e4) {
          return i3.ensureCatalog("permissions");
        });
        l3.on("GetMetadata", function(e4) {
          return Promise.all([i3.ensureDoc("documentInfo"), i3.ensureCatalog("metadata")]);
        });
        l3.on("GetMarkInfo", function(e4) {
          return i3.ensureCatalog("markInfo");
        });
        l3.on("GetData", function(e4) {
          return i3.requestLoadedStream().then(function(e5) {
            return e5.bytes;
          });
        });
        l3.on("GetAnnotations", function({ pageIndex: e4, intent: t4 }) {
          return i3.getPage(e4).then(function(i4) {
            const a4 = new WorkerTask(`GetAnnotations: page ${e4}`);
            startWorkerTask(a4);
            return i4.getAnnotationsData(l3, a4, t4).then((e5) => {
              finishWorkerTask(a4);
              return e5;
            }, (e5) => {
              finishWorkerTask(a4);
              throw e5;
            });
          });
        });
        l3.on("GetFieldObjects", function(e4) {
          return i3.ensureDoc("fieldObjects");
        });
        l3.on("HasJSActions", function(e4) {
          return i3.ensureDoc("hasJSActions");
        });
        l3.on("GetCalculationOrderIds", function(e4) {
          return i3.ensureDoc("calculationOrderIds");
        });
        l3.on("SaveDocument", async function({ isPureXfa: e4, numPages: t4, annotationStorage: a4, filename: s4 }) {
          const r4 = [i3.requestLoadedStream(), i3.ensureCatalog("acroForm"), i3.ensureCatalog("acroFormRef"), i3.ensureDoc("startXRef"), i3.ensureDoc("xref"), i3.ensureDoc("linearization"), i3.ensureCatalog("structTreeRoot")], n4 = [], o4 = e4 ? null : getNewAnnotationsMap(a4), [g4, c4, C4, h3, Q3, E3, u3] = await Promise.all(r4), d3 = Q3.trailer.getRaw("Root") || null;
          let f2;
          if (o4) {
            u3 ? await u3.canUpdateStructTree({ pdfManager: i3, xref: Q3, newAnnotationsByPage: o4 }) && (f2 = u3) : await StructTreeRoot.canCreateStructureTree({ catalogRef: d3, pdfManager: i3, newAnnotationsByPage: o4 }) && (f2 = null);
            const e5 = AnnotationFactory.generateImages(a4.values(), Q3, i3.evaluatorOptions.isOffscreenCanvasSupported), t5 = void 0 === f2 ? n4 : [];
            for (const [a5, s5] of o4)
              t5.push(i3.getPage(a5).then((t6) => {
                const i4 = new WorkerTask(`Save (editor): page ${a5}`);
                return t6.saveNewAnnotations(l3, i4, s5, e5).finally(function() {
                  finishWorkerTask(i4);
                });
              }));
            null === f2 ? n4.push(Promise.all(t5).then(async (e6) => {
              await StructTreeRoot.createStructureTree({ newAnnotationsByPage: o4, xref: Q3, catalogRef: d3, pdfManager: i3, newRefs: e6 });
              return e6;
            })) : f2 && n4.push(Promise.all(t5).then(async (e6) => {
              await f2.updateStructureTree({ newAnnotationsByPage: o4, pdfManager: i3, newRefs: e6 });
              return e6;
            }));
          }
          if (e4)
            n4.push(i3.serializeXfaData(a4));
          else
            for (let e5 = 0; e5 < t4; e5++)
              n4.push(i3.getPage(e5).then(function(t5) {
                const i4 = new WorkerTask(`Save: page ${e5}`);
                return t5.save(l3, i4, a4).finally(function() {
                  finishWorkerTask(i4);
                });
              }));
          const p2 = await Promise.all(n4);
          let m3 = [], y3 = null;
          if (e4) {
            y3 = p2[0];
            if (!y3)
              return g4.bytes;
          } else {
            m3 = p2.flat(2);
            if (0 === m3.length)
              return g4.bytes;
          }
          const w3 = C4 && c4 instanceof Dict && m3.some((e5) => e5.needAppearances), b3 = c4 instanceof Dict && c4.get("XFA") || null;
          let D3 = null, F3 = false;
          if (Array.isArray(b3)) {
            for (let e5 = 0, t5 = b3.length; e5 < t5; e5 += 2)
              if ("datasets" === b3[e5]) {
                D3 = b3[e5 + 1];
                F3 = true;
              }
            null === D3 && (D3 = Q3.getNewTemporaryRef());
          } else
            b3 && warn("Unsupported XFA type.");
          let S3 = /* @__PURE__ */ Object.create(null);
          if (Q3.trailer) {
            const e5 = /* @__PURE__ */ Object.create(null), t5 = Q3.trailer.get("Info") || null;
            t5 instanceof Dict && t5.forEach((t6, i4) => {
              "string" == typeof i4 && (e5[t6] = stringToPDFString(i4));
            });
            S3 = { rootRef: d3, encryptRef: Q3.trailer.getRaw("Encrypt") || null, newRef: Q3.getNewTemporaryRef(), infoRef: Q3.trailer.getRaw("Info") || null, info: e5, fileIds: Q3.trailer.get("ID") || null, startXRef: E3 ? h3 : Q3.lastXRefStreamPos ?? h3, filename: s4 };
          }
          return incrementalUpdate({ originalData: g4.bytes, xrefInfo: S3, newRefs: m3, xref: Q3, hasXfa: !!b3, xfaDatasetsRef: D3, hasXfaDatasetsEntry: F3, needAppearances: w3, acroFormRef: C4, acroForm: c4, xfaData: y3, useXrefStream: isDict(Q3.topDict, "XRef") }).finally(() => {
            Q3.resetNewTemporaryRef();
          });
        });
        l3.on("GetOperatorList", function(e4, t4) {
          const a4 = e4.pageIndex;
          i3.getPage(a4).then(function(i4) {
            const s4 = new WorkerTask(`GetOperatorList: page ${a4}`);
            startWorkerTask(s4);
            const r4 = n3 >= pA.INFOS ? Date.now() : 0;
            i4.getOperatorList({ handler: l3, sink: t4, task: s4, intent: e4.intent, cacheKey: e4.cacheKey, annotationStorage: e4.annotationStorage }).then(function(e5) {
              finishWorkerTask(s4);
              r4 && info(`page=${a4 + 1} - getOperatorList: time=${Date.now() - r4}ms, len=${e5.length}`);
              t4.close();
            }, function(e5) {
              finishWorkerTask(s4);
              s4.terminated || t4.error(e5);
            });
          });
        });
        l3.on("GetTextContent", function(e4, t4) {
          const { pageIndex: a4, includeMarkedContent: s4, disableNormalization: r4 } = e4;
          i3.getPage(a4).then(function(e5) {
            const i4 = new WorkerTask("GetTextContent: page " + a4);
            startWorkerTask(i4);
            const o4 = n3 >= pA.INFOS ? Date.now() : 0;
            e5.extractTextContent({ handler: l3, task: i4, sink: t4, includeMarkedContent: s4, disableNormalization: r4 }).then(function() {
              finishWorkerTask(i4);
              o4 && info(`page=${a4 + 1} - getTextContent: time=` + (Date.now() - o4) + "ms");
              t4.close();
            }, function(e6) {
              finishWorkerTask(i4);
              i4.terminated || t4.error(e6);
            });
          });
        });
        l3.on("GetStructTree", function(e4) {
          return i3.getPage(e4.pageIndex).then(function(e5) {
            return i3.ensure(e5, "getStructTree");
          });
        });
        l3.on("FontFallback", function(e4) {
          return i3.fontFallback(e4.id, l3);
        });
        l3.on("Cleanup", function(e4) {
          return i3.cleanup(true);
        });
        l3.on("Terminate", function(e4) {
          a3 = true;
          const t4 = [];
          if (i3) {
            i3.terminate(new AbortException("Worker was terminated."));
            const e5 = i3.cleanup();
            t4.push(e5);
            i3 = null;
          } else
            clearGlobalCaches();
          s3 && s3(new AbortException("Worker was terminated."));
          for (const e5 of r3) {
            t4.push(e5.finished);
            e5.terminate();
          }
          return Promise.all(t4).then(function() {
            l3.destroy();
            l3 = null;
          });
        });
        l3.on("Ready", function(t4) {
          !function setupDoc(e4) {
            function onSuccess(e5) {
              ensureNotTerminated();
              l3.send("GetDoc", { pdfInfo: e5 });
            }
            function onFailure(e5) {
              ensureNotTerminated();
              if (e5 instanceof PasswordException) {
                const t5 = new WorkerTask(`PasswordException: response ${e5.code}`);
                startWorkerTask(t5);
                l3.sendWithPromise("PasswordRequest", e5).then(function({ password: e6 }) {
                  finishWorkerTask(t5);
                  i3.updatePassword(e6);
                  pdfManagerReady();
                }).catch(function() {
                  finishWorkerTask(t5);
                  l3.send("DocException", e5);
                });
              } else
                e5 instanceof InvalidPDFException || e5 instanceof MissingPDFException || e5 instanceof UnexpectedResponseException || e5 instanceof UnknownErrorException ? l3.send("DocException", e5) : l3.send("DocException", new UnknownErrorException(e5.message, e5.toString()));
            }
            function pdfManagerReady() {
              ensureNotTerminated();
              loadDocument(false).then(onSuccess, function(e5) {
                ensureNotTerminated();
                e5 instanceof XRefParseException ? i3.requestLoadedStream().then(function() {
                  ensureNotTerminated();
                  loadDocument(true).then(onSuccess, onFailure);
                }) : onFailure(e5);
              });
            }
            ensureNotTerminated();
            getPdfManager(e4).then(function(e5) {
              if (a3) {
                e5.terminate(new AbortException("Worker was terminated."));
                throw new Error("Worker was terminated");
              }
              i3 = e5;
              i3.requestLoadedStream(true).then((e6) => {
                l3.send("DataLoaded", { length: e6.bytes.byteLength });
              });
            }).then(pdfManagerReady, onFailure);
          }(e3);
          e3 = null;
        });
        return h2;
      }
      static initializeFromPort(e3) {
        const t3 = new MessageHandler("worker", "main", e3);
        _WorkerMessageHandler.setup(t3, e3);
        t3.send("ready", null);
      }
    };
    "undefined" == typeof window && !t2 && "undefined" != typeof self && function isMessagePort(e3) {
      return "function" == typeof e3.postMessage && "onmessage" in e3;
    }(self) && WorkerMessageHandler.initializeFromPort(self);
    fo = __webpack_exports__2.WorkerMessageHandler;
  }
});

// browser-external:canvas
var require_canvas = __commonJS({
  "browser-external:canvas"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "canvas" has been externalized for browser compatibility. Cannot access "canvas.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js
var require_pdf = __commonJS({
  "node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = root.pdfjsLib = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], () => {
          return root.pdfjsLib = factory();
        });
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module2, exports2) => {
              var _settled;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.RenderingIntentFlag = exports2.PromiseCapability = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.MAX_IMAGE_SIZE_TO_CACHE = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.BASELINE_FACTOR = exports2.AnnotationType = exports2.AnnotationReplyType = exports2.AnnotationPrefix = exports2.AnnotationMode = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.assert = assert2;
              exports2.bytesToString = bytesToString2;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl2;
              exports2.getModificationDate = getModificationDate2;
              exports2.getUuid = getUuid;
              exports2.getVerbosityLevel = getVerbosityLevel2;
              exports2.info = info2;
              exports2.isArrayBuffer = isArrayBuffer;
              exports2.isArrayEqual = isArrayEqual2;
              exports2.isNodeJS = void 0;
              exports2.normalizeUnicode = normalizeUnicode;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize2;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow2;
              exports2.string32 = string322;
              exports2.stringToBytes = stringToBytes2;
              exports2.stringToPDFString = stringToPDFString2;
              exports2.stringToUTF8String = stringToUTF8String2;
              exports2.unreachable = unreachable2;
              exports2.utf8StringToString = utf8StringToString2;
              exports2.warn = warn2;
              const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
              const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              const MAX_IMAGE_SIZE_TO_CACHE = 1e7;
              exports2.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;
              const LINE_FACTOR = 1.35;
              exports2.LINE_FACTOR = LINE_FACTOR;
              const LINE_DESCENT_FACTOR = 0.35;
              exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
              const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
              exports2.BASELINE_FACTOR = BASELINE_FACTOR;
              const RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                SAVE: 8,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              const AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              const AnnotationEditorPrefix = "pdfjs_internal_editor_";
              exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
              const AnnotationEditorType = {
                DISABLE: -1,
                NONE: 0,
                FREETEXT: 3,
                STAMP: 13,
                INK: 15
              };
              exports2.AnnotationEditorType = AnnotationEditorType;
              const AnnotationEditorParamsType = {
                RESIZE: 1,
                CREATE: 2,
                FREETEXT_SIZE: 11,
                FREETEXT_COLOR: 12,
                FREETEXT_OPACITY: 13,
                INK_COLOR: 21,
                INK_THICKNESS: 22,
                INK_OPACITY: 23
              };
              exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
              const PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              const TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              const ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              const AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              const AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              const AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              const AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              const AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              const AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              const DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              const PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              const VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              const CMapCompressionType = {
                NONE: 0,
                BINARY: 1
              };
              exports2.CMapCompressionType = CMapCompressionType;
              const OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              const PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              let verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              function getVerbosityLevel2() {
                return verbosity;
              }
              function info2(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log(`Info: ${msg}`);
                }
              }
              function warn2(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log(`Warning: ${msg}`);
                }
              }
              function unreachable2(msg) {
                throw new Error(msg);
              }
              function assert2(cond, msg) {
                if (!cond) {
                  unreachable2(msg);
                }
              }
              function _isValidProtocol(url) {
                switch (url == null ? void 0 : url.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              function createValidAbsoluteUrl2(url, baseUrl = null, options = null) {
                if (!url) {
                  return null;
                }
                try {
                  if (options && typeof url === "string") {
                    if (options.addDefaultProtocol && url.startsWith("www.")) {
                      const dots = url.match(/\./g);
                      if ((dots == null ? void 0 : dots.length) >= 2) {
                        url = `http://${url}`;
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url = stringToUTF8String2(url);
                      } catch {
                      }
                    }
                  }
                  const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch {
                }
                return null;
              }
              function shadow2(obj, prop, value, nonSerializable = false) {
                Object.defineProperty(obj, prop, {
                  value,
                  enumerable: !nonSerializable,
                  configurable: true,
                  writable: false
                });
                return value;
              }
              const BaseException = function BaseExceptionClosure2() {
                function BaseException2(message, name) {
                  if (this.constructor === BaseException2) {
                    unreachable2("Cannot initialize BaseException.");
                  }
                  this.message = message;
                  this.name = name;
                }
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }();
              exports2.BaseException = BaseException;
              class PasswordException2 extends BaseException {
                constructor(msg, code) {
                  super(msg, "PasswordException");
                  this.code = code;
                }
              }
              exports2.PasswordException = PasswordException2;
              class UnknownErrorException2 extends BaseException {
                constructor(msg, details) {
                  super(msg, "UnknownErrorException");
                  this.details = details;
                }
              }
              exports2.UnknownErrorException = UnknownErrorException2;
              class InvalidPDFException2 extends BaseException {
                constructor(msg) {
                  super(msg, "InvalidPDFException");
                }
              }
              exports2.InvalidPDFException = InvalidPDFException2;
              class MissingPDFException2 extends BaseException {
                constructor(msg) {
                  super(msg, "MissingPDFException");
                }
              }
              exports2.MissingPDFException = MissingPDFException2;
              class UnexpectedResponseException2 extends BaseException {
                constructor(msg, status) {
                  super(msg, "UnexpectedResponseException");
                  this.status = status;
                }
              }
              exports2.UnexpectedResponseException = UnexpectedResponseException2;
              class FormatError2 extends BaseException {
                constructor(msg) {
                  super(msg, "FormatError");
                }
              }
              exports2.FormatError = FormatError2;
              class AbortException2 extends BaseException {
                constructor(msg) {
                  super(msg, "AbortException");
                }
              }
              exports2.AbortException = AbortException2;
              function bytesToString2(bytes) {
                if (typeof bytes !== "object" || (bytes == null ? void 0 : bytes.length) === void 0) {
                  unreachable2("Invalid argument for bytesToString");
                }
                const length = bytes.length;
                const MAX_ARGUMENT_COUNT = 8192;
                if (length < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                const strBuf = [];
                for (let i3 = 0; i3 < length; i3 += MAX_ARGUMENT_COUNT) {
                  const chunkEnd = Math.min(i3 + MAX_ARGUMENT_COUNT, length);
                  const chunk = bytes.subarray(i3, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              function stringToBytes2(str) {
                if (typeof str !== "string") {
                  unreachable2("Invalid argument for stringToBytes");
                }
                const length = str.length;
                const bytes = new Uint8Array(length);
                for (let i3 = 0; i3 < length; ++i3) {
                  bytes[i3] = str.charCodeAt(i3) & 255;
                }
                return bytes;
              }
              function string322(value) {
                return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
              }
              function objectSize2(obj) {
                return Object.keys(obj).length;
              }
              function objectFromMap(map) {
                const obj = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of map) {
                  obj[key] = value;
                }
                return obj;
              }
              function isLittleEndian() {
                const buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch {
                  return false;
                }
              }
              class FeatureTest2 {
                static get isLittleEndian() {
                  return shadow2(this, "isLittleEndian", isLittleEndian());
                }
                static get isEvalSupported() {
                  return shadow2(this, "isEvalSupported", isEvalSupported());
                }
                static get isOffscreenCanvasSupported() {
                  return shadow2(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                }
                static get platform() {
                  if (typeof navigator === "undefined") {
                    return shadow2(this, "platform", {
                      isWin: false,
                      isMac: false
                    });
                  }
                  return shadow2(this, "platform", {
                    isWin: navigator.platform.includes("Win"),
                    isMac: navigator.platform.includes("Mac")
                  });
                }
                static get isCSSRoundSupported() {
                  var _a3, _b2;
                  return shadow2(this, "isCSSRoundSupported", (_b2 = (_a3 = globalThis.CSS) == null ? void 0 : _a3.supports) == null ? void 0 : _b2.call(_a3, "width: round(1.5px, 1px)"));
                }
              }
              exports2.FeatureTest = FeatureTest2;
              const hexNumbers = [...Array(256).keys()].map((n3) => n3.toString(16).padStart(2, "0"));
              class Util2 {
                static makeHexColor(r3, g3, b3) {
                  return `#${hexNumbers[r3]}${hexNumbers[g3]}${hexNumbers[b3]}`;
                }
                static scaleMinMax(transform, minMax) {
                  let temp;
                  if (transform[0]) {
                    if (transform[0] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[0];
                    minMax[1] *= transform[0];
                    if (transform[3] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[3];
                    minMax[3] *= transform[3];
                  } else {
                    temp = minMax[0];
                    minMax[0] = minMax[2];
                    minMax[2] = temp;
                    temp = minMax[1];
                    minMax[1] = minMax[3];
                    minMax[3] = temp;
                    if (transform[1] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[1];
                    minMax[3] *= transform[1];
                    if (transform[2] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[2];
                    minMax[1] *= transform[2];
                  }
                  minMax[0] += transform[4];
                  minMax[1] += transform[4];
                  minMax[2] += transform[5];
                  minMax[3] += transform[5];
                }
                static transform(m1, m22) {
                  return [m1[0] * m22[0] + m1[2] * m22[1], m1[1] * m22[0] + m1[3] * m22[1], m1[0] * m22[2] + m1[2] * m22[3], m1[1] * m22[2] + m1[3] * m22[3], m1[0] * m22[4] + m1[2] * m22[5] + m1[4], m1[1] * m22[4] + m1[3] * m22[5] + m1[5]];
                }
                static applyTransform(p2, m3) {
                  const xt2 = p2[0] * m3[0] + p2[1] * m3[2] + m3[4];
                  const yt2 = p2[0] * m3[1] + p2[1] * m3[3] + m3[5];
                  return [xt2, yt2];
                }
                static applyInverseTransform(p2, m3) {
                  const d3 = m3[0] * m3[3] - m3[1] * m3[2];
                  const xt2 = (p2[0] * m3[3] - p2[1] * m3[2] + m3[2] * m3[5] - m3[4] * m3[3]) / d3;
                  const yt2 = (-p2[0] * m3[1] + p2[1] * m3[0] + m3[4] * m3[1] - m3[5] * m3[0]) / d3;
                  return [xt2, yt2];
                }
                static getAxialAlignedBoundingBox(r3, m3) {
                  const p1 = this.applyTransform(r3, m3);
                  const p2 = this.applyTransform(r3.slice(2, 4), m3);
                  const p3 = this.applyTransform([r3[0], r3[3]], m3);
                  const p4 = this.applyTransform([r3[2], r3[1]], m3);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
                static inverseTransform(m3) {
                  const d3 = m3[0] * m3[3] - m3[1] * m3[2];
                  return [m3[3] / d3, -m3[1] / d3, -m3[2] / d3, m3[0] / d3, (m3[2] * m3[5] - m3[4] * m3[3]) / d3, (m3[4] * m3[1] - m3[5] * m3[0]) / d3];
                }
                static singularValueDecompose2dScale(m3) {
                  const transpose = [m3[0], m3[2], m3[1], m3[3]];
                  const a3 = m3[0] * transpose[0] + m3[1] * transpose[2];
                  const b3 = m3[0] * transpose[1] + m3[1] * transpose[3];
                  const c3 = m3[2] * transpose[0] + m3[3] * transpose[2];
                  const d3 = m3[2] * transpose[1] + m3[3] * transpose[3];
                  const first = (a3 + d3) / 2;
                  const second = Math.sqrt((a3 + d3) ** 2 - 4 * (a3 * d3 - c3 * b3)) / 2;
                  const sx = first + second || 1;
                  const sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
                static normalizeRect(rect) {
                  const r3 = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r3[0] = rect[2];
                    r3[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r3[1] = rect[3];
                    r3[3] = rect[1];
                  }
                  return r3;
                }
                static intersect(rect1, rect2) {
                  const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                  const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                  if (xLow > xHigh) {
                    return null;
                  }
                  const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                  const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                  if (yLow > yHigh) {
                    return null;
                  }
                  return [xLow, yLow, xHigh, yHigh];
                }
                static bezierBoundingBox(x0, y0, x1, y1, x22, y22, x3, y3) {
                  const tvalues = [], bounds = [[], []];
                  let a3, b3, c3, t3, t1, t22, b2ac, sqrtb2ac;
                  for (let i3 = 0; i3 < 2; ++i3) {
                    if (i3 === 0) {
                      b3 = 6 * x0 - 12 * x1 + 6 * x22;
                      a3 = -3 * x0 + 9 * x1 - 9 * x22 + 3 * x3;
                      c3 = 3 * x1 - 3 * x0;
                    } else {
                      b3 = 6 * y0 - 12 * y1 + 6 * y22;
                      a3 = -3 * y0 + 9 * y1 - 9 * y22 + 3 * y3;
                      c3 = 3 * y1 - 3 * y0;
                    }
                    if (Math.abs(a3) < 1e-12) {
                      if (Math.abs(b3) < 1e-12) {
                        continue;
                      }
                      t3 = -c3 / b3;
                      if (0 < t3 && t3 < 1) {
                        tvalues.push(t3);
                      }
                      continue;
                    }
                    b2ac = b3 * b3 - 4 * c3 * a3;
                    sqrtb2ac = Math.sqrt(b2ac);
                    if (b2ac < 0) {
                      continue;
                    }
                    t1 = (-b3 + sqrtb2ac) / (2 * a3);
                    if (0 < t1 && t1 < 1) {
                      tvalues.push(t1);
                    }
                    t22 = (-b3 - sqrtb2ac) / (2 * a3);
                    if (0 < t22 && t22 < 1) {
                      tvalues.push(t22);
                    }
                  }
                  let j3 = tvalues.length, mt2;
                  const jlen = j3;
                  while (j3--) {
                    t3 = tvalues[j3];
                    mt2 = 1 - t3;
                    bounds[0][j3] = mt2 * mt2 * mt2 * x0 + 3 * mt2 * mt2 * t3 * x1 + 3 * mt2 * t3 * t3 * x22 + t3 * t3 * t3 * x3;
                    bounds[1][j3] = mt2 * mt2 * mt2 * y0 + 3 * mt2 * mt2 * t3 * y1 + 3 * mt2 * t3 * t3 * y22 + t3 * t3 * t3 * y3;
                  }
                  bounds[0][jlen] = x0;
                  bounds[1][jlen] = y0;
                  bounds[0][jlen + 1] = x3;
                  bounds[1][jlen + 1] = y3;
                  bounds[0].length = bounds[1].length = jlen + 2;
                  return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                }
              }
              exports2.Util = Util2;
              const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString2(str) {
                if (str[0] >= "ï") {
                  let encoding;
                  if (str[0] === "þ" && str[1] === "ÿ") {
                    encoding = "utf-16be";
                  } else if (str[0] === "ÿ" && str[1] === "þ") {
                    encoding = "utf-16le";
                  } else if (str[0] === "ï" && str[1] === "»" && str[2] === "¿") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = stringToBytes2(str);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn2(`stringToPDFString: "${ex}".`);
                    }
                  }
                }
                const strBuf = [];
                for (let i3 = 0, ii2 = str.length; i3 < ii2; i3++) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i3)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i3));
                }
                return strBuf.join("");
              }
              function stringToUTF8String2(str) {
                return decodeURIComponent(escape(str));
              }
              function utf8StringToString2(str) {
                return unescape(encodeURIComponent(str));
              }
              function isArrayBuffer(v3) {
                return typeof v3 === "object" && (v3 == null ? void 0 : v3.byteLength) !== void 0;
              }
              function isArrayEqual2(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (let i3 = 0, ii2 = arr1.length; i3 < ii2; i3++) {
                  if (arr1[i3] !== arr2[i3]) {
                    return false;
                  }
                }
                return true;
              }
              function getModificationDate2(date = /* @__PURE__ */ new Date()) {
                const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              class PromiseCapability {
                constructor() {
                  __privateAdd(this, _settled, false);
                  this.promise = new Promise((resolve, reject) => {
                    this.resolve = (data) => {
                      __privateSet(this, _settled, true);
                      resolve(data);
                    };
                    this.reject = (reason) => {
                      __privateSet(this, _settled, true);
                      reject(reason);
                    };
                  });
                }
                get settled() {
                  return __privateGet(this, _settled);
                }
              }
              _settled = new WeakMap();
              exports2.PromiseCapability = PromiseCapability;
              let NormalizeRegex = null;
              let NormalizationMap = null;
              function normalizeUnicode(str) {
                if (!NormalizeRegex) {
                  NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
                  NormalizationMap = /* @__PURE__ */ new Map([["ﬅ", "ſt"]]);
                }
                return str.replaceAll(NormalizeRegex, (_3, p1, p2) => {
                  return p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
                });
              }
              function getUuid() {
                if (typeof crypto !== "undefined" && typeof (crypto == null ? void 0 : crypto.randomUUID) === "function") {
                  return crypto.randomUUID();
                }
                const buf = new Uint8Array(32);
                if (typeof crypto !== "undefined" && typeof (crypto == null ? void 0 : crypto.getRandomValues) === "function") {
                  crypto.getRandomValues(buf);
                } else {
                  for (let i3 = 0; i3 < 32; i3++) {
                    buf[i3] = Math.floor(Math.random() * 255);
                  }
                }
                return bytesToString2(buf);
              }
              const AnnotationPrefix = "pdfjs_internal_id_";
              exports2.AnnotationPrefix = AnnotationPrefix;
            },
            /* 2 */
            /***/
            (__unused_webpack_module, exports, __w_pdfjs_require__) => {
              var _docId, _delayedCleanupTimeout, _pendingCleanup, _tryCleanup, tryCleanup_fn, _abortDelayedCleanup, abortDelayedCleanup_fn, _listeners, _deferred, _a3, _workerPorts, _methodPromises, _pageCache, _pagePromises, _passwordCapability, _cacheSimpleMethod, cacheSimpleMethod_fn, _objs, _ensureObj, ensureObj_fn, _internalRenderTask, _canvasInUse;
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
              Object.defineProperty(exports, "SVGGraphics", {
                enumerable: true,
                get: function() {
                  return _displaySvg.SVGGraphics;
                }
              });
              exports.build = void 0;
              exports.getDocument = getDocument;
              exports.version = void 0;
              var _util = __w_pdfjs_require__(1);
              var _annotation_storage = __w_pdfjs_require__(3);
              var _display_utils = __w_pdfjs_require__(6);
              var _font_loader = __w_pdfjs_require__(9);
              var _displayNode_utils = __w_pdfjs_require__(10);
              var _canvas = __w_pdfjs_require__(11);
              var _worker_options = __w_pdfjs_require__(14);
              var _message_handler = __w_pdfjs_require__(15);
              var _metadata = __w_pdfjs_require__(16);
              var _optional_content_config = __w_pdfjs_require__(17);
              var _transport_stream = __w_pdfjs_require__(18);
              var _displayFetch_stream = __w_pdfjs_require__(19);
              var _displayNetwork = __w_pdfjs_require__(22);
              var _displayNode_stream = __w_pdfjs_require__(23);
              var _displaySvg = __w_pdfjs_require__(24);
              var _xfa_text = __w_pdfjs_require__(25);
              const DEFAULT_RANGE_CHUNK_SIZE = 65536;
              const RENDERING_CANCELLED_TIMEOUT = 100;
              const DELAYED_CLEANUP_TIMEOUT = 5e3;
              const DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
              exports.DefaultCanvasFactory = DefaultCanvasFactory;
              const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
              exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
              const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
              exports.DefaultFilterFactory = DefaultFilterFactory;
              const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
              exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
              function getDocument(src) {
                if (typeof src === "string" || src instanceof URL) {
                  src = {
                    url: src
                  };
                } else if ((0, _util.isArrayBuffer)(src)) {
                  src = {
                    data: src
                  };
                }
                if (typeof src !== "object") {
                  throw new Error("Invalid parameter in getDocument, need parameter object.");
                }
                if (!src.url && !src.data && !src.range) {
                  throw new Error("Invalid parameter object: need either .data, .range or .url");
                }
                const task = new PDFDocumentLoadingTask();
                const {
                  docId
                } = task;
                const url = src.url ? getUrlProp(src.url) : null;
                const data = src.data ? getDataProp(src.data) : null;
                const httpHeaders = src.httpHeaders || null;
                const withCredentials = src.withCredentials === true;
                const password = src.password ?? null;
                const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
                const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
                let worker2 = src.worker instanceof PDFWorker ? src.worker : null;
                const verbosity = src.verbosity;
                const docBaseUrl = typeof src.docBaseUrl === "string" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;
                const cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
                const cMapPacked = src.cMapPacked !== false;
                const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
                const standardFontDataUrl = typeof src.standardFontDataUrl === "string" ? src.standardFontDataUrl : null;
                const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;
                const ignoreErrors = src.stopAtErrors !== true;
                const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
                const isEvalSupported = src.isEvalSupported !== false;
                const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !_util.isNodeJS;
                const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
                const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : _util.isNodeJS;
                const fontExtraProperties = src.fontExtraProperties === true;
                const enableXfa = src.enableXfa === true;
                const ownerDocument = src.ownerDocument || globalThis.document;
                const disableRange = src.disableRange === true;
                const disableStream = src.disableStream === true;
                const disableAutoFetch = src.disableAutoFetch === true;
                const pdfBug = src.pdfBug === true;
                const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
                const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !_util.isNodeJS && !disableFontFace;
                const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);
                const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({
                  ownerDocument
                });
                const filterFactory = src.filterFactory || new DefaultFilterFactory({
                  docId,
                  ownerDocument
                });
                const styleElement = null;
                (0, _util.setVerbosityLevel)(verbosity);
                const transportFactory = {
                  canvasFactory,
                  filterFactory
                };
                if (!useWorkerFetch) {
                  transportFactory.cMapReaderFactory = new CMapReaderFactory({
                    baseUrl: cMapUrl,
                    isCompressed: cMapPacked
                  });
                  transportFactory.standardFontDataFactory = new StandardFontDataFactory({
                    baseUrl: standardFontDataUrl
                  });
                }
                if (!worker2) {
                  const workerParams = {
                    verbosity,
                    port: _worker_options.GlobalWorkerOptions.workerPort
                  };
                  worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                  task._worker = worker2;
                }
                const fetchDocParams = {
                  docId,
                  apiVersion: "3.11.174",
                  data,
                  password,
                  disableAutoFetch,
                  rangeChunkSize,
                  length,
                  docBaseUrl,
                  enableXfa,
                  evaluatorOptions: {
                    maxImageSize,
                    disableFontFace,
                    ignoreErrors,
                    isEvalSupported,
                    isOffscreenCanvasSupported,
                    canvasMaxAreaInBytes,
                    fontExtraProperties,
                    useSystemFonts,
                    cMapUrl: useWorkerFetch ? cMapUrl : null,
                    standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null
                  }
                };
                const transportParams = {
                  ignoreErrors,
                  isEvalSupported,
                  disableFontFace,
                  fontExtraProperties,
                  enableXfa,
                  ownerDocument,
                  disableAutoFetch,
                  pdfBug,
                  styleElement
                };
                worker2.promise.then(function() {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  const workerIdPromise = _fetchDocument(worker2, fetchDocParams);
                  const networkStreamPromise = new Promise(function(resolve) {
                    let networkStream;
                    if (rangeTransport) {
                      networkStream = new _transport_stream.PDFDataTransportStream({
                        length,
                        initialData: rangeTransport.initialData,
                        progressiveDone: rangeTransport.progressiveDone,
                        contentDispositionFilename: rangeTransport.contentDispositionFilename,
                        disableRange,
                        disableStream
                      }, rangeTransport);
                    } else if (!data) {
                      const createPDFNetworkStream = (params) => {
                        if (_util.isNodeJS) {
                          return new _displayNode_stream.PDFNodeStream(params);
                        }
                        return (0, _display_utils.isValidFetchUrl)(params.url) ? new _displayFetch_stream.PDFFetchStream(params) : new _displayNetwork.PDFNetworkStream(params);
                      };
                      networkStream = createPDFNetworkStream({
                        url,
                        length,
                        httpHeaders,
                        withCredentials,
                        rangeChunkSize,
                        disableRange,
                        disableStream
                      });
                    }
                    resolve(networkStream);
                  });
                  return Promise.all([workerIdPromise, networkStreamPromise]).then(function([workerId, networkStream]) {
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                    const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);
                    task._transport = transport;
                    messageHandler.send("Ready", null);
                  });
                }).catch(task._capability.reject);
                return task;
              }
              async function _fetchDocument(worker2, source) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                const workerId = await worker2.messageHandler.sendWithPromise("GetDocRequest", source, source.data ? [source.data.buffer] : null);
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              }
              function getUrlProp(val) {
                if (val instanceof URL) {
                  return val.href;
                }
                try {
                  return new URL(val, window.location).href;
                } catch {
                  if (_util.isNodeJS && typeof val === "string") {
                    return val;
                  }
                }
                throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
              }
              function getDataProp(val) {
                if (_util.isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
                  throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
                }
                if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
                  return val;
                }
                if (typeof val === "string") {
                  return (0, _util.stringToBytes)(val);
                }
                if (typeof val === "object" && !isNaN(val == null ? void 0 : val.length) || (0, _util.isArrayBuffer)(val)) {
                  return new Uint8Array(val);
                }
                throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
              }
              const _PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
                constructor() {
                  this._capability = new _util.PromiseCapability();
                  this._transport = null;
                  this._worker = null;
                  this.docId = `d${__privateWrapper(_PDFDocumentLoadingTask, _docId)._++}`;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                async destroy() {
                  var _a4, _b2, _c2;
                  this.destroyed = true;
                  try {
                    if ((_a4 = this._worker) == null ? void 0 : _a4.port) {
                      this._worker._pendingDestroy = true;
                    }
                    await ((_b2 = this._transport) == null ? void 0 : _b2.destroy());
                  } catch (ex) {
                    if ((_c2 = this._worker) == null ? void 0 : _c2.port) {
                      delete this._worker._pendingDestroy;
                    }
                    throw ex;
                  }
                  this._transport = null;
                  if (this._worker) {
                    this._worker.destroy();
                    this._worker = null;
                  }
                }
              };
              _docId = new WeakMap();
              __privateAdd(_PDFDocumentLoadingTask, _docId, 0);
              let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
              exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
              class PDFDataRangeTransport {
                constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
                  this.length = length;
                  this.initialData = initialData;
                  this.progressiveDone = progressiveDone;
                  this.contentDispositionFilename = contentDispositionFilename;
                  this._rangeListeners = [];
                  this._progressListeners = [];
                  this._progressiveReadListeners = [];
                  this._progressiveDoneListeners = [];
                  this._readyCapability = new _util.PromiseCapability();
                }
                addRangeListener(listener) {
                  this._rangeListeners.push(listener);
                }
                addProgressListener(listener) {
                  this._progressListeners.push(listener);
                }
                addProgressiveReadListener(listener) {
                  this._progressiveReadListeners.push(listener);
                }
                addProgressiveDoneListener(listener) {
                  this._progressiveDoneListeners.push(listener);
                }
                onDataRange(begin, chunk) {
                  for (const listener of this._rangeListeners) {
                    listener(begin, chunk);
                  }
                }
                onDataProgress(loaded, total) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressListeners) {
                      listener(loaded, total);
                    }
                  });
                }
                onDataProgressiveRead(chunk) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveReadListeners) {
                      listener(chunk);
                    }
                  });
                }
                onDataProgressiveDone() {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveDoneListeners) {
                      listener();
                    }
                  });
                }
                transportReady() {
                  this._readyCapability.resolve();
                }
                requestDataRange(begin, end) {
                  (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                }
                abort() {
                }
              }
              exports.PDFDataRangeTransport = PDFDataRangeTransport;
              class PDFDocumentProxy {
                constructor(pdfInfo, transport) {
                  this._pdfInfo = pdfInfo;
                  this._transport = transport;
                  Object.defineProperty(this, "getJavaScript", {
                    value: () => {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead.");
                      return this.getJSActions().then((js2) => {
                        if (!js2) {
                          return js2;
                        }
                        const jsArr = [];
                        for (const name in js2) {
                          jsArr.push(...js2[name]);
                        }
                        return jsArr;
                      });
                    }
                  });
                }
                get annotationStorage() {
                  return this._transport.annotationStorage;
                }
                get filterFactory() {
                  return this._transport.filterFactory;
                }
                get numPages() {
                  return this._pdfInfo.numPages;
                }
                get fingerprints() {
                  return this._pdfInfo.fingerprints;
                }
                get isPureXfa() {
                  return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
                }
                get allXfaHtml() {
                  return this._transport._htmlForXfa;
                }
                getPage(pageNumber) {
                  return this._transport.getPage(pageNumber);
                }
                getPageIndex(ref) {
                  return this._transport.getPageIndex(ref);
                }
                getDestinations() {
                  return this._transport.getDestinations();
                }
                getDestination(id) {
                  return this._transport.getDestination(id);
                }
                getPageLabels() {
                  return this._transport.getPageLabels();
                }
                getPageLayout() {
                  return this._transport.getPageLayout();
                }
                getPageMode() {
                  return this._transport.getPageMode();
                }
                getViewerPreferences() {
                  return this._transport.getViewerPreferences();
                }
                getOpenAction() {
                  return this._transport.getOpenAction();
                }
                getAttachments() {
                  return this._transport.getAttachments();
                }
                getJSActions() {
                  return this._transport.getDocJSActions();
                }
                getOutline() {
                  return this._transport.getOutline();
                }
                getOptionalContentConfig() {
                  return this._transport.getOptionalContentConfig();
                }
                getPermissions() {
                  return this._transport.getPermissions();
                }
                getMetadata() {
                  return this._transport.getMetadata();
                }
                getMarkInfo() {
                  return this._transport.getMarkInfo();
                }
                getData() {
                  return this._transport.getData();
                }
                saveDocument() {
                  return this._transport.saveDocument();
                }
                getDownloadInfo() {
                  return this._transport.downloadInfoCapability.promise;
                }
                cleanup(keepLoadedFonts = false) {
                  return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                }
                destroy() {
                  return this.loadingTask.destroy();
                }
                get loadingParams() {
                  return this._transport.loadingParams;
                }
                get loadingTask() {
                  return this._transport.loadingTask;
                }
                getFieldObjects() {
                  return this._transport.getFieldObjects();
                }
                hasJSActions() {
                  return this._transport.hasJSActions();
                }
                getCalculationOrderIds() {
                  return this._transport.getCalculationOrderIds();
                }
              }
              exports.PDFDocumentProxy = PDFDocumentProxy;
              class PDFPageProxy {
                constructor(pageIndex, pageInfo, transport, pdfBug = false) {
                  __privateAdd(this, _tryCleanup);
                  __privateAdd(this, _abortDelayedCleanup);
                  __privateAdd(this, _delayedCleanupTimeout, null);
                  __privateAdd(this, _pendingCleanup, false);
                  this._pageIndex = pageIndex;
                  this._pageInfo = pageInfo;
                  this._transport = transport;
                  this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                  this._pdfBug = pdfBug;
                  this.commonObjs = transport.commonObjs;
                  this.objs = new PDFObjects();
                  this._maybeCleanupAfterRender = false;
                  this._intentStates = /* @__PURE__ */ new Map();
                  this.destroyed = false;
                }
                get pageNumber() {
                  return this._pageIndex + 1;
                }
                get rotate() {
                  return this._pageInfo.rotate;
                }
                get ref() {
                  return this._pageInfo.ref;
                }
                get userUnit() {
                  return this._pageInfo.userUnit;
                }
                get view() {
                  return this._pageInfo.view;
                }
                getViewport({
                  scale,
                  rotation = this.rotate,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                } = {}) {
                  return new _display_utils.PageViewport({
                    viewBox: this.view,
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                getAnnotations({
                  intent = "display"
                } = {}) {
                  const intentArgs = this._transport.getRenderingIntent(intent);
                  return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
                }
                getJSActions() {
                  return this._transport.getPageJSActions(this._pageIndex);
                }
                get filterFactory() {
                  return this._transport.filterFactory;
                }
                get isPureXfa() {
                  return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
                }
                async getXfa() {
                  var _a4;
                  return ((_a4 = this._transport._htmlForXfa) == null ? void 0 : _a4.children[this._pageIndex]) || null;
                }
                render({
                  canvasContext,
                  viewport,
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  transform = null,
                  background = null,
                  optionalContentConfigPromise = null,
                  annotationCanvasMap = null,
                  pageColors = null,
                  printAnnotationStorage = null
                }) {
                  var _a4, _b2;
                  (_a4 = this._stats) == null ? void 0 : _a4.time("Overall");
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
                  __privateSet(this, _pendingCleanup, false);
                  __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
                  if (!optionalContentConfigPromise) {
                    optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                  }
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                  if (!intentState.displayReadyCapability) {
                    intentState.displayReadyCapability = new _util.PromiseCapability();
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    (_b2 = this._stats) == null ? void 0 : _b2.time("Page Request");
                    this._pumpOperatorList(intentArgs);
                  }
                  const complete = (error) => {
                    var _a5, _b3;
                    intentState.renderTasks.delete(internalRenderTask);
                    if (this._maybeCleanupAfterRender || intentPrint) {
                      __privateSet(this, _pendingCleanup, true);
                    }
                    __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, !intentPrint);
                    if (error) {
                      internalRenderTask.capability.reject(error);
                      this._abortOperatorList({
                        intentState,
                        reason: error instanceof Error ? error : new Error(error)
                      });
                    } else {
                      internalRenderTask.capability.resolve();
                    }
                    (_a5 = this._stats) == null ? void 0 : _a5.timeEnd("Rendering");
                    (_b3 = this._stats) == null ? void 0 : _b3.timeEnd("Overall");
                  };
                  const internalRenderTask = new InternalRenderTask({
                    callback: complete,
                    params: {
                      canvasContext,
                      viewport,
                      transform,
                      background
                    },
                    objs: this.objs,
                    commonObjs: this.commonObjs,
                    annotationCanvasMap,
                    operatorList: intentState.operatorList,
                    pageIndex: this._pageIndex,
                    canvasFactory: this._transport.canvasFactory,
                    filterFactory: this._transport.filterFactory,
                    useRequestAnimationFrame: !intentPrint,
                    pdfBug: this._pdfBug,
                    pageColors
                  });
                  (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
                  const renderTask = internalRenderTask.task;
                  Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
                    var _a5;
                    if (this.destroyed) {
                      complete();
                      return;
                    }
                    (_a5 = this._stats) == null ? void 0 : _a5.time("Rendering");
                    internalRenderTask.initializeGraphics({
                      transparency,
                      optionalContentConfig
                    });
                    internalRenderTask.operatorListChanged();
                  }).catch(complete);
                  return renderTask;
                }
                getOperatorList({
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  printAnnotationStorage = null
                } = {}) {
                  var _a4;
                  function operatorListChanged() {
                    if (intentState.operatorList.lastChunk) {
                      intentState.opListReadCapability.resolve(intentState.operatorList);
                      intentState.renderTasks.delete(opListTask);
                    }
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  let opListTask;
                  if (!intentState.opListReadCapability) {
                    opListTask = /* @__PURE__ */ Object.create(null);
                    opListTask.operatorListChanged = operatorListChanged;
                    intentState.opListReadCapability = new _util.PromiseCapability();
                    (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    (_a4 = this._stats) == null ? void 0 : _a4.time("Page Request");
                    this._pumpOperatorList(intentArgs);
                  }
                  return intentState.opListReadCapability.promise;
                }
                streamTextContent({
                  includeMarkedContent = false,
                  disableNormalization = false
                } = {}) {
                  const TEXT_CONTENT_CHUNK_SIZE = 100;
                  return this._transport.messageHandler.sendWithStream("GetTextContent", {
                    pageIndex: this._pageIndex,
                    includeMarkedContent: includeMarkedContent === true,
                    disableNormalization: disableNormalization === true
                  }, {
                    highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                    size(textContent) {
                      return textContent.items.length;
                    }
                  });
                }
                getTextContent(params = {}) {
                  if (this._transport._htmlForXfa) {
                    return this.getXfa().then((xfa) => {
                      return _xfa_text.XfaText.textContent(xfa);
                    });
                  }
                  const readableStream = this.streamTextContent(params);
                  return new Promise(function(resolve, reject) {
                    function pump() {
                      reader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          resolve(textContent);
                          return;
                        }
                        Object.assign(textContent.styles, value.styles);
                        textContent.items.push(...value.items);
                        pump();
                      }, reject);
                    }
                    const reader = readableStream.getReader();
                    const textContent = {
                      items: [],
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    pump();
                  });
                }
                getStructTree() {
                  return this._transport.getStructTree(this._pageIndex);
                }
                _destroy() {
                  this.destroyed = true;
                  const waitOn = [];
                  for (const intentState of this._intentStates.values()) {
                    this._abortOperatorList({
                      intentState,
                      reason: new Error("Page was destroyed."),
                      force: true
                    });
                    if (intentState.opListReadCapability) {
                      continue;
                    }
                    for (const internalRenderTask of intentState.renderTasks) {
                      waitOn.push(internalRenderTask.completed);
                      internalRenderTask.cancel();
                    }
                  }
                  this.objs.clear();
                  __privateSet(this, _pendingCleanup, false);
                  __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
                  return Promise.all(waitOn);
                }
                cleanup(resetStats = false) {
                  __privateSet(this, _pendingCleanup, true);
                  const success = __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, false);
                  if (resetStats && success) {
                    this._stats && (this._stats = new _display_utils.StatTimer());
                  }
                  return success;
                }
                _startRenderPage(transparency, cacheKey) {
                  var _a4, _b2;
                  const intentState = this._intentStates.get(cacheKey);
                  if (!intentState) {
                    return;
                  }
                  (_a4 = this._stats) == null ? void 0 : _a4.timeEnd("Page Request");
                  (_b2 = intentState.displayReadyCapability) == null ? void 0 : _b2.resolve(transparency);
                }
                _renderPageChunk(operatorListChunk, intentState) {
                  for (let i3 = 0, ii2 = operatorListChunk.length; i3 < ii2; i3++) {
                    intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i3]);
                    intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i3]);
                  }
                  intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                  intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
                  for (const internalRenderTask of intentState.renderTasks) {
                    internalRenderTask.operatorListChanged();
                  }
                  if (operatorListChunk.lastChunk) {
                    __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, true);
                  }
                }
                _pumpOperatorList({
                  renderingIntent,
                  cacheKey,
                  annotationStorageSerializable
                }) {
                  const {
                    map,
                    transfers
                  } = annotationStorageSerializable;
                  const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    cacheKey,
                    annotationStorage: map
                  }, transfers);
                  const reader = readableStream.getReader();
                  const intentState = this._intentStates.get(cacheKey);
                  intentState.streamReader = reader;
                  const pump = () => {
                    reader.read().then(({
                      value,
                      done
                    }) => {
                      if (done) {
                        intentState.streamReader = null;
                        return;
                      }
                      if (this._transport.destroyed) {
                        return;
                      }
                      this._renderPageChunk(value, intentState);
                      pump();
                    }, (reason) => {
                      intentState.streamReader = null;
                      if (this._transport.destroyed) {
                        return;
                      }
                      if (intentState.operatorList) {
                        intentState.operatorList.lastChunk = true;
                        for (const internalRenderTask of intentState.renderTasks) {
                          internalRenderTask.operatorListChanged();
                        }
                        __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, true);
                      }
                      if (intentState.displayReadyCapability) {
                        intentState.displayReadyCapability.reject(reason);
                      } else if (intentState.opListReadCapability) {
                        intentState.opListReadCapability.reject(reason);
                      } else {
                        throw reason;
                      }
                    });
                  };
                  pump();
                }
                _abortOperatorList({
                  intentState,
                  reason,
                  force = false
                }) {
                  if (!intentState.streamReader) {
                    return;
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  if (!force) {
                    if (intentState.renderTasks.size > 0) {
                      return;
                    }
                    if (reason instanceof _display_utils.RenderingCancelledException) {
                      let delay = RENDERING_CANCELLED_TIMEOUT;
                      if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
                        delay += reason.extraDelay;
                      }
                      intentState.streamReaderCancelTimeout = setTimeout(() => {
                        intentState.streamReaderCancelTimeout = null;
                        this._abortOperatorList({
                          intentState,
                          reason,
                          force: true
                        });
                      }, delay);
                      return;
                    }
                  }
                  intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {
                  });
                  intentState.streamReader = null;
                  if (this._transport.destroyed) {
                    return;
                  }
                  for (const [curCacheKey, curIntentState] of this._intentStates) {
                    if (curIntentState === intentState) {
                      this._intentStates.delete(curCacheKey);
                      break;
                    }
                  }
                  this.cleanup();
                }
                get stats() {
                  return this._stats;
                }
              }
              _delayedCleanupTimeout = new WeakMap();
              _pendingCleanup = new WeakMap();
              _tryCleanup = new WeakSet();
              tryCleanup_fn = function(delayed = false) {
                __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
                if (!__privateGet(this, _pendingCleanup) || this.destroyed) {
                  return false;
                }
                if (delayed) {
                  __privateSet(this, _delayedCleanupTimeout, setTimeout(() => {
                    __privateSet(this, _delayedCleanupTimeout, null);
                    __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, false);
                  }, DELAYED_CLEANUP_TIMEOUT));
                  return false;
                }
                for (const {
                  renderTasks,
                  operatorList
                } of this._intentStates.values()) {
                  if (renderTasks.size > 0 || !operatorList.lastChunk) {
                    return false;
                  }
                }
                this._intentStates.clear();
                this.objs.clear();
                __privateSet(this, _pendingCleanup, false);
                return true;
              };
              _abortDelayedCleanup = new WeakSet();
              abortDelayedCleanup_fn = function() {
                if (__privateGet(this, _delayedCleanupTimeout)) {
                  clearTimeout(__privateGet(this, _delayedCleanupTimeout));
                  __privateSet(this, _delayedCleanupTimeout, null);
                }
              };
              exports.PDFPageProxy = PDFPageProxy;
              class LoopbackPort {
                constructor() {
                  __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
                  __privateAdd(this, _deferred, Promise.resolve());
                }
                postMessage(obj, transfer) {
                  const event = {
                    data: structuredClone(obj, transfer ? {
                      transfer
                    } : null)
                  };
                  __privateGet(this, _deferred).then(() => {
                    for (const listener of __privateGet(this, _listeners)) {
                      listener.call(this, event);
                    }
                  });
                }
                addEventListener(name, listener) {
                  __privateGet(this, _listeners).add(listener);
                }
                removeEventListener(name, listener) {
                  __privateGet(this, _listeners).delete(listener);
                }
                terminate() {
                  __privateGet(this, _listeners).clear();
                }
              }
              _listeners = new WeakMap();
              _deferred = new WeakMap();
              exports.LoopbackPort = LoopbackPort;
              const PDFWorkerUtil = {
                isWorkerDisabled: false,
                fallbackWorkerSrc: null,
                fakeWorkerId: 0
              };
              exports.PDFWorkerUtil = PDFWorkerUtil;
              {
                if (_util.isNodeJS && typeof __require === "function") {
                  PDFWorkerUtil.isWorkerDisabled = true;
                  PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                } else if (typeof document === "object") {
                  const pdfjsFilePath = (_a3 = document == null ? void 0 : document.currentScript) == null ? void 0 : _a3.src;
                  if (pdfjsFilePath) {
                    PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                  }
                }
                PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                  let base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch {
                    return false;
                  }
                  const other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                };
                PDFWorkerUtil.createCDNWrapper = function(url) {
                  const wrapper = `importScripts("${url}");`;
                  return URL.createObjectURL(new Blob([wrapper]));
                };
              }
              const _PDFWorker = class _PDFWorker {
                constructor({
                  name = null,
                  port = null,
                  verbosity = (0, _util.getVerbosityLevel)()
                } = {}) {
                  var _a4;
                  this.name = name;
                  this.destroyed = false;
                  this.verbosity = verbosity;
                  this._readyCapability = new _util.PromiseCapability();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    if ((_a4 = __privateGet(_PDFWorker, _workerPorts)) == null ? void 0 : _a4.has(port)) {
                      throw new Error("Cannot use more than one PDFWorker per port.");
                    }
                    (__privateGet(_PDFWorker, _workerPorts) || __privateSet(_PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap())).set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                  this._messageHandler.send("configure", {
                    verbosity: this.verbosity
                  });
                }
                _initialize() {
                  if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                    let {
                      workerSrc
                    } = _PDFWorker;
                    try {
                      if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                        workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array();
                        messageHandler.send("test", testObj, [testObj.buffer]);
                      };
                      sendTest();
                      return;
                    } catch {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!PDFWorkerUtil.isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    PDFWorkerUtil.isWorkerDisabled = true;
                  }
                  _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler2) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
                    const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler2.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  var _a4;
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  (_a4 = __privateGet(_PDFWorker, _workerPorts)) == null ? void 0 : _a4.delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  var _a4;
                  if (!(params == null ? void 0 : params.port)) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  const cachedPort = (_a4 = __privateGet(this, _workerPorts)) == null ? void 0 : _a4.get(params.port);
                  if (cachedPort) {
                    if (cachedPort._pendingDestroy) {
                      throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                    }
                    return cachedPort;
                  }
                  return new _PDFWorker(params);
                }
                static get workerSrc() {
                  if (_worker_options.GlobalWorkerOptions.workerSrc) {
                    return _worker_options.GlobalWorkerOptions.workerSrc;
                  }
                  if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                    if (!_util.isNodeJS) {
                      (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                    }
                    return PDFWorkerUtil.fallbackWorkerSrc;
                  }
                  throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                }
                static get _mainThreadWorkerMessageHandler() {
                  var _a4;
                  try {
                    return ((_a4 = globalThis.pdfjsWorker) == null ? void 0 : _a4.WorkerMessageHandler) || null;
                  } catch {
                    return null;
                  }
                }
                static get _setupFakeWorkerGlobal() {
                  const loader = async () => {
                    const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                    if (mainWorkerMessageHandler) {
                      return mainWorkerMessageHandler;
                    }
                    if (_util.isNodeJS && typeof __require === "function") {
                      const worker = eval("require")(this.workerSrc);
                      return worker.WorkerMessageHandler;
                    }
                    await (0, _display_utils.loadScript)(this.workerSrc);
                    return window.pdfjsWorker.WorkerMessageHandler;
                  };
                  return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                }
              };
              _workerPorts = new WeakMap();
              __privateAdd(_PDFWorker, _workerPorts, void 0);
              let PDFWorker = _PDFWorker;
              exports.PDFWorker = PDFWorker;
              class WorkerTransport {
                constructor(messageHandler, loadingTask, networkStream, params, factory) {
                  __privateAdd(this, _cacheSimpleMethod);
                  __privateAdd(this, _methodPromises, /* @__PURE__ */ new Map());
                  __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
                  __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
                  __privateAdd(this, _passwordCapability, null);
                  this.messageHandler = messageHandler;
                  this.loadingTask = loadingTask;
                  this.commonObjs = new PDFObjects();
                  this.fontLoader = new _font_loader.FontLoader({
                    ownerDocument: params.ownerDocument,
                    styleElement: params.styleElement
                  });
                  this._params = params;
                  this.canvasFactory = factory.canvasFactory;
                  this.filterFactory = factory.filterFactory;
                  this.cMapReaderFactory = factory.cMapReaderFactory;
                  this.standardFontDataFactory = factory.standardFontDataFactory;
                  this.destroyed = false;
                  this.destroyCapability = null;
                  this._networkStream = networkStream;
                  this._fullReader = null;
                  this._lastProgress = null;
                  this.downloadInfoCapability = new _util.PromiseCapability();
                  this.setupMessageHandler();
                }
                get annotationStorage() {
                  return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                }
                getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
                  let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                  let annotationStorageSerializable = _annotation_storage.SerializableEmpty;
                  switch (intent) {
                    case "any":
                      renderingIntent = _util.RenderingIntentFlag.ANY;
                      break;
                    case "display":
                      break;
                    case "print":
                      renderingIntent = _util.RenderingIntentFlag.PRINT;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
                  }
                  switch (annotationMode) {
                    case _util.AnnotationMode.DISABLE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                      break;
                    case _util.AnnotationMode.ENABLE:
                      break;
                    case _util.AnnotationMode.ENABLE_FORMS:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                      break;
                    case _util.AnnotationMode.ENABLE_STORAGE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                      const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
                      annotationStorageSerializable = annotationStorage.serializable;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
                  }
                  if (isOpList) {
                    renderingIntent += _util.RenderingIntentFlag.OPLIST;
                  }
                  return {
                    renderingIntent,
                    cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,
                    annotationStorageSerializable
                  };
                }
                destroy() {
                  var _a4;
                  if (this.destroyCapability) {
                    return this.destroyCapability.promise;
                  }
                  this.destroyed = true;
                  this.destroyCapability = new _util.PromiseCapability();
                  (_a4 = __privateGet(this, _passwordCapability)) == null ? void 0 : _a4.reject(new Error("Worker was destroyed during onPassword callback"));
                  const waitOn = [];
                  for (const page of __privateGet(this, _pageCache).values()) {
                    waitOn.push(page._destroy());
                  }
                  __privateGet(this, _pageCache).clear();
                  __privateGet(this, _pagePromises).clear();
                  if (this.hasOwnProperty("annotationStorage")) {
                    this.annotationStorage.resetModified();
                  }
                  const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                  waitOn.push(terminated);
                  Promise.all(waitOn).then(() => {
                    var _a5;
                    this.commonObjs.clear();
                    this.fontLoader.clear();
                    __privateGet(this, _methodPromises).clear();
                    this.filterFactory.destroy();
                    (_a5 = this._networkStream) == null ? void 0 : _a5.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                    if (this.messageHandler) {
                      this.messageHandler.destroy();
                      this.messageHandler = null;
                    }
                    this.destroyCapability.resolve();
                  }, this.destroyCapability.reject);
                  return this.destroyCapability.promise;
                }
                setupMessageHandler() {
                  const {
                    messageHandler,
                    loadingTask
                  } = this;
                  messageHandler.on("GetReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                    this._fullReader = this._networkStream.getFullReader();
                    this._fullReader.onProgress = (evt) => {
                      this._lastProgress = {
                        loaded: evt.loaded,
                        total: evt.total
                      };
                    };
                    sink.onPull = () => {
                      this._fullReader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      this._fullReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("ReaderHeadersReady", (data) => {
                    const headersCapability = new _util.PromiseCapability();
                    const fullReader = this._fullReader;
                    fullReader.headersReady.then(() => {
                      var _a4;
                      if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                        if (this._lastProgress) {
                          (_a4 = loadingTask.onProgress) == null ? void 0 : _a4.call(loadingTask, this._lastProgress);
                        }
                        fullReader.onProgress = (evt) => {
                          var _a5;
                          (_a5 = loadingTask.onProgress) == null ? void 0 : _a5.call(loadingTask, {
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        };
                      }
                      headersCapability.resolve({
                        isStreamingSupported: fullReader.isStreamingSupported,
                        isRangeSupported: fullReader.isRangeSupported,
                        contentLength: fullReader.contentLength
                      });
                    }, headersCapability.reject);
                    return headersCapability.promise;
                  });
                  messageHandler.on("GetRangeReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                    const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                    if (!rangeReader) {
                      sink.close();
                      return;
                    }
                    sink.onPull = () => {
                      rangeReader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      rangeReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("GetDoc", ({
                    pdfInfo
                  }) => {
                    this._numPages = pdfInfo.numPages;
                    this._htmlForXfa = pdfInfo.htmlForXfa;
                    delete pdfInfo.htmlForXfa;
                    loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                  });
                  messageHandler.on("DocException", function(ex) {
                    let reason;
                    switch (ex.name) {
                      case "PasswordException":
                        reason = new _util.PasswordException(ex.message, ex.code);
                        break;
                      case "InvalidPDFException":
                        reason = new _util.InvalidPDFException(ex.message);
                        break;
                      case "MissingPDFException":
                        reason = new _util.MissingPDFException(ex.message);
                        break;
                      case "UnexpectedResponseException":
                        reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                        break;
                      case "UnknownErrorException":
                        reason = new _util.UnknownErrorException(ex.message, ex.details);
                        break;
                      default:
                        (0, _util.unreachable)("DocException - expected a valid Error.");
                    }
                    loadingTask._capability.reject(reason);
                  });
                  messageHandler.on("PasswordRequest", (exception) => {
                    __privateSet(this, _passwordCapability, new _util.PromiseCapability());
                    if (loadingTask.onPassword) {
                      const updatePassword = (password) => {
                        if (password instanceof Error) {
                          __privateGet(this, _passwordCapability).reject(password);
                        } else {
                          __privateGet(this, _passwordCapability).resolve({
                            password
                          });
                        }
                      };
                      try {
                        loadingTask.onPassword(updatePassword, exception.code);
                      } catch (ex) {
                        __privateGet(this, _passwordCapability).reject(ex);
                      }
                    } else {
                      __privateGet(this, _passwordCapability).reject(new _util.PasswordException(exception.message, exception.code));
                    }
                    return __privateGet(this, _passwordCapability).promise;
                  });
                  messageHandler.on("DataLoaded", (data) => {
                    var _a4;
                    (_a4 = loadingTask.onProgress) == null ? void 0 : _a4.call(loadingTask, {
                      loaded: data.length,
                      total: data.length
                    });
                    this.downloadInfoCapability.resolve(data);
                  });
                  messageHandler.on("StartRenderPage", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    const page = __privateGet(this, _pageCache).get(data.pageIndex);
                    page._startRenderPage(data.transparency, data.cacheKey);
                  });
                  messageHandler.on("commonobj", ([id, type, exportedData]) => {
                    var _a4;
                    if (this.destroyed) {
                      return;
                    }
                    if (this.commonObjs.has(id)) {
                      return;
                    }
                    switch (type) {
                      case "Font":
                        const params = this._params;
                        if ("error" in exportedData) {
                          const exportedError = exportedData.error;
                          (0, _util.warn)(`Error during font loading: ${exportedError}`);
                          this.commonObjs.resolve(id, exportedError);
                          break;
                        }
                        const inspectFont = params.pdfBug && ((_a4 = globalThis.FontInspector) == null ? void 0 : _a4.enabled) ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
                        const font = new _font_loader.FontFaceObject(exportedData, {
                          isEvalSupported: params.isEvalSupported,
                          disableFontFace: params.disableFontFace,
                          ignoreErrors: params.ignoreErrors,
                          inspectFont
                        });
                        this.fontLoader.bind(font).catch((reason) => {
                          return messageHandler.sendWithPromise("FontFallback", {
                            id
                          });
                        }).finally(() => {
                          if (!params.fontExtraProperties && font.data) {
                            font.data = null;
                          }
                          this.commonObjs.resolve(id, font);
                        });
                        break;
                      case "FontPath":
                      case "Image":
                      case "Pattern":
                        this.commonObjs.resolve(id, exportedData);
                        break;
                      default:
                        throw new Error(`Got unknown common object type ${type}`);
                    }
                  });
                  messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
                    var _a4;
                    if (this.destroyed) {
                      return;
                    }
                    const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
                    if (pageProxy.objs.has(id)) {
                      return;
                    }
                    switch (type) {
                      case "Image":
                        pageProxy.objs.resolve(id, imageData);
                        if (imageData) {
                          let length;
                          if (imageData.bitmap) {
                            const {
                              width,
                              height
                            } = imageData;
                            length = width * height * 4;
                          } else {
                            length = ((_a4 = imageData.data) == null ? void 0 : _a4.length) || 0;
                          }
                          if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {
                            pageProxy._maybeCleanupAfterRender = true;
                          }
                        }
                        break;
                      case "Pattern":
                        pageProxy.objs.resolve(id, imageData);
                        break;
                      default:
                        throw new Error(`Got unknown object type ${type}`);
                    }
                  });
                  messageHandler.on("DocProgress", (data) => {
                    var _a4;
                    if (this.destroyed) {
                      return;
                    }
                    (_a4 = loadingTask.onProgress) == null ? void 0 : _a4.call(loadingTask, {
                      loaded: data.loaded,
                      total: data.total
                    });
                  });
                  messageHandler.on("FetchBuiltInCMap", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.cMapReaderFactory) {
                      return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.cMapReaderFactory.fetch(data);
                  });
                  messageHandler.on("FetchStandardFontData", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.standardFontDataFactory) {
                      return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.standardFontDataFactory.fetch(data);
                  });
                }
                getData() {
                  return this.messageHandler.sendWithPromise("GetData", null);
                }
                saveDocument() {
                  var _a4;
                  if (this.annotationStorage.size <= 0) {
                    (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                  }
                  const {
                    map,
                    transfers
                  } = this.annotationStorage.serializable;
                  return this.messageHandler.sendWithPromise("SaveDocument", {
                    isPureXfa: !!this._htmlForXfa,
                    numPages: this._numPages,
                    annotationStorage: map,
                    filename: ((_a4 = this._fullReader) == null ? void 0 : _a4.filename) ?? null
                  }, transfers).finally(() => {
                    this.annotationStorage.resetModified();
                  });
                }
                getPage(pageNumber) {
                  if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                    return Promise.reject(new Error("Invalid page request."));
                  }
                  const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const promise = this.messageHandler.sendWithPromise("GetPage", {
                    pageIndex
                  }).then((pageInfo) => {
                    if (this.destroyed) {
                      throw new Error("Transport destroyed");
                    }
                    const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
                    __privateGet(this, _pageCache).set(pageIndex, page);
                    return page;
                  });
                  __privateGet(this, _pagePromises).set(pageIndex, promise);
                  return promise;
                }
                getPageIndex(ref) {
                  if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                    return Promise.reject(new Error("Invalid pageIndex request."));
                  }
                  return this.messageHandler.sendWithPromise("GetPageIndex", {
                    num: ref.num,
                    gen: ref.gen
                  });
                }
                getAnnotations(pageIndex, intent) {
                  return this.messageHandler.sendWithPromise("GetAnnotations", {
                    pageIndex,
                    intent
                  });
                }
                getFieldObjects() {
                  return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetFieldObjects");
                }
                hasJSActions() {
                  return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "HasJSActions");
                }
                getCalculationOrderIds() {
                  return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                }
                getDestinations() {
                  return this.messageHandler.sendWithPromise("GetDestinations", null);
                }
                getDestination(id) {
                  if (typeof id !== "string") {
                    return Promise.reject(new Error("Invalid destination request."));
                  }
                  return this.messageHandler.sendWithPromise("GetDestination", {
                    id
                  });
                }
                getPageLabels() {
                  return this.messageHandler.sendWithPromise("GetPageLabels", null);
                }
                getPageLayout() {
                  return this.messageHandler.sendWithPromise("GetPageLayout", null);
                }
                getPageMode() {
                  return this.messageHandler.sendWithPromise("GetPageMode", null);
                }
                getViewerPreferences() {
                  return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                }
                getOpenAction() {
                  return this.messageHandler.sendWithPromise("GetOpenAction", null);
                }
                getAttachments() {
                  return this.messageHandler.sendWithPromise("GetAttachments", null);
                }
                getDocJSActions() {
                  return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetDocJSActions");
                }
                getPageJSActions(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetPageJSActions", {
                    pageIndex
                  });
                }
                getStructTree(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetStructTree", {
                    pageIndex
                  });
                }
                getOutline() {
                  return this.messageHandler.sendWithPromise("GetOutline", null);
                }
                getOptionalContentConfig() {
                  return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                    return new _optional_content_config.OptionalContentConfig(results);
                  });
                }
                getPermissions() {
                  return this.messageHandler.sendWithPromise("GetPermissions", null);
                }
                getMetadata() {
                  const name = "GetMetadata", cachedPromise = __privateGet(this, _methodPromises).get(name);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const promise = this.messageHandler.sendWithPromise(name, null).then((results) => {
                    var _a4, _b2;
                    return {
                      info: results[0],
                      metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                      contentDispositionFilename: ((_a4 = this._fullReader) == null ? void 0 : _a4.filename) ?? null,
                      contentLength: ((_b2 = this._fullReader) == null ? void 0 : _b2.contentLength) ?? null
                    };
                  });
                  __privateGet(this, _methodPromises).set(name, promise);
                  return promise;
                }
                getMarkInfo() {
                  return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                }
                async startCleanup(keepLoadedFonts = false) {
                  if (this.destroyed) {
                    return;
                  }
                  await this.messageHandler.sendWithPromise("Cleanup", null);
                  for (const page of __privateGet(this, _pageCache).values()) {
                    const cleanupSuccessful = page.cleanup();
                    if (!cleanupSuccessful) {
                      throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
                    }
                  }
                  this.commonObjs.clear();
                  if (!keepLoadedFonts) {
                    this.fontLoader.clear();
                  }
                  __privateGet(this, _methodPromises).clear();
                  this.filterFactory.destroy(true);
                }
                get loadingParams() {
                  const {
                    disableAutoFetch,
                    enableXfa
                  } = this._params;
                  return (0, _util.shadow)(this, "loadingParams", {
                    disableAutoFetch,
                    enableXfa
                  });
                }
              }
              _methodPromises = new WeakMap();
              _pageCache = new WeakMap();
              _pagePromises = new WeakMap();
              _passwordCapability = new WeakMap();
              _cacheSimpleMethod = new WeakSet();
              cacheSimpleMethod_fn = function(name, data = null) {
                const cachedPromise = __privateGet(this, _methodPromises).get(name);
                if (cachedPromise) {
                  return cachedPromise;
                }
                const promise = this.messageHandler.sendWithPromise(name, data);
                __privateGet(this, _methodPromises).set(name, promise);
                return promise;
              };
              class PDFObjects {
                constructor() {
                  __privateAdd(this, _ensureObj);
                  __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
                }
                get(objId, callback = null) {
                  if (callback) {
                    const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                    obj2.capability.promise.then(() => callback(obj2.data));
                    return null;
                  }
                  const obj = __privateGet(this, _objs)[objId];
                  if (!(obj == null ? void 0 : obj.capability.settled)) {
                    throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                  }
                  return obj.data;
                }
                has(objId) {
                  const obj = __privateGet(this, _objs)[objId];
                  return (obj == null ? void 0 : obj.capability.settled) || false;
                }
                resolve(objId, data = null) {
                  const obj = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                  obj.data = data;
                  obj.capability.resolve();
                }
                clear() {
                  var _a4;
                  for (const objId in __privateGet(this, _objs)) {
                    const {
                      data
                    } = __privateGet(this, _objs)[objId];
                    (_a4 = data == null ? void 0 : data.bitmap) == null ? void 0 : _a4.close();
                  }
                  __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
                }
              }
              _objs = new WeakMap();
              _ensureObj = new WeakSet();
              ensureObj_fn = function(objId) {
                var _a4;
                return (_a4 = __privateGet(this, _objs))[objId] || (_a4[objId] = {
                  capability: new _util.PromiseCapability(),
                  data: null
                });
              };
              class RenderTask {
                constructor(internalRenderTask) {
                  __privateAdd(this, _internalRenderTask, null);
                  __privateSet(this, _internalRenderTask, internalRenderTask);
                  this.onContinue = null;
                }
                get promise() {
                  return __privateGet(this, _internalRenderTask).capability.promise;
                }
                cancel(extraDelay = 0) {
                  __privateGet(this, _internalRenderTask).cancel(null, extraDelay);
                }
                get separateAnnots() {
                  const {
                    separateAnnots
                  } = __privateGet(this, _internalRenderTask).operatorList;
                  if (!separateAnnots) {
                    return false;
                  }
                  const {
                    annotationCanvasMap
                  } = __privateGet(this, _internalRenderTask);
                  return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap == null ? void 0 : annotationCanvasMap.size) > 0;
                }
              }
              _internalRenderTask = new WeakMap();
              exports.RenderTask = RenderTask;
              const _InternalRenderTask = class _InternalRenderTask {
                constructor({
                  callback,
                  params,
                  objs,
                  commonObjs,
                  annotationCanvasMap,
                  operatorList,
                  pageIndex,
                  canvasFactory,
                  filterFactory,
                  useRequestAnimationFrame = false,
                  pdfBug = false,
                  pageColors = null
                }) {
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this.filterFactory = filterFactory;
                  this._pdfBug = pdfBug;
                  this.pageColors = pageColors;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = new _util.PromiseCapability();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                get completed() {
                  return this.capability.promise.catch(function() {
                  });
                }
                initializeGraphics({
                  transparency = false,
                  optionalContentConfig
                }) {
                  var _a4, _b2;
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
                  }
                  if (this._pdfBug && ((_a4 = globalThis.StepperManager) == null ? void 0 : _a4.enabled)) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                    optionalContentConfig
                  }, this.annotationCanvasMap, this.pageColors);
                  this.gfx.beginDrawing({
                    transform,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  (_b2 = this.graphicsReadyCallback) == null ? void 0 : _b2.call(this);
                }
                cancel(error = null, extraDelay = 0) {
                  var _a4;
                  this.running = false;
                  this.cancelled = true;
                  (_a4 = this.gfx) == null ? void 0 : _a4.endDrawing();
                  __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
                }
                operatorListChanged() {
                  var _a4;
                  if (!this.graphicsReady) {
                    this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                    return;
                  }
                  (_a4 = this.stepper) == null ? void 0 : _a4.updateOperatorList(this.operatorList);
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this._cancelBound);
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                  }
                }
                async _next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();
                      __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                      this.callback();
                    }
                  }
                }
              };
              _canvasInUse = new WeakMap();
              __privateAdd(_InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
              let InternalRenderTask = _InternalRenderTask;
              const version = "3.11.174";
              exports.version = version;
              const build = "ce8716743";
              exports.build = build;
            },
            /* 3 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _modified, _storage, _setModified, setModified_fn, _serializable;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SerializableEmpty = exports2.PrintAnnotationStorage = exports2.AnnotationStorage = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(4);
              var _murmurhash = __w_pdfjs_require__2(8);
              const SerializableEmpty = Object.freeze({
                map: null,
                hash: "",
                transfers: void 0
              });
              exports2.SerializableEmpty = SerializableEmpty;
              class AnnotationStorage {
                constructor() {
                  __privateAdd(this, _setModified);
                  __privateAdd(this, _modified, false);
                  __privateAdd(this, _storage, /* @__PURE__ */ new Map());
                  this.onSetModified = null;
                  this.onResetModified = null;
                  this.onAnnotationEditor = null;
                }
                getValue(key, defaultValue) {
                  const value = __privateGet(this, _storage).get(key);
                  if (value === void 0) {
                    return defaultValue;
                  }
                  return Object.assign(defaultValue, value);
                }
                getRawValue(key) {
                  return __privateGet(this, _storage).get(key);
                }
                remove(key) {
                  __privateGet(this, _storage).delete(key);
                  if (__privateGet(this, _storage).size === 0) {
                    this.resetModified();
                  }
                  if (typeof this.onAnnotationEditor === "function") {
                    for (const value of __privateGet(this, _storage).values()) {
                      if (value instanceof _editor.AnnotationEditor) {
                        return;
                      }
                    }
                    this.onAnnotationEditor(null);
                  }
                }
                setValue(key, value) {
                  const obj = __privateGet(this, _storage).get(key);
                  let modified = false;
                  if (obj !== void 0) {
                    for (const [entry, val] of Object.entries(value)) {
                      if (obj[entry] !== val) {
                        modified = true;
                        obj[entry] = val;
                      }
                    }
                  } else {
                    modified = true;
                    __privateGet(this, _storage).set(key, value);
                  }
                  if (modified) {
                    __privateMethod(this, _setModified, setModified_fn).call(this);
                  }
                  if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
                    this.onAnnotationEditor(value.constructor._type);
                  }
                }
                has(key) {
                  return __privateGet(this, _storage).has(key);
                }
                getAll() {
                  return __privateGet(this, _storage).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _storage)) : null;
                }
                setAll(obj) {
                  for (const [key, val] of Object.entries(obj)) {
                    this.setValue(key, val);
                  }
                }
                get size() {
                  return __privateGet(this, _storage).size;
                }
                resetModified() {
                  if (__privateGet(this, _modified)) {
                    __privateSet(this, _modified, false);
                    if (typeof this.onResetModified === "function") {
                      this.onResetModified();
                    }
                  }
                }
                get print() {
                  return new PrintAnnotationStorage(this);
                }
                get serializable() {
                  if (__privateGet(this, _storage).size === 0) {
                    return SerializableEmpty;
                  }
                  const map = /* @__PURE__ */ new Map(), hash = new _murmurhash.MurmurHash3_64(), transfers = [];
                  const context = /* @__PURE__ */ Object.create(null);
                  let hasBitmap = false;
                  for (const [key, val] of __privateGet(this, _storage)) {
                    const serialized = val instanceof _editor.AnnotationEditor ? val.serialize(false, context) : val;
                    if (serialized) {
                      map.set(key, serialized);
                      hash.update(`${key}:${JSON.stringify(serialized)}`);
                      hasBitmap || (hasBitmap = !!serialized.bitmap);
                    }
                  }
                  if (hasBitmap) {
                    for (const value of map.values()) {
                      if (value.bitmap) {
                        transfers.push(value.bitmap);
                      }
                    }
                  }
                  return map.size > 0 ? {
                    map,
                    hash: hash.hexdigest(),
                    transfers
                  } : SerializableEmpty;
                }
              }
              _modified = new WeakMap();
              _storage = new WeakMap();
              _setModified = new WeakSet();
              setModified_fn = function() {
                if (!__privateGet(this, _modified)) {
                  __privateSet(this, _modified, true);
                  if (typeof this.onSetModified === "function") {
                    this.onSetModified();
                  }
                }
              };
              exports2.AnnotationStorage = AnnotationStorage;
              class PrintAnnotationStorage extends AnnotationStorage {
                constructor(parent) {
                  super();
                  __privateAdd(this, _serializable, void 0);
                  const {
                    map,
                    hash,
                    transfers
                  } = parent.serializable;
                  const clone = structuredClone(map, transfers ? {
                    transfer: transfers
                  } : null);
                  __privateSet(this, _serializable, {
                    map: clone,
                    hash,
                    transfers
                  });
                }
                get print() {
                  (0, _util2.unreachable)("Should not call PrintAnnotationStorage.print");
                }
                get serializable() {
                  return __privateGet(this, _serializable);
                }
              }
              _serializable = new WeakMap();
              exports2.PrintAnnotationStorage = PrintAnnotationStorage;
            },
            /* 4 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _altText, _altTextDecorative, _altTextButton, _altTextTooltip, _altTextTooltipTimeout, _keepAspectRatio, _resizersDiv, _boundFocusin, _boundFocusout, _hasBeenClicked, _isEditing, _isInEditMode, _isDraggable, _zIndex, _translate, translate_fn, _getBaseTranslation, getBaseTranslation_fn, _rotatePoint, rotatePoint_fn, _getRotationMatrix, getRotationMatrix_fn, _createResizers, createResizers_fn, _resizerPointerdown, resizerPointerdown_fn, _resizerPointermove, resizerPointermove_fn, _setAltTextButtonState, setAltTextButtonState_fn, _setUpDragSession, setUpDragSession_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditor = void 0;
              var _tools = __w_pdfjs_require__2(5);
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              const _AnnotationEditor = class _AnnotationEditor {
                constructor(parameters) {
                  __privateAdd(this, _translate);
                  __privateAdd(this, _getBaseTranslation);
                  __privateAdd(this, _getRotationMatrix);
                  __privateAdd(this, _createResizers);
                  __privateAdd(this, _resizerPointerdown);
                  __privateAdd(this, _resizerPointermove);
                  __privateAdd(this, _setAltTextButtonState);
                  __privateAdd(this, _setUpDragSession);
                  __privateAdd(this, _altText, "");
                  __privateAdd(this, _altTextDecorative, false);
                  __privateAdd(this, _altTextButton, null);
                  __privateAdd(this, _altTextTooltip, null);
                  __privateAdd(this, _altTextTooltipTimeout, null);
                  __privateAdd(this, _keepAspectRatio, false);
                  __privateAdd(this, _resizersDiv, null);
                  __privateAdd(this, _boundFocusin, this.focusin.bind(this));
                  __privateAdd(this, _boundFocusout, this.focusout.bind(this));
                  __privateAdd(this, _hasBeenClicked, false);
                  __privateAdd(this, _isEditing, false);
                  __privateAdd(this, _isInEditMode, false);
                  __publicField(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
                  __publicField(this, "_uiManager", null);
                  __publicField(this, "_focusEventsAllowed", true);
                  __publicField(this, "_l10nPromise", null);
                  __privateAdd(this, _isDraggable, false);
                  __privateAdd(this, _zIndex, _AnnotationEditor._zIndex++);
                  if (this.constructor === _AnnotationEditor) {
                    (0, _util2.unreachable)("Cannot initialize AnnotationEditor.");
                  }
                  this.parent = parameters.parent;
                  this.id = parameters.id;
                  this.width = this.height = null;
                  this.pageIndex = parameters.parent.pageIndex;
                  this.name = parameters.name;
                  this.div = null;
                  this._uiManager = parameters.uiManager;
                  this.annotationElementId = null;
                  this._willKeepAspectRatio = false;
                  this._initialOptions.isCentered = parameters.isCentered;
                  this._structTreeParentId = null;
                  const {
                    rotation,
                    rawDims: {
                      pageWidth,
                      pageHeight,
                      pageX,
                      pageY
                    }
                  } = this.parent.viewport;
                  this.rotation = rotation;
                  this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
                  this.pageDimensions = [pageWidth, pageHeight];
                  this.pageTranslation = [pageX, pageY];
                  const [width, height] = this.parentDimensions;
                  this.x = parameters.x / width;
                  this.y = parameters.y / height;
                  this.isAttachedToDOM = false;
                  this.deleted = false;
                }
                get editorType() {
                  return Object.getPrototypeOf(this).constructor._type;
                }
                static get _defaultLineColor() {
                  return (0, _util2.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
                }
                static deleteAnnotationElement(editor) {
                  const fakeEditor = new FakeEditor({
                    id: editor.parent.getNextId(),
                    parent: editor.parent,
                    uiManager: editor._uiManager
                  });
                  fakeEditor.annotationElementId = editor.annotationElementId;
                  fakeEditor.deleted = true;
                  fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
                }
                static initialize(l10n, options = null) {
                  _AnnotationEditor._l10nPromise || (_AnnotationEditor._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((str) => [str, l10n.get(str)])));
                  if (options == null ? void 0 : options.strings) {
                    for (const str of options.strings) {
                      _AnnotationEditor._l10nPromise.set(str, l10n.get(str));
                    }
                  }
                  if (_AnnotationEditor._borderLineWidth !== -1) {
                    return;
                  }
                  const style = getComputedStyle(document.documentElement);
                  _AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
                }
                static updateDefaultParams(_type, _value) {
                }
                static get defaultPropertiesToUpdate() {
                  return [];
                }
                static isHandlingMimeForPasting(mime) {
                  return false;
                }
                static paste(item, parent) {
                  (0, _util2.unreachable)("Not implemented");
                }
                get propertiesToUpdate() {
                  return [];
                }
                get _isDraggable() {
                  return __privateGet(this, _isDraggable);
                }
                set _isDraggable(value) {
                  var _a3;
                  __privateSet(this, _isDraggable, value);
                  (_a3 = this.div) == null ? void 0 : _a3.classList.toggle("draggable", value);
                }
                center() {
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  switch (this.parentRotation) {
                    case 90:
                      this.x -= this.height * pageHeight / (pageWidth * 2);
                      this.y += this.width * pageWidth / (pageHeight * 2);
                      break;
                    case 180:
                      this.x += this.width / 2;
                      this.y += this.height / 2;
                      break;
                    case 270:
                      this.x += this.height * pageHeight / (pageWidth * 2);
                      this.y -= this.width * pageWidth / (pageHeight * 2);
                      break;
                    default:
                      this.x -= this.width / 2;
                      this.y -= this.height / 2;
                      break;
                  }
                  this.fixAndSetPosition();
                }
                addCommands(params) {
                  this._uiManager.addCommands(params);
                }
                get currentLayer() {
                  return this._uiManager.currentLayer;
                }
                setInBackground() {
                  this.div.style.zIndex = 0;
                }
                setInForeground() {
                  this.div.style.zIndex = __privateGet(this, _zIndex);
                }
                setParent(parent) {
                  if (parent !== null) {
                    this.pageIndex = parent.pageIndex;
                    this.pageDimensions = parent.pageDimensions;
                  }
                  this.parent = parent;
                }
                focusin(event) {
                  if (!this._focusEventsAllowed) {
                    return;
                  }
                  if (!__privateGet(this, _hasBeenClicked)) {
                    this.parent.setSelected(this);
                  } else {
                    __privateSet(this, _hasBeenClicked, false);
                  }
                }
                focusout(event) {
                  var _a3;
                  if (!this._focusEventsAllowed) {
                    return;
                  }
                  if (!this.isAttachedToDOM) {
                    return;
                  }
                  const target = event.relatedTarget;
                  if (target == null ? void 0 : target.closest(`#${this.id}`)) {
                    return;
                  }
                  event.preventDefault();
                  if (!((_a3 = this.parent) == null ? void 0 : _a3.isMultipleSelection)) {
                    this.commitOrRemove();
                  }
                }
                commitOrRemove() {
                  if (this.isEmpty()) {
                    this.remove();
                  } else {
                    this.commit();
                  }
                }
                commit() {
                  this.addToAnnotationStorage();
                }
                addToAnnotationStorage() {
                  this._uiManager.addToAnnotationStorage(this);
                }
                setAt(x3, y3, tx, ty) {
                  const [width, height] = this.parentDimensions;
                  [tx, ty] = this.screenToPageTranslation(tx, ty);
                  this.x = (x3 + tx) / width;
                  this.y = (y3 + ty) / height;
                  this.fixAndSetPosition();
                }
                translate(x3, y3) {
                  __privateMethod(this, _translate, translate_fn).call(this, this.parentDimensions, x3, y3);
                }
                translateInPage(x3, y3) {
                  __privateMethod(this, _translate, translate_fn).call(this, this.pageDimensions, x3, y3);
                  this.div.scrollIntoView({
                    block: "nearest"
                  });
                }
                drag(tx, ty) {
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  this.x += tx / parentWidth;
                  this.y += ty / parentHeight;
                  if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                    const {
                      x: x4,
                      y: y4
                    } = this.div.getBoundingClientRect();
                    if (this.parent.findNewParent(this, x4, y4)) {
                      this.x -= Math.floor(this.x);
                      this.y -= Math.floor(this.y);
                    }
                  }
                  let {
                    x: x3,
                    y: y3
                  } = this;
                  const [bx, by] = __privateMethod(this, _getBaseTranslation, getBaseTranslation_fn).call(this);
                  x3 += bx;
                  y3 += by;
                  this.div.style.left = `${(100 * x3).toFixed(2)}%`;
                  this.div.style.top = `${(100 * y3).toFixed(2)}%`;
                  this.div.scrollIntoView({
                    block: "nearest"
                  });
                }
                fixAndSetPosition() {
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  let {
                    x: x3,
                    y: y3,
                    width,
                    height
                  } = this;
                  width *= pageWidth;
                  height *= pageHeight;
                  x3 *= pageWidth;
                  y3 *= pageHeight;
                  switch (this.rotation) {
                    case 0:
                      x3 = Math.max(0, Math.min(pageWidth - width, x3));
                      y3 = Math.max(0, Math.min(pageHeight - height, y3));
                      break;
                    case 90:
                      x3 = Math.max(0, Math.min(pageWidth - height, x3));
                      y3 = Math.min(pageHeight, Math.max(width, y3));
                      break;
                    case 180:
                      x3 = Math.min(pageWidth, Math.max(width, x3));
                      y3 = Math.min(pageHeight, Math.max(height, y3));
                      break;
                    case 270:
                      x3 = Math.min(pageWidth, Math.max(height, x3));
                      y3 = Math.max(0, Math.min(pageHeight - width, y3));
                      break;
                  }
                  this.x = x3 /= pageWidth;
                  this.y = y3 /= pageHeight;
                  const [bx, by] = __privateMethod(this, _getBaseTranslation, getBaseTranslation_fn).call(this);
                  x3 += bx;
                  y3 += by;
                  const {
                    style
                  } = this.div;
                  style.left = `${(100 * x3).toFixed(2)}%`;
                  style.top = `${(100 * y3).toFixed(2)}%`;
                  this.moveInDOM();
                }
                screenToPageTranslation(x3, y3) {
                  var _a3;
                  return __privateMethod(_a3 = _AnnotationEditor, _rotatePoint, rotatePoint_fn).call(_a3, x3, y3, this.parentRotation);
                }
                pageTranslationToScreen(x3, y3) {
                  var _a3;
                  return __privateMethod(_a3 = _AnnotationEditor, _rotatePoint, rotatePoint_fn).call(_a3, x3, y3, 360 - this.parentRotation);
                }
                get parentScale() {
                  return this._uiManager.viewParameters.realScale;
                }
                get parentRotation() {
                  return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
                }
                get parentDimensions() {
                  const {
                    parentScale,
                    pageDimensions: [pageWidth, pageHeight]
                  } = this;
                  const scaledWidth = pageWidth * parentScale;
                  const scaledHeight = pageHeight * parentScale;
                  return _util2.FeatureTest.isCSSRoundSupported ? [Math.round(scaledWidth), Math.round(scaledHeight)] : [scaledWidth, scaledHeight];
                }
                setDims(width, height) {
                  var _a3;
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;
                  if (!__privateGet(this, _keepAspectRatio)) {
                    this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;
                  }
                  (_a3 = __privateGet(this, _altTextButton)) == null ? void 0 : _a3.classList.toggle("small", width < _AnnotationEditor.SMALL_EDITOR_SIZE || height < _AnnotationEditor.SMALL_EDITOR_SIZE);
                }
                fixDims() {
                  const {
                    style
                  } = this.div;
                  const {
                    height,
                    width
                  } = style;
                  const widthPercent = width.endsWith("%");
                  const heightPercent = !__privateGet(this, _keepAspectRatio) && height.endsWith("%");
                  if (widthPercent && heightPercent) {
                    return;
                  }
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  if (!widthPercent) {
                    style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;
                  }
                  if (!__privateGet(this, _keepAspectRatio) && !heightPercent) {
                    style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;
                  }
                }
                getInitialTranslation() {
                  return [0, 0];
                }
                async addAltTextButton() {
                  if (__privateGet(this, _altTextButton)) {
                    return;
                  }
                  const altText = __privateSet(this, _altTextButton, document.createElement("button"));
                  altText.className = "altText";
                  const msg = await _AnnotationEditor._l10nPromise.get("editor_alt_text_button_label");
                  altText.textContent = msg;
                  altText.setAttribute("aria-label", msg);
                  altText.tabIndex = "0";
                  altText.addEventListener("contextmenu", _display_utils2.noContextMenu);
                  altText.addEventListener("pointerdown", (event) => event.stopPropagation());
                  altText.addEventListener("click", (event) => {
                    event.preventDefault();
                    this._uiManager.editAltText(this);
                  }, {
                    capture: true
                  });
                  altText.addEventListener("keydown", (event) => {
                    if (event.target === altText && event.key === "Enter") {
                      event.preventDefault();
                      this._uiManager.editAltText(this);
                    }
                  });
                  __privateMethod(this, _setAltTextButtonState, setAltTextButtonState_fn).call(this);
                  this.div.append(altText);
                  if (!_AnnotationEditor.SMALL_EDITOR_SIZE) {
                    const PERCENT = 40;
                    _AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100)));
                  }
                }
                getClientDimensions() {
                  return this.div.getBoundingClientRect();
                }
                get altTextData() {
                  return {
                    altText: __privateGet(this, _altText),
                    decorative: __privateGet(this, _altTextDecorative)
                  };
                }
                set altTextData({
                  altText,
                  decorative
                }) {
                  if (__privateGet(this, _altText) === altText && __privateGet(this, _altTextDecorative) === decorative) {
                    return;
                  }
                  __privateSet(this, _altText, altText);
                  __privateSet(this, _altTextDecorative, decorative);
                  __privateMethod(this, _setAltTextButtonState, setAltTextButtonState_fn).call(this);
                }
                render() {
                  this.div = document.createElement("div");
                  this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
                  this.div.className = this.name;
                  this.div.setAttribute("id", this.id);
                  this.div.setAttribute("tabIndex", 0);
                  this.setInForeground();
                  this.div.addEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.addEventListener("focusout", __privateGet(this, _boundFocusout));
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  if (this.parentRotation % 180 !== 0) {
                    this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
                    this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
                  }
                  const [tx, ty] = this.getInitialTranslation();
                  this.translate(tx, ty);
                  (0, _tools.bindEvents)(this, this.div, ["pointerdown"]);
                  return this.div;
                }
                pointerdown(event) {
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    event.preventDefault();
                    return;
                  }
                  __privateSet(this, _hasBeenClicked, true);
                  __privateMethod(this, _setUpDragSession, setUpDragSession_fn).call(this, event);
                }
                moveInDOM() {
                  var _a3;
                  (_a3 = this.parent) == null ? void 0 : _a3.moveEditorInDOM(this);
                }
                _setParentAndPosition(parent, x3, y3) {
                  parent.changeParent(this);
                  this.x = x3;
                  this.y = y3;
                  this.fixAndSetPosition();
                }
                getRect(tx, ty) {
                  const scale = this.parentScale;
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  const [pageX, pageY] = this.pageTranslation;
                  const shiftX = tx / scale;
                  const shiftY = ty / scale;
                  const x3 = this.x * pageWidth;
                  const y3 = this.y * pageHeight;
                  const width = this.width * pageWidth;
                  const height = this.height * pageHeight;
                  switch (this.rotation) {
                    case 0:
                      return [x3 + shiftX + pageX, pageHeight - y3 - shiftY - height + pageY, x3 + shiftX + width + pageX, pageHeight - y3 - shiftY + pageY];
                    case 90:
                      return [x3 + shiftY + pageX, pageHeight - y3 + shiftX + pageY, x3 + shiftY + height + pageX, pageHeight - y3 + shiftX + width + pageY];
                    case 180:
                      return [x3 - shiftX - width + pageX, pageHeight - y3 + shiftY + pageY, x3 - shiftX + pageX, pageHeight - y3 + shiftY + height + pageY];
                    case 270:
                      return [x3 - shiftY - height + pageX, pageHeight - y3 - shiftX - width + pageY, x3 - shiftY + pageX, pageHeight - y3 - shiftX + pageY];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                getRectInCurrentCoords(rect, pageHeight) {
                  const [x1, y1, x22, y22] = rect;
                  const width = x22 - x1;
                  const height = y22 - y1;
                  switch (this.rotation) {
                    case 0:
                      return [x1, pageHeight - y22, width, height];
                    case 90:
                      return [x1, pageHeight - y1, height, width];
                    case 180:
                      return [x22, pageHeight - y1, width, height];
                    case 270:
                      return [x22, pageHeight - y22, height, width];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                onceAdded() {
                }
                isEmpty() {
                  return false;
                }
                enableEditMode() {
                  __privateSet(this, _isInEditMode, true);
                }
                disableEditMode() {
                  __privateSet(this, _isInEditMode, false);
                }
                isInEditMode() {
                  return __privateGet(this, _isInEditMode);
                }
                shouldGetKeyboardEvents() {
                  return false;
                }
                needsToBeRebuilt() {
                  return this.div && !this.isAttachedToDOM;
                }
                rebuild() {
                  var _a3, _b2;
                  (_a3 = this.div) == null ? void 0 : _a3.addEventListener("focusin", __privateGet(this, _boundFocusin));
                  (_b2 = this.div) == null ? void 0 : _b2.addEventListener("focusout", __privateGet(this, _boundFocusout));
                }
                serialize(isForCopying = false, context = null) {
                  (0, _util2.unreachable)("An editor must be serializable");
                }
                static deserialize(data, parent, uiManager) {
                  const editor = new this.prototype.constructor({
                    parent,
                    id: parent.getNextId(),
                    uiManager
                  });
                  editor.rotation = data.rotation;
                  const [pageWidth, pageHeight] = editor.pageDimensions;
                  const [x3, y3, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
                  editor.x = x3 / pageWidth;
                  editor.y = y3 / pageHeight;
                  editor.width = width / pageWidth;
                  editor.height = height / pageHeight;
                  return editor;
                }
                remove() {
                  var _a3;
                  this.div.removeEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.removeEventListener("focusout", __privateGet(this, _boundFocusout));
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  if (this.parent) {
                    this.parent.remove(this);
                  } else {
                    this._uiManager.removeEditor(this);
                  }
                  (_a3 = __privateGet(this, _altTextButton)) == null ? void 0 : _a3.remove();
                  __privateSet(this, _altTextButton, null);
                  __privateSet(this, _altTextTooltip, null);
                }
                get isResizable() {
                  return false;
                }
                makeResizable() {
                  if (this.isResizable) {
                    __privateMethod(this, _createResizers, createResizers_fn).call(this);
                    __privateGet(this, _resizersDiv).classList.remove("hidden");
                  }
                }
                select() {
                  var _a3;
                  this.makeResizable();
                  (_a3 = this.div) == null ? void 0 : _a3.classList.add("selectedEditor");
                }
                unselect() {
                  var _a3, _b2, _c2;
                  (_a3 = __privateGet(this, _resizersDiv)) == null ? void 0 : _a3.classList.add("hidden");
                  (_b2 = this.div) == null ? void 0 : _b2.classList.remove("selectedEditor");
                  if ((_c2 = this.div) == null ? void 0 : _c2.contains(document.activeElement)) {
                    this._uiManager.currentLayer.div.focus();
                  }
                }
                updateParams(type, value) {
                }
                disableEditing() {
                  if (__privateGet(this, _altTextButton)) {
                    __privateGet(this, _altTextButton).hidden = true;
                  }
                }
                enableEditing() {
                  if (__privateGet(this, _altTextButton)) {
                    __privateGet(this, _altTextButton).hidden = false;
                  }
                }
                enterInEditMode() {
                }
                get contentDiv() {
                  return this.div;
                }
                get isEditing() {
                  return __privateGet(this, _isEditing);
                }
                set isEditing(value) {
                  __privateSet(this, _isEditing, value);
                  if (!this.parent) {
                    return;
                  }
                  if (value) {
                    this.parent.setSelected(this);
                    this.parent.setActiveEditor(this);
                  } else {
                    this.parent.setActiveEditor(null);
                  }
                }
                setAspectRatio(width, height) {
                  __privateSet(this, _keepAspectRatio, true);
                  const aspectRatio = width / height;
                  const {
                    style
                  } = this.div;
                  style.aspectRatio = aspectRatio;
                  style.height = "auto";
                }
                static get MIN_SIZE() {
                  return 16;
                }
              };
              _altText = new WeakMap();
              _altTextDecorative = new WeakMap();
              _altTextButton = new WeakMap();
              _altTextTooltip = new WeakMap();
              _altTextTooltipTimeout = new WeakMap();
              _keepAspectRatio = new WeakMap();
              _resizersDiv = new WeakMap();
              _boundFocusin = new WeakMap();
              _boundFocusout = new WeakMap();
              _hasBeenClicked = new WeakMap();
              _isEditing = new WeakMap();
              _isInEditMode = new WeakMap();
              _isDraggable = new WeakMap();
              _zIndex = new WeakMap();
              _translate = new WeakSet();
              translate_fn = function([width, height], x3, y3) {
                [x3, y3] = this.screenToPageTranslation(x3, y3);
                this.x += x3 / width;
                this.y += y3 / height;
                this.fixAndSetPosition();
              };
              _getBaseTranslation = new WeakSet();
              getBaseTranslation_fn = function() {
                const [parentWidth, parentHeight] = this.parentDimensions;
                const {
                  _borderLineWidth
                } = _AnnotationEditor;
                const x3 = _borderLineWidth / parentWidth;
                const y3 = _borderLineWidth / parentHeight;
                switch (this.rotation) {
                  case 90:
                    return [-x3, y3];
                  case 180:
                    return [x3, y3];
                  case 270:
                    return [x3, -y3];
                  default:
                    return [-x3, -y3];
                }
              };
              _rotatePoint = new WeakSet();
              rotatePoint_fn = function(x3, y3, angle) {
                switch (angle) {
                  case 90:
                    return [y3, -x3];
                  case 180:
                    return [-x3, -y3];
                  case 270:
                    return [-y3, x3];
                  default:
                    return [x3, y3];
                }
              };
              _getRotationMatrix = new WeakSet();
              getRotationMatrix_fn = function(rotation) {
                switch (rotation) {
                  case 90: {
                    const [pageWidth, pageHeight] = this.pageDimensions;
                    return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
                  }
                  case 180:
                    return [-1, 0, 0, -1];
                  case 270: {
                    const [pageWidth, pageHeight] = this.pageDimensions;
                    return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
                  }
                  default:
                    return [1, 0, 0, 1];
                }
              };
              _createResizers = new WeakSet();
              createResizers_fn = function() {
                if (__privateGet(this, _resizersDiv)) {
                  return;
                }
                __privateSet(this, _resizersDiv, document.createElement("div"));
                __privateGet(this, _resizersDiv).classList.add("resizers");
                const classes = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
                if (!this._willKeepAspectRatio) {
                  classes.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
                }
                for (const name of classes) {
                  const div = document.createElement("div");
                  __privateGet(this, _resizersDiv).append(div);
                  div.classList.add("resizer", name);
                  div.addEventListener("pointerdown", __privateMethod(this, _resizerPointerdown, resizerPointerdown_fn).bind(this, name));
                  div.addEventListener("contextmenu", _display_utils2.noContextMenu);
                }
                this.div.prepend(__privateGet(this, _resizersDiv));
              };
              _resizerPointerdown = new WeakSet();
              resizerPointerdown_fn = function(name, event) {
                event.preventDefault();
                const {
                  isMac
                } = _util2.FeatureTest.platform;
                if (event.button !== 0 || event.ctrlKey && isMac) {
                  return;
                }
                const boundResizerPointermove = __privateMethod(this, _resizerPointermove, resizerPointermove_fn).bind(this, name);
                const savedDraggable = this._isDraggable;
                this._isDraggable = false;
                const pointerMoveOptions = {
                  passive: true,
                  capture: true
                };
                window.addEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
                const savedX = this.x;
                const savedY = this.y;
                const savedWidth = this.width;
                const savedHeight = this.height;
                const savedParentCursor = this.parent.div.style.cursor;
                const savedCursor = this.div.style.cursor;
                this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
                const pointerUpCallback = () => {
                  this._isDraggable = savedDraggable;
                  window.removeEventListener("pointerup", pointerUpCallback);
                  window.removeEventListener("blur", pointerUpCallback);
                  window.removeEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
                  this.parent.div.style.cursor = savedParentCursor;
                  this.div.style.cursor = savedCursor;
                  const newX = this.x;
                  const newY = this.y;
                  const newWidth = this.width;
                  const newHeight = this.height;
                  if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
                    return;
                  }
                  this.addCommands({
                    cmd: () => {
                      this.width = newWidth;
                      this.height = newHeight;
                      this.x = newX;
                      this.y = newY;
                      const [parentWidth, parentHeight] = this.parentDimensions;
                      this.setDims(parentWidth * newWidth, parentHeight * newHeight);
                      this.fixAndSetPosition();
                    },
                    undo: () => {
                      this.width = savedWidth;
                      this.height = savedHeight;
                      this.x = savedX;
                      this.y = savedY;
                      const [parentWidth, parentHeight] = this.parentDimensions;
                      this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);
                      this.fixAndSetPosition();
                    },
                    mustExec: true
                  });
                };
                window.addEventListener("pointerup", pointerUpCallback);
                window.addEventListener("blur", pointerUpCallback);
              };
              _resizerPointermove = new WeakSet();
              resizerPointermove_fn = function(name, event) {
                const [parentWidth, parentHeight] = this.parentDimensions;
                const savedX = this.x;
                const savedY = this.y;
                const savedWidth = this.width;
                const savedHeight = this.height;
                const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
                const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
                const round = (x3) => Math.round(x3 * 1e4) / 1e4;
                const rotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, this.rotation);
                const transf = (x3, y3) => [rotationMatrix[0] * x3 + rotationMatrix[2] * y3, rotationMatrix[1] * x3 + rotationMatrix[3] * y3];
                const invRotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, 360 - this.rotation);
                const invTransf = (x3, y3) => [invRotationMatrix[0] * x3 + invRotationMatrix[2] * y3, invRotationMatrix[1] * x3 + invRotationMatrix[3] * y3];
                let getPoint;
                let getOpposite;
                let isDiagonal = false;
                let isHorizontal = false;
                switch (name) {
                  case "topLeft":
                    isDiagonal = true;
                    getPoint = (w3, h2) => [0, 0];
                    getOpposite = (w3, h2) => [w3, h2];
                    break;
                  case "topMiddle":
                    getPoint = (w3, h2) => [w3 / 2, 0];
                    getOpposite = (w3, h2) => [w3 / 2, h2];
                    break;
                  case "topRight":
                    isDiagonal = true;
                    getPoint = (w3, h2) => [w3, 0];
                    getOpposite = (w3, h2) => [0, h2];
                    break;
                  case "middleRight":
                    isHorizontal = true;
                    getPoint = (w3, h2) => [w3, h2 / 2];
                    getOpposite = (w3, h2) => [0, h2 / 2];
                    break;
                  case "bottomRight":
                    isDiagonal = true;
                    getPoint = (w3, h2) => [w3, h2];
                    getOpposite = (w3, h2) => [0, 0];
                    break;
                  case "bottomMiddle":
                    getPoint = (w3, h2) => [w3 / 2, h2];
                    getOpposite = (w3, h2) => [w3 / 2, 0];
                    break;
                  case "bottomLeft":
                    isDiagonal = true;
                    getPoint = (w3, h2) => [0, h2];
                    getOpposite = (w3, h2) => [w3, 0];
                    break;
                  case "middleLeft":
                    isHorizontal = true;
                    getPoint = (w3, h2) => [0, h2 / 2];
                    getOpposite = (w3, h2) => [w3, h2 / 2];
                    break;
                }
                const point = getPoint(savedWidth, savedHeight);
                const oppositePoint = getOpposite(savedWidth, savedHeight);
                let transfOppositePoint = transf(...oppositePoint);
                const oppositeX = round(savedX + transfOppositePoint[0]);
                const oppositeY = round(savedY + transfOppositePoint[1]);
                let ratioX = 1;
                let ratioY = 1;
                let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);
                [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
                if (isDiagonal) {
                  const oldDiag = Math.hypot(savedWidth, savedHeight);
                  ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
                } else if (isHorizontal) {
                  ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;
                } else {
                  ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;
                }
                const newWidth = round(savedWidth * ratioX);
                const newHeight = round(savedHeight * ratioY);
                transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
                const newX = oppositeX - transfOppositePoint[0];
                const newY = oppositeY - transfOppositePoint[1];
                this.width = newWidth;
                this.height = newHeight;
                this.x = newX;
                this.y = newY;
                this.setDims(parentWidth * newWidth, parentHeight * newHeight);
                this.fixAndSetPosition();
              };
              _setAltTextButtonState = new WeakSet();
              setAltTextButtonState_fn = async function() {
                var _a3;
                const button = __privateGet(this, _altTextButton);
                if (!button) {
                  return;
                }
                if (!__privateGet(this, _altText) && !__privateGet(this, _altTextDecorative)) {
                  button.classList.remove("done");
                  (_a3 = __privateGet(this, _altTextTooltip)) == null ? void 0 : _a3.remove();
                  return;
                }
                _AnnotationEditor._l10nPromise.get("editor_alt_text_edit_button_label").then((msg) => {
                  button.setAttribute("aria-label", msg);
                });
                let tooltip = __privateGet(this, _altTextTooltip);
                if (!tooltip) {
                  __privateSet(this, _altTextTooltip, tooltip = document.createElement("span"));
                  tooltip.className = "tooltip";
                  tooltip.setAttribute("role", "tooltip");
                  const id = tooltip.id = `alt-text-tooltip-${this.id}`;
                  button.setAttribute("aria-describedby", id);
                  const DELAY_TO_SHOW_TOOLTIP = 100;
                  button.addEventListener("mouseenter", () => {
                    __privateSet(this, _altTextTooltipTimeout, setTimeout(() => {
                      __privateSet(this, _altTextTooltipTimeout, null);
                      __privateGet(this, _altTextTooltip).classList.add("show");
                      this._uiManager._eventBus.dispatch("reporttelemetry", {
                        source: this,
                        details: {
                          type: "editing",
                          subtype: this.editorType,
                          data: {
                            action: "alt_text_tooltip"
                          }
                        }
                      });
                    }, DELAY_TO_SHOW_TOOLTIP));
                  });
                  button.addEventListener("mouseleave", () => {
                    var _a4;
                    clearTimeout(__privateGet(this, _altTextTooltipTimeout));
                    __privateSet(this, _altTextTooltipTimeout, null);
                    (_a4 = __privateGet(this, _altTextTooltip)) == null ? void 0 : _a4.classList.remove("show");
                  });
                }
                button.classList.add("done");
                tooltip.innerText = __privateGet(this, _altTextDecorative) ? await _AnnotationEditor._l10nPromise.get("editor_alt_text_decorative_tooltip") : __privateGet(this, _altText);
                if (!tooltip.parentNode) {
                  button.append(tooltip);
                }
              };
              _setUpDragSession = new WeakSet();
              setUpDragSession_fn = function(event) {
                if (!this._isDraggable) {
                  return;
                }
                const isSelected = this._uiManager.isSelected(this);
                this._uiManager.setUpDragSession();
                let pointerMoveOptions, pointerMoveCallback;
                if (isSelected) {
                  pointerMoveOptions = {
                    passive: true,
                    capture: true
                  };
                  pointerMoveCallback = (e3) => {
                    const [tx, ty] = this.screenToPageTranslation(e3.movementX, e3.movementY);
                    this._uiManager.dragSelectedEditors(tx, ty);
                  };
                  window.addEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
                }
                const pointerUpCallback = () => {
                  window.removeEventListener("pointerup", pointerUpCallback);
                  window.removeEventListener("blur", pointerUpCallback);
                  if (isSelected) {
                    window.removeEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
                  }
                  __privateSet(this, _hasBeenClicked, false);
                  if (!this._uiManager.endDragSession()) {
                    const {
                      isMac
                    } = _util2.FeatureTest.platform;
                    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
                      this.parent.toggleSelected(this);
                    } else {
                      this.parent.setSelected(this);
                    }
                  }
                };
                window.addEventListener("pointerup", pointerUpCallback);
                window.addEventListener("blur", pointerUpCallback);
              };
              __privateAdd(_AnnotationEditor, _rotatePoint);
              __publicField(_AnnotationEditor, "_borderLineWidth", -1);
              __publicField(_AnnotationEditor, "_colorManager", new _tools.ColorManager());
              __publicField(_AnnotationEditor, "_zIndex", 1);
              __publicField(_AnnotationEditor, "SMALL_EDITOR_SIZE", 0);
              let AnnotationEditor = _AnnotationEditor;
              exports2.AnnotationEditor = AnnotationEditor;
              class FakeEditor extends AnnotationEditor {
                constructor(params) {
                  super(params);
                  this.annotationElementId = params.annotationElementId;
                  this.deleted = true;
                }
                serialize() {
                  return {
                    id: this.annotationElementId,
                    deleted: true,
                    pageIndex: this.pageIndex
                  };
                }
              }
            },
            /* 5 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _id, _baseId, _id2, _cache, _get, get_fn, _commands, _locked, _maxSize, _position, _serialize, serialize_fn, _activeEditor, _allEditors, _allLayers, _altTextManager, _annotationStorage, _commandManager, _currentPageIndex, _deletedAnnotationsElementIds, _draggingEditors, _editorTypes, _editorsToRescale, _filterFactory, _idManager, _isEnabled, _isWaiting, _lastActiveElement, _mode, _selectedEditors, _pageColors, _boundBlur, _boundFocus, _boundCopy, _boundCut, _boundPaste, _boundKeydown, _boundOnEditingAction, _boundOnPageChanging, _boundOnScaleChanging, _boundOnRotationChanging, _previousStates, _translation, _translationTimeoutId, _container, _viewer, _addFocusManager, addFocusManager_fn, _removeFocusManager, removeFocusManager_fn, _addKeyboardManager, addKeyboardManager_fn, _removeKeyboardManager, removeKeyboardManager_fn, _addCopyPasteListeners, addCopyPasteListeners_fn, _removeCopyPasteListeners, removeCopyPasteListeners_fn, _dispatchUpdateStates, dispatchUpdateStates_fn, _dispatchUpdateUI, dispatchUpdateUI_fn, _enableAll, enableAll_fn, _disableAll, disableAll_fn, _addEditorToLayer, addEditorToLayer_fn, _isEmpty, isEmpty_fn, _selectEditors, selectEditors_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.KeyboardManager = exports2.CommandManager = exports2.ColorManager = exports2.AnnotationEditorUIManager = void 0;
              exports2.bindEvents = bindEvents;
              exports2.opacityToHex = opacityToHex;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              function bindEvents(obj, element, names) {
                for (const name of names) {
                  element.addEventListener(name, obj[name].bind(obj));
                }
              }
              function opacityToHex(opacity) {
                return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
              }
              class IdManager {
                constructor() {
                  __privateAdd(this, _id, 0);
                }
                getId() {
                  return `${_util2.AnnotationEditorPrefix}${__privateWrapper(this, _id)._++}`;
                }
              }
              _id = new WeakMap();
              const _ImageManager = class _ImageManager {
                constructor() {
                  __privateAdd(this, _get);
                  __privateAdd(this, _baseId, (0, _util2.getUuid)());
                  __privateAdd(this, _id2, 0);
                  __privateAdd(this, _cache, null);
                }
                static get _isSVGFittingCanvas() {
                  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
                  const canvas = new OffscreenCanvas(1, 3);
                  const ctx = canvas.getContext("2d");
                  const image = new Image();
                  image.src = svg;
                  const promise = image.decode().then(() => {
                    ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
                    return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
                  });
                  return (0, _util2.shadow)(this, "_isSVGFittingCanvas", promise);
                }
                async getFromFile(file) {
                  const {
                    lastModified,
                    name,
                    size,
                    type
                  } = file;
                  return __privateMethod(this, _get, get_fn).call(this, `${lastModified}_${name}_${size}_${type}`, file);
                }
                async getFromUrl(url) {
                  return __privateMethod(this, _get, get_fn).call(this, url, url);
                }
                async getFromId(id) {
                  __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
                  const data = __privateGet(this, _cache).get(id);
                  if (!data) {
                    return null;
                  }
                  if (data.bitmap) {
                    data.refCounter += 1;
                    return data;
                  }
                  if (data.file) {
                    return this.getFromFile(data.file);
                  }
                  return this.getFromUrl(data.url);
                }
                getSvgUrl(id) {
                  const data = __privateGet(this, _cache).get(id);
                  if (!(data == null ? void 0 : data.isSvg)) {
                    return null;
                  }
                  return data.svgUrl;
                }
                deleteId(id) {
                  __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
                  const data = __privateGet(this, _cache).get(id);
                  if (!data) {
                    return;
                  }
                  data.refCounter -= 1;
                  if (data.refCounter !== 0) {
                    return;
                  }
                  data.bitmap = null;
                }
                isValidId(id) {
                  return id.startsWith(`image_${__privateGet(this, _baseId)}_`);
                }
              };
              _baseId = new WeakMap();
              _id2 = new WeakMap();
              _cache = new WeakMap();
              _get = new WeakSet();
              get_fn = async function(key, rawData) {
                __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
                let data = __privateGet(this, _cache).get(key);
                if (data === null) {
                  return null;
                }
                if (data == null ? void 0 : data.bitmap) {
                  data.refCounter += 1;
                  return data;
                }
                try {
                  data || (data = {
                    bitmap: null,
                    id: `image_${__privateGet(this, _baseId)}_${__privateWrapper(this, _id2)._++}`,
                    refCounter: 0,
                    isSvg: false
                  });
                  let image;
                  if (typeof rawData === "string") {
                    data.url = rawData;
                    const response = await fetch(rawData);
                    if (!response.ok) {
                      throw new Error(response.statusText);
                    }
                    image = await response.blob();
                  } else {
                    image = data.file = rawData;
                  }
                  if (image.type === "image/svg+xml") {
                    const mustRemoveAspectRatioPromise = _ImageManager._isSVGFittingCanvas;
                    const fileReader = new FileReader();
                    const imageElement = new Image();
                    const imagePromise = new Promise((resolve, reject) => {
                      imageElement.onload = () => {
                        data.bitmap = imageElement;
                        data.isSvg = true;
                        resolve();
                      };
                      fileReader.onload = async () => {
                        const url = data.svgUrl = fileReader.result;
                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
                      };
                      imageElement.onerror = fileReader.onerror = reject;
                    });
                    fileReader.readAsDataURL(image);
                    await imagePromise;
                  } else {
                    data.bitmap = await createImageBitmap(image);
                  }
                  data.refCounter = 1;
                } catch (e3) {
                  console.error(e3);
                  data = null;
                }
                __privateGet(this, _cache).set(key, data);
                if (data) {
                  __privateGet(this, _cache).set(data.id, data);
                }
                return data;
              };
              let ImageManager = _ImageManager;
              class CommandManager {
                constructor(maxSize = 128) {
                  __privateAdd(this, _commands, []);
                  __privateAdd(this, _locked, false);
                  __privateAdd(this, _maxSize, void 0);
                  __privateAdd(this, _position, -1);
                  __privateSet(this, _maxSize, maxSize);
                }
                add({
                  cmd,
                  undo,
                  mustExec,
                  type = NaN,
                  overwriteIfSameType = false,
                  keepUndo = false
                }) {
                  if (mustExec) {
                    cmd();
                  }
                  if (__privateGet(this, _locked)) {
                    return;
                  }
                  const save = {
                    cmd,
                    undo,
                    type
                  };
                  if (__privateGet(this, _position) === -1) {
                    if (__privateGet(this, _commands).length > 0) {
                      __privateGet(this, _commands).length = 0;
                    }
                    __privateSet(this, _position, 0);
                    __privateGet(this, _commands).push(save);
                    return;
                  }
                  if (overwriteIfSameType && __privateGet(this, _commands)[__privateGet(this, _position)].type === type) {
                    if (keepUndo) {
                      save.undo = __privateGet(this, _commands)[__privateGet(this, _position)].undo;
                    }
                    __privateGet(this, _commands)[__privateGet(this, _position)] = save;
                    return;
                  }
                  const next = __privateGet(this, _position) + 1;
                  if (next === __privateGet(this, _maxSize)) {
                    __privateGet(this, _commands).splice(0, 1);
                  } else {
                    __privateSet(this, _position, next);
                    if (next < __privateGet(this, _commands).length) {
                      __privateGet(this, _commands).splice(next);
                    }
                  }
                  __privateGet(this, _commands).push(save);
                }
                undo() {
                  if (__privateGet(this, _position) === -1) {
                    return;
                  }
                  __privateSet(this, _locked, true);
                  __privateGet(this, _commands)[__privateGet(this, _position)].undo();
                  __privateSet(this, _locked, false);
                  __privateSet(this, _position, __privateGet(this, _position) - 1);
                }
                redo() {
                  if (__privateGet(this, _position) < __privateGet(this, _commands).length - 1) {
                    __privateSet(this, _position, __privateGet(this, _position) + 1);
                    __privateSet(this, _locked, true);
                    __privateGet(this, _commands)[__privateGet(this, _position)].cmd();
                    __privateSet(this, _locked, false);
                  }
                }
                hasSomethingToUndo() {
                  return __privateGet(this, _position) !== -1;
                }
                hasSomethingToRedo() {
                  return __privateGet(this, _position) < __privateGet(this, _commands).length - 1;
                }
                destroy() {
                  __privateSet(this, _commands, null);
                }
              }
              _commands = new WeakMap();
              _locked = new WeakMap();
              _maxSize = new WeakMap();
              _position = new WeakMap();
              exports2.CommandManager = CommandManager;
              class KeyboardManager {
                constructor(callbacks) {
                  __privateAdd(this, _serialize);
                  this.buffer = [];
                  this.callbacks = /* @__PURE__ */ new Map();
                  this.allKeys = /* @__PURE__ */ new Set();
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  for (const [keys, callback, options = {}] of callbacks) {
                    for (const key of keys) {
                      const isMacKey = key.startsWith("mac+");
                      if (isMac && isMacKey) {
                        this.callbacks.set(key.slice(4), {
                          callback,
                          options
                        });
                        this.allKeys.add(key.split("+").at(-1));
                      } else if (!isMac && !isMacKey) {
                        this.callbacks.set(key, {
                          callback,
                          options
                        });
                        this.allKeys.add(key.split("+").at(-1));
                      }
                    }
                  }
                }
                exec(self2, event) {
                  if (!this.allKeys.has(event.key)) {
                    return;
                  }
                  const info2 = this.callbacks.get(__privateMethod(this, _serialize, serialize_fn).call(this, event));
                  if (!info2) {
                    return;
                  }
                  const {
                    callback,
                    options: {
                      bubbles = false,
                      args = [],
                      checker = null
                    }
                  } = info2;
                  if (checker && !checker(self2, event)) {
                    return;
                  }
                  callback.bind(self2, ...args)();
                  if (!bubbles) {
                    event.stopPropagation();
                    event.preventDefault();
                  }
                }
              }
              _serialize = new WeakSet();
              serialize_fn = function(event) {
                if (event.altKey) {
                  this.buffer.push("alt");
                }
                if (event.ctrlKey) {
                  this.buffer.push("ctrl");
                }
                if (event.metaKey) {
                  this.buffer.push("meta");
                }
                if (event.shiftKey) {
                  this.buffer.push("shift");
                }
                this.buffer.push(event.key);
                const str = this.buffer.join("+");
                this.buffer.length = 0;
                return str;
              };
              exports2.KeyboardManager = KeyboardManager;
              const _ColorManager = class _ColorManager {
                get _colors() {
                  const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
                  (0, _display_utils2.getColorValues)(colors);
                  return (0, _util2.shadow)(this, "_colors", colors);
                }
                convert(color) {
                  const rgb = (0, _display_utils2.getRGB)(color);
                  if (!window.matchMedia("(forced-colors: active)").matches) {
                    return rgb;
                  }
                  for (const [name, RGB] of this._colors) {
                    if (RGB.every((x3, i3) => x3 === rgb[i3])) {
                      return _ColorManager._colorsMapping.get(name);
                    }
                  }
                  return rgb;
                }
                getHexCode(name) {
                  const rgb = this._colors.get(name);
                  if (!rgb) {
                    return name;
                  }
                  return _util2.Util.makeHexColor(...rgb);
                }
              };
              __publicField(_ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
              let ColorManager = _ColorManager;
              exports2.ColorManager = ColorManager;
              const _AnnotationEditorUIManager = class _AnnotationEditorUIManager {
                constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors) {
                  __privateAdd(this, _addFocusManager);
                  __privateAdd(this, _removeFocusManager);
                  __privateAdd(this, _addKeyboardManager);
                  __privateAdd(this, _removeKeyboardManager);
                  __privateAdd(this, _addCopyPasteListeners);
                  __privateAdd(this, _removeCopyPasteListeners);
                  __privateAdd(this, _dispatchUpdateStates);
                  __privateAdd(this, _dispatchUpdateUI);
                  __privateAdd(this, _enableAll);
                  __privateAdd(this, _disableAll);
                  __privateAdd(this, _addEditorToLayer);
                  __privateAdd(this, _isEmpty);
                  __privateAdd(this, _selectEditors);
                  __privateAdd(this, _activeEditor, null);
                  __privateAdd(this, _allEditors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _allLayers, /* @__PURE__ */ new Map());
                  __privateAdd(this, _altTextManager, null);
                  __privateAdd(this, _annotationStorage, null);
                  __privateAdd(this, _commandManager, new CommandManager());
                  __privateAdd(this, _currentPageIndex, 0);
                  __privateAdd(this, _deletedAnnotationsElementIds, /* @__PURE__ */ new Set());
                  __privateAdd(this, _draggingEditors, null);
                  __privateAdd(this, _editorTypes, null);
                  __privateAdd(this, _editorsToRescale, /* @__PURE__ */ new Set());
                  __privateAdd(this, _filterFactory, null);
                  __privateAdd(this, _idManager, new IdManager());
                  __privateAdd(this, _isEnabled, false);
                  __privateAdd(this, _isWaiting, false);
                  __privateAdd(this, _lastActiveElement, null);
                  __privateAdd(this, _mode, _util2.AnnotationEditorType.NONE);
                  __privateAdd(this, _selectedEditors, /* @__PURE__ */ new Set());
                  __privateAdd(this, _pageColors, null);
                  __privateAdd(this, _boundBlur, this.blur.bind(this));
                  __privateAdd(this, _boundFocus, this.focus.bind(this));
                  __privateAdd(this, _boundCopy, this.copy.bind(this));
                  __privateAdd(this, _boundCut, this.cut.bind(this));
                  __privateAdd(this, _boundPaste, this.paste.bind(this));
                  __privateAdd(this, _boundKeydown, this.keydown.bind(this));
                  __privateAdd(this, _boundOnEditingAction, this.onEditingAction.bind(this));
                  __privateAdd(this, _boundOnPageChanging, this.onPageChanging.bind(this));
                  __privateAdd(this, _boundOnScaleChanging, this.onScaleChanging.bind(this));
                  __privateAdd(this, _boundOnRotationChanging, this.onRotationChanging.bind(this));
                  __privateAdd(this, _previousStates, {
                    isEditing: false,
                    isEmpty: true,
                    hasSomethingToUndo: false,
                    hasSomethingToRedo: false,
                    hasSelectedEditor: false
                  });
                  __privateAdd(this, _translation, [0, 0]);
                  __privateAdd(this, _translationTimeoutId, null);
                  __privateAdd(this, _container, null);
                  __privateAdd(this, _viewer, null);
                  __privateSet(this, _container, container);
                  __privateSet(this, _viewer, viewer);
                  __privateSet(this, _altTextManager, altTextManager);
                  this._eventBus = eventBus;
                  this._eventBus._on("editingaction", __privateGet(this, _boundOnEditingAction));
                  this._eventBus._on("pagechanging", __privateGet(this, _boundOnPageChanging));
                  this._eventBus._on("scalechanging", __privateGet(this, _boundOnScaleChanging));
                  this._eventBus._on("rotationchanging", __privateGet(this, _boundOnRotationChanging));
                  __privateSet(this, _annotationStorage, pdfDocument.annotationStorage);
                  __privateSet(this, _filterFactory, pdfDocument.filterFactory);
                  __privateSet(this, _pageColors, pageColors);
                  this.viewParameters = {
                    realScale: _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS,
                    rotation: 0
                  };
                }
                static get _keyboardManager() {
                  const proto = _AnnotationEditorUIManager.prototype;
                  const arrowChecker = (self2) => {
                    const {
                      activeElement
                    } = document;
                    return activeElement && __privateGet(self2, _container).contains(activeElement) && self2.hasSomethingToControl();
                  };
                  const small = this.TRANSLATE_SMALL;
                  const big = this.TRANSLATE_BIG;
                  return (0, _util2.shadow)(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll], [["ctrl+z", "mac+meta+z"], proto.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
                    args: [-small, 0],
                    checker: arrowChecker
                  }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
                    args: [-big, 0],
                    checker: arrowChecker
                  }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
                    args: [small, 0],
                    checker: arrowChecker
                  }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
                    args: [big, 0],
                    checker: arrowChecker
                  }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
                    args: [0, -small],
                    checker: arrowChecker
                  }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
                    args: [0, -big],
                    checker: arrowChecker
                  }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
                    args: [0, small],
                    checker: arrowChecker
                  }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
                    args: [0, big],
                    checker: arrowChecker
                  }]]));
                }
                destroy() {
                  __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                  __privateMethod(this, _removeFocusManager, removeFocusManager_fn).call(this);
                  this._eventBus._off("editingaction", __privateGet(this, _boundOnEditingAction));
                  this._eventBus._off("pagechanging", __privateGet(this, _boundOnPageChanging));
                  this._eventBus._off("scalechanging", __privateGet(this, _boundOnScaleChanging));
                  this._eventBus._off("rotationchanging", __privateGet(this, _boundOnRotationChanging));
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.destroy();
                  }
                  __privateGet(this, _allLayers).clear();
                  __privateGet(this, _allEditors).clear();
                  __privateGet(this, _editorsToRescale).clear();
                  __privateSet(this, _activeEditor, null);
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _commandManager).destroy();
                  __privateGet(this, _altTextManager).destroy();
                }
                get hcmFilter() {
                  return (0, _util2.shadow)(this, "hcmFilter", __privateGet(this, _pageColors) ? __privateGet(this, _filterFactory).addHCMFilter(__privateGet(this, _pageColors).foreground, __privateGet(this, _pageColors).background) : "none");
                }
                get direction() {
                  return (0, _util2.shadow)(this, "direction", getComputedStyle(__privateGet(this, _container)).direction);
                }
                editAltText(editor) {
                  var _a3;
                  (_a3 = __privateGet(this, _altTextManager)) == null ? void 0 : _a3.editAltText(this, editor);
                }
                onPageChanging({
                  pageNumber
                }) {
                  __privateSet(this, _currentPageIndex, pageNumber - 1);
                }
                focusMainContainer() {
                  __privateGet(this, _container).focus();
                }
                findParent(x3, y3) {
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    const {
                      x: layerX,
                      y: layerY,
                      width,
                      height
                    } = layer.div.getBoundingClientRect();
                    if (x3 >= layerX && x3 <= layerX + width && y3 >= layerY && y3 <= layerY + height) {
                      return layer;
                    }
                  }
                  return null;
                }
                disableUserSelect(value = false) {
                  __privateGet(this, _viewer).classList.toggle("noUserSelect", value);
                }
                addShouldRescale(editor) {
                  __privateGet(this, _editorsToRescale).add(editor);
                }
                removeShouldRescale(editor) {
                  __privateGet(this, _editorsToRescale).delete(editor);
                }
                onScaleChanging({
                  scale
                }) {
                  this.commitOrRemove();
                  this.viewParameters.realScale = scale * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS;
                  for (const editor of __privateGet(this, _editorsToRescale)) {
                    editor.onScaleChanging();
                  }
                }
                onRotationChanging({
                  pagesRotation
                }) {
                  this.commitOrRemove();
                  this.viewParameters.rotation = pagesRotation;
                }
                addToAnnotationStorage(editor) {
                  if (!editor.isEmpty() && __privateGet(this, _annotationStorage) && !__privateGet(this, _annotationStorage).has(editor.id)) {
                    __privateGet(this, _annotationStorage).setValue(editor.id, editor);
                  }
                }
                blur() {
                  if (!this.hasSelection) {
                    return;
                  }
                  const {
                    activeElement
                  } = document;
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    if (editor.div.contains(activeElement)) {
                      __privateSet(this, _lastActiveElement, [editor, activeElement]);
                      editor._focusEventsAllowed = false;
                      break;
                    }
                  }
                }
                focus() {
                  if (!__privateGet(this, _lastActiveElement)) {
                    return;
                  }
                  const [lastEditor, lastActiveElement] = __privateGet(this, _lastActiveElement);
                  __privateSet(this, _lastActiveElement, null);
                  lastActiveElement.addEventListener("focusin", () => {
                    lastEditor._focusEventsAllowed = true;
                  }, {
                    once: true
                  });
                  lastActiveElement.focus();
                }
                addEditListeners() {
                  __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
                  __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
                }
                removeEditListeners() {
                  __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                  __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
                }
                copy(event) {
                  var _a3;
                  event.preventDefault();
                  (_a3 = __privateGet(this, _activeEditor)) == null ? void 0 : _a3.commitOrRemove();
                  if (!this.hasSelection) {
                    return;
                  }
                  const editors = [];
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    const serialized = editor.serialize(true);
                    if (serialized) {
                      editors.push(serialized);
                    }
                  }
                  if (editors.length === 0) {
                    return;
                  }
                  event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
                }
                cut(event) {
                  this.copy(event);
                  this.delete();
                }
                paste(event) {
                  event.preventDefault();
                  const {
                    clipboardData
                  } = event;
                  for (const item of clipboardData.items) {
                    for (const editorType of __privateGet(this, _editorTypes)) {
                      if (editorType.isHandlingMimeForPasting(item.type)) {
                        editorType.paste(item, this.currentLayer);
                        return;
                      }
                    }
                  }
                  let data = clipboardData.getData("application/pdfjs");
                  if (!data) {
                    return;
                  }
                  try {
                    data = JSON.parse(data);
                  } catch (ex) {
                    (0, _util2.warn)(`paste: "${ex.message}".`);
                    return;
                  }
                  if (!Array.isArray(data)) {
                    return;
                  }
                  this.unselectAll();
                  const layer = this.currentLayer;
                  try {
                    const newEditors = [];
                    for (const editor of data) {
                      const deserializedEditor = layer.deserialize(editor);
                      if (!deserializedEditor) {
                        return;
                      }
                      newEditors.push(deserializedEditor);
                    }
                    const cmd = () => {
                      for (const editor of newEditors) {
                        __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                      }
                      __privateMethod(this, _selectEditors, selectEditors_fn).call(this, newEditors);
                    };
                    const undo = () => {
                      for (const editor of newEditors) {
                        editor.remove();
                      }
                    };
                    this.addCommands({
                      cmd,
                      undo,
                      mustExec: true
                    });
                  } catch (ex) {
                    (0, _util2.warn)(`paste: "${ex.message}".`);
                  }
                }
                keydown(event) {
                  var _a3;
                  if (!((_a3 = this.getActive()) == null ? void 0 : _a3.shouldGetKeyboardEvents())) {
                    _AnnotationEditorUIManager._keyboardManager.exec(this, event);
                  }
                }
                onEditingAction(details) {
                  if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
                    this[details.name]();
                  }
                }
                setEditingState(isEditing) {
                  if (isEditing) {
                    __privateMethod(this, _addFocusManager, addFocusManager_fn).call(this);
                    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
                    __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: __privateGet(this, _mode) !== _util2.AnnotationEditorType.NONE,
                      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this),
                      hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                      hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                      hasSelectedEditor: false
                    });
                  } else {
                    __privateMethod(this, _removeFocusManager, removeFocusManager_fn).call(this);
                    __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                    __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: false
                    });
                    this.disableUserSelect(false);
                  }
                }
                registerEditorTypes(types) {
                  if (__privateGet(this, _editorTypes)) {
                    return;
                  }
                  __privateSet(this, _editorTypes, types);
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
                  }
                }
                getId() {
                  return __privateGet(this, _idManager).getId();
                }
                get currentLayer() {
                  return __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
                }
                getLayer(pageIndex) {
                  return __privateGet(this, _allLayers).get(pageIndex);
                }
                get currentPageIndex() {
                  return __privateGet(this, _currentPageIndex);
                }
                addLayer(layer) {
                  __privateGet(this, _allLayers).set(layer.pageIndex, layer);
                  if (__privateGet(this, _isEnabled)) {
                    layer.enable();
                  } else {
                    layer.disable();
                  }
                }
                removeLayer(layer) {
                  __privateGet(this, _allLayers).delete(layer.pageIndex);
                }
                updateMode(mode, editId = null) {
                  if (__privateGet(this, _mode) === mode) {
                    return;
                  }
                  __privateSet(this, _mode, mode);
                  if (mode === _util2.AnnotationEditorType.NONE) {
                    this.setEditingState(false);
                    __privateMethod(this, _disableAll, disableAll_fn).call(this);
                    return;
                  }
                  this.setEditingState(true);
                  __privateMethod(this, _enableAll, enableAll_fn).call(this);
                  this.unselectAll();
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.updateMode(mode);
                  }
                  if (!editId) {
                    return;
                  }
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    if (editor.annotationElementId === editId) {
                      this.setSelected(editor);
                      editor.enterInEditMode();
                      break;
                    }
                  }
                }
                updateToolbar(mode) {
                  if (mode === __privateGet(this, _mode)) {
                    return;
                  }
                  this._eventBus.dispatch("switchannotationeditormode", {
                    source: this,
                    mode
                  });
                }
                updateParams(type, value) {
                  if (!__privateGet(this, _editorTypes)) {
                    return;
                  }
                  if (type === _util2.AnnotationEditorParamsType.CREATE) {
                    this.currentLayer.addNewEditor(type);
                    return;
                  }
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.updateParams(type, value);
                  }
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    editorType.updateDefaultParams(type, value);
                  }
                }
                enableWaiting(mustWait = false) {
                  if (__privateGet(this, _isWaiting) === mustWait) {
                    return;
                  }
                  __privateSet(this, _isWaiting, mustWait);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    if (mustWait) {
                      layer.disableClick();
                    } else {
                      layer.enableClick();
                    }
                    layer.div.classList.toggle("waiting", mustWait);
                  }
                }
                getEditors(pageIndex) {
                  const editors = [];
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    if (editor.pageIndex === pageIndex) {
                      editors.push(editor);
                    }
                  }
                  return editors;
                }
                getEditor(id) {
                  return __privateGet(this, _allEditors).get(id);
                }
                addEditor(editor) {
                  __privateGet(this, _allEditors).set(editor.id, editor);
                }
                removeEditor(editor) {
                  var _a3;
                  __privateGet(this, _allEditors).delete(editor.id);
                  this.unselect(editor);
                  if (!editor.annotationElementId || !__privateGet(this, _deletedAnnotationsElementIds).has(editor.annotationElementId)) {
                    (_a3 = __privateGet(this, _annotationStorage)) == null ? void 0 : _a3.remove(editor.id);
                  }
                }
                addDeletedAnnotationElement(editor) {
                  __privateGet(this, _deletedAnnotationsElementIds).add(editor.annotationElementId);
                  editor.deleted = true;
                }
                isDeletedAnnotationElement(annotationElementId) {
                  return __privateGet(this, _deletedAnnotationsElementIds).has(annotationElementId);
                }
                removeDeletedAnnotationElement(editor) {
                  __privateGet(this, _deletedAnnotationsElementIds).delete(editor.annotationElementId);
                  editor.deleted = false;
                }
                setActiveEditor(editor) {
                  if (__privateGet(this, _activeEditor) === editor) {
                    return;
                  }
                  __privateSet(this, _activeEditor, editor);
                  if (editor) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  }
                }
                toggleSelected(editor) {
                  if (__privateGet(this, _selectedEditors).has(editor)) {
                    __privateGet(this, _selectedEditors).delete(editor);
                    editor.unselect();
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      hasSelectedEditor: this.hasSelection
                    });
                    return;
                  }
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                setSelected(editor) {
                  for (const ed of __privateGet(this, _selectedEditors)) {
                    if (ed !== editor) {
                      ed.unselect();
                    }
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                isSelected(editor) {
                  return __privateGet(this, _selectedEditors).has(editor);
                }
                unselect(editor) {
                  editor.unselect();
                  __privateGet(this, _selectedEditors).delete(editor);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: this.hasSelection
                  });
                }
                get hasSelection() {
                  return __privateGet(this, _selectedEditors).size !== 0;
                }
                undo() {
                  __privateGet(this, _commandManager).undo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                    hasSomethingToRedo: true,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                redo() {
                  __privateGet(this, _commandManager).redo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                addCommands(params) {
                  __privateGet(this, _commandManager).add(params);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: false,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                delete() {
                  this.commitOrRemove();
                  if (!this.hasSelection) {
                    return;
                  }
                  const editors = [...__privateGet(this, _selectedEditors)];
                  const cmd = () => {
                    for (const editor of editors) {
                      editor.remove();
                    }
                  };
                  const undo = () => {
                    for (const editor of editors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                commitOrRemove() {
                  var _a3;
                  (_a3 = __privateGet(this, _activeEditor)) == null ? void 0 : _a3.commitOrRemove();
                }
                hasSomethingToControl() {
                  return __privateGet(this, _activeEditor) || this.hasSelection;
                }
                selectAll() {
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.commit();
                  }
                  __privateMethod(this, _selectEditors, selectEditors_fn).call(this, __privateGet(this, _allEditors).values());
                }
                unselectAll() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                    return;
                  }
                  if (!this.hasSelection) {
                    return;
                  }
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.unselect();
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: false
                  });
                }
                translateSelectedEditors(x3, y3, noCommit = false) {
                  if (!noCommit) {
                    this.commitOrRemove();
                  }
                  if (!this.hasSelection) {
                    return;
                  }
                  __privateGet(this, _translation)[0] += x3;
                  __privateGet(this, _translation)[1] += y3;
                  const [totalX, totalY] = __privateGet(this, _translation);
                  const editors = [...__privateGet(this, _selectedEditors)];
                  const TIME_TO_WAIT = 1e3;
                  if (__privateGet(this, _translationTimeoutId)) {
                    clearTimeout(__privateGet(this, _translationTimeoutId));
                  }
                  __privateSet(this, _translationTimeoutId, setTimeout(() => {
                    __privateSet(this, _translationTimeoutId, null);
                    __privateGet(this, _translation)[0] = __privateGet(this, _translation)[1] = 0;
                    this.addCommands({
                      cmd: () => {
                        for (const editor of editors) {
                          if (__privateGet(this, _allEditors).has(editor.id)) {
                            editor.translateInPage(totalX, totalY);
                          }
                        }
                      },
                      undo: () => {
                        for (const editor of editors) {
                          if (__privateGet(this, _allEditors).has(editor.id)) {
                            editor.translateInPage(-totalX, -totalY);
                          }
                        }
                      },
                      mustExec: false
                    });
                  }, TIME_TO_WAIT));
                  for (const editor of editors) {
                    editor.translateInPage(x3, y3);
                  }
                }
                setUpDragSession() {
                  if (!this.hasSelection) {
                    return;
                  }
                  this.disableUserSelect(true);
                  __privateSet(this, _draggingEditors, /* @__PURE__ */ new Map());
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    __privateGet(this, _draggingEditors).set(editor, {
                      savedX: editor.x,
                      savedY: editor.y,
                      savedPageIndex: editor.pageIndex,
                      newX: 0,
                      newY: 0,
                      newPageIndex: -1
                    });
                  }
                }
                endDragSession() {
                  if (!__privateGet(this, _draggingEditors)) {
                    return false;
                  }
                  this.disableUserSelect(false);
                  const map = __privateGet(this, _draggingEditors);
                  __privateSet(this, _draggingEditors, null);
                  let mustBeAddedInUndoStack = false;
                  for (const [{
                    x: x3,
                    y: y3,
                    pageIndex
                  }, value] of map) {
                    value.newX = x3;
                    value.newY = y3;
                    value.newPageIndex = pageIndex;
                    mustBeAddedInUndoStack || (mustBeAddedInUndoStack = x3 !== value.savedX || y3 !== value.savedY || pageIndex !== value.savedPageIndex);
                  }
                  if (!mustBeAddedInUndoStack) {
                    return false;
                  }
                  const move = (editor, x3, y3, pageIndex) => {
                    if (__privateGet(this, _allEditors).has(editor.id)) {
                      const parent = __privateGet(this, _allLayers).get(pageIndex);
                      if (parent) {
                        editor._setParentAndPosition(parent, x3, y3);
                      } else {
                        editor.pageIndex = pageIndex;
                        editor.x = x3;
                        editor.y = y3;
                      }
                    }
                  };
                  this.addCommands({
                    cmd: () => {
                      for (const [editor, {
                        newX,
                        newY,
                        newPageIndex
                      }] of map) {
                        move(editor, newX, newY, newPageIndex);
                      }
                    },
                    undo: () => {
                      for (const [editor, {
                        savedX,
                        savedY,
                        savedPageIndex
                      }] of map) {
                        move(editor, savedX, savedY, savedPageIndex);
                      }
                    },
                    mustExec: true
                  });
                  return true;
                }
                dragSelectedEditors(tx, ty) {
                  if (!__privateGet(this, _draggingEditors)) {
                    return;
                  }
                  for (const editor of __privateGet(this, _draggingEditors).keys()) {
                    editor.drag(tx, ty);
                  }
                }
                rebuild(editor) {
                  if (editor.parent === null) {
                    const parent = this.getLayer(editor.pageIndex);
                    if (parent) {
                      parent.changeParent(editor);
                      parent.addOrRebuild(editor);
                    } else {
                      this.addEditor(editor);
                      this.addToAnnotationStorage(editor);
                      editor.rebuild();
                    }
                  } else {
                    editor.parent.addOrRebuild(editor);
                  }
                }
                isActive(editor) {
                  return __privateGet(this, _activeEditor) === editor;
                }
                getActive() {
                  return __privateGet(this, _activeEditor);
                }
                getMode() {
                  return __privateGet(this, _mode);
                }
                get imageManager() {
                  return (0, _util2.shadow)(this, "imageManager", new ImageManager());
                }
              };
              _activeEditor = new WeakMap();
              _allEditors = new WeakMap();
              _allLayers = new WeakMap();
              _altTextManager = new WeakMap();
              _annotationStorage = new WeakMap();
              _commandManager = new WeakMap();
              _currentPageIndex = new WeakMap();
              _deletedAnnotationsElementIds = new WeakMap();
              _draggingEditors = new WeakMap();
              _editorTypes = new WeakMap();
              _editorsToRescale = new WeakMap();
              _filterFactory = new WeakMap();
              _idManager = new WeakMap();
              _isEnabled = new WeakMap();
              _isWaiting = new WeakMap();
              _lastActiveElement = new WeakMap();
              _mode = new WeakMap();
              _selectedEditors = new WeakMap();
              _pageColors = new WeakMap();
              _boundBlur = new WeakMap();
              _boundFocus = new WeakMap();
              _boundCopy = new WeakMap();
              _boundCut = new WeakMap();
              _boundPaste = new WeakMap();
              _boundKeydown = new WeakMap();
              _boundOnEditingAction = new WeakMap();
              _boundOnPageChanging = new WeakMap();
              _boundOnScaleChanging = new WeakMap();
              _boundOnRotationChanging = new WeakMap();
              _previousStates = new WeakMap();
              _translation = new WeakMap();
              _translationTimeoutId = new WeakMap();
              _container = new WeakMap();
              _viewer = new WeakMap();
              _addFocusManager = new WeakSet();
              addFocusManager_fn = function() {
                window.addEventListener("focus", __privateGet(this, _boundFocus));
                window.addEventListener("blur", __privateGet(this, _boundBlur));
              };
              _removeFocusManager = new WeakSet();
              removeFocusManager_fn = function() {
                window.removeEventListener("focus", __privateGet(this, _boundFocus));
                window.removeEventListener("blur", __privateGet(this, _boundBlur));
              };
              _addKeyboardManager = new WeakSet();
              addKeyboardManager_fn = function() {
                window.addEventListener("keydown", __privateGet(this, _boundKeydown), {
                  capture: true
                });
              };
              _removeKeyboardManager = new WeakSet();
              removeKeyboardManager_fn = function() {
                window.removeEventListener("keydown", __privateGet(this, _boundKeydown), {
                  capture: true
                });
              };
              _addCopyPasteListeners = new WeakSet();
              addCopyPasteListeners_fn = function() {
                document.addEventListener("copy", __privateGet(this, _boundCopy));
                document.addEventListener("cut", __privateGet(this, _boundCut));
                document.addEventListener("paste", __privateGet(this, _boundPaste));
              };
              _removeCopyPasteListeners = new WeakSet();
              removeCopyPasteListeners_fn = function() {
                document.removeEventListener("copy", __privateGet(this, _boundCopy));
                document.removeEventListener("cut", __privateGet(this, _boundCut));
                document.removeEventListener("paste", __privateGet(this, _boundPaste));
              };
              _dispatchUpdateStates = new WeakSet();
              dispatchUpdateStates_fn = function(details) {
                const hasChanged = Object.entries(details).some(([key, value]) => __privateGet(this, _previousStates)[key] !== value);
                if (hasChanged) {
                  this._eventBus.dispatch("annotationeditorstateschanged", {
                    source: this,
                    details: Object.assign(__privateGet(this, _previousStates), details)
                  });
                }
              };
              _dispatchUpdateUI = new WeakSet();
              dispatchUpdateUI_fn = function(details) {
                this._eventBus.dispatch("annotationeditorparamschanged", {
                  source: this,
                  details
                });
              };
              _enableAll = new WeakSet();
              enableAll_fn = function() {
                if (!__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, true);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.enable();
                  }
                }
              };
              _disableAll = new WeakSet();
              disableAll_fn = function() {
                this.unselectAll();
                if (__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, false);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.disable();
                  }
                }
              };
              _addEditorToLayer = new WeakSet();
              addEditorToLayer_fn = function(editor) {
                const layer = __privateGet(this, _allLayers).get(editor.pageIndex);
                if (layer) {
                  layer.addOrRebuild(editor);
                } else {
                  this.addEditor(editor);
                }
              };
              _isEmpty = new WeakSet();
              isEmpty_fn = function() {
                if (__privateGet(this, _allEditors).size === 0) {
                  return true;
                }
                if (__privateGet(this, _allEditors).size === 1) {
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    return editor.isEmpty();
                  }
                }
                return false;
              };
              _selectEditors = new WeakSet();
              selectEditors_fn = function(editors) {
                __privateGet(this, _selectedEditors).clear();
                for (const editor of editors) {
                  if (editor.isEmpty()) {
                    continue;
                  }
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                }
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: true
                });
              };
              __publicField(_AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
              __publicField(_AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
              let AnnotationEditorUIManager = _AnnotationEditorUIManager;
              exports2.AnnotationEditorUIManager = AnnotationEditorUIManager;
            },
            /* 6 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var __cache, __defs, _docId, _document, _hcmFilter, _hcmKey, _hcmUrl, _hcmHighlightFilter, _hcmHighlightKey, _hcmHighlightUrl, _id, _cache, cache_get, _defs, defs_get, _addGrayConversion, addGrayConversion_fn, _createFilter, createFilter_fn, _appendFeFunc, appendFeFunc_fn, _addTransferMapConversion, addTransferMapConversion_fn, _getRGB, getRGB_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMFilterFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = void 0;
              exports2.deprecated = deprecated;
              exports2.getColorValues = getColorValues;
              exports2.getCurrentTransform = getCurrentTransform;
              exports2.getCurrentTransformInverse = getCurrentTransformInverse;
              exports2.getFilenameFromUrl = getFilenameFromUrl;
              exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
              exports2.getRGB = getRGB;
              exports2.getXfaPageViewport = getXfaPageViewport;
              exports2.isDataScheme = isDataScheme;
              exports2.isPdfFile = isPdfFile;
              exports2.isValidFetchUrl = isValidFetchUrl;
              exports2.loadScript = loadScript;
              exports2.noContextMenu = noContextMenu;
              exports2.setLayerDimensions = setLayerDimensions;
              var _base_factory = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              const SVG_NS = "http://www.w3.org/2000/svg";
              const _PixelsPerInch = class _PixelsPerInch {
              };
              __publicField(_PixelsPerInch, "CSS", 96);
              __publicField(_PixelsPerInch, "PDF", 72);
              __publicField(_PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
              let PixelsPerInch = _PixelsPerInch;
              exports2.PixelsPerInch = PixelsPerInch;
              class DOMFilterFactory extends _base_factory.BaseFilterFactory {
                constructor({
                  docId,
                  ownerDocument = globalThis.document
                } = {}) {
                  super();
                  __privateAdd(this, _cache);
                  __privateAdd(this, _defs);
                  __privateAdd(this, _addGrayConversion);
                  __privateAdd(this, _createFilter);
                  __privateAdd(this, _appendFeFunc);
                  __privateAdd(this, _addTransferMapConversion);
                  __privateAdd(this, _getRGB);
                  __privateAdd(this, __cache, void 0);
                  __privateAdd(this, __defs, void 0);
                  __privateAdd(this, _docId, void 0);
                  __privateAdd(this, _document, void 0);
                  __privateAdd(this, _hcmFilter, void 0);
                  __privateAdd(this, _hcmKey, void 0);
                  __privateAdd(this, _hcmUrl, void 0);
                  __privateAdd(this, _hcmHighlightFilter, void 0);
                  __privateAdd(this, _hcmHighlightKey, void 0);
                  __privateAdd(this, _hcmHighlightUrl, void 0);
                  __privateAdd(this, _id, 0);
                  __privateSet(this, _docId, docId);
                  __privateSet(this, _document, ownerDocument);
                }
                addFilter(maps) {
                  if (!maps) {
                    return "none";
                  }
                  let value = __privateGet(this, _cache, cache_get).get(maps);
                  if (value) {
                    return value;
                  }
                  let tableR, tableG, tableB, key;
                  if (maps.length === 1) {
                    const mapR = maps[0];
                    const buffer = new Array(256);
                    for (let i3 = 0; i3 < 256; i3++) {
                      buffer[i3] = mapR[i3] / 255;
                    }
                    key = tableR = tableG = tableB = buffer.join(",");
                  } else {
                    const [mapR, mapG, mapB] = maps;
                    const bufferR = new Array(256);
                    const bufferG = new Array(256);
                    const bufferB = new Array(256);
                    for (let i3 = 0; i3 < 256; i3++) {
                      bufferR[i3] = mapR[i3] / 255;
                      bufferG[i3] = mapG[i3] / 255;
                      bufferB[i3] = mapB[i3] / 255;
                    }
                    tableR = bufferR.join(",");
                    tableG = bufferG.join(",");
                    tableB = bufferB.join(",");
                    key = `${tableR}${tableG}${tableB}`;
                  }
                  value = __privateGet(this, _cache, cache_get).get(key);
                  if (value) {
                    __privateGet(this, _cache, cache_get).set(maps, value);
                    return value;
                  }
                  const id = `g_${__privateGet(this, _docId)}_transfer_map_${__privateWrapper(this, _id)._++}`;
                  const url = `url(#${id})`;
                  __privateGet(this, _cache, cache_get).set(maps, url);
                  __privateGet(this, _cache, cache_get).set(key, url);
                  const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
                  __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, tableR, tableG, tableB, filter);
                  return url;
                }
                addHCMFilter(fgColor, bgColor) {
                  var _a3;
                  const key = `${fgColor}-${bgColor}`;
                  if (__privateGet(this, _hcmKey) === key) {
                    return __privateGet(this, _hcmUrl);
                  }
                  __privateSet(this, _hcmKey, key);
                  __privateSet(this, _hcmUrl, "none");
                  (_a3 = __privateGet(this, _hcmFilter)) == null ? void 0 : _a3.remove();
                  if (!fgColor || !bgColor) {
                    return __privateGet(this, _hcmUrl);
                  }
                  const fgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, fgColor);
                  fgColor = _util2.Util.makeHexColor(...fgRGB);
                  const bgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, bgColor);
                  bgColor = _util2.Util.makeHexColor(...bgRGB);
                  __privateGet(this, _defs, defs_get).style.color = "";
                  if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
                    return __privateGet(this, _hcmUrl);
                  }
                  const map = new Array(256);
                  for (let i3 = 0; i3 <= 255; i3++) {
                    const x3 = i3 / 255;
                    map[i3] = x3 <= 0.03928 ? x3 / 12.92 : ((x3 + 0.055) / 1.055) ** 2.4;
                  }
                  const table = map.join(",");
                  const id = `g_${__privateGet(this, _docId)}_hcm_filter`;
                  const filter = __privateSet(this, _hcmHighlightFilter, __privateMethod(this, _createFilter, createFilter_fn).call(this, id));
                  __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, table, table, table, filter);
                  __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
                  const getSteps = (c3, n3) => {
                    const start = fgRGB[c3] / 255;
                    const end = bgRGB[c3] / 255;
                    const arr = new Array(n3 + 1);
                    for (let i3 = 0; i3 <= n3; i3++) {
                      arr[i3] = start + i3 / n3 * (end - start);
                    }
                    return arr.join(",");
                  };
                  __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
                  __privateSet(this, _hcmUrl, `url(#${id})`);
                  return __privateGet(this, _hcmUrl);
                }
                addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
                  var _a3;
                  const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
                  if (__privateGet(this, _hcmHighlightKey) === key) {
                    return __privateGet(this, _hcmHighlightUrl);
                  }
                  __privateSet(this, _hcmHighlightKey, key);
                  __privateSet(this, _hcmHighlightUrl, "none");
                  (_a3 = __privateGet(this, _hcmHighlightFilter)) == null ? void 0 : _a3.remove();
                  if (!fgColor || !bgColor) {
                    return __privateGet(this, _hcmHighlightUrl);
                  }
                  const [fgRGB, bgRGB] = [fgColor, bgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
                  let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
                  let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
                  let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
                  if (bgGray < fgGray) {
                    [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
                  }
                  __privateGet(this, _defs, defs_get).style.color = "";
                  const getSteps = (fg, bg, n3) => {
                    const arr = new Array(256);
                    const step = (bgGray - fgGray) / n3;
                    const newStart = fg / 255;
                    const newStep = (bg - fg) / (255 * n3);
                    let prev = 0;
                    for (let i3 = 0; i3 <= n3; i3++) {
                      const k3 = Math.round(fgGray + i3 * step);
                      const value = newStart + i3 * newStep;
                      for (let j3 = prev; j3 <= k3; j3++) {
                        arr[j3] = value;
                      }
                      prev = k3 + 1;
                    }
                    for (let i3 = prev; i3 < 256; i3++) {
                      arr[i3] = arr[prev - 1];
                    }
                    return arr.join(",");
                  };
                  const id = `g_${__privateGet(this, _docId)}_hcm_highlight_filter`;
                  const filter = __privateSet(this, _hcmHighlightFilter, __privateMethod(this, _createFilter, createFilter_fn).call(this, id));
                  __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
                  __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
                  __privateSet(this, _hcmHighlightUrl, `url(#${id})`);
                  return __privateGet(this, _hcmHighlightUrl);
                }
                destroy(keepHCM = false) {
                  if (keepHCM && (__privateGet(this, _hcmUrl) || __privateGet(this, _hcmHighlightUrl))) {
                    return;
                  }
                  if (__privateGet(this, __defs)) {
                    __privateGet(this, __defs).parentNode.parentNode.remove();
                    __privateSet(this, __defs, null);
                  }
                  if (__privateGet(this, __cache)) {
                    __privateGet(this, __cache).clear();
                    __privateSet(this, __cache, null);
                  }
                  __privateSet(this, _id, 0);
                }
              }
              __cache = new WeakMap();
              __defs = new WeakMap();
              _docId = new WeakMap();
              _document = new WeakMap();
              _hcmFilter = new WeakMap();
              _hcmKey = new WeakMap();
              _hcmUrl = new WeakMap();
              _hcmHighlightFilter = new WeakMap();
              _hcmHighlightKey = new WeakMap();
              _hcmHighlightUrl = new WeakMap();
              _id = new WeakMap();
              _cache = new WeakSet();
              cache_get = function() {
                return __privateGet(this, __cache) || __privateSet(this, __cache, /* @__PURE__ */ new Map());
              };
              _defs = new WeakSet();
              defs_get = function() {
                if (!__privateGet(this, __defs)) {
                  const div = __privateGet(this, _document).createElement("div");
                  const {
                    style
                  } = div;
                  style.visibility = "hidden";
                  style.contain = "strict";
                  style.width = style.height = 0;
                  style.position = "absolute";
                  style.top = style.left = 0;
                  style.zIndex = -1;
                  const svg = __privateGet(this, _document).createElementNS(SVG_NS, "svg");
                  svg.setAttribute("width", 0);
                  svg.setAttribute("height", 0);
                  __privateSet(this, __defs, __privateGet(this, _document).createElementNS(SVG_NS, "defs"));
                  div.append(svg);
                  svg.append(__privateGet(this, __defs));
                  __privateGet(this, _document).body.append(div);
                }
                return __privateGet(this, __defs);
              };
              _addGrayConversion = new WeakSet();
              addGrayConversion_fn = function(filter) {
                const feColorMatrix = __privateGet(this, _document).createElementNS(SVG_NS, "feColorMatrix");
                feColorMatrix.setAttribute("type", "matrix");
                feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
                filter.append(feColorMatrix);
              };
              _createFilter = new WeakSet();
              createFilter_fn = function(id) {
                const filter = __privateGet(this, _document).createElementNS(SVG_NS, "filter");
                filter.setAttribute("color-interpolation-filters", "sRGB");
                filter.setAttribute("id", id);
                __privateGet(this, _defs, defs_get).append(filter);
                return filter;
              };
              _appendFeFunc = new WeakSet();
              appendFeFunc_fn = function(feComponentTransfer, func, table) {
                const feFunc = __privateGet(this, _document).createElementNS(SVG_NS, func);
                feFunc.setAttribute("type", "discrete");
                feFunc.setAttribute("tableValues", table);
                feComponentTransfer.append(feFunc);
              };
              _addTransferMapConversion = new WeakSet();
              addTransferMapConversion_fn = function(rTable, gTable, bTable, filter) {
                const feComponentTransfer = __privateGet(this, _document).createElementNS(SVG_NS, "feComponentTransfer");
                filter.append(feComponentTransfer);
                __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncR", rTable);
                __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncG", gTable);
                __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncB", bTable);
              };
              _getRGB = new WeakSet();
              getRGB_fn = function(color) {
                __privateGet(this, _defs, defs_get).style.color = color;
                return getRGB(getComputedStyle(__privateGet(this, _defs, defs_get)).getPropertyValue("color"));
              };
              exports2.DOMFilterFactory = DOMFilterFactory;
              class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
                constructor({
                  ownerDocument = globalThis.document
                } = {}) {
                  super();
                  this._document = ownerDocument;
                }
                _createCanvas(width, height) {
                  const canvas = this._document.createElement("canvas");
                  canvas.width = width;
                  canvas.height = height;
                  return canvas;
                }
              }
              exports2.DOMCanvasFactory = DOMCanvasFactory;
              async function fetchData(url, asTypedArray = false) {
                if (isValidFetchUrl(url, document.baseURI)) {
                  const response = await fetch(url);
                  if (!response.ok) {
                    throw new Error(response.statusText);
                  }
                  return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util2.stringToBytes)(await response.text());
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url, true);
                  if (asTypedArray) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let data;
                      if (asTypedArray && request.response) {
                        data = new Uint8Array(request.response);
                      } else if (!asTypedArray && request.responseText) {
                        data = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (data) {
                        resolve(data);
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                });
              }
              class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url, compressionType) {
                  return fetchData(url, this.isCompressed).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
              class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url) {
                  return fetchData(url, true);
                }
              }
              exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
              class DOMSVGFactory extends _base_factory.BaseSVGFactory {
                _createSVG(type) {
                  return document.createElementNS(SVG_NS, type);
                }
              }
              exports2.DOMSVGFactory = DOMSVGFactory;
              class PageViewport {
                constructor({
                  viewBox,
                  scale,
                  rotation,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                }) {
                  this.viewBox = viewBox;
                  this.scale = scale;
                  this.rotation = rotation;
                  this.offsetX = offsetX;
                  this.offsetY = offsetY;
                  const centerX = (viewBox[2] + viewBox[0]) / 2;
                  const centerY = (viewBox[3] + viewBox[1]) / 2;
                  let rotateA, rotateB, rotateC, rotateD;
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  switch (rotation) {
                    case 180:
                      rotateA = -1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = 1;
                      break;
                    case 90:
                      rotateA = 0;
                      rotateB = 1;
                      rotateC = 1;
                      rotateD = 0;
                      break;
                    case 270:
                      rotateA = 0;
                      rotateB = -1;
                      rotateC = -1;
                      rotateD = 0;
                      break;
                    case 0:
                      rotateA = 1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = -1;
                      break;
                    default:
                      throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                  }
                  if (dontFlip) {
                    rotateC = -rotateC;
                    rotateD = -rotateD;
                  }
                  let offsetCanvasX, offsetCanvasY;
                  let width, height;
                  if (rotateA === 0) {
                    offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                    offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                    width = (viewBox[3] - viewBox[1]) * scale;
                    height = (viewBox[2] - viewBox[0]) * scale;
                  } else {
                    offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                    offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                    width = (viewBox[2] - viewBox[0]) * scale;
                    height = (viewBox[3] - viewBox[1]) * scale;
                  }
                  this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                  this.width = width;
                  this.height = height;
                }
                get rawDims() {
                  const {
                    viewBox
                  } = this;
                  return (0, _util2.shadow)(this, "rawDims", {
                    pageWidth: viewBox[2] - viewBox[0],
                    pageHeight: viewBox[3] - viewBox[1],
                    pageX: viewBox[0],
                    pageY: viewBox[1]
                  });
                }
                clone({
                  scale = this.scale,
                  rotation = this.rotation,
                  offsetX = this.offsetX,
                  offsetY = this.offsetY,
                  dontFlip = false
                } = {}) {
                  return new PageViewport({
                    viewBox: this.viewBox.slice(),
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                convertToViewportPoint(x3, y3) {
                  return _util2.Util.applyTransform([x3, y3], this.transform);
                }
                convertToViewportRectangle(rect) {
                  const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                  const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                }
                convertToPdfPoint(x3, y3) {
                  return _util2.Util.applyInverseTransform([x3, y3], this.transform);
                }
              }
              exports2.PageViewport = PageViewport;
              class RenderingCancelledException extends _util2.BaseException {
                constructor(msg, extraDelay = 0) {
                  super(msg, "RenderingCancelledException");
                  this.extraDelay = extraDelay;
                }
              }
              exports2.RenderingCancelledException = RenderingCancelledException;
              function isDataScheme(url) {
                const ii2 = url.length;
                let i3 = 0;
                while (i3 < ii2 && url[i3].trim() === "") {
                  i3++;
                }
                return url.substring(i3, i3 + 5).toLowerCase() === "data:";
              }
              function isPdfFile(filename) {
                return typeof filename === "string" && /\.pdf$/i.test(filename);
              }
              function getFilenameFromUrl(url, onlyStripPath = false) {
                if (!onlyStripPath) {
                  [url] = url.split(/[#?]/, 1);
                }
                return url.substring(url.lastIndexOf("/") + 1);
              }
              function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
                if (typeof url !== "string") {
                  return defaultFilename;
                }
                if (isDataScheme(url)) {
                  (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                  return defaultFilename;
                }
                const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
                const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
                const splitURI = reURI.exec(url);
                let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
                if (suggestedFilename) {
                  suggestedFilename = suggestedFilename[0];
                  if (suggestedFilename.includes("%")) {
                    try {
                      suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                    } catch {
                    }
                  }
                }
                return suggestedFilename || defaultFilename;
              }
              class StatTimer {
                constructor() {
                  __publicField(this, "started", /* @__PURE__ */ Object.create(null));
                  __publicField(this, "times", []);
                }
                time(name) {
                  if (name in this.started) {
                    (0, _util2.warn)(`Timer is already running for ${name}`);
                  }
                  this.started[name] = Date.now();
                }
                timeEnd(name) {
                  if (!(name in this.started)) {
                    (0, _util2.warn)(`Timer has not been started for ${name}`);
                  }
                  this.times.push({
                    name,
                    start: this.started[name],
                    end: Date.now()
                  });
                  delete this.started[name];
                }
                toString() {
                  const outBuf = [];
                  let longest = 0;
                  for (const {
                    name
                  } of this.times) {
                    longest = Math.max(name.length, longest);
                  }
                  for (const {
                    name,
                    start,
                    end
                  } of this.times) {
                    outBuf.push(`${name.padEnd(longest)} ${end - start}ms
`);
                  }
                  return outBuf.join("");
                }
              }
              exports2.StatTimer = StatTimer;
              function isValidFetchUrl(url, baseUrl) {
                try {
                  const {
                    protocol
                  } = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  return protocol === "http:" || protocol === "https:";
                } catch {
                  return false;
                }
              }
              function noContextMenu(e3) {
                e3.preventDefault();
              }
              function loadScript(src, removeScriptElement = false) {
                return new Promise((resolve, reject) => {
                  const script = document.createElement("script");
                  script.src = src;
                  script.onload = function(evt) {
                    if (removeScriptElement) {
                      script.remove();
                    }
                    resolve(evt);
                  };
                  script.onerror = function() {
                    reject(new Error(`Cannot load script at: ${script.src}`));
                  };
                  (document.head || document.documentElement).append(script);
                });
              }
              function deprecated(details) {
                console.log("Deprecated API usage: " + details);
              }
              let pdfDateStringRegex;
              class PDFDateString {
                static toDateObject(input) {
                  if (!input || typeof input !== "string") {
                    return null;
                  }
                  pdfDateStringRegex || (pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
                  const matches = pdfDateStringRegex.exec(input);
                  if (!matches) {
                    return null;
                  }
                  const year = parseInt(matches[1], 10);
                  let month = parseInt(matches[2], 10);
                  month = month >= 1 && month <= 12 ? month - 1 : 0;
                  let day = parseInt(matches[3], 10);
                  day = day >= 1 && day <= 31 ? day : 1;
                  let hour = parseInt(matches[4], 10);
                  hour = hour >= 0 && hour <= 23 ? hour : 0;
                  let minute = parseInt(matches[5], 10);
                  minute = minute >= 0 && minute <= 59 ? minute : 0;
                  let second = parseInt(matches[6], 10);
                  second = second >= 0 && second <= 59 ? second : 0;
                  const universalTimeRelation = matches[7] || "Z";
                  let offsetHour = parseInt(matches[8], 10);
                  offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                  let offsetMinute = parseInt(matches[9], 10) || 0;
                  offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                  if (universalTimeRelation === "-") {
                    hour += offsetHour;
                    minute += offsetMinute;
                  } else if (universalTimeRelation === "+") {
                    hour -= offsetHour;
                    minute -= offsetMinute;
                  }
                  return new Date(Date.UTC(year, month, day, hour, minute, second));
                }
              }
              exports2.PDFDateString = PDFDateString;
              function getXfaPageViewport(xfaPage, {
                scale = 1,
                rotation = 0
              }) {
                const {
                  width,
                  height
                } = xfaPage.attributes.style;
                const viewBox = [0, 0, parseInt(width), parseInt(height)];
                return new PageViewport({
                  viewBox,
                  scale,
                  rotation
                });
              }
              function getRGB(color) {
                if (color.startsWith("#")) {
                  const colorRGB = parseInt(color.slice(1), 16);
                  return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
                }
                if (color.startsWith("rgb(")) {
                  return color.slice(4, -1).split(",").map((x3) => parseInt(x3));
                }
                if (color.startsWith("rgba(")) {
                  return color.slice(5, -1).split(",").map((x3) => parseInt(x3)).slice(0, 3);
                }
                (0, _util2.warn)(`Not a valid color format: "${color}"`);
                return [0, 0, 0];
              }
              function getColorValues(colors) {
                const span = document.createElement("span");
                span.style.visibility = "hidden";
                document.body.append(span);
                for (const name of colors.keys()) {
                  span.style.color = name;
                  const computedColor = window.getComputedStyle(span).color;
                  colors.set(name, getRGB(computedColor));
                }
                span.remove();
              }
              function getCurrentTransform(ctx) {
                const {
                  a: a3,
                  b: b3,
                  c: c3,
                  d: d3,
                  e: e3,
                  f: f2
                } = ctx.getTransform();
                return [a3, b3, c3, d3, e3, f2];
              }
              function getCurrentTransformInverse(ctx) {
                const {
                  a: a3,
                  b: b3,
                  c: c3,
                  d: d3,
                  e: e3,
                  f: f2
                } = ctx.getTransform().invertSelf();
                return [a3, b3, c3, d3, e3, f2];
              }
              function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
                if (viewport instanceof PageViewport) {
                  const {
                    pageWidth,
                    pageHeight
                  } = viewport.rawDims;
                  const {
                    style
                  } = div;
                  const useRound = _util2.FeatureTest.isCSSRoundSupported;
                  const w3 = `var(--scale-factor) * ${pageWidth}px`, h2 = `var(--scale-factor) * ${pageHeight}px`;
                  const widthStr = useRound ? `round(${w3}, 1px)` : `calc(${w3})`, heightStr = useRound ? `round(${h2}, 1px)` : `calc(${h2})`;
                  if (!mustFlip || viewport.rotation % 180 === 0) {
                    style.width = widthStr;
                    style.height = heightStr;
                  } else {
                    style.width = heightStr;
                    style.height = widthStr;
                  }
                }
                if (mustRotate) {
                  div.setAttribute("data-main-rotation", viewport.rotation);
                }
              }
            },
            /* 7 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseFilterFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseFilterFactory {
                constructor() {
                  if (this.constructor === BaseFilterFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseFilterFactory.");
                  }
                }
                addFilter(maps) {
                  return "none";
                }
                addHCMFilter(fgColor, bgColor) {
                  return "none";
                }
                addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
                  return "none";
                }
                destroy(keepHCM = false) {
                }
              }
              exports2.BaseFilterFactory = BaseFilterFactory;
              class BaseCanvasFactory {
                constructor() {
                  if (this.constructor === BaseCanvasFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                  }
                }
                create(width, height) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  const canvas = this._createCanvas(width, height);
                  return {
                    canvas,
                    context: canvas.getContext("2d")
                  };
                }
                reset(canvasAndContext, width, height) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  canvasAndContext.canvas.width = width;
                  canvasAndContext.canvas.height = height;
                }
                destroy(canvasAndContext) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  canvasAndContext.canvas.width = 0;
                  canvasAndContext.canvas.height = 0;
                  canvasAndContext.canvas = null;
                  canvasAndContext.context = null;
                }
                _createCanvas(width, height) {
                  (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
                }
              }
              exports2.BaseCanvasFactory = BaseCanvasFactory;
              class BaseCMapReaderFactory {
                constructor({
                  baseUrl = null,
                  isCompressed = true
                }) {
                  if (this.constructor === BaseCMapReaderFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                  }
                  this.baseUrl = baseUrl;
                  this.isCompressed = isCompressed;
                }
                async fetch({
                  name
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                  }
                  if (!name) {
                    throw new Error("CMap name must be specified.");
                  }
                  const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                  const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                  return this._fetchData(url, compressionType).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                  });
                }
                _fetchData(url, compressionType) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
              class BaseStandardFontDataFactory {
                constructor({
                  baseUrl = null
                }) {
                  if (this.constructor === BaseStandardFontDataFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                  }
                  this.baseUrl = baseUrl;
                }
                async fetch({
                  filename
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                  }
                  if (!filename) {
                    throw new Error("Font filename must be specified.");
                  }
                  const url = `${this.baseUrl}${filename}`;
                  return this._fetchData(url).catch((reason) => {
                    throw new Error(`Unable to load font data at: ${url}`);
                  });
                }
                _fetchData(url) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
              class BaseSVGFactory {
                constructor() {
                  if (this.constructor === BaseSVGFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                  }
                }
                create(width, height, skipDimensions = false) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid SVG dimensions");
                  }
                  const svg = this._createSVG("svg:svg");
                  svg.setAttribute("version", "1.1");
                  if (!skipDimensions) {
                    svg.setAttribute("width", `${width}px`);
                    svg.setAttribute("height", `${height}px`);
                  }
                  svg.setAttribute("preserveAspectRatio", "none");
                  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
                  return svg;
                }
                createElement(type) {
                  if (typeof type !== "string") {
                    throw new Error("Invalid SVG element type");
                  }
                  return this._createSVG(type);
                }
                _createSVG(type) {
                  (0, _util2.unreachable)("Abstract method `_createSVG` called.");
                }
              }
              exports2.BaseSVGFactory = BaseSVGFactory;
            },
            /* 8 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const SEED = 3285377520;
              const MASK_HIGH = 4294901760;
              const MASK_LOW = 65535;
              class MurmurHash3_642 {
                constructor(seed) {
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                update(input) {
                  let data, length;
                  if (typeof input === "string") {
                    data = new Uint8Array(input.length * 2);
                    length = 0;
                    for (let i3 = 0, ii2 = input.length; i3 < ii2; i3++) {
                      const code = input.charCodeAt(i3);
                      if (code <= 255) {
                        data[length++] = code;
                      } else {
                        data[length++] = code >>> 8;
                        data[length++] = code & 255;
                      }
                    }
                  } else if ((0, _util2.isArrayBuffer)(input)) {
                    data = input.slice();
                    length = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  const blockCounts = length >> 2;
                  const tailLength = length - blockCounts * 4;
                  const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  let k1 = 0, k22 = 0;
                  let h1 = this.h1, h2 = this.h2;
                  const C1 = 3432918353, C22 = 461845907;
                  const C1_LOW = C1 & MASK_LOW, C2_LOW = C22 & MASK_LOW;
                  for (let i3 = 0; i3 < blockCounts; i3++) {
                    if (i3 & 1) {
                      k1 = dataUint32[i3];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C22 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k22 = dataUint32[i3];
                      k22 = k22 * C1 & MASK_HIGH | k22 * C1_LOW & MASK_LOW;
                      k22 = k22 << 15 | k22 >>> 17;
                      k22 = k22 * C22 & MASK_HIGH | k22 * C2_LOW & MASK_LOW;
                      h2 ^= k22;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C22 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                }
                hexdigest() {
                  let h1 = this.h1, h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
                }
              }
              exports2.MurmurHash3_64 = MurmurHash3_642;
            },
            /* 9 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _systemFonts;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontLoader = exports2.FontFaceObject = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class FontLoader {
                constructor({
                  ownerDocument = globalThis.document,
                  styleElement = null
                }) {
                  __privateAdd(this, _systemFonts, /* @__PURE__ */ new Set());
                  this._document = ownerDocument;
                  this.nativeFontFaces = /* @__PURE__ */ new Set();
                  this.styleElement = null;
                  this.loadingRequests = [];
                  this.loadTestFontId = 0;
                }
                addNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.add(nativeFontFace);
                  this._document.fonts.add(nativeFontFace);
                }
                removeNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.delete(nativeFontFace);
                  this._document.fonts.delete(nativeFontFace);
                }
                insertRule(rule) {
                  if (!this.styleElement) {
                    this.styleElement = this._document.createElement("style");
                    this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
                  }
                  const styleSheet = this.styleElement.sheet;
                  styleSheet.insertRule(rule, styleSheet.cssRules.length);
                }
                clear() {
                  for (const nativeFontFace of this.nativeFontFaces) {
                    this._document.fonts.delete(nativeFontFace);
                  }
                  this.nativeFontFaces.clear();
                  __privateGet(this, _systemFonts).clear();
                  if (this.styleElement) {
                    this.styleElement.remove();
                    this.styleElement = null;
                  }
                }
                async loadSystemFont(info2) {
                  if (!info2 || __privateGet(this, _systemFonts).has(info2.loadedName)) {
                    return;
                  }
                  (0, _util2.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
                  if (this.isFontLoadingAPISupported) {
                    const {
                      loadedName,
                      src,
                      style
                    } = info2;
                    const fontFace = new FontFace(loadedName, src, style);
                    this.addNativeFontFace(fontFace);
                    try {
                      await fontFace.load();
                      __privateGet(this, _systemFonts).add(loadedName);
                    } catch {
                      (0, _util2.warn)(`Cannot load system font: ${info2.baseFontName}, installing it could help to improve PDF rendering.`);
                      this.removeNativeFontFace(fontFace);
                    }
                    return;
                  }
                  (0, _util2.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
                }
                async bind(font) {
                  if (font.attached || font.missingFile && !font.systemFontInfo) {
                    return;
                  }
                  font.attached = true;
                  if (font.systemFontInfo) {
                    await this.loadSystemFont(font.systemFontInfo);
                    return;
                  }
                  if (this.isFontLoadingAPISupported) {
                    const nativeFontFace = font.createNativeFontFace();
                    if (nativeFontFace) {
                      this.addNativeFontFace(nativeFontFace);
                      try {
                        await nativeFontFace.loaded;
                      } catch (ex) {
                        (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                        font.disableFontFace = true;
                        throw ex;
                      }
                    }
                    return;
                  }
                  const rule = font.createFontFaceRule();
                  if (rule) {
                    this.insertRule(rule);
                    if (this.isSyncFontLoadingSupported) {
                      return;
                    }
                    await new Promise((resolve) => {
                      const request = this._queueLoadingCallback(resolve);
                      this._prepareFontLoadEvent(font, request);
                    });
                  }
                }
                get isFontLoadingAPISupported() {
                  var _a3;
                  const hasFonts = !!((_a3 = this._document) == null ? void 0 : _a3.fonts);
                  return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
                }
                get isSyncFontLoadingSupported() {
                  let supported = false;
                  if (_util2.isNodeJS) {
                    supported = true;
                  } else if (typeof navigator !== "undefined" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) {
                    supported = true;
                  }
                  return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                }
                _queueLoadingCallback(callback) {
                  function completeRequest() {
                    (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                    request.done = true;
                    while (loadingRequests.length > 0 && loadingRequests[0].done) {
                      const otherRequest = loadingRequests.shift();
                      setTimeout(otherRequest.callback, 0);
                    }
                  }
                  const {
                    loadingRequests
                  } = this;
                  const request = {
                    done: false,
                    complete: completeRequest,
                    callback
                  };
                  loadingRequests.push(request);
                  return request;
                }
                get _loadTestFont() {
                  const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                  return (0, _util2.shadow)(this, "_loadTestFont", testFont);
                }
                _prepareFontLoadEvent(font, request) {
                  function int32(data2, offset) {
                    return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                  }
                  function spliceString(s3, offset, remove, insert) {
                    const chunk1 = s3.substring(0, offset);
                    const chunk2 = s3.substring(offset + remove);
                    return chunk1 + insert + chunk2;
                  }
                  let i3, ii2;
                  const canvas = this._document.createElement("canvas");
                  canvas.width = 1;
                  canvas.height = 1;
                  const ctx = canvas.getContext("2d");
                  let called = 0;
                  function isFontReady(name, callback) {
                    if (++called > 30) {
                      (0, _util2.warn)("Load test font never loaded.");
                      callback();
                      return;
                    }
                    ctx.font = "30px " + name;
                    ctx.fillText(".", 0, 20);
                    const imageData = ctx.getImageData(0, 0, 1, 1);
                    if (imageData.data[3] > 0) {
                      callback();
                      return;
                    }
                    setTimeout(isFontReady.bind(null, name, callback));
                  }
                  const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                  let data = this._loadTestFont;
                  const COMMENT_OFFSET = 976;
                  data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                  const CFF_CHECKSUM_OFFSET = 16;
                  const XXXX_VALUE = 1482184792;
                  let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                  for (i3 = 0, ii2 = loadTestFontId.length - 3; i3 < ii2; i3 += 4) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i3) | 0;
                  }
                  if (i3 < loadTestFontId.length) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i3) | 0;
                  }
                  data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                  const url = `url(data:font/opentype;base64,${btoa(data)});`;
                  const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
                  this.insertRule(rule);
                  const div = this._document.createElement("div");
                  div.style.visibility = "hidden";
                  div.style.width = div.style.height = "10px";
                  div.style.position = "absolute";
                  div.style.top = div.style.left = "0px";
                  for (const name of [font.loadedName, loadTestFontId]) {
                    const span = this._document.createElement("span");
                    span.textContent = "Hi";
                    span.style.fontFamily = name;
                    div.append(span);
                  }
                  this._document.body.append(div);
                  isFontReady(loadTestFontId, () => {
                    div.remove();
                    request.complete();
                  });
                }
              }
              _systemFonts = new WeakMap();
              exports2.FontLoader = FontLoader;
              class FontFaceObject {
                constructor(translatedData, {
                  isEvalSupported = true,
                  disableFontFace = false,
                  ignoreErrors = false,
                  inspectFont = null
                }) {
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  for (const i3 in translatedData) {
                    this[i3] = translatedData[i3];
                  }
                  this.isEvalSupported = isEvalSupported !== false;
                  this.disableFontFace = disableFontFace === true;
                  this.ignoreErrors = ignoreErrors === true;
                  this._inspectFont = inspectFont;
                }
                createNativeFontFace() {
                  var _a3;
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  let nativeFontFace;
                  if (!this.cssFontInfo) {
                    nativeFontFace = new FontFace(this.loadedName, this.data, {});
                  } else {
                    const css = {
                      weight: this.cssFontInfo.fontWeight
                    };
                    if (this.cssFontInfo.italicAngle) {
                      css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
                    }
                    nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                  }
                  (_a3 = this._inspectFont) == null ? void 0 : _a3.call(this, this);
                  return nativeFontFace;
                }
                createFontFaceRule() {
                  var _a3;
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  const data = (0, _util2.bytesToString)(this.data);
                  const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
                  let rule;
                  if (!this.cssFontInfo) {
                    rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
                  } else {
                    let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
                    if (this.cssFontInfo.italicAngle) {
                      css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
                    }
                    rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
                  }
                  (_a3 = this._inspectFont) == null ? void 0 : _a3.call(this, this, url);
                  return rule;
                }
                getPathGenerator(objs, character) {
                  if (this.compiledGlyphs[character] !== void 0) {
                    return this.compiledGlyphs[character];
                  }
                  let cmds;
                  try {
                    cmds = objs.get(this.loadedName + "_path_" + character);
                  } catch (ex) {
                    if (!this.ignoreErrors) {
                      throw ex;
                    }
                    (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                    return this.compiledGlyphs[character] = function(c3, size) {
                    };
                  }
                  if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                    const jsBuf = [];
                    for (const current of cmds) {
                      const args = current.args !== void 0 ? current.args.join(",") : "";
                      jsBuf.push("c.", current.cmd, "(", args, ");\n");
                    }
                    return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                  }
                  return this.compiledGlyphs[character] = function(c3, size) {
                    for (const current of cmds) {
                      if (current.cmd === "scale") {
                        current.args = [size, -size];
                      }
                      c3[current.cmd].apply(c3, current.args);
                    }
                  };
                }
              }
              exports2.FontFaceObject = FontFaceObject;
            },
            /* 10 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NodeStandardFontDataFactory = exports2.NodeFilterFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
              var _base_factory = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              ;
              ;
              const fetchData = function(url) {
                return new Promise((resolve, reject) => {
                  const fs2 = require_fs();
                  fs2.readFile(url, (error, data) => {
                    if (error || !data) {
                      reject(new Error(error));
                      return;
                    }
                    resolve(new Uint8Array(data));
                  });
                });
              };
              class NodeFilterFactory extends _base_factory.BaseFilterFactory {
              }
              exports2.NodeFilterFactory = NodeFilterFactory;
              class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
                _createCanvas(width, height) {
                  const Canvas = require_canvas();
                  return Canvas.createCanvas(width, height);
                }
              }
              exports2.NodeCanvasFactory = NodeCanvasFactory;
              class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url, compressionType) {
                  return fetchData(url).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
              class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url) {
                  return fetchData(url);
                }
              }
              exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
            },
            /* 11 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _restoreInitialState, restoreInitialState_fn, _drawFilter, drawFilter_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CanvasGraphics = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _pattern_helper = __w_pdfjs_require__2(12);
              var _image_utils = __w_pdfjs_require__2(13);
              const MIN_FONT_SIZE = 16;
              const MAX_FONT_SIZE = 100;
              const MAX_GROUP_SIZE = 4096;
              const EXECUTION_TIME = 15;
              const EXECUTION_STEPS = 10;
              const MAX_SIZE_TO_COMPILE = 1e3;
              const FULL_CHUNK_HEIGHT = 16;
              function mirrorContextOperations(ctx, destCtx) {
                if (ctx._removeMirroring) {
                  throw new Error("Context is already forwarding operations.");
                }
                ctx.__originalSave = ctx.save;
                ctx.__originalRestore = ctx.restore;
                ctx.__originalRotate = ctx.rotate;
                ctx.__originalScale = ctx.scale;
                ctx.__originalTranslate = ctx.translate;
                ctx.__originalTransform = ctx.transform;
                ctx.__originalSetTransform = ctx.setTransform;
                ctx.__originalResetTransform = ctx.resetTransform;
                ctx.__originalClip = ctx.clip;
                ctx.__originalMoveTo = ctx.moveTo;
                ctx.__originalLineTo = ctx.lineTo;
                ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
                ctx.__originalRect = ctx.rect;
                ctx.__originalClosePath = ctx.closePath;
                ctx.__originalBeginPath = ctx.beginPath;
                ctx._removeMirroring = () => {
                  ctx.save = ctx.__originalSave;
                  ctx.restore = ctx.__originalRestore;
                  ctx.rotate = ctx.__originalRotate;
                  ctx.scale = ctx.__originalScale;
                  ctx.translate = ctx.__originalTranslate;
                  ctx.transform = ctx.__originalTransform;
                  ctx.setTransform = ctx.__originalSetTransform;
                  ctx.resetTransform = ctx.__originalResetTransform;
                  ctx.clip = ctx.__originalClip;
                  ctx.moveTo = ctx.__originalMoveTo;
                  ctx.lineTo = ctx.__originalLineTo;
                  ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                  ctx.rect = ctx.__originalRect;
                  ctx.closePath = ctx.__originalClosePath;
                  ctx.beginPath = ctx.__originalBeginPath;
                  delete ctx._removeMirroring;
                };
                ctx.save = function ctxSave() {
                  destCtx.save();
                  this.__originalSave();
                };
                ctx.restore = function ctxRestore() {
                  destCtx.restore();
                  this.__originalRestore();
                };
                ctx.translate = function ctxTranslate(x3, y3) {
                  destCtx.translate(x3, y3);
                  this.__originalTranslate(x3, y3);
                };
                ctx.scale = function ctxScale(x3, y3) {
                  destCtx.scale(x3, y3);
                  this.__originalScale(x3, y3);
                };
                ctx.transform = function ctxTransform(a3, b3, c3, d3, e3, f2) {
                  destCtx.transform(a3, b3, c3, d3, e3, f2);
                  this.__originalTransform(a3, b3, c3, d3, e3, f2);
                };
                ctx.setTransform = function ctxSetTransform(a3, b3, c3, d3, e3, f2) {
                  destCtx.setTransform(a3, b3, c3, d3, e3, f2);
                  this.__originalSetTransform(a3, b3, c3, d3, e3, f2);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  destCtx.resetTransform();
                  this.__originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle) {
                  destCtx.rotate(angle);
                  this.__originalRotate(angle);
                };
                ctx.clip = function ctxRotate(rule) {
                  destCtx.clip(rule);
                  this.__originalClip(rule);
                };
                ctx.moveTo = function(x3, y3) {
                  destCtx.moveTo(x3, y3);
                  this.__originalMoveTo(x3, y3);
                };
                ctx.lineTo = function(x3, y3) {
                  destCtx.lineTo(x3, y3);
                  this.__originalLineTo(x3, y3);
                };
                ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x3, y3) {
                  destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3);
                  this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3);
                };
                ctx.rect = function(x3, y3, width, height) {
                  destCtx.rect(x3, y3, width, height);
                  this.__originalRect(x3, y3, width, height);
                };
                ctx.closePath = function() {
                  destCtx.closePath();
                  this.__originalClosePath();
                };
                ctx.beginPath = function() {
                  destCtx.beginPath();
                  this.__originalBeginPath();
                };
              }
              class CachedCanvases {
                constructor(canvasFactory) {
                  this.canvasFactory = canvasFactory;
                  this.cache = /* @__PURE__ */ Object.create(null);
                }
                getCanvas(id, width, height) {
                  let canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  return canvasEntry;
                }
                delete(id) {
                  delete this.cache[id];
                }
                clear() {
                  for (const id in this.cache) {
                    const canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              }
              function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
                const [a3, b3, c3, d3, tx, ty] = (0, _display_utils2.getCurrentTransform)(ctx);
                if (b3 === 0 && c3 === 0) {
                  const tlX = destX * a3 + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destY * d3 + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destX + destW) * a3 + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destY + destH) * d3 + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(Math.sign(a3), 0, 0, Math.sign(d3), rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                  ctx.setTransform(a3, b3, c3, d3, tx, ty);
                  return [rWidth, rHeight];
                }
                if (a3 === 0 && d3 === 0) {
                  const tlX = destY * c3 + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destX * b3 + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destY + destH) * c3 + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destX + destW) * b3 + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(0, Math.sign(b3), Math.sign(c3), 0, rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
                  ctx.setTransform(a3, b3, c3, d3, tx, ty);
                  return [rHeight, rWidth];
                }
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                const scaleX = Math.hypot(a3, b3);
                const scaleY = Math.hypot(c3, d3);
                return [scaleX * destW, scaleY * destH];
              }
              function compileType3Glyph(imgData) {
                const {
                  width,
                  height
                } = imgData;
                if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
                  return null;
                }
                const POINT_TO_PROCESS_LIMIT = 1e3;
                const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                const width1 = width + 1;
                let points = new Uint8Array(width1 * (height + 1));
                let i3, j3, j0;
                const lineSize = width + 7 & ~7;
                let data = new Uint8Array(lineSize * height), pos = 0;
                for (const elem of imgData.data) {
                  let mask = 128;
                  while (mask > 0) {
                    data[pos++] = elem & mask ? 0 : 255;
                    mask >>= 1;
                  }
                }
                let count = 0;
                pos = 0;
                if (data[pos] !== 0) {
                  points[0] = 1;
                  ++count;
                }
                for (j3 = 1; j3 < width; j3++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j3] = data[pos] ? 2 : 1;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j3] = 2;
                  ++count;
                }
                for (i3 = 1; i3 < height; i3++) {
                  pos = i3 * lineSize;
                  j0 = i3 * width1;
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0] = data[pos] ? 1 : 8;
                    ++count;
                  }
                  let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                  for (j3 = 1; j3 < width; j3++) {
                    sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                    if (POINT_TYPES[sum]) {
                      points[j0 + j3] = POINT_TYPES[sum];
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0 + j3] = data[pos] ? 2 : 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                }
                pos = lineSize * (height - 1);
                j0 = i3 * width1;
                if (data[pos] !== 0) {
                  points[j0] = 8;
                  ++count;
                }
                for (j3 = 1; j3 < width; j3++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j0 + j3] = data[pos] ? 4 : 8;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j0 + j3] = 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
                const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                const path = new Path2D();
                for (i3 = 0; count && i3 <= height; i3++) {
                  let p2 = i3 * width1;
                  const end = p2 + width;
                  while (p2 < end && !points[p2]) {
                    p2++;
                  }
                  if (p2 === end) {
                    continue;
                  }
                  path.moveTo(p2 % width1, i3);
                  const p0 = p2;
                  let type = points[p2];
                  do {
                    const step = steps[type];
                    do {
                      p2 += step;
                    } while (!points[p2]);
                    const pp = points[p2];
                    if (pp !== 5 && pp !== 10) {
                      type = pp;
                      points[p2] = 0;
                    } else {
                      type = pp & 51 * type >> 4;
                      points[p2] &= type >> 2 | type << 2;
                    }
                    path.lineTo(p2 % width1, p2 / width1 | 0);
                    if (!points[p2]) {
                      --count;
                    }
                  } while (p0 !== p2);
                  --i3;
                }
                data = null;
                points = null;
                const drawOutline = function(c3) {
                  c3.save();
                  c3.scale(1 / width, -1 / height);
                  c3.translate(0, -height);
                  c3.fill(path);
                  c3.beginPath();
                  c3.restore();
                };
                return drawOutline;
              }
              class CanvasExtraState {
                constructor(width, height) {
                  this.alphaIsShape = false;
                  this.fontSize = 0;
                  this.fontSizeScale = 1;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.textMatrixScale = 1;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textRise = 0;
                  this.fillColor = "#000000";
                  this.strokeColor = "#000000";
                  this.patternFill = false;
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.activeSMask = null;
                  this.transferMaps = "none";
                  this.startNewPathAndClipBox([0, 0, width, height]);
                }
                clone() {
                  const clone = Object.create(this);
                  clone.clipBox = this.clipBox.slice();
                  return clone;
                }
                setCurrentPoint(x3, y3) {
                  this.x = x3;
                  this.y = y3;
                }
                updatePathMinMax(transform, x3, y3) {
                  [x3, y3] = _util2.Util.applyTransform([x3, y3], transform);
                  this.minX = Math.min(this.minX, x3);
                  this.minY = Math.min(this.minY, y3);
                  this.maxX = Math.max(this.maxX, x3);
                  this.maxY = Math.max(this.maxY, y3);
                }
                updateRectMinMax(transform, rect) {
                  const p1 = _util2.Util.applyTransform(rect, transform);
                  const p2 = _util2.Util.applyTransform(rect.slice(2), transform);
                  this.minX = Math.min(this.minX, p1[0], p2[0]);
                  this.minY = Math.min(this.minY, p1[1], p2[1]);
                  this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                  this.maxY = Math.max(this.maxY, p1[1], p2[1]);
                }
                updateScalingPathMinMax(transform, minMax) {
                  _util2.Util.scaleMinMax(transform, minMax);
                  this.minX = Math.min(this.minX, minMax[0]);
                  this.maxX = Math.max(this.maxX, minMax[1]);
                  this.minY = Math.min(this.minY, minMax[2]);
                  this.maxY = Math.max(this.maxY, minMax[3]);
                }
                updateCurvePathMinMax(transform, x0, y0, x1, y1, x22, y22, x3, y3, minMax) {
                  const box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x22, y22, x3, y3);
                  if (minMax) {
                    minMax[0] = Math.min(minMax[0], box[0], box[2]);
                    minMax[1] = Math.max(minMax[1], box[0], box[2]);
                    minMax[2] = Math.min(minMax[2], box[1], box[3]);
                    minMax[3] = Math.max(minMax[3], box[1], box[3]);
                    return;
                  }
                  this.updateRectMinMax(transform, box);
                }
                getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                  const box = [this.minX, this.minY, this.maxX, this.maxY];
                  if (pathType === _pattern_helper.PathType.STROKE) {
                    if (!transform) {
                      (0, _util2.unreachable)("Stroke bounding box must include transform.");
                    }
                    const scale = _util2.Util.singularValueDecompose2dScale(transform);
                    const xStrokePad = scale[0] * this.lineWidth / 2;
                    const yStrokePad = scale[1] * this.lineWidth / 2;
                    box[0] -= xStrokePad;
                    box[1] -= yStrokePad;
                    box[2] += xStrokePad;
                    box[3] += yStrokePad;
                  }
                  return box;
                }
                updateClipFromPath() {
                  const intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                  this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
                }
                isEmptyClip() {
                  return this.minX === Infinity;
                }
                startNewPathAndClipBox(box) {
                  this.clipBox = box;
                  this.minX = Infinity;
                  this.minY = Infinity;
                  this.maxX = 0;
                  this.maxY = 0;
                }
                getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                  return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
                }
              }
              function putBinaryImageData(ctx, imgData) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0, destPos;
                const src = imgData.data;
                const dest = chunkImgData.data;
                let i3, j3, thisChunkHeight, elemsInThisChunk;
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  const srcLength = src.byteLength;
                  const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  const dest32DataLength = dest32.length;
                  const fullSrcDiff = width + 7 >> 3;
                  const white = 4294967295;
                  const black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                  for (i3 = 0; i3 < totalChunks; i3++) {
                    thisChunkHeight = i3 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j3 = 0; j3 < thisChunkHeight; j3++) {
                      const srcDiff = srcLength - srcPos;
                      let k3 = 0;
                      const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      const kEndUnrolled = kEnd & ~7;
                      let mask = 0;
                      let srcByte = 0;
                      for (; k3 < kEndUnrolled; k3 += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k3 < kEnd; k3++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i3 * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  j3 = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i3 = 0; i3 < fullChunks; i3++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    ctx.putImageData(chunkImgData, 0, j3);
                    j3 += FULL_CHUNK_HEIGHT;
                  }
                  if (i3 < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    ctx.putImageData(chunkImgData, 0, j3);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i3 = 0; i3 < totalChunks; i3++) {
                    if (i3 >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j3 = elemsInThisChunk; j3--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    ctx.putImageData(chunkImgData, 0, i3 * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                if (imgData.bitmap) {
                  ctx.drawImage(imgData.bitmap, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0;
                const src = imgData.data;
                const dest = chunkImgData.data;
                for (let i3 = 0; i3 < totalChunks; i3++) {
                  const thisChunkHeight = i3 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  ({
                    srcPos
                  } = (0, _image_utils.convertBlackAndWhiteToRGBA)({
                    src,
                    srcPos,
                    dest,
                    width,
                    height: thisChunkHeight,
                    nonBlackColor: 0
                  }));
                  ctx.putImageData(chunkImgData, 0, i3 * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
                for (const property of properties) {
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx) {
                ctx.strokeStyle = ctx.fillStyle = "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
                if (!_util2.isNodeJS) {
                  const {
                    filter
                  } = ctx;
                  if (filter !== "none" && filter !== "") {
                    ctx.filter = "none";
                  }
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                const length = bytes.length;
                for (let i3 = 3; i3 < length; i3 += 4) {
                  const alpha = bytes[i3];
                  if (alpha === 0) {
                    bytes[i3 - 3] = r0;
                    bytes[i3 - 2] = g0;
                    bytes[i3 - 1] = b0;
                  } else if (alpha < 255) {
                    const alpha_ = 255 - alpha;
                    bytes[i3 - 3] = bytes[i3 - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i3 - 2] = bytes[i3 - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i3 - 1] = bytes[i3 - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                const length = maskData.length;
                const scale = 1 / 255;
                for (let i3 = 3; i3 < length; i3 += 4) {
                  const alpha = transferMap ? transferMap[maskData[i3]] : maskData[i3];
                  layerData[i3] = layerData[i3] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                const length = maskData.length;
                for (let i3 = 3; i3 < length; i3 += 4) {
                  const y3 = maskData[i3 - 3] * 77 + maskData[i3 - 2] * 152 + maskData[i3 - 1] * 28;
                  layerData[i3] = transferMap ? layerData[i3] * transferMap[y3 >> 8] >> 8 : layerData[i3] * y3 >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
                const hasBackdrop = !!backdrop;
                const r0 = hasBackdrop ? backdrop[0] : 0;
                const g0 = hasBackdrop ? backdrop[1] : 0;
                const b0 = hasBackdrop ? backdrop[2] : 0;
                const composeFn = subtype === "Luminosity" ? composeSMaskLuminosity : composeSMaskAlpha;
                const PIXELS_TO_PROCESS = 1048576;
                const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (let row = 0; row < height; row += chunkSize) {
                  const chunkHeight = Math.min(chunkSize, height - row);
                  const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
                  const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
                }
              }
              function composeSMask(ctx, smask, layerCtx, layerBox) {
                const layerOffsetX = layerBox[0];
                const layerOffsetY = layerBox[1];
                const layerWidth = layerBox[2] - layerOffsetX;
                const layerHeight = layerBox[3] - layerOffsetY;
                if (layerWidth === 0 || layerHeight === 0) {
                  return;
                }
                genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(layerCtx.canvas, 0, 0);
                ctx.restore();
              }
              function getImageSmoothingEnabled(transform, interpolate) {
                const scale = _util2.Util.singularValueDecompose2dScale(transform);
                scale[0] = Math.fround(scale[0]);
                scale[1] = Math.fround(scale[1]);
                const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                if (interpolate !== void 0) {
                  return interpolate;
                } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
                  return true;
                }
                return false;
              }
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const NORMAL_CLIP = {};
              const EO_CLIP = {};
              const _CanvasGraphics = class _CanvasGraphics {
                constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
                  optionalContentConfig,
                  markedContentStack = null
                }, annotationCanvasMap, pageColors) {
                  __privateAdd(this, _restoreInitialState);
                  __privateAdd(this, _drawFilter);
                  this.ctx = canvasCtx;
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.stateStack = [];
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.res = null;
                  this.xobjs = null;
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.canvasFactory = canvasFactory;
                  this.filterFactory = filterFactory;
                  this.groupStack = [];
                  this.processingType3 = null;
                  this.baseTransform = null;
                  this.baseTransformStack = [];
                  this.groupLevel = 0;
                  this.smaskStack = [];
                  this.smaskCounter = 0;
                  this.tempSMask = null;
                  this.suspendedCtx = null;
                  this.contentVisible = true;
                  this.markedContentStack = markedContentStack || [];
                  this.optionalContentConfig = optionalContentConfig;
                  this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                  this.cachedPatterns = /* @__PURE__ */ new Map();
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.viewportScale = 1;
                  this.outputScaleX = 1;
                  this.outputScaleY = 1;
                  this.pageColors = pageColors;
                  this._cachedScaleForStroking = [-1, 0];
                  this._cachedGetSinglePixelWidth = null;
                  this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                }
                getObject(data, fallback = null) {
                  if (typeof data === "string") {
                    return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                  }
                  return fallback;
                }
                beginDrawing({
                  transform,
                  viewport,
                  transparency = false,
                  background = null
                }) {
                  const width = this.ctx.canvas.width;
                  const height = this.ctx.canvas.height;
                  const savedFillStyle = this.ctx.fillStyle;
                  this.ctx.fillStyle = background || "#ffffff";
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.fillStyle = savedFillStyle;
                  if (transparency) {
                    const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform(...(0, _display_utils2.getCurrentTransform)(this.compositeCtx));
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx);
                  if (transform) {
                    this.ctx.transform(...transform);
                    this.outputScaleX = transform[0];
                    this.outputScaleY = transform[0];
                  }
                  this.ctx.transform(...viewport.transform);
                  this.viewportScale = viewport.scale;
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                }
                executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  let i3 = executionStartIdx || 0;
                  const argsArrayLen = argsArray.length;
                  if (argsArrayLen === i3) {
                    return i3;
                  }
                  const chunkOperations = argsArrayLen - i3 > EXECUTION_STEPS && typeof continueCallback === "function";
                  const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  let steps = 0;
                  const commonObjs = this.commonObjs;
                  const objs = this.objs;
                  let fnId;
                  while (true) {
                    if (stepper !== void 0 && i3 === stepper.nextBreakPoint) {
                      stepper.breakIt(i3, continueCallback);
                      return i3;
                    }
                    fnId = fnArray[i3];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i3]);
                    } else {
                      for (const depObjId of argsArray[i3]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i3;
                        }
                      }
                    }
                    i3++;
                    if (i3 === argsArrayLen) {
                      return i3;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i3;
                      }
                      steps = 0;
                    }
                  }
                }
                endDrawing() {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  this.cachedCanvases.clear();
                  this.cachedPatterns.clear();
                  for (const cache of this._cachedBitmapsMap.values()) {
                    for (const canvas of cache.values()) {
                      if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                        canvas.width = canvas.height = 0;
                      }
                    }
                    cache.clear();
                  }
                  this._cachedBitmapsMap.clear();
                  __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
                }
                _scaleImage(img, inverseTransform) {
                  const width = img.width;
                  const height = img.height;
                  let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                  let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                  let paintWidth = width, paintHeight = height;
                  let tmpCanvasId = "prescale1";
                  let tmpCanvas, tmpCtx;
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    let newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    img = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  return {
                    img,
                    paintWidth,
                    paintHeight
                  };
                }
                _createMaskCanvas(img) {
                  const ctx = this.ctx;
                  const {
                    width,
                    height
                  } = img;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  let cache, cacheKey, scaled, maskCanvas;
                  if ((img.bitmap || img.data) && img.count > 1) {
                    const mainKey = img.bitmap || img.data.buffer;
                    cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
                    cache = this._cachedBitmapsMap.get(mainKey);
                    if (!cache) {
                      cache = /* @__PURE__ */ new Map();
                      this._cachedBitmapsMap.set(mainKey, cache);
                    }
                    const cachedImage = cache.get(cacheKey);
                    if (cachedImage && !isPatternFill) {
                      const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                      const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                      return {
                        canvas: cachedImage,
                        offsetX: offsetX2,
                        offsetY: offsetY2
                      };
                    }
                    scaled = cachedImage;
                  }
                  if (!scaled) {
                    maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    putBinaryImageMask(maskCanvas.context, img);
                  }
                  let maskToCanvas = _util2.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
                  maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
                  const cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                  const cord2 = _util2.Util.applyTransform([width, height], maskToCanvas);
                  const rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                  const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                  const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                  const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
                  const fillCtx = fillCanvas.context;
                  const offsetX = Math.min(cord1[0], cord2[0]);
                  const offsetY = Math.min(cord1[1], cord2[1]);
                  fillCtx.translate(-offsetX, -offsetY);
                  fillCtx.transform(...maskToCanvas);
                  if (!scaled) {
                    scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils2.getCurrentTransformInverse)(fillCtx));
                    scaled = scaled.img;
                    if (cache && isPatternFill) {
                      cache.set(cacheKey, scaled);
                    }
                  }
                  fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(fillCtx), img.interpolate);
                  drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
                  fillCtx.globalCompositeOperation = "source-in";
                  const inverse = _util2.Util.transform((0, _display_utils2.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
                  fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
                  fillCtx.fillRect(0, 0, width, height);
                  if (cache && !isPatternFill) {
                    this.cachedCanvases.delete("fillCanvas");
                    cache.set(cacheKey, fillCanvas.canvas);
                  }
                  return {
                    canvas: fillCanvas.canvas,
                    offsetX: Math.round(offsetX),
                    offsetY: Math.round(offsetY)
                  };
                }
                setLineWidth(width) {
                  if (width !== this.current.lineWidth) {
                    this._cachedScaleForStroking[0] = -1;
                  }
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                }
                setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                }
                setDash(dashArray, dashPhase) {
                  const ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (const [key, value] of states) {
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = value;
                        break;
                      case "ca":
                        this.current.fillAlpha = value;
                        this.ctx.globalAlpha = value;
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        this.current.activeSMask = value ? this.tempSMask : null;
                        this.tempSMask = null;
                        this.checkSMaskState();
                        break;
                      case "TR":
                        this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
                        break;
                    }
                  }
                }
                get inSMaskMode() {
                  return !!this.suspendedCtx;
                }
                checkSMaskState() {
                  const inSMaskMode = this.inSMaskMode;
                  if (this.current.activeSMask && !inSMaskMode) {
                    this.beginSMaskMode();
                  } else if (!this.current.activeSMask && inSMaskMode) {
                    this.endSMaskMode();
                  }
                }
                beginSMaskMode() {
                  if (this.inSMaskMode) {
                    throw new Error("beginSMaskMode called while already in smask mode");
                  }
                  const drawnWidth = this.ctx.canvas.width;
                  const drawnHeight = this.ctx.canvas.height;
                  const cacheId = "smaskGroupAt" + this.groupLevel;
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  this.suspendedCtx = this.ctx;
                  this.ctx = scratchCanvas.context;
                  const ctx = this.ctx;
                  ctx.setTransform(...(0, _display_utils2.getCurrentTransform)(this.suspendedCtx));
                  copyCtxState(this.suspendedCtx, ctx);
                  mirrorContextOperations(ctx, this.suspendedCtx);
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                }
                endSMaskMode() {
                  if (!this.inSMaskMode) {
                    throw new Error("endSMaskMode called while not in smask mode");
                  }
                  this.ctx._removeMirroring();
                  copyCtxState(this.ctx, this.suspendedCtx);
                  this.ctx = this.suspendedCtx;
                  this.suspendedCtx = null;
                }
                compose(dirtyBox) {
                  if (!this.current.activeSMask) {
                    return;
                  }
                  if (!dirtyBox) {
                    dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                  } else {
                    dirtyBox[0] = Math.floor(dirtyBox[0]);
                    dirtyBox[1] = Math.floor(dirtyBox[1]);
                    dirtyBox[2] = Math.ceil(dirtyBox[2]);
                    dirtyBox[3] = Math.ceil(dirtyBox[3]);
                  }
                  const smask = this.current.activeSMask;
                  const suspendedCtx = this.suspendedCtx;
                  composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                  this.ctx.restore();
                }
                save() {
                  if (this.inSMaskMode) {
                    copyCtxState(this.ctx, this.suspendedCtx);
                    this.suspendedCtx.save();
                  } else {
                    this.ctx.save();
                  }
                  const old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  if (this.stateStack.length === 0 && this.inSMaskMode) {
                    this.endSMaskMode();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    if (this.inSMaskMode) {
                      this.suspendedCtx.restore();
                      copyCtxState(this.suspendedCtx, this.ctx);
                    } else {
                      this.ctx.restore();
                    }
                    this.checkSMaskState();
                    this.pendingClip = null;
                    this._cachedScaleForStroking[0] = -1;
                    this._cachedGetSinglePixelWidth = null;
                  }
                }
                transform(a3, b3, c3, d3, e3, f2) {
                  this.ctx.transform(a3, b3, c3, d3, e3, f2);
                  this._cachedScaleForStroking[0] = -1;
                  this._cachedGetSinglePixelWidth = null;
                }
                constructPath(ops, args, minMax) {
                  const ctx = this.ctx;
                  const current = this.current;
                  let x3 = current.x, y3 = current.y;
                  let startX, startY;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                  const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                  for (let i3 = 0, j3 = 0, ii2 = ops.length; i3 < ii2; i3++) {
                    switch (ops[i3] | 0) {
                      case _util2.OPS.rectangle:
                        x3 = args[j3++];
                        y3 = args[j3++];
                        const width = args[j3++];
                        const height = args[j3++];
                        const xw = x3 + width;
                        const yh = y3 + height;
                        ctx.moveTo(x3, y3);
                        if (width === 0 || height === 0) {
                          ctx.lineTo(xw, yh);
                        } else {
                          ctx.lineTo(xw, y3);
                          ctx.lineTo(xw, yh);
                          ctx.lineTo(x3, yh);
                        }
                        if (!isScalingMatrix) {
                          current.updateRectMinMax(currentTransform, [x3, y3, xw, yh]);
                        }
                        ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x3 = args[j3++];
                        y3 = args[j3++];
                        ctx.moveTo(x3, y3);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x3, y3);
                        }
                        break;
                      case _util2.OPS.lineTo:
                        x3 = args[j3++];
                        y3 = args[j3++];
                        ctx.lineTo(x3, y3);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x3, y3);
                        }
                        break;
                      case _util2.OPS.curveTo:
                        startX = x3;
                        startY = y3;
                        x3 = args[j3 + 4];
                        y3 = args[j3 + 5];
                        ctx.bezierCurveTo(args[j3], args[j3 + 1], args[j3 + 2], args[j3 + 3], x3, y3);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j3], args[j3 + 1], args[j3 + 2], args[j3 + 3], x3, y3, minMaxForBezier);
                        j3 += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        startX = x3;
                        startY = y3;
                        ctx.bezierCurveTo(x3, y3, args[j3], args[j3 + 1], args[j3 + 2], args[j3 + 3]);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, x3, y3, args[j3], args[j3 + 1], args[j3 + 2], args[j3 + 3], minMaxForBezier);
                        x3 = args[j3 + 2];
                        y3 = args[j3 + 3];
                        j3 += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        startX = x3;
                        startY = y3;
                        x3 = args[j3 + 2];
                        y3 = args[j3 + 3];
                        ctx.bezierCurveTo(args[j3], args[j3 + 1], x3, y3, x3, y3);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j3], args[j3 + 1], x3, y3, x3, y3, minMaxForBezier);
                        j3 += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  if (isScalingMatrix) {
                    current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                  }
                  current.setCurrentPoint(x3, y3);
                }
                closePath() {
                  this.ctx.closePath();
                }
                stroke(consumePath = true) {
                  const ctx = this.ctx;
                  const strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (this.contentVisible) {
                    if (typeof strokeColor === "object" && (strokeColor == null ? void 0 : strokeColor.getPattern)) {
                      ctx.save();
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
                      this.rescaleAndStroke(false);
                      ctx.restore();
                    } else {
                      this.rescaleAndStroke(true);
                    }
                  }
                  if (consumePath) {
                    this.consumePath(this.current.getClippedPathBoundingBox());
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                fill(consumePath = true) {
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  let needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    needRestore = true;
                  }
                  const intersect = this.current.getClippedPathBoundingBox();
                  if (this.contentVisible && intersect !== null) {
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath(intersect);
                  }
                }
                eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                }
                fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                }
                eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                }
                endPath() {
                  this.consumePath();
                }
                clip() {
                  this.pendingClip = NORMAL_CLIP;
                }
                eoClip() {
                  this.pendingClip = EO_CLIP;
                }
                beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                endText() {
                  const paths = this.pendingTextPaths;
                  const ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (const path of paths) {
                    ctx.setTransform(...path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                }
                setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                }
                setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                }
                setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setFont(fontRefName, size) {
                  var _a3;
                  const fontObj = this.commonObjs.get(fontRefName);
                  const current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  const name = fontObj.loadedName || "sans-serif";
                  const typeface = ((_a3 = fontObj.systemFontInfo) == null ? void 0 : _a3.css) || `"${name}", ${fontObj.fallbackName}`;
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  let browserFontSize = size;
                  if (size < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                }
                setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                }
                setTextRise(rise) {
                  this.current.textRise = rise;
                }
                moveText(x3, y3) {
                  this.current.x = this.current.lineX += x3;
                  this.current.y = this.current.lineY += y3;
                }
                setLeadingMoveText(x3, y3) {
                  this.setLeading(-y3);
                  this.moveText(x3, y3);
                }
                setTextMatrix(a3, b3, c3, d3, e3, f2) {
                  this.current.textMatrix = [a3, b3, c3, d3, e3, f2];
                  this.current.textMatrixScale = Math.hypot(a3, b3);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                paintChar(character, x3, y3, patternTransform) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const textRenderingMode = current.textRenderingMode;
                  const fontSize = current.fontSize / current.fontSizeScale;
                  const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && !font.missingFile;
                  let addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x3, y3);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform(...patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x3, y3);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x3, y3);
                    }
                  }
                  if (isAddToPathSet) {
                    const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: (0, _display_utils2.getCurrentTransform)(ctx),
                      x: x3,
                      y: y3,
                      fontSize,
                      addToPath
                    });
                  }
                }
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  const data = ctx.getImageData(0, 0, 10, 10).data;
                  let enabled = false;
                  for (let i3 = 3; i3 < data.length; i3 += 4) {
                    if (data[i3] > 0 && data[i3] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  const ctx = this.ctx;
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const glyphsLength = glyphs.length;
                  const vertical = font.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    patternTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  let lineWidth = current.lineWidth;
                  const scale = current.textMatrixScale;
                  if (scale === 0 || lineWidth === 0) {
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      lineWidth = this.getSinglePixelWidth();
                    }
                  } else {
                    lineWidth /= scale;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  if (font.isInvalidPDFjsFont) {
                    const chars = [];
                    let width = 0;
                    for (const glyph of glyphs) {
                      chars.push(glyph.unicode);
                      width += glyph.width;
                    }
                    ctx.fillText(chars.join(""), 0, 0);
                    current.x += width * widthAdvanceScale * textHScale;
                    ctx.restore();
                    this.compose();
                    return void 0;
                  }
                  let x3 = 0, i3;
                  for (i3 = 0; i3 < glyphsLength; ++i3) {
                    const glyph = glyphs[i3];
                    if (typeof glyph === "number") {
                      x3 += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    let restoreNeeded = false;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    const accent = glyph.accent;
                    let scaledX, scaledY;
                    let width = glyph.width;
                    if (vertical) {
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x3 + vy) / fontSizeScale;
                    } else {
                      scaledX = x3 / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        const characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                          const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
                    x3 += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x3;
                  } else {
                    current.x += x3 * textHScale;
                  }
                  ctx.restore();
                  this.compose();
                  return void 0;
                }
                showType3Text(glyphs) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  const fontDirection = current.fontDirection;
                  const spacingDir = font.vertical ? 1 : -1;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const textHScale = current.textHScale * fontDirection;
                  const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  const glyphsLength = glyphs.length;
                  const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  let i3, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedScaleForStroking[0] = -1;
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i3 = 0; i3 < glyphsLength; ++i3) {
                    glyph = glyphs[i3];
                    if (typeof glyph === "number") {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    if (this.contentVisible) {
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize, fontSize);
                      ctx.transform(...fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                    }
                    const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                }
                setCharWidth(xWidth, yWidth) {
                }
                setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.ctx.clip();
                  this.endPath();
                }
                getColorN_Pattern(IR) {
                  let pattern;
                  if (IR[0] === "TilingPattern") {
                    const color = IR[1];
                    const baseTransform = this.baseTransform || (0, _display_utils2.getCurrentTransform)(this.ctx);
                    const canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                          optionalContentConfig: this.optionalContentConfig,
                          markedContentStack: this.markedContentStack
                        });
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = this._getPattern(IR[1], IR[2]);
                  }
                  return pattern;
                }
                setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                }
                setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                }
                setStrokeRGBColor(r3, g3, b3) {
                  const color = _util2.Util.makeHexColor(r3, g3, b3);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                }
                setFillRGBColor(r3, g3, b3) {
                  const color = _util2.Util.makeHexColor(r3, g3, b3);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                }
                _getPattern(objId, matrix = null) {
                  let pattern;
                  if (this.cachedPatterns.has(objId)) {
                    pattern = this.cachedPatterns.get(objId);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));
                    this.cachedPatterns.set(objId, pattern);
                  }
                  if (matrix) {
                    pattern.matrix = matrix;
                  }
                  return pattern;
                }
                shadingFill(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  this.save();
                  const pattern = this._getPattern(objId);
                  ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
                  const inv = (0, _display_utils2.getCurrentTransformInverse)(ctx);
                  if (inv) {
                    const {
                      width,
                      height
                    } = ctx.canvas;
                    const [x0, y0, x1, y1] = _util2.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.compose(this.current.getClippedPathBoundingBox());
                  this.restore();
                }
                beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                }
                beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(...matrix);
                  }
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(this.ctx), bbox);
                    this.clip();
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                }
                beginGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  if (this.inSMaskMode) {
                    this.endSMaskMode();
                    this.current.activeSMask = null;
                  }
                  const currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(currentCtx);
                  if (group.matrix) {
                    currentCtx.transform(...group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  let bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils2.getCurrentTransform)(currentCtx));
                  const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  const offsetX = Math.floor(bounds[0]);
                  const offsetY = Math.floor(bounds[1]);
                  let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  let scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                  let cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  const groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform(...currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                    currentCtx.save();
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                }
                endGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.groupLevel--;
                  const groupCtx = this.ctx;
                  const ctx = this.groupStack.pop();
                  this.ctx = ctx;
                  this.ctx.imageSmoothingEnabled = false;
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                    this.restore();
                  } else {
                    this.ctx.restore();
                    const currentMtx = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    this.restore();
                    this.ctx.save();
                    this.ctx.setTransform(...currentMtx);
                    const dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                    this.ctx.restore();
                    this.compose(dirtyBox);
                  }
                }
                beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  resetCtxToDefault(this.ctx);
                  this.ctx.save();
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform(...this.baseTransform);
                  }
                  if (Array.isArray(rect) && rect.length === 4) {
                    const width = rect[2] - rect[0];
                    const height = rect[3] - rect[1];
                    if (hasOwnCanvas && this.annotationCanvasMap) {
                      transform = transform.slice();
                      transform[4] -= rect[0];
                      transform[5] -= rect[1];
                      rect = rect.slice();
                      rect[0] = rect[1] = 0;
                      rect[2] = width;
                      rect[3] = height;
                      const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(this.ctx));
                      const {
                        viewportScale
                      } = this;
                      const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                      const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                      this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                      const {
                        canvas,
                        context
                      } = this.annotationCanvas;
                      this.annotationCanvasMap.set(id, canvas);
                      this.annotationCanvas.savedCtx = this.ctx;
                      this.ctx = context;
                      this.ctx.save();
                      this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                      resetCtxToDefault(this.ctx);
                    } else {
                      resetCtxToDefault(this.ctx);
                      this.ctx.rect(rect[0], rect[1], width, height);
                      this.ctx.clip();
                      this.endPath();
                    }
                  }
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.transform(...transform);
                  this.transform(...matrix);
                }
                endAnnotation() {
                  if (this.annotationCanvas) {
                    this.ctx.restore();
                    __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
                    this.ctx = this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas;
                  }
                }
                paintImageMaskXObject(img) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const count = img.count;
                  img = this.getObject(img.data, img);
                  img.count = count;
                  const ctx = this.ctx;
                  const glyph = this.processingType3;
                  if (glyph) {
                    if (glyph.compiled === void 0) {
                      glyph.compiled = compileType3Glyph(img);
                    }
                    if (glyph.compiled) {
                      glyph.compiled(ctx);
                      return;
                    }
                  }
                  const mask = this._createMaskCanvas(img);
                  const maskCanvas = mask.canvas;
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  img = this.getObject(img.data, img);
                  const ctx = this.ctx;
                  ctx.save();
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                  const mask = this._createMaskCanvas(img);
                  ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
                  for (let i3 = 0, ii2 = positions.length; i3 < ii2; i3 += 2) {
                    const trans = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i3], positions[i3 + 1]]);
                    const [x3, y3] = _util2.Util.applyTransform([0, 0], trans);
                    ctx.drawImage(mask.canvas, x3, y3);
                  }
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectGroup(images) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  for (const image of images) {
                    const {
                      data,
                      width,
                      height,
                      transform
                    } = image;
                    const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    const maskCtx = maskCanvas.context;
                    maskCtx.save();
                    const img = this.getObject(data, image);
                    putBinaryImageMask(maskCtx, img);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform(...transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                  this.compose();
                }
                paintImageXObject(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const map = [];
                  for (let i3 = 0, ii2 = positions.length; i3 < ii2; i3 += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i3], positions[i3 + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                }
                applyTransferMapsToCanvas(ctx) {
                  if (this.current.transferMaps !== "none") {
                    ctx.filter = this.current.transferMaps;
                    ctx.drawImage(ctx.canvas, 0, 0);
                    ctx.filter = "none";
                  }
                  return ctx.canvas;
                }
                applyTransferMapsToBitmap(imgData) {
                  if (this.current.transferMaps === "none") {
                    return imgData.bitmap;
                  }
                  const {
                    bitmap,
                    width,
                    height
                  } = imgData;
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                  const tmpCtx = tmpCanvas.context;
                  tmpCtx.filter = this.current.transferMaps;
                  tmpCtx.drawImage(bitmap, 0, 0);
                  tmpCtx.filter = "none";
                  return tmpCanvas.canvas;
                }
                paintInlineImageXObject(imgData) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const ctx = this.ctx;
                  this.save();
                  if (!_util2.isNodeJS) {
                    const {
                      filter
                    } = ctx;
                    if (filter !== "none" && filter !== "") {
                      ctx.filter = "none";
                    }
                  }
                  ctx.scale(1 / width, -1 / height);
                  let imgToPaint;
                  if (imgData.bitmap) {
                    imgToPaint = this.applyTransferMapsToBitmap(imgData);
                  } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData);
                    imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
                  }
                  const scaled = this._scaleImage(imgToPaint, (0, _display_utils2.getCurrentTransformInverse)(ctx));
                  ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(ctx), imgData.interpolate);
                  drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
                  this.compose();
                  this.restore();
                }
                paintInlineImageXObjectGroup(imgData, map) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  let imgToPaint;
                  if (imgData.bitmap) {
                    imgToPaint = imgData.bitmap;
                  } else {
                    const w3 = imgData.width;
                    const h2 = imgData.height;
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w3, h2);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData);
                    imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
                  }
                  for (const entry of map) {
                    ctx.save();
                    ctx.transform(...entry.transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    ctx.restore();
                  }
                  this.compose();
                }
                paintSolidColorImageMask() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.ctx.fillRect(0, 0, 1, 1);
                  this.compose();
                }
                markPoint(tag) {
                }
                markPointProps(tag, properties) {
                }
                beginMarkedContent(tag) {
                  this.markedContentStack.push({
                    visible: true
                  });
                }
                beginMarkedContentProps(tag, properties) {
                  if (tag === "OC") {
                    this.markedContentStack.push({
                      visible: this.optionalContentConfig.isVisible(properties)
                    });
                  } else {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  this.contentVisible = this.isContentVisible();
                }
                endMarkedContent() {
                  this.markedContentStack.pop();
                  this.contentVisible = this.isContentVisible();
                }
                beginCompat() {
                }
                endCompat() {
                }
                consumePath(clipBox) {
                  const isEmpty = this.current.isEmptyClip();
                  if (this.pendingClip) {
                    this.current.updateClipFromPath();
                  }
                  if (!this.pendingClip) {
                    this.compose(clipBox);
                  }
                  const ctx = this.ctx;
                  if (this.pendingClip) {
                    if (!isEmpty) {
                      if (this.pendingClip === EO_CLIP) {
                        ctx.clip("evenodd");
                      } else {
                        ctx.clip();
                      }
                    }
                    this.pendingClip = null;
                  }
                  this.current.startNewPathAndClipBox(this.current.clipBox);
                  ctx.beginPath();
                }
                getSinglePixelWidth() {
                  if (!this._cachedGetSinglePixelWidth) {
                    const m3 = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    if (m3[1] === 0 && m3[2] === 0) {
                      this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m3[0]), Math.abs(m3[3]));
                    } else {
                      const absDet = Math.abs(m3[0] * m3[3] - m3[2] * m3[1]);
                      const normX = Math.hypot(m3[0], m3[2]);
                      const normY = Math.hypot(m3[1], m3[3]);
                      this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                    }
                  }
                  return this._cachedGetSinglePixelWidth;
                }
                getScaleForStroking() {
                  if (this._cachedScaleForStroking[0] === -1) {
                    const {
                      lineWidth
                    } = this.current;
                    const {
                      a: a3,
                      b: b3,
                      c: c3,
                      d: d3
                    } = this.ctx.getTransform();
                    let scaleX, scaleY;
                    if (b3 === 0 && c3 === 0) {
                      const normX = Math.abs(a3);
                      const normY = Math.abs(d3);
                      if (normX === normY) {
                        if (lineWidth === 0) {
                          scaleX = scaleY = 1 / normX;
                        } else {
                          const scaledLineWidth = normX * lineWidth;
                          scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
                        }
                      } else if (lineWidth === 0) {
                        scaleX = 1 / normX;
                        scaleY = 1 / normY;
                      } else {
                        const scaledXLineWidth = normX * lineWidth;
                        const scaledYLineWidth = normY * lineWidth;
                        scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                        scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                      }
                    } else {
                      const absDet = Math.abs(a3 * d3 - b3 * c3);
                      const normX = Math.hypot(a3, b3);
                      const normY = Math.hypot(c3, d3);
                      if (lineWidth === 0) {
                        scaleX = normY / absDet;
                        scaleY = normX / absDet;
                      } else {
                        const baseArea = lineWidth * absDet;
                        scaleX = normY > baseArea ? normY / baseArea : 1;
                        scaleY = normX > baseArea ? normX / baseArea : 1;
                      }
                    }
                    this._cachedScaleForStroking[0] = scaleX;
                    this._cachedScaleForStroking[1] = scaleY;
                  }
                  return this._cachedScaleForStroking;
                }
                rescaleAndStroke(saveRestore) {
                  const {
                    ctx
                  } = this;
                  const {
                    lineWidth
                  } = this.current;
                  const [scaleX, scaleY] = this.getScaleForStroking();
                  ctx.lineWidth = lineWidth || 1;
                  if (scaleX === 1 && scaleY === 1) {
                    ctx.stroke();
                    return;
                  }
                  const dashes = ctx.getLineDash();
                  if (saveRestore) {
                    ctx.save();
                  }
                  ctx.scale(scaleX, scaleY);
                  if (dashes.length > 0) {
                    const scale = Math.max(scaleX, scaleY);
                    ctx.setLineDash(dashes.map((x3) => x3 / scale));
                    ctx.lineDashOffset /= scale;
                  }
                  ctx.stroke();
                  if (saveRestore) {
                    ctx.restore();
                  }
                }
                isContentVisible() {
                  for (let i3 = this.markedContentStack.length - 1; i3 >= 0; i3--) {
                    if (!this.markedContentStack[i3].visible) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              _restoreInitialState = new WeakSet();
              restoreInitialState_fn = function() {
                while (this.stateStack.length || this.inSMaskMode) {
                  this.restore();
                }
                this.ctx.restore();
                if (this.transparentCanvas) {
                  this.ctx = this.compositeCtx;
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.drawImage(this.transparentCanvas, 0, 0);
                  this.ctx.restore();
                  this.transparentCanvas = null;
                }
              };
              _drawFilter = new WeakSet();
              drawFilter_fn = function() {
                if (this.pageColors) {
                  const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
                  if (hcmFilterId !== "none") {
                    const savedFilter = this.ctx.filter;
                    this.ctx.filter = hcmFilterId;
                    this.ctx.drawImage(this.ctx.canvas, 0, 0);
                    this.ctx.filter = savedFilter;
                  }
                }
              };
              let CanvasGraphics = _CanvasGraphics;
              exports2.CanvasGraphics = CanvasGraphics;
              for (const op in _util2.OPS) {
                if (CanvasGraphics.prototype[op] !== void 0) {
                  CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
                }
              }
            },
            /* 12 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TilingPattern = exports2.PathType = void 0;
              exports2.getShadingPattern = getShadingPattern;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              const PathType = {
                FILL: "Fill",
                STROKE: "Stroke",
                SHADING: "Shading"
              };
              exports2.PathType = PathType;
              function applyBoundingBox(ctx, bbox) {
                if (!bbox) {
                  return;
                }
                const width = bbox[2] - bbox[0];
                const height = bbox[3] - bbox[1];
                const region = new Path2D();
                region.rect(bbox[0], bbox[1], width, height);
                ctx.clip(region);
              }
              class BaseShadingPattern {
                constructor() {
                  if (this.constructor === BaseShadingPattern) {
                    (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                  }
                }
                getPattern() {
                  (0, _util2.unreachable)("Abstract method `getPattern` called.");
                }
              }
              class RadialAxialShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._type = IR[1];
                  this._bbox = IR[2];
                  this._colorStops = IR[3];
                  this._p0 = IR[4];
                  this._p1 = IR[5];
                  this._r0 = IR[6];
                  this._r1 = IR[7];
                  this.matrix = null;
                }
                _createGradient(ctx) {
                  let grad;
                  if (this._type === "axial") {
                    grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                  } else if (this._type === "radial") {
                    grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                  }
                  for (const colorStop of this._colorStops) {
                    grad.addColorStop(colorStop[0], colorStop[1]);
                  }
                  return grad;
                }
                getPattern(ctx, owner, inverse, pathType) {
                  let pattern;
                  if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                    const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils2.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
                    const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                    const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
                    const tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.beginPath();
                    tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                    inverse = _util2.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                    tmpCtx.transform(...owner.baseTransform);
                    if (this.matrix) {
                      tmpCtx.transform(...this.matrix);
                    }
                    applyBoundingBox(tmpCtx, this._bbox);
                    tmpCtx.fillStyle = this._createGradient(tmpCtx);
                    tmpCtx.fill();
                    pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                    const domMatrix = new DOMMatrix(inverse);
                    pattern.setTransform(domMatrix);
                  } else {
                    applyBoundingBox(ctx, this._bbox);
                    pattern = this._createGradient(ctx);
                  }
                  return pattern;
                }
              }
              function drawTriangle(data, context, p1, p2, p3, c1, c22, c3) {
                const coords = context.coords, colors = context.colors;
                const bytes = data.data, rowSize = data.width * 4;
                let tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c22;
                  c22 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c22;
                  c22 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c22;
                  c22 = tmp;
                }
                const x1 = (coords[p1] + context.offsetX) * context.scaleX;
                const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                const x22 = (coords[p2] + context.offsetX) * context.scaleX;
                const y22 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                const x3 = (coords[p3] + context.offsetX) * context.scaleX;
                const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                const c2r = colors[c22], c2g = colors[c22 + 1], c2b = colors[c22 + 2];
                const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                const minY = Math.round(y1), maxY = Math.round(y3);
                let xa2, car, cag, cab;
                let xb, cbr, cbg, cbb;
                for (let y4 = minY; y4 <= maxY; y4++) {
                  if (y4 < y22) {
                    const k4 = y4 < y1 ? 0 : (y1 - y4) / (y1 - y22);
                    xa2 = x1 - (x1 - x22) * k4;
                    car = c1r - (c1r - c2r) * k4;
                    cag = c1g - (c1g - c2g) * k4;
                    cab = c1b - (c1b - c2b) * k4;
                  } else {
                    let k4;
                    if (y4 > y3) {
                      k4 = 1;
                    } else if (y22 === y3) {
                      k4 = 0;
                    } else {
                      k4 = (y22 - y4) / (y22 - y3);
                    }
                    xa2 = x22 - (x22 - x3) * k4;
                    car = c2r - (c2r - c3r) * k4;
                    cag = c2g - (c2g - c3g) * k4;
                    cab = c2b - (c2b - c3b) * k4;
                  }
                  let k3;
                  if (y4 < y1) {
                    k3 = 0;
                  } else if (y4 > y3) {
                    k3 = 1;
                  } else {
                    k3 = (y1 - y4) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k3;
                  cbr = c1r - (c1r - c3r) * k3;
                  cbg = c1g - (c1g - c3g) * k3;
                  cbb = c1b - (c1b - c3b) * k3;
                  const x1_ = Math.round(Math.min(xa2, xb));
                  const x2_ = Math.round(Math.max(xa2, xb));
                  let j3 = rowSize * y4 + x1_ * 4;
                  for (let x4 = x1_; x4 <= x2_; x4++) {
                    k3 = (xa2 - x4) / (xa2 - xb);
                    if (k3 < 0) {
                      k3 = 0;
                    } else if (k3 > 1) {
                      k3 = 1;
                    }
                    bytes[j3++] = car - (car - cbr) * k3 | 0;
                    bytes[j3++] = cag - (cag - cbg) * k3 | 0;
                    bytes[j3++] = cab - (cab - cbb) * k3 | 0;
                    bytes[j3++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                const ps2 = figure.coords;
                const cs2 = figure.colors;
                let i3, ii2;
                switch (figure.type) {
                  case "lattice":
                    const verticesPerRow = figure.verticesPerRow;
                    const rows = Math.floor(ps2.length / verticesPerRow) - 1;
                    const cols = verticesPerRow - 1;
                    for (i3 = 0; i3 < rows; i3++) {
                      let q3 = i3 * verticesPerRow;
                      for (let j3 = 0; j3 < cols; j3++, q3++) {
                        drawTriangle(data, context, ps2[q3], ps2[q3 + 1], ps2[q3 + verticesPerRow], cs2[q3], cs2[q3 + 1], cs2[q3 + verticesPerRow]);
                        drawTriangle(data, context, ps2[q3 + verticesPerRow + 1], ps2[q3 + 1], ps2[q3 + verticesPerRow], cs2[q3 + verticesPerRow + 1], cs2[q3 + 1], cs2[q3 + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i3 = 0, ii2 = ps2.length; i3 < ii2; i3 += 3) {
                      drawTriangle(data, context, ps2[i3], ps2[i3 + 1], ps2[i3 + 2], cs2[i3], cs2[i3 + 1], cs2[i3 + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              class MeshShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._coords = IR[2];
                  this._colors = IR[3];
                  this._figures = IR[4];
                  this._bounds = IR[5];
                  this._bbox = IR[7];
                  this._background = IR[8];
                  this.matrix = null;
                }
                _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
                  const EXPECTED_SCALE = 1.1;
                  const MAX_PATTERN_SIZE = 3e3;
                  const BORDER_SIZE = 2;
                  const offsetX = Math.floor(this._bounds[0]);
                  const offsetY = Math.floor(this._bounds[1]);
                  const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                  const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                  const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const scaleX = boundsWidth / width;
                  const scaleY = boundsHeight / height;
                  const context = {
                    coords: this._coords,
                    colors: this._colors,
                    offsetX: -offsetX,
                    offsetY: -offsetY,
                    scaleX: 1 / scaleX,
                    scaleY: 1 / scaleY
                  };
                  const paddedWidth = width + BORDER_SIZE * 2;
                  const paddedHeight = height + BORDER_SIZE * 2;
                  const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  const tmpCtx = tmpCanvas.context;
                  const data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    const bytes = data.data;
                    for (let i3 = 0, ii2 = bytes.length; i3 < ii2; i3 += 4) {
                      bytes[i3] = backgroundColor[0];
                      bytes[i3 + 1] = backgroundColor[1];
                      bytes[i3 + 2] = backgroundColor[2];
                      bytes[i3 + 3] = 255;
                    }
                  }
                  for (const figure of this._figures) {
                    drawFigure(data, figure, context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  const canvas = tmpCanvas.canvas;
                  return {
                    canvas,
                    offsetX: offsetX - BORDER_SIZE * scaleX,
                    offsetY: offsetY - BORDER_SIZE * scaleY,
                    scaleX,
                    scaleY
                  };
                }
                getPattern(ctx, owner, inverse, pathType) {
                  applyBoundingBox(ctx, this._bbox);
                  let scale;
                  if (pathType === PathType.SHADING) {
                    scale = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(ctx));
                  } else {
                    scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                    if (this.matrix) {
                      const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                      scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                    }
                  }
                  const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                  if (pathType !== PathType.SHADING) {
                    ctx.setTransform(...owner.baseTransform);
                    if (this.matrix) {
                      ctx.transform(...this.matrix);
                    }
                  }
                  ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                  return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                }
              }
              class DummyShadingPattern extends BaseShadingPattern {
                getPattern() {
                  return "hotpink";
                }
              }
              function getShadingPattern(IR) {
                switch (IR[0]) {
                  case "RadialAxial":
                    return new RadialAxialShadingPattern(IR);
                  case "Mesh":
                    return new MeshShadingPattern(IR);
                  case "Dummy":
                    return new DummyShadingPattern();
                }
                throw new Error(`Unknown IR type: ${IR[0]}`);
              }
              const PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              const _TilingPattern = class _TilingPattern {
                constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                  this.operatorList = IR[2];
                  this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                  this.bbox = IR[4];
                  this.xstep = IR[5];
                  this.ystep = IR[6];
                  this.paintType = IR[7];
                  this.tilingType = IR[8];
                  this.color = color;
                  this.ctx = ctx;
                  this.canvasGraphicsFactory = canvasGraphicsFactory;
                  this.baseTransform = baseTransform;
                }
                createPatternCanvas(owner) {
                  const operatorList = this.operatorList;
                  const bbox = this.bbox;
                  const xstep = this.xstep;
                  const ystep = this.ystep;
                  const paintType = this.paintType;
                  const tilingType = this.tilingType;
                  const color = this.color;
                  const canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  const tmpCtx = tmpCanvas.context;
                  const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  let adjustedX0 = x0;
                  let adjustedY0 = y0;
                  let adjustedX1 = x1;
                  let adjustedY1 = y1;
                  if (x0 < 0) {
                    adjustedX0 = 0;
                    adjustedX1 += Math.abs(x0);
                  }
                  if (y0 < 0) {
                    adjustedY0 = 0;
                    adjustedY1 += Math.abs(y0);
                  }
                  tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  tmpCtx.save();
                  this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                  graphics.baseTransform = (0, _display_utils2.getCurrentTransform)(graphics.ctx);
                  graphics.executeOperatorList(operatorList);
                  graphics.endDrawing();
                  return {
                    canvas: tmpCanvas.canvas,
                    scaleX: dimx.scale,
                    scaleY: dimy.scale,
                    offsetX: adjustedX0,
                    offsetY: adjustedY0
                  };
                }
                getSizeAndScale(step, realOutputSize, scale) {
                  step = Math.abs(step);
                  const maxSize = Math.max(_TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
                  let size = Math.ceil(step * scale);
                  if (size >= maxSize) {
                    size = maxSize;
                  } else {
                    scale = size / step;
                  }
                  return {
                    scale,
                    size
                  };
                }
                clipBbox(graphics, x0, y0, x1, y1) {
                  const bboxWidth = x1 - x0;
                  const bboxHeight = y1 - y0;
                  graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                  graphics.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
                  graphics.clip();
                  graphics.endPath();
                }
                setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  const context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      const ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      const cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                }
                getPattern(ctx, owner, inverse, pathType) {
                  let matrix = inverse;
                  if (pathType !== PathType.SHADING) {
                    matrix = _util2.Util.transform(matrix, owner.baseTransform);
                    if (this.matrix) {
                      matrix = _util2.Util.transform(matrix, this.matrix);
                    }
                  }
                  const temporaryPatternCanvas = this.createPatternCanvas(owner);
                  let domMatrix = new DOMMatrix(matrix);
                  domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                  const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                  pattern.setTransform(domMatrix);
                  return pattern;
                }
              };
              __publicField(_TilingPattern, "MAX_PATTERN_SIZE", 3e3);
              let TilingPattern = _TilingPattern;
              exports2.TilingPattern = TilingPattern;
            },
            /* 13 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA2;
              exports2.convertToRGBA = convertToRGBA2;
              exports2.grayToRGBA = grayToRGBA;
              var _util2 = __w_pdfjs_require__2(1);
              function convertToRGBA2(params) {
                switch (params.kind) {
                  case _util2.ImageKind.GRAYSCALE_1BPP:
                    return convertBlackAndWhiteToRGBA2(params);
                  case _util2.ImageKind.RGB_24BPP:
                    return convertRGBToRGBA(params);
                }
                return null;
              }
              function convertBlackAndWhiteToRGBA2({
                src,
                srcPos = 0,
                dest,
                width,
                height,
                nonBlackColor = 4294967295,
                inverseDecode = false
              }) {
                const black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
                const widthInSource = width >> 3;
                const widthRemainder = width & 7;
                const srcLength = src.length;
                dest = new Uint32Array(dest.buffer);
                let destPos = 0;
                for (let i3 = 0; i3 < height; i3++) {
                  for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
                    const elem2 = srcPos < srcLength ? src[srcPos] : 255;
                    dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  const elem = srcPos < srcLength ? src[srcPos++] : 255;
                  for (let j3 = 0; j3 < widthRemainder; j3++) {
                    dest[destPos++] = elem & 1 << 7 - j3 ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
              function convertRGBToRGBA({
                src,
                srcPos = 0,
                dest,
                destPos = 0,
                width,
                height
              }) {
                let i3 = 0;
                const len32 = src.length >> 2;
                const src32 = new Uint32Array(src.buffer, srcPos, len32);
                if (_util2.FeatureTest.isLittleEndian) {
                  for (; i3 < len32 - 2; i3 += 3, destPos += 4) {
                    const s1 = src32[i3];
                    const s22 = src32[i3 + 1];
                    const s3 = src32[i3 + 2];
                    dest[destPos] = s1 | 4278190080;
                    dest[destPos + 1] = s1 >>> 24 | s22 << 8 | 4278190080;
                    dest[destPos + 2] = s22 >>> 16 | s3 << 16 | 4278190080;
                    dest[destPos + 3] = s3 >>> 8 | 4278190080;
                  }
                  for (let j3 = i3 * 4, jj = src.length; j3 < jj; j3 += 3) {
                    dest[destPos++] = src[j3] | src[j3 + 1] << 8 | src[j3 + 2] << 16 | 4278190080;
                  }
                } else {
                  for (; i3 < len32 - 2; i3 += 3, destPos += 4) {
                    const s1 = src32[i3];
                    const s22 = src32[i3 + 1];
                    const s3 = src32[i3 + 2];
                    dest[destPos] = s1 | 255;
                    dest[destPos + 1] = s1 << 24 | s22 >>> 8 | 255;
                    dest[destPos + 2] = s22 << 16 | s3 >>> 16 | 255;
                    dest[destPos + 3] = s3 << 8 | 255;
                  }
                  for (let j3 = i3 * 4, jj = src.length; j3 < jj; j3 += 3) {
                    dest[destPos++] = src[j3] << 24 | src[j3 + 1] << 16 | src[j3 + 2] << 8 | 255;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
              function grayToRGBA(src, dest) {
                if (_util2.FeatureTest.isLittleEndian) {
                  for (let i3 = 0, ii2 = src.length; i3 < ii2; i3++) {
                    dest[i3] = src[i3] * 65793 | 4278190080;
                  }
                } else {
                  for (let i3 = 0, ii2 = src.length; i3 < ii2; i3++) {
                    dest[i3] = src[i3] * 16843008 | 255;
                  }
                }
              }
            },
            /* 14 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlobalWorkerOptions = void 0;
              const GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
              exports2.GlobalWorkerOptions = GlobalWorkerOptions;
              GlobalWorkerOptions.workerPort = null;
              GlobalWorkerOptions.workerSrc = "";
            },
            /* 15 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _createStreamSink, createStreamSink_fn, _processStreamMessage, processStreamMessage_fn, _deleteStreamController, deleteStreamController_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              const StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason2(reason) {
                if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                  (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util2.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util2.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util2.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util2.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util2.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util2.UnknownErrorException(reason.message, reason.toString());
                }
              }
              class MessageHandler2 {
                constructor(sourceName, targetName, comObj) {
                  __privateAdd(this, _createStreamSink);
                  __privateAdd(this, _processStreamMessage);
                  __privateAdd(this, _deleteStreamController);
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = (event) => {
                    const data = event.data;
                    if (data.targetName !== this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      __privateMethod(this, _processStreamMessage, processStreamMessage_fn).call(this, data);
                      return;
                    }
                    if (data.callback) {
                      const callbackId = data.callbackId;
                      const capability = this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error(`Cannot resolve callback ${callbackId}`);
                      }
                      delete this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason2(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    const action = this.actionHandler[data.action];
                    if (!action) {
                      throw new Error(`Unknown action from worker: ${data.action}`);
                    }
                    if (data.callbackId) {
                      const cbSourceName = this.sourceName;
                      const cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason2(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      __privateMethod(this, _createStreamSink, createStreamSink_fn).call(this, data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                on(actionName, handler) {
                  const ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error(`There is already an actionName called "${actionName}"`);
                  }
                  ah[actionName] = handler;
                }
                send(actionName, data, transfers) {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
                sendWithPromise(actionName, data, transfers) {
                  const callbackId = this.callbackId++;
                  const capability = new _util2.PromiseCapability();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
                sendWithStream(actionName, data, queueingStrategy, transfers) {
                  const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                  return new ReadableStream({
                    start: (controller) => {
                      const startCapability = new _util2.PromiseCapability();
                      this.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: (controller) => {
                      const pullCapability = new _util2.PromiseCapability();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: (reason) => {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = new _util2.PromiseCapability();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason2(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
                destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              }
              _createStreamSink = new WeakSet();
              createStreamSink_fn = function(data) {
                const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                const self2 = this, action = this.actionHandler[data.action];
                const streamSink = {
                  enqueue(chunk, size = 1, transfers) {
                    if (this.isCancelled) {
                      return;
                    }
                    const lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = new _util2.PromiseCapability();
                      this.ready = this.sinkCapability.promise;
                    }
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ENQUEUE,
                      streamId,
                      chunk
                    }, transfers);
                  },
                  close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CLOSE,
                      streamId
                    });
                    delete self2.streamSinks[streamId];
                  },
                  error(reason) {
                    (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ERROR,
                      streamId,
                      reason: wrapReason2(reason)
                    });
                  },
                  sinkCapability: new _util2.PromiseCapability(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize: data.desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                new Promise(function(resolve) {
                  resolve(action(data.data, streamSink));
                }).then(function() {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function(reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    reason: wrapReason2(reason)
                  });
                });
              };
              _processStreamMessage = new WeakSet();
              processStreamMessage_fn = function(data) {
                const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                switch (data.stream) {
                  case StreamKind.START_COMPLETE:
                    if (data.success) {
                      streamController.startCall.resolve();
                    } else {
                      streamController.startCall.reject(wrapReason2(data.reason));
                    }
                    break;
                  case StreamKind.PULL_COMPLETE:
                    if (data.success) {
                      streamController.pullCall.resolve();
                    } else {
                      streamController.pullCall.reject(wrapReason2(data.reason));
                    }
                    break;
                  case StreamKind.PULL:
                    if (!streamSink) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                      break;
                    }
                    if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                      streamSink.sinkCapability.resolve();
                    }
                    streamSink.desiredSize = data.desiredSize;
                    new Promise(function(resolve) {
                      var _a3;
                      resolve((_a3 = streamSink.onPull) == null ? void 0 : _a3.call(streamSink));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        reason: wrapReason2(reason)
                      });
                    });
                    break;
                  case StreamKind.ENQUEUE:
                    (0, _util2.assert)(streamController, "enqueue should have stream controller");
                    if (streamController.isClosed) {
                      break;
                    }
                    streamController.controller.enqueue(data.chunk);
                    break;
                  case StreamKind.CLOSE:
                    (0, _util2.assert)(streamController, "close should have stream controller");
                    if (streamController.isClosed) {
                      break;
                    }
                    streamController.isClosed = true;
                    streamController.controller.close();
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.ERROR:
                    (0, _util2.assert)(streamController, "error should have stream controller");
                    streamController.controller.error(wrapReason2(data.reason));
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.CANCEL_COMPLETE:
                    if (data.success) {
                      streamController.cancelCall.resolve();
                    } else {
                      streamController.cancelCall.reject(wrapReason2(data.reason));
                    }
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.CANCEL:
                    if (!streamSink) {
                      break;
                    }
                    new Promise(function(resolve) {
                      var _a3;
                      resolve((_a3 = streamSink.onCancel) == null ? void 0 : _a3.call(streamSink, wrapReason2(data.reason)));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        reason: wrapReason2(reason)
                      });
                    });
                    streamSink.sinkCapability.reject(wrapReason2(data.reason));
                    streamSink.isCancelled = true;
                    delete this.streamSinks[streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              };
              _deleteStreamController = new WeakSet();
              deleteStreamController_fn = async function(streamController, streamId) {
                var _a3, _b2, _c2;
                await Promise.allSettled([(_a3 = streamController.startCall) == null ? void 0 : _a3.promise, (_b2 = streamController.pullCall) == null ? void 0 : _b2.promise, (_c2 = streamController.cancelCall) == null ? void 0 : _c2.promise]);
                delete this.streamControllers[streamId];
              };
              exports2.MessageHandler = MessageHandler2;
            },
            /* 16 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _metadataMap, _data;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Metadata = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class Metadata {
                constructor({
                  parsedData,
                  rawData
                }) {
                  __privateAdd(this, _metadataMap, void 0);
                  __privateAdd(this, _data, void 0);
                  __privateSet(this, _metadataMap, parsedData);
                  __privateSet(this, _data, rawData);
                }
                getRaw() {
                  return __privateGet(this, _data);
                }
                get(name) {
                  return __privateGet(this, _metadataMap).get(name) ?? null;
                }
                getAll() {
                  return (0, _util2.objectFromMap)(__privateGet(this, _metadataMap));
                }
                has(name) {
                  return __privateGet(this, _metadataMap).has(name);
                }
              }
              _metadataMap = new WeakMap();
              _data = new WeakMap();
              exports2.Metadata = Metadata;
            },
            /* 17 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _visible, _cachedGetHash, _groups, _initialHash, _order, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OptionalContentConfig = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _murmurhash = __w_pdfjs_require__2(8);
              const INTERNAL = Symbol("INTERNAL");
              class OptionalContentGroup {
                constructor(name, intent) {
                  __privateAdd(this, _visible, true);
                  this.name = name;
                  this.intent = intent;
                }
                get visible() {
                  return __privateGet(this, _visible);
                }
                _setVisible(internal, visible) {
                  if (internal !== INTERNAL) {
                    (0, _util2.unreachable)("Internal method `_setVisible` called.");
                  }
                  __privateSet(this, _visible, visible);
                }
              }
              _visible = new WeakMap();
              class OptionalContentConfig {
                constructor(data) {
                  __privateAdd(this, _evaluateVisibilityExpression);
                  __privateAdd(this, _cachedGetHash, null);
                  __privateAdd(this, _groups, /* @__PURE__ */ new Map());
                  __privateAdd(this, _initialHash, null);
                  __privateAdd(this, _order, null);
                  this.name = null;
                  this.creator = null;
                  if (data === null) {
                    return;
                  }
                  this.name = data.name;
                  this.creator = data.creator;
                  __privateSet(this, _order, data.order);
                  for (const group of data.groups) {
                    __privateGet(this, _groups).set(group.id, new OptionalContentGroup(group.name, group.intent));
                  }
                  if (data.baseState === "OFF") {
                    for (const group of __privateGet(this, _groups).values()) {
                      group._setVisible(INTERNAL, false);
                    }
                  }
                  for (const on2 of data.on) {
                    __privateGet(this, _groups).get(on2)._setVisible(INTERNAL, true);
                  }
                  for (const off of data.off) {
                    __privateGet(this, _groups).get(off)._setVisible(INTERNAL, false);
                  }
                  __privateSet(this, _initialHash, this.getHash());
                }
                isVisible(group) {
                  if (__privateGet(this, _groups).size === 0) {
                    return true;
                  }
                  if (!group) {
                    (0, _util2.warn)("Optional content group not defined.");
                    return true;
                  }
                  if (group.type === "OCG") {
                    if (!__privateGet(this, _groups).has(group.id)) {
                      (0, _util2.warn)(`Optional content group not found: ${group.id}`);
                      return true;
                    }
                    return __privateGet(this, _groups).get(group.id).visible;
                  } else if (group.type === "OCMD") {
                    if (group.expression) {
                      return __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, group.expression);
                    }
                    if (!group.policy || group.policy === "AnyOn") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOn") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id).visible) {
                          return false;
                        }
                      }
                      return true;
                    } else if (group.policy === "AnyOff") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOff") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id).visible) {
                          return false;
                        }
                      }
                      return true;
                    }
                    (0, _util2.warn)(`Unknown optional content policy ${group.policy}.`);
                    return true;
                  }
                  (0, _util2.warn)(`Unknown group type ${group.type}.`);
                  return true;
                }
                setVisibility(id, visible = true) {
                  if (!__privateGet(this, _groups).has(id)) {
                    (0, _util2.warn)(`Optional content group not found: ${id}`);
                    return;
                  }
                  __privateGet(this, _groups).get(id)._setVisible(INTERNAL, !!visible);
                  __privateSet(this, _cachedGetHash, null);
                }
                get hasInitialVisibility() {
                  return __privateGet(this, _initialHash) === null || this.getHash() === __privateGet(this, _initialHash);
                }
                getOrder() {
                  if (!__privateGet(this, _groups).size) {
                    return null;
                  }
                  if (__privateGet(this, _order)) {
                    return __privateGet(this, _order).slice();
                  }
                  return [...__privateGet(this, _groups).keys()];
                }
                getGroups() {
                  return __privateGet(this, _groups).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _groups)) : null;
                }
                getGroup(id) {
                  return __privateGet(this, _groups).get(id) || null;
                }
                getHash() {
                  if (__privateGet(this, _cachedGetHash) !== null) {
                    return __privateGet(this, _cachedGetHash);
                  }
                  const hash = new _murmurhash.MurmurHash3_64();
                  for (const [id, group] of __privateGet(this, _groups)) {
                    hash.update(`${id}:${group.visible}`);
                  }
                  return __privateSet(this, _cachedGetHash, hash.hexdigest());
                }
              }
              _cachedGetHash = new WeakMap();
              _groups = new WeakMap();
              _initialHash = new WeakMap();
              _order = new WeakMap();
              _evaluateVisibilityExpression = new WeakSet();
              evaluateVisibilityExpression_fn = function(array) {
                const length = array.length;
                if (length < 2) {
                  return true;
                }
                const operator = array[0];
                for (let i3 = 1; i3 < length; i3++) {
                  const element = array[i3];
                  let state;
                  if (Array.isArray(element)) {
                    state = __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, element);
                  } else if (__privateGet(this, _groups).has(element)) {
                    state = __privateGet(this, _groups).get(element).visible;
                  } else {
                    (0, _util2.warn)(`Optional content group not found: ${element}`);
                    return true;
                  }
                  switch (operator) {
                    case "And":
                      if (!state) {
                        return false;
                      }
                      break;
                    case "Or":
                      if (state) {
                        return true;
                      }
                      break;
                    case "Not":
                      return !state;
                    default:
                      return true;
                  }
                }
                return operator === "And";
              };
              exports2.OptionalContentConfig = OptionalContentConfig;
            },
            /* 18 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFDataTransportStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              class PDFDataTransportStream {
                constructor({
                  length,
                  initialData,
                  progressiveDone = false,
                  contentDispositionFilename = null,
                  disableRange = false,
                  disableStream = false
                }, pdfDataRangeTransport) {
                  (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                  this._queuedChunks = [];
                  this._progressiveDone = progressiveDone;
                  this._contentDispositionFilename = contentDispositionFilename;
                  if ((initialData == null ? void 0 : initialData.length) > 0) {
                    const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
                    this._queuedChunks.push(buffer);
                  }
                  this._pdfDataRangeTransport = pdfDataRangeTransport;
                  this._isStreamingSupported = !disableStream;
                  this._isRangeSupported = !disableRange;
                  this._contentLength = length;
                  this._fullRequestReader = null;
                  this._rangeReaders = [];
                  this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                    this._onReceiveData({
                      begin,
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                    this._onProgress({
                      loaded,
                      total
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                    this._onReceiveData({
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                    this._onProgressiveDone();
                  });
                  this._pdfDataRangeTransport.transportReady();
                }
                _onReceiveData({
                  begin,
                  chunk
                }) {
                  const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
                  if (begin === void 0) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader._enqueue(buffer);
                    } else {
                      this._queuedChunks.push(buffer);
                    }
                  } else {
                    const found = this._rangeReaders.some(function(rangeReader) {
                      if (rangeReader._begin !== begin) {
                        return false;
                      }
                      rangeReader._enqueue(buffer);
                      return true;
                    });
                    (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                  }
                }
                get _progressiveDataLength() {
                  var _a3;
                  return ((_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) ?? 0;
                }
                _onProgress(evt) {
                  var _a3, _b2, _c2, _d2;
                  if (evt.total === void 0) {
                    (_b2 = (_a3 = this._rangeReaders[0]) == null ? void 0 : _a3.onProgress) == null ? void 0 : _b2.call(_a3, {
                      loaded: evt.loaded
                    });
                  } else {
                    (_d2 = (_c2 = this._fullRequestReader) == null ? void 0 : _c2.onProgress) == null ? void 0 : _d2.call(_c2, {
                      loaded: evt.loaded,
                      total: evt.total
                    });
                  }
                }
                _onProgressiveDone() {
                  var _a3;
                  (_a3 = this._fullRequestReader) == null ? void 0 : _a3.progressiveDone();
                  this._progressiveDone = true;
                }
                _removeRangeReader(reader) {
                  const i3 = this._rangeReaders.indexOf(reader);
                  if (i3 >= 0) {
                    this._rangeReaders.splice(i3, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                  const queuedChunks = this._queuedChunks;
                  this._queuedChunks = null;
                  return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                }
                getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                  this._pdfDataRangeTransport.requestDataRange(begin, end);
                  this._rangeReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  var _a3;
                  (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
                  for (const reader of this._rangeReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                  this._pdfDataRangeTransport.abort();
                }
              }
              exports2.PDFDataTransportStream = PDFDataTransportStream;
              class PDFDataTransportStreamReader {
                constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
                  this._stream = stream;
                  this._done = progressiveDone || false;
                  this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                  this._queuedChunks = queuedChunks || [];
                  this._loaded = 0;
                  for (const chunk of this._queuedChunks) {
                    this._loaded += chunk.byteLength;
                  }
                  this._requests = [];
                  this._headersReady = Promise.resolve();
                  stream._fullRequestReader = this;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunks.push(chunk);
                  }
                  this._loaded += chunk.byteLength;
                }
                get headersReady() {
                  return this._headersReady;
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._stream._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._stream._isStreamingSupported;
                }
                get contentLength() {
                  return this._stream._contentLength;
                }
                async read() {
                  if (this._queuedChunks.length > 0) {
                    const chunk = this._queuedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = new _util2.PromiseCapability();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                progressiveDone() {
                  if (this._done) {
                    return;
                  }
                  this._done = true;
                }
              }
              class PDFDataTransportStreamRangeReader {
                constructor(stream, begin, end) {
                  this._stream = stream;
                  this._begin = begin;
                  this._end = end;
                  this._queuedChunk = null;
                  this._requests = [];
                  this._done = false;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length === 0) {
                    this._queuedChunk = chunk;
                  } else {
                    const requestsCapability = this._requests.shift();
                    requestsCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                  }
                  this._done = true;
                  this._stream._removeRangeReader(this);
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._queuedChunk) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = new _util2.PromiseCapability();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._stream._removeRangeReader(this);
                }
              }
            },
            /* 19 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFFetchStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(20);
              ;
              function createFetchOptions(headers, withCredentials, abortController) {
                return {
                  method: "GET",
                  headers,
                  signal: abortController.signal,
                  mode: "cors",
                  credentials: withCredentials ? "include" : "same-origin",
                  redirect: "follow"
                };
              }
              function createHeaders(httpHeaders) {
                const headers = new Headers();
                for (const property in httpHeaders) {
                  const value = httpHeaders[property];
                  if (value === void 0) {
                    continue;
                  }
                  headers.append(property, value);
                }
                return headers;
              }
              function getArrayBuffer(val) {
                if (val instanceof Uint8Array) {
                  return val.buffer;
                }
                if (val instanceof ArrayBuffer) {
                  return val;
                }
                (0, _util2.warn)(`getArrayBuffer - unexpected data format: ${val}`);
                return new Uint8Array(val).buffer;
              }
              class PDFFetchStream {
                constructor(source) {
                  this.source = source;
                  this.isHttp = /^https?:/i.test(source.url);
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  var _a3;
                  return ((_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFFetchStreamReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFFetchStreamRangeReader(this, begin, end);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  var _a3;
                  (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFFetchStream = PDFFetchStream;
              class PDFFetchStreamReader {
                constructor(stream) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  this._filename = null;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._contentLength = source.length;
                  this._headersCapability = new _util2.PromiseCapability();
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._abortController = new AbortController();
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._headers = createHeaders(this._stream.httpHeaders);
                  const url = source.url;
                  fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url);
                    }
                    this._reader = response.body.getReader();
                    this._headersCapability.resolve();
                    const getResponseHeader = (name) => {
                      return response.headers.get(name);
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: this._stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this.cancel(new _util2.AbortException("Streaming is disabled."));
                    }
                  }).catch(this._headersCapability.reject);
                  this.onProgress = null;
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  var _a3;
                  await this._headersCapability.promise;
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                  return {
                    value: getArrayBuffer(value),
                    done: false
                  };
                }
                cancel(reason) {
                  var _a3;
                  (_a3 = this._reader) == null ? void 0 : _a3.cancel(reason);
                  this._abortController.abort();
                }
              }
              class PDFFetchStreamRangeReader {
                constructor(stream, begin, end) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._readCapability = new _util2.PromiseCapability();
                  this._isStreamingSupported = !source.disableStream;
                  this._abortController = new AbortController();
                  this._headers = createHeaders(this._stream.httpHeaders);
                  this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                  const url = source.url;
                  fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url);
                    }
                    this._readCapability.resolve();
                    this._reader = response.body.getReader();
                  }).catch(this._readCapability.reject);
                  this.onProgress = null;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  var _a3;
                  await this._readCapability.promise;
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                    loaded: this._loaded
                  });
                  return {
                    value: getArrayBuffer(value),
                    done: false
                  };
                }
                cancel(reason) {
                  var _a3;
                  (_a3 = this._reader) == null ? void 0 : _a3.cancel(reason);
                  this._abortController.abort();
                }
              }
            },
            /* 20 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createResponseStatusError = createResponseStatusError;
              exports2.extractFilenameFromHeader = extractFilenameFromHeader;
              exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
              exports2.validateResponseStatus = validateResponseStatus;
              var _util2 = __w_pdfjs_require__2(1);
              var _content_disposition = __w_pdfjs_require__2(21);
              var _display_utils2 = __w_pdfjs_require__2(6);
              function validateRangeRequestCapabilities({
                getResponseHeader,
                isHttp,
                rangeChunkSize,
                disableRange
              }) {
                const returnValues = {
                  allowRangeRequests: false,
                  suggestedLength: void 0
                };
                const length = parseInt(getResponseHeader("Content-Length"), 10);
                if (!Number.isInteger(length)) {
                  return returnValues;
                }
                returnValues.suggestedLength = length;
                if (length <= 2 * rangeChunkSize) {
                  return returnValues;
                }
                if (disableRange || !isHttp) {
                  return returnValues;
                }
                if (getResponseHeader("Accept-Ranges") !== "bytes") {
                  return returnValues;
                }
                const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                if (contentEncoding !== "identity") {
                  return returnValues;
                }
                returnValues.allowRangeRequests = true;
                return returnValues;
              }
              function extractFilenameFromHeader(getResponseHeader) {
                const contentDisposition = getResponseHeader("Content-Disposition");
                if (contentDisposition) {
                  let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                  if (filename.includes("%")) {
                    try {
                      filename = decodeURIComponent(filename);
                    } catch {
                    }
                  }
                  if ((0, _display_utils2.isPdfFile)(filename)) {
                    return filename;
                  }
                }
                return null;
              }
              function createResponseStatusError(status, url) {
                if (status === 404 || status === 0 && url.startsWith("file:")) {
                  return new _util2.MissingPDFException('Missing PDF "' + url + '".');
                }
                return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
              }
              function validateResponseStatus(status) {
                return status === 200 || status === 206;
              }
            },
            /* 21 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
              var _util2 = __w_pdfjs_require__2(1);
              function getFilenameFromContentDispositionHeader(contentDisposition) {
                let needsEncodingFixup = true;
                let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = unescape(filename);
                  filename = rfc5987decode(filename);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                tmp = rfc2231getparam(contentDisposition);
                if (tmp) {
                  const filename = rfc2047decode(tmp);
                  return fixupEncoding(filename);
                }
                tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                function toParamRegExp(attributePattern, flags) {
                  return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                }
                function textdecode(encoding, value) {
                  if (encoding) {
                    if (!/^[\x00-\xFF]+$/.test(value)) {
                      return value;
                    }
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = (0, _util2.stringToBytes)(value);
                      value = decoder.decode(buffer);
                      needsEncodingFixup = false;
                    } catch {
                    }
                  }
                  return value;
                }
                function fixupEncoding(value) {
                  if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                    value = textdecode("utf-8", value);
                    if (needsEncodingFixup) {
                      value = textdecode("iso-8859-1", value);
                    }
                  }
                  return value;
                }
                function rfc2231getparam(contentDispositionStr) {
                  const matches = [];
                  let match;
                  const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                  while ((match = iter.exec(contentDispositionStr)) !== null) {
                    let [, n3, quot, part] = match;
                    n3 = parseInt(n3, 10);
                    if (n3 in matches) {
                      if (n3 === 0) {
                        break;
                      }
                      continue;
                    }
                    matches[n3] = [quot, part];
                  }
                  const parts = [];
                  for (let n3 = 0; n3 < matches.length; ++n3) {
                    if (!(n3 in matches)) {
                      break;
                    }
                    let [quot, part] = matches[n3];
                    part = rfc2616unquote(part);
                    if (quot) {
                      part = unescape(part);
                      if (n3 === 0) {
                        part = rfc5987decode(part);
                      }
                    }
                    parts.push(part);
                  }
                  return parts.join("");
                }
                function rfc2616unquote(value) {
                  if (value.startsWith('"')) {
                    const parts = value.slice(1).split('\\"');
                    for (let i3 = 0; i3 < parts.length; ++i3) {
                      const quotindex = parts[i3].indexOf('"');
                      if (quotindex !== -1) {
                        parts[i3] = parts[i3].slice(0, quotindex);
                        parts.length = i3 + 1;
                      }
                      parts[i3] = parts[i3].replaceAll(/\\(.)/g, "$1");
                    }
                    value = parts.join('"');
                  }
                  return value;
                }
                function rfc5987decode(extvalue) {
                  const encodingend = extvalue.indexOf("'");
                  if (encodingend === -1) {
                    return extvalue;
                  }
                  const encoding = extvalue.slice(0, encodingend);
                  const langvalue = extvalue.slice(encodingend + 1);
                  const value = langvalue.replace(/^[^']*'/, "");
                  return textdecode(encoding, value);
                }
                function rfc2047decode(value) {
                  if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                    return value;
                  }
                  return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
                    if (encoding === "q" || encoding === "Q") {
                      text = text.replaceAll("_", " ");
                      text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                        return String.fromCharCode(parseInt(hex, 16));
                      });
                      return textdecode(charset, text);
                    }
                    try {
                      text = atob(text);
                    } catch {
                    }
                    return textdecode(charset, text);
                  });
                }
                return "";
              }
            },
            /* 22 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNetworkStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(20);
              ;
              const OK_RESPONSE = 200;
              const PARTIAL_CONTENT_RESPONSE = 206;
              function getArrayBuffer(xhr) {
                const data = xhr.response;
                if (typeof data !== "string") {
                  return data;
                }
                return (0, _util2.stringToBytes)(data).buffer;
              }
              class NetworkManager {
                constructor(url, args = {}) {
                  this.url = url;
                  this.isHttp = /^https?:/i.test(url);
                  this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                  this.withCredentials = args.withCredentials || false;
                  this.currXhrId = 0;
                  this.pendingRequests = /* @__PURE__ */ Object.create(null);
                }
                requestRange(begin, end, listeners) {
                  const args = {
                    begin,
                    end
                  };
                  for (const prop in listeners) {
                    args[prop] = listeners[prop];
                  }
                  return this.request(args);
                }
                requestFull(listeners) {
                  return this.request(listeners);
                }
                request(args) {
                  const xhr = new XMLHttpRequest();
                  const xhrId = this.currXhrId++;
                  const pendingRequest = this.pendingRequests[xhrId] = {
                    xhr
                  };
                  xhr.open("GET", this.url);
                  xhr.withCredentials = this.withCredentials;
                  for (const property in this.httpHeaders) {
                    const value = this.httpHeaders[property];
                    if (value === void 0) {
                      continue;
                    }
                    xhr.setRequestHeader(property, value);
                  }
                  if (this.isHttp && "begin" in args && "end" in args) {
                    xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                    pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                  } else {
                    pendingRequest.expectedStatus = OK_RESPONSE;
                  }
                  xhr.responseType = "arraybuffer";
                  if (args.onError) {
                    xhr.onerror = function(evt) {
                      args.onError(xhr.status);
                    };
                  }
                  xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                  xhr.onprogress = this.onProgress.bind(this, xhrId);
                  pendingRequest.onHeadersReceived = args.onHeadersReceived;
                  pendingRequest.onDone = args.onDone;
                  pendingRequest.onError = args.onError;
                  pendingRequest.onProgress = args.onProgress;
                  xhr.send(null);
                  return xhrId;
                }
                onProgress(xhrId, evt) {
                  var _a3;
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  (_a3 = pendingRequest.onProgress) == null ? void 0 : _a3.call(pendingRequest, evt);
                }
                onStateChange(xhrId, evt) {
                  var _a3, _b2, _c2;
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  const xhr = pendingRequest.xhr;
                  if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                    pendingRequest.onHeadersReceived();
                    delete pendingRequest.onHeadersReceived;
                  }
                  if (xhr.readyState !== 4) {
                    return;
                  }
                  if (!(xhrId in this.pendingRequests)) {
                    return;
                  }
                  delete this.pendingRequests[xhrId];
                  if (xhr.status === 0 && this.isHttp) {
                    (_a3 = pendingRequest.onError) == null ? void 0 : _a3.call(pendingRequest, xhr.status);
                    return;
                  }
                  const xhrStatus = xhr.status || OK_RESPONSE;
                  const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                  if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                    (_b2 = pendingRequest.onError) == null ? void 0 : _b2.call(pendingRequest, xhr.status);
                    return;
                  }
                  const chunk = getArrayBuffer(xhr);
                  if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                    const rangeHeader = xhr.getResponseHeader("Content-Range");
                    const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                    pendingRequest.onDone({
                      begin: parseInt(matches[1], 10),
                      chunk
                    });
                  } else if (chunk) {
                    pendingRequest.onDone({
                      begin: 0,
                      chunk
                    });
                  } else {
                    (_c2 = pendingRequest.onError) == null ? void 0 : _c2.call(pendingRequest, xhr.status);
                  }
                }
                getRequestXhr(xhrId) {
                  return this.pendingRequests[xhrId].xhr;
                }
                isPendingRequest(xhrId) {
                  return xhrId in this.pendingRequests;
                }
                abortRequest(xhrId) {
                  const xhr = this.pendingRequests[xhrId].xhr;
                  delete this.pendingRequests[xhrId];
                  xhr.abort();
                }
              }
              class PDFNetworkStream {
                constructor(source) {
                  this._source = source;
                  this._manager = new NetworkManager(source.url, {
                    httpHeaders: source.httpHeaders,
                    withCredentials: source.withCredentials
                  });
                  this._rangeChunkSize = source.rangeChunkSize;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _onRangeRequestReaderClosed(reader) {
                  const i3 = this._rangeRequestReaders.indexOf(reader);
                  if (i3 >= 0) {
                    this._rangeRequestReaders.splice(i3, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                  reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  var _a3;
                  (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNetworkStream = PDFNetworkStream;
              class PDFNetworkStreamFullRequestReader {
                constructor(manager, source) {
                  this._manager = manager;
                  const args = {
                    onHeadersReceived: this._onHeadersReceived.bind(this),
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = source.url;
                  this._fullRequestId = manager.requestFull(args);
                  this._headersReceivedCapability = new _util2.PromiseCapability();
                  this._disableRange = source.disableRange || false;
                  this._contentLength = source.length;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = false;
                  this._isRangeSupported = false;
                  this._cachedChunks = [];
                  this._requests = [];
                  this._done = false;
                  this._storedError = void 0;
                  this._filename = null;
                  this.onProgress = null;
                }
                _onHeadersReceived() {
                  const fullRequestXhrId = this._fullRequestId;
                  const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                  const getResponseHeader = (name) => {
                    return fullRequestXhr.getResponseHeader(name);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._manager.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  if (allowRangeRequests) {
                    this._isRangeSupported = true;
                  }
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (this._isRangeSupported) {
                    this._manager.abortRequest(fullRequestXhrId);
                  }
                  this._headersReceivedCapability.resolve();
                }
                _onDone(data) {
                  if (data) {
                    if (this._requests.length > 0) {
                      const requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: data.chunk,
                        done: false
                      });
                    } else {
                      this._cachedChunks.push(data.chunk);
                    }
                  }
                  this._done = true;
                  if (this._cachedChunks.length > 0) {
                    return;
                  }
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  this._headersReceivedCapability.reject(this._storedError);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._cachedChunks.length = 0;
                }
                _onProgress(evt) {
                  var _a3;
                  (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                    loaded: evt.loaded,
                    total: evt.lengthComputable ? evt.total : this._contentLength
                  });
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get headersReady() {
                  return this._headersReceivedCapability.promise;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._cachedChunks.length > 0) {
                    const chunk = this._cachedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = new _util2.PromiseCapability();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  this._headersReceivedCapability.reject(reason);
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._fullRequestId)) {
                    this._manager.abortRequest(this._fullRequestId);
                  }
                  this._fullRequestReader = null;
                }
              }
              class PDFNetworkStreamRangeRequestReader {
                constructor(manager, begin, end) {
                  this._manager = manager;
                  const args = {
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = manager.url;
                  this._requestId = manager.requestRange(begin, end, args);
                  this._requests = [];
                  this._queuedChunk = null;
                  this._done = false;
                  this._storedError = void 0;
                  this.onProgress = null;
                  this.onClosed = null;
                }
                _close() {
                  var _a3;
                  (_a3 = this.onClosed) == null ? void 0 : _a3.call(this, this);
                }
                _onDone(data) {
                  const chunk = data.chunk;
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunk = chunk;
                  }
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._close();
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._queuedChunk = null;
                }
                _onProgress(evt) {
                  var _a3;
                  if (!this.isStreamingSupported) {
                    (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                      loaded: evt.loaded
                    });
                  }
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._queuedChunk !== null) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = new _util2.PromiseCapability();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._requestId)) {
                    this._manager.abortRequest(this._requestId);
                  }
                  this._close();
                }
              }
            },
            /* 23 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNodeStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(20);
              ;
              const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
              function parseUrl(sourceUrl) {
                const url = require_url();
                const parsedUrl = url.parse(sourceUrl);
                if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                  return parsedUrl;
                }
                if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                  return url.parse(`file:///${sourceUrl}`);
                }
                if (!parsedUrl.host) {
                  parsedUrl.protocol = "file:";
                }
                return parsedUrl;
              }
              class PDFNodeStream {
                constructor(source) {
                  this.source = source;
                  this.url = parseUrl(source.url);
                  this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                  this.isFsUrl = this.url.protocol === "file:";
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  var _a3;
                  return ((_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                  this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(start, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                  this._rangeRequestReaders.push(rangeReader);
                  return rangeReader;
                }
                cancelAllRequests(reason) {
                  var _a3;
                  (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNodeStream = PDFNodeStream;
              class BaseFullReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  const source = stream.source;
                  this._contentLength = source.length;
                  this._loaded = 0;
                  this._filename = null;
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._readableStream = null;
                  this._readCapability = new _util2.PromiseCapability();
                  this._headersCapability = new _util2.PromiseCapability();
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  var _a3;
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = new _util2.PromiseCapability();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this._error(new _util2.AbortException("streaming is disabled"));
                  }
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              class BaseRangeReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  this._loaded = 0;
                  this._readableStream = null;
                  this._readCapability = new _util2.PromiseCapability();
                  const source = stream.source;
                  this._isStreamingSupported = !source.disableStream;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  var _a3;
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = new _util2.PromiseCapability();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                    loaded: this._loaded
                  });
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              function createRequestOptions(parsedUrl, headers) {
                return {
                  protocol: parsedUrl.protocol,
                  auth: parsedUrl.auth,
                  host: parsedUrl.hostname,
                  port: parsedUrl.port,
                  path: parsedUrl.path,
                  method: "GET",
                  headers
                };
              }
              class PDFNodeStreamFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._headersCapability.resolve();
                    this._setReadableStream(response);
                    const getResponseHeader = (name) => {
                      return this._readableStream.headers[name.toLowerCase()];
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    const http = require_http();
                    this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  } else {
                    const https = require_https();
                    this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                    this._headersCapability.reject(reason);
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamRangeReader extends BaseRangeReader {
                constructor(stream, start, end) {
                  super(stream);
                  this._httpHeaders = {};
                  for (const property in stream.httpHeaders) {
                    const value = stream.httpHeaders[property];
                    if (value === void 0) {
                      continue;
                    }
                    this._httpHeaders[property] = value;
                  }
                  this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      return;
                    }
                    this._setReadableStream(response);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    const http = require_http();
                    this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  } else {
                    const https = require_https();
                    this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamFsFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  const fs2 = require_fs();
                  fs2.lstat(path, (error, stat) => {
                    if (error) {
                      if (error.code === "ENOENT") {
                        error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                      }
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._contentLength = stat.size;
                    this._setReadableStream(fs2.createReadStream(path));
                    this._headersCapability.resolve();
                  });
                }
              }
              class PDFNodeStreamFsRangeReader extends BaseRangeReader {
                constructor(stream, start, end) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  const fs2 = require_fs();
                  this._setReadableStream(fs2.createReadStream(path, {
                    start,
                    end: end - 1
                  }));
                }
              }
            },
            /* 24 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SVGGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _util2 = __w_pdfjs_require__2(1);
              ;
              const SVG_DEFAULTS = {
                fontStyle: "normal",
                fontWeight: "normal",
                fillColor: "#000000"
              };
              const XML_NS = "http://www.w3.org/XML/1998/namespace";
              const XLINK_NS = "http://www.w3.org/1999/xlink";
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const createObjectURL = function(data, contentType = "", forceDataSchema = false) {
                if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                  return URL.createObjectURL(new Blob([data], {
                    type: contentType
                  }));
                }
                const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                let buffer = `data:${contentType};base64,`;
                for (let i3 = 0, ii2 = data.length; i3 < ii2; i3 += 3) {
                  const b1 = data[i3] & 255;
                  const b22 = data[i3 + 1] & 255;
                  const b3 = data[i3 + 2] & 255;
                  const d1 = b1 >> 2, d22 = (b1 & 3) << 4 | b22 >> 4;
                  const d3 = i3 + 1 < ii2 ? (b22 & 15) << 2 | b3 >> 6 : 64;
                  const d4 = i3 + 2 < ii2 ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d22] + digits[d3] + digits[d4];
                }
                return buffer;
              };
              const convertImgDataToPng = function() {
                const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                const CHUNK_WRAPPER_SIZE = 12;
                const crcTable = new Int32Array(256);
                for (let i3 = 0; i3 < 256; i3++) {
                  let c3 = i3;
                  for (let h2 = 0; h2 < 8; h2++) {
                    c3 = c3 & 1 ? 3988292384 ^ c3 >> 1 & 2147483647 : c3 >> 1 & 2147483647;
                  }
                  crcTable[i3] = c3;
                }
                function crc32(data, start, end) {
                  let crc = -1;
                  for (let i3 = start; i3 < end; i3++) {
                    const a3 = (crc ^ data[i3]) & 255;
                    const b3 = crcTable[a3];
                    crc = crc >>> 8 ^ b3;
                  }
                  return crc ^ -1;
                }
                function writePngChunk(type, body, data, offset) {
                  let p2 = offset;
                  const len = body.length;
                  data[p2] = len >> 24 & 255;
                  data[p2 + 1] = len >> 16 & 255;
                  data[p2 + 2] = len >> 8 & 255;
                  data[p2 + 3] = len & 255;
                  p2 += 4;
                  data[p2] = type.charCodeAt(0) & 255;
                  data[p2 + 1] = type.charCodeAt(1) & 255;
                  data[p2 + 2] = type.charCodeAt(2) & 255;
                  data[p2 + 3] = type.charCodeAt(3) & 255;
                  p2 += 4;
                  data.set(body, p2);
                  p2 += body.length;
                  const crc = crc32(data, offset + 4, p2);
                  data[p2] = crc >> 24 & 255;
                  data[p2 + 1] = crc >> 16 & 255;
                  data[p2 + 2] = crc >> 8 & 255;
                  data[p2 + 3] = crc & 255;
                }
                function adler32(data, start, end) {
                  let a3 = 1;
                  let b3 = 0;
                  for (let i3 = start; i3 < end; ++i3) {
                    a3 = (a3 + (data[i3] & 255)) % 65521;
                    b3 = (b3 + a3) % 65521;
                  }
                  return b3 << 16 | a3;
                }
                function deflateSync(literals) {
                  if (!_util2.isNodeJS) {
                    return deflateSyncUncompressed(literals);
                  }
                  try {
                    const input = parseInt(process.versions.node) >= 8 ? literals : Buffer.from(literals);
                    const output = require_zlib().deflateSync(input, {
                      level: 9
                    });
                    return output instanceof Uint8Array ? output : new Uint8Array(output);
                  } catch (e3) {
                    (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e3);
                  }
                  return deflateSyncUncompressed(literals);
                }
                function deflateSyncUncompressed(literals) {
                  let len = literals.length;
                  const maxBlockLength = 65535;
                  const deflateBlocks = Math.ceil(len / maxBlockLength);
                  const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                  let pi2 = 0;
                  idat[pi2++] = 120;
                  idat[pi2++] = 156;
                  let pos = 0;
                  while (len > maxBlockLength) {
                    idat[pi2++] = 0;
                    idat[pi2++] = 255;
                    idat[pi2++] = 255;
                    idat[pi2++] = 0;
                    idat[pi2++] = 0;
                    idat.set(literals.subarray(pos, pos + maxBlockLength), pi2);
                    pi2 += maxBlockLength;
                    pos += maxBlockLength;
                    len -= maxBlockLength;
                  }
                  idat[pi2++] = 1;
                  idat[pi2++] = len & 255;
                  idat[pi2++] = len >> 8 & 255;
                  idat[pi2++] = ~len & 65535 & 255;
                  idat[pi2++] = (~len & 65535) >> 8 & 255;
                  idat.set(literals.subarray(pos), pi2);
                  pi2 += literals.length - pos;
                  const adler = adler32(literals, 0, literals.length);
                  idat[pi2++] = adler >> 24 & 255;
                  idat[pi2++] = adler >> 16 & 255;
                  idat[pi2++] = adler >> 8 & 255;
                  idat[pi2++] = adler & 255;
                  return idat;
                }
                function encode(imgData, kind, forceDataSchema, isMask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  let bitDepth, colorType, lineSize;
                  const bytes = imgData.data;
                  switch (kind) {
                    case _util2.ImageKind.GRAYSCALE_1BPP:
                      colorType = 0;
                      bitDepth = 1;
                      lineSize = width + 7 >> 3;
                      break;
                    case _util2.ImageKind.RGB_24BPP:
                      colorType = 2;
                      bitDepth = 8;
                      lineSize = width * 3;
                      break;
                    case _util2.ImageKind.RGBA_32BPP:
                      colorType = 6;
                      bitDepth = 8;
                      lineSize = width * 4;
                      break;
                    default:
                      throw new Error("invalid format");
                  }
                  const literals = new Uint8Array((1 + lineSize) * height);
                  let offsetLiterals = 0, offsetBytes = 0;
                  for (let y3 = 0; y3 < height; ++y3) {
                    literals[offsetLiterals++] = 0;
                    literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                    offsetBytes += lineSize;
                    offsetLiterals += lineSize;
                  }
                  if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                    offsetLiterals = 0;
                    for (let y3 = 0; y3 < height; y3++) {
                      offsetLiterals++;
                      for (let i3 = 0; i3 < lineSize; i3++) {
                        literals[offsetLiterals++] ^= 255;
                      }
                    }
                  }
                  const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                  const idat = deflateSync(literals);
                  const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                  const data = new Uint8Array(pngLength);
                  let offset = 0;
                  data.set(PNG_HEADER, offset);
                  offset += PNG_HEADER.length;
                  writePngChunk("IHDR", ihdr, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                  writePngChunk("IDATA", idat, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + idat.length;
                  writePngChunk("IEND", new Uint8Array(0), data, offset);
                  return createObjectURL(data, "image/png", forceDataSchema);
                }
                return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                  const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                  return encode(imgData, kind, forceDataSchema, isMask);
                };
              }();
              class SVGExtraState {
                constructor() {
                  this.fontSizeScale = 1;
                  this.fontWeight = SVG_DEFAULTS.fontWeight;
                  this.fontSize = 0;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textMatrixScale = 1;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                  this.fillColor = SVG_DEFAULTS.fillColor;
                  this.strokeColor = "#000000";
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.lineJoin = "";
                  this.lineCap = "";
                  this.miterLimit = 0;
                  this.dashArray = [];
                  this.dashPhase = 0;
                  this.dependencies = [];
                  this.activeClipUrl = null;
                  this.clipGroup = null;
                  this.maskId = "";
                }
                clone() {
                  return Object.create(this);
                }
                setCurrentPoint(x3, y3) {
                  this.x = x3;
                  this.y = y3;
                }
              }
              function opListToTree(opList) {
                let opTree = [];
                const tmp = [];
                for (const opListElement of opList) {
                  if (opListElement.fn === "save") {
                    opTree.push({
                      fnId: 92,
                      fn: "group",
                      items: []
                    });
                    tmp.push(opTree);
                    opTree = opTree.at(-1).items;
                    continue;
                  }
                  if (opListElement.fn === "restore") {
                    opTree = tmp.pop();
                  } else {
                    opTree.push(opListElement);
                  }
                }
                return opTree;
              }
              function pf(value) {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                const s3 = value.toFixed(10);
                let i3 = s3.length - 1;
                if (s3[i3] !== "0") {
                  return s3;
                }
                do {
                  i3--;
                } while (s3[i3] === "0");
                return s3.substring(0, s3[i3] === "." ? i3 : i3 + 1);
              }
              function pm(m3) {
                if (m3[4] === 0 && m3[5] === 0) {
                  if (m3[1] === 0 && m3[2] === 0) {
                    if (m3[0] === 1 && m3[3] === 1) {
                      return "";
                    }
                    return `scale(${pf(m3[0])} ${pf(m3[3])})`;
                  }
                  if (m3[0] === m3[3] && m3[1] === -m3[2]) {
                    const a3 = Math.acos(m3[0]) * 180 / Math.PI;
                    return `rotate(${pf(a3)})`;
                  }
                } else if (m3[0] === 1 && m3[1] === 0 && m3[2] === 0 && m3[3] === 1) {
                  return `translate(${pf(m3[4])} ${pf(m3[5])})`;
                }
                return `matrix(${pf(m3[0])} ${pf(m3[1])} ${pf(m3[2])} ${pf(m3[3])} ${pf(m3[4])} ${pf(m3[5])})`;
              }
              let clipCount = 0;
              let maskCount = 0;
              let shadingCount = 0;
              class SVGGraphics {
                constructor(commonObjs, objs, forceDataSchema = false) {
                  (0, _display_utils2.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
                  this.svgFactory = new _display_utils2.DOMSVGFactory();
                  this.current = new SVGExtraState();
                  this.transformMatrix = _util2.IDENTITY_MATRIX;
                  this.transformStack = [];
                  this.extraStack = [];
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.embedFonts = false;
                  this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                  this.cssStyle = null;
                  this.forceDataSchema = !!forceDataSchema;
                  this._operatorIdMapping = [];
                  for (const op in _util2.OPS) {
                    this._operatorIdMapping[_util2.OPS[op]] = op;
                  }
                }
                getObject(data, fallback = null) {
                  if (typeof data === "string") {
                    return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                  }
                  return fallback;
                }
                save() {
                  this.transformStack.push(this.transformMatrix);
                  const old = this.current;
                  this.extraStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  this.transformMatrix = this.transformStack.pop();
                  this.current = this.extraStack.pop();
                  this.pendingClip = null;
                  this.tgrp = null;
                }
                group(items) {
                  this.save();
                  this.executeOpTree(items);
                  this.restore();
                }
                loadDependencies(operatorList) {
                  const fnArray = operatorList.fnArray;
                  const argsArray = operatorList.argsArray;
                  for (let i3 = 0, ii2 = fnArray.length; i3 < ii2; i3++) {
                    if (fnArray[i3] !== _util2.OPS.dependency) {
                      continue;
                    }
                    for (const obj of argsArray[i3]) {
                      const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                      const promise = new Promise((resolve) => {
                        objsPool.get(obj, resolve);
                      });
                      this.current.dependencies.push(promise);
                    }
                  }
                  return Promise.all(this.current.dependencies);
                }
                transform(a3, b3, c3, d3, e3, f2) {
                  const transformMatrix = [a3, b3, c3, d3, e3, f2];
                  this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                  this.tgrp = null;
                }
                getSVG(operatorList, viewport) {
                  this.viewport = viewport;
                  const svgElement = this._initialize(viewport);
                  return this.loadDependencies(operatorList).then(() => {
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.executeOpTree(this.convertOpList(operatorList));
                    return svgElement;
                  });
                }
                convertOpList(operatorList) {
                  const operatorIdMapping = this._operatorIdMapping;
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  const opList = [];
                  for (let i3 = 0, ii2 = fnArray.length; i3 < ii2; i3++) {
                    const fnId = fnArray[i3];
                    opList.push({
                      fnId,
                      fn: operatorIdMapping[fnId],
                      args: argsArray[i3]
                    });
                  }
                  return opListToTree(opList);
                }
                executeOpTree(opTree) {
                  for (const opTreeElement of opTree) {
                    const fn2 = opTreeElement.fn;
                    const fnId = opTreeElement.fnId;
                    const args = opTreeElement.args;
                    switch (fnId | 0) {
                      case _util2.OPS.beginText:
                        this.beginText();
                        break;
                      case _util2.OPS.dependency:
                        break;
                      case _util2.OPS.setLeading:
                        this.setLeading(args);
                        break;
                      case _util2.OPS.setLeadingMoveText:
                        this.setLeadingMoveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setFont:
                        this.setFont(args);
                        break;
                      case _util2.OPS.showText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.showSpacedText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.endText:
                        this.endText();
                        break;
                      case _util2.OPS.moveText:
                        this.moveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setCharSpacing:
                        this.setCharSpacing(args[0]);
                        break;
                      case _util2.OPS.setWordSpacing:
                        this.setWordSpacing(args[0]);
                        break;
                      case _util2.OPS.setHScale:
                        this.setHScale(args[0]);
                        break;
                      case _util2.OPS.setTextMatrix:
                        this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.setTextRise:
                        this.setTextRise(args[0]);
                        break;
                      case _util2.OPS.setTextRenderingMode:
                        this.setTextRenderingMode(args[0]);
                        break;
                      case _util2.OPS.setLineWidth:
                        this.setLineWidth(args[0]);
                        break;
                      case _util2.OPS.setLineJoin:
                        this.setLineJoin(args[0]);
                        break;
                      case _util2.OPS.setLineCap:
                        this.setLineCap(args[0]);
                        break;
                      case _util2.OPS.setMiterLimit:
                        this.setMiterLimit(args[0]);
                        break;
                      case _util2.OPS.setFillRGBColor:
                        this.setFillRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeRGBColor:
                        this.setStrokeRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeColorN:
                        this.setStrokeColorN(args);
                        break;
                      case _util2.OPS.setFillColorN:
                        this.setFillColorN(args);
                        break;
                      case _util2.OPS.shadingFill:
                        this.shadingFill(args[0]);
                        break;
                      case _util2.OPS.setDash:
                        this.setDash(args[0], args[1]);
                        break;
                      case _util2.OPS.setRenderingIntent:
                        this.setRenderingIntent(args[0]);
                        break;
                      case _util2.OPS.setFlatness:
                        this.setFlatness(args[0]);
                        break;
                      case _util2.OPS.setGState:
                        this.setGState(args[0]);
                        break;
                      case _util2.OPS.fill:
                        this.fill();
                        break;
                      case _util2.OPS.eoFill:
                        this.eoFill();
                        break;
                      case _util2.OPS.stroke:
                        this.stroke();
                        break;
                      case _util2.OPS.fillStroke:
                        this.fillStroke();
                        break;
                      case _util2.OPS.eoFillStroke:
                        this.eoFillStroke();
                        break;
                      case _util2.OPS.clip:
                        this.clip("nonzero");
                        break;
                      case _util2.OPS.eoClip:
                        this.clip("evenodd");
                        break;
                      case _util2.OPS.paintSolidColorImageMask:
                        this.paintSolidColorImageMask();
                        break;
                      case _util2.OPS.paintImageXObject:
                        this.paintImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintInlineImageXObject:
                        this.paintInlineImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintImageMaskXObject:
                        this.paintImageMaskXObject(args[0]);
                        break;
                      case _util2.OPS.paintFormXObjectBegin:
                        this.paintFormXObjectBegin(args[0], args[1]);
                        break;
                      case _util2.OPS.paintFormXObjectEnd:
                        this.paintFormXObjectEnd();
                        break;
                      case _util2.OPS.closePath:
                        this.closePath();
                        break;
                      case _util2.OPS.closeStroke:
                        this.closeStroke();
                        break;
                      case _util2.OPS.closeFillStroke:
                        this.closeFillStroke();
                        break;
                      case _util2.OPS.closeEOFillStroke:
                        this.closeEOFillStroke();
                        break;
                      case _util2.OPS.nextLine:
                        this.nextLine();
                        break;
                      case _util2.OPS.transform:
                        this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.constructPath:
                        this.constructPath(args[0], args[1]);
                        break;
                      case _util2.OPS.endPath:
                        this.endPath();
                        break;
                      case 92:
                        this.group(opTreeElement.items);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented operator ${fn2}`);
                        break;
                    }
                  }
                }
                setWordSpacing(wordSpacing) {
                  this.current.wordSpacing = wordSpacing;
                }
                setCharSpacing(charSpacing) {
                  this.current.charSpacing = charSpacing;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                setTextMatrix(a3, b3, c3, d3, e3, f2) {
                  const current = this.current;
                  current.textMatrix = current.lineMatrix = [a3, b3, c3, d3, e3, f2];
                  current.textMatrixScale = Math.hypot(a3, b3);
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.xcoords = [];
                  current.ycoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtElement.append(current.tspan);
                }
                beginText() {
                  const current = this.current;
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.textMatrix = _util2.IDENTITY_MATRIX;
                  current.lineMatrix = _util2.IDENTITY_MATRIX;
                  current.textMatrixScale = 1;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtgrp = this.svgFactory.createElement("svg:g");
                  current.xcoords = [];
                  current.ycoords = [];
                }
                moveText(x3, y3) {
                  const current = this.current;
                  current.x = current.lineX += x3;
                  current.y = current.lineY += y3;
                  current.xcoords = [];
                  current.ycoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return;
                  }
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const vertical = font.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  let x3 = 0;
                  for (const glyph of glyphs) {
                    if (glyph === null) {
                      x3 += fontDirection * wordSpacing;
                      continue;
                    } else if (typeof glyph === "number") {
                      x3 += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    let scaledX, scaledY;
                    let width = glyph.width;
                    if (vertical) {
                      let vx;
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                      vx = -vx * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x3 + vy) / fontSizeScale;
                    } else {
                      scaledX = x3 / fontSizeScale;
                      scaledY = 0;
                    }
                    if (glyph.isInFont || font.missingFile) {
                      current.xcoords.push(current.x + scaledX);
                      if (vertical) {
                        current.ycoords.push(-current.y + scaledY);
                      }
                      current.tspan.textContent += character;
                    } else {
                    }
                    const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
                    x3 += charWidth;
                  }
                  current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                  if (vertical) {
                    current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                  } else {
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  }
                  if (vertical) {
                    current.y -= x3;
                  } else {
                    current.x += x3 * textHScale;
                  }
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                    current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                  }
                  if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                    current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                  }
                  const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                      current.tspan.setAttributeNS(null, "fill", current.fillColor);
                    }
                    if (current.fillAlpha < 1) {
                      current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    }
                  } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                    current.tspan.setAttributeNS(null, "fill", "transparent");
                  } else {
                    current.tspan.setAttributeNS(null, "fill", "none");
                  }
                  if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    const lineWidthScale = 1 / (current.textMatrixScale || 1);
                    this._setStrokeAttributes(current.tspan, lineWidthScale);
                  }
                  let textMatrix = current.textMatrix;
                  if (current.textRise !== 0) {
                    textMatrix = textMatrix.slice();
                    textMatrix[5] += current.textRise;
                  }
                  current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                  current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                  current.txtElement.append(current.tspan);
                  current.txtgrp.append(current.txtElement);
                  this._ensureTransformGroup().append(current.txtElement);
                }
                setLeadingMoveText(x3, y3) {
                  this.setLeading(-y3);
                  this.moveText(x3, y3);
                }
                addFontStyle(fontObj) {
                  if (!fontObj.data) {
                    throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                  }
                  if (!this.cssStyle) {
                    this.cssStyle = this.svgFactory.createElement("svg:style");
                    this.cssStyle.setAttributeNS(null, "type", "text/css");
                    this.defs.append(this.cssStyle);
                  }
                  const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                  this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url}); }
`;
                }
                setFont(details) {
                  const current = this.current;
                  const fontObj = this.commonObjs.get(details[0]);
                  let size = details[1];
                  current.font = fontObj;
                  if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                    this.addFontStyle(fontObj);
                    this.embeddedFonts[fontObj.loadedName] = fontObj;
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  current.fontSize = size;
                  current.fontFamily = fontObj.loadedName;
                  current.fontWeight = bold;
                  current.fontStyle = italic;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.xcoords = [];
                  current.ycoords = [];
                }
                endText() {
                  var _a3;
                  const current = this.current;
                  if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && ((_a3 = current.txtElement) == null ? void 0 : _a3.hasChildNodes())) {
                    current.element = current.txtElement;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                setLineWidth(width) {
                  if (width > 0) {
                    this.current.lineWidth = width;
                  }
                }
                setLineCap(style) {
                  this.current.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.current.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.current.miterLimit = limit;
                }
                setStrokeAlpha(strokeAlpha) {
                  this.current.strokeAlpha = strokeAlpha;
                }
                setStrokeRGBColor(r3, g3, b3) {
                  this.current.strokeColor = _util2.Util.makeHexColor(r3, g3, b3);
                }
                setFillAlpha(fillAlpha) {
                  this.current.fillAlpha = fillAlpha;
                }
                setFillRGBColor(r3, g3, b3) {
                  this.current.fillColor = _util2.Util.makeHexColor(r3, g3, b3);
                  this.current.tspan = this.svgFactory.createElement("svg:tspan");
                  this.current.xcoords = [];
                  this.current.ycoords = [];
                }
                setStrokeColorN(args) {
                  this.current.strokeColor = this._makeColorN_Pattern(args);
                }
                setFillColorN(args) {
                  this.current.fillColor = this._makeColorN_Pattern(args);
                }
                shadingFill(args) {
                  const {
                    width,
                    height
                  } = this.viewport;
                  const inv = _util2.Util.inverseTransform(this.transformMatrix);
                  const [x0, y0, x1, y1] = _util2.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", x0);
                  rect.setAttributeNS(null, "y", y0);
                  rect.setAttributeNS(null, "width", x1 - x0);
                  rect.setAttributeNS(null, "height", y1 - y0);
                  rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                  if (this.current.fillAlpha < 1) {
                    rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                  }
                  this._ensureTransformGroup().append(rect);
                }
                _makeColorN_Pattern(args) {
                  if (args[0] === "TilingPattern") {
                    return this._makeTilingPattern(args);
                  }
                  return this._makeShadingPattern(args);
                }
                _makeTilingPattern(args) {
                  const color = args[1];
                  const operatorList = args[2];
                  const matrix = args[3] || _util2.IDENTITY_MATRIX;
                  const [x0, y0, x1, y1] = args[4];
                  const xstep = args[5];
                  const ystep = args[6];
                  const paintType = args[7];
                  const tilingId = `shading${shadingCount++}`;
                  const [tx0, ty0, tx1, ty1] = _util2.Util.normalizeRect([..._util2.Util.applyTransform([x0, y0], matrix), ..._util2.Util.applyTransform([x1, y1], matrix)]);
                  const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                  const txstep = xstep * xscale;
                  const tystep = ystep * yscale;
                  const tiling = this.svgFactory.createElement("svg:pattern");
                  tiling.setAttributeNS(null, "id", tilingId);
                  tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                  tiling.setAttributeNS(null, "width", txstep);
                  tiling.setAttributeNS(null, "height", tystep);
                  tiling.setAttributeNS(null, "x", `${tx0}`);
                  tiling.setAttributeNS(null, "y", `${ty0}`);
                  const svg = this.svg;
                  const transformMatrix = this.transformMatrix;
                  const fillColor = this.current.fillColor;
                  const strokeColor = this.current.strokeColor;
                  const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                  this.svg = bbox;
                  this.transformMatrix = matrix;
                  if (paintType === 2) {
                    const cssColor = _util2.Util.makeHexColor(...color);
                    this.current.fillColor = cssColor;
                    this.current.strokeColor = cssColor;
                  }
                  this.executeOpTree(this.convertOpList(operatorList));
                  this.svg = svg;
                  this.transformMatrix = transformMatrix;
                  this.current.fillColor = fillColor;
                  this.current.strokeColor = strokeColor;
                  tiling.append(bbox.childNodes[0]);
                  this.defs.append(tiling);
                  return `url(#${tilingId})`;
                }
                _makeShadingPattern(args) {
                  if (typeof args === "string") {
                    args = this.objs.get(args);
                  }
                  switch (args[0]) {
                    case "RadialAxial":
                      const shadingId = `shading${shadingCount++}`;
                      const colorStops = args[3];
                      let gradient;
                      switch (args[1]) {
                        case "axial":
                          const point0 = args[4];
                          const point1 = args[5];
                          gradient = this.svgFactory.createElement("svg:linearGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "x1", point0[0]);
                          gradient.setAttributeNS(null, "y1", point0[1]);
                          gradient.setAttributeNS(null, "x2", point1[0]);
                          gradient.setAttributeNS(null, "y2", point1[1]);
                          break;
                        case "radial":
                          const focalPoint = args[4];
                          const circlePoint = args[5];
                          const focalRadius = args[6];
                          const circleRadius = args[7];
                          gradient = this.svgFactory.createElement("svg:radialGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "cx", circlePoint[0]);
                          gradient.setAttributeNS(null, "cy", circlePoint[1]);
                          gradient.setAttributeNS(null, "r", circleRadius);
                          gradient.setAttributeNS(null, "fx", focalPoint[0]);
                          gradient.setAttributeNS(null, "fy", focalPoint[1]);
                          gradient.setAttributeNS(null, "fr", focalRadius);
                          break;
                        default:
                          throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                      }
                      for (const colorStop of colorStops) {
                        const stop = this.svgFactory.createElement("svg:stop");
                        stop.setAttributeNS(null, "offset", colorStop[0]);
                        stop.setAttributeNS(null, "stop-color", colorStop[1]);
                        gradient.append(stop);
                      }
                      this.defs.append(gradient);
                      return `url(#${shadingId})`;
                    case "Mesh":
                      (0, _util2.warn)("Unimplemented pattern Mesh");
                      return null;
                    case "Dummy":
                      return "hotpink";
                    default:
                      throw new Error(`Unknown IR type: ${args[0]}`);
                  }
                }
                setDash(dashArray, dashPhase) {
                  this.current.dashArray = dashArray;
                  this.current.dashPhase = dashPhase;
                }
                constructPath(ops, args) {
                  const current = this.current;
                  let x3 = current.x, y3 = current.y;
                  let d3 = [];
                  let j3 = 0;
                  for (const op of ops) {
                    switch (op | 0) {
                      case _util2.OPS.rectangle:
                        x3 = args[j3++];
                        y3 = args[j3++];
                        const width = args[j3++];
                        const height = args[j3++];
                        const xw = x3 + width;
                        const yh = y3 + height;
                        d3.push("M", pf(x3), pf(y3), "L", pf(xw), pf(y3), "L", pf(xw), pf(yh), "L", pf(x3), pf(yh), "Z");
                        break;
                      case _util2.OPS.moveTo:
                        x3 = args[j3++];
                        y3 = args[j3++];
                        d3.push("M", pf(x3), pf(y3));
                        break;
                      case _util2.OPS.lineTo:
                        x3 = args[j3++];
                        y3 = args[j3++];
                        d3.push("L", pf(x3), pf(y3));
                        break;
                      case _util2.OPS.curveTo:
                        x3 = args[j3 + 4];
                        y3 = args[j3 + 5];
                        d3.push("C", pf(args[j3]), pf(args[j3 + 1]), pf(args[j3 + 2]), pf(args[j3 + 3]), pf(x3), pf(y3));
                        j3 += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        d3.push("C", pf(x3), pf(y3), pf(args[j3]), pf(args[j3 + 1]), pf(args[j3 + 2]), pf(args[j3 + 3]));
                        x3 = args[j3 + 2];
                        y3 = args[j3 + 3];
                        j3 += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x3 = args[j3 + 2];
                        y3 = args[j3 + 3];
                        d3.push("C", pf(args[j3]), pf(args[j3 + 1]), pf(x3), pf(y3), pf(x3), pf(y3));
                        j3 += 4;
                        break;
                      case _util2.OPS.closePath:
                        d3.push("Z");
                        break;
                    }
                  }
                  d3 = d3.join(" ");
                  if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                    d3 = current.path.getAttributeNS(null, "d") + d3;
                  } else {
                    current.path = this.svgFactory.createElement("svg:path");
                    this._ensureTransformGroup().append(current.path);
                  }
                  current.path.setAttributeNS(null, "d", d3);
                  current.path.setAttributeNS(null, "fill", "none");
                  current.element = current.path;
                  current.setCurrentPoint(x3, y3);
                }
                endPath() {
                  const current = this.current;
                  current.path = null;
                  if (!this.pendingClip) {
                    return;
                  }
                  if (!current.element) {
                    this.pendingClip = null;
                    return;
                  }
                  const clipId = `clippath${clipCount++}`;
                  const clipPath = this.svgFactory.createElement("svg:clipPath");
                  clipPath.setAttributeNS(null, "id", clipId);
                  clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                  const clipElement = current.element.cloneNode(true);
                  if (this.pendingClip === "evenodd") {
                    clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                  } else {
                    clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                  }
                  this.pendingClip = null;
                  clipPath.append(clipElement);
                  this.defs.append(clipPath);
                  if (current.activeClipUrl) {
                    current.clipGroup = null;
                    for (const prev of this.extraStack) {
                      prev.clipGroup = null;
                    }
                    clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                  }
                  current.activeClipUrl = `url(#${clipId})`;
                  this.tgrp = null;
                }
                clip(type) {
                  this.pendingClip = type;
                }
                closePath() {
                  const current = this.current;
                  if (current.path) {
                    const d3 = `${current.path.getAttributeNS(null, "d")}Z`;
                    current.path.setAttributeNS(null, "d", d3);
                  }
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setTextRise(textRise) {
                  this.current.textRise = textRise;
                }
                setTextRenderingMode(textRenderingMode) {
                  this.current.textRenderingMode = textRenderingMode;
                }
                setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (const [key, value] of states) {
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value);
                        break;
                      case "CA":
                        this.setStrokeAlpha(value);
                        break;
                      case "ca":
                        this.setFillAlpha(value);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                        break;
                    }
                  }
                }
                fill() {
                  const current = this.current;
                  if (current.element) {
                    current.element.setAttributeNS(null, "fill", current.fillColor);
                    current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    this.endPath();
                  }
                }
                stroke() {
                  const current = this.current;
                  if (current.element) {
                    this._setStrokeAttributes(current.element);
                    current.element.setAttributeNS(null, "fill", "none");
                    this.endPath();
                  }
                }
                _setStrokeAttributes(element, lineWidthScale = 1) {
                  const current = this.current;
                  let dashArray = current.dashArray;
                  if (lineWidthScale !== 1 && dashArray.length > 0) {
                    dashArray = dashArray.map(function(value) {
                      return lineWidthScale * value;
                    });
                  }
                  element.setAttributeNS(null, "stroke", current.strokeColor);
                  element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                  element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                  element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                  element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                  element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                  element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                  element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                }
                eoFill() {
                  var _a3;
                  (_a3 = this.current.element) == null ? void 0 : _a3.setAttributeNS(null, "fill-rule", "evenodd");
                  this.fill();
                }
                fillStroke() {
                  this.stroke();
                  this.fill();
                }
                eoFillStroke() {
                  var _a3;
                  (_a3 = this.current.element) == null ? void 0 : _a3.setAttributeNS(null, "fill-rule", "evenodd");
                  this.fillStroke();
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.closePath();
                  this.eoFillStroke();
                }
                paintSolidColorImageMask() {
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", "1px");
                  rect.setAttributeNS(null, "height", "1px");
                  rect.setAttributeNS(null, "fill", this.current.fillColor);
                  this._ensureTransformGroup().append(rect);
                }
                paintImageXObject(objId) {
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintInlineImageXObject(imgData, mask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                  const cliprect = this.svgFactory.createElement("svg:rect");
                  cliprect.setAttributeNS(null, "x", "0");
                  cliprect.setAttributeNS(null, "y", "0");
                  cliprect.setAttributeNS(null, "width", pf(width));
                  cliprect.setAttributeNS(null, "height", pf(height));
                  this.current.element = cliprect;
                  this.clip("nonzero");
                  const imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-height));
                  imgEl.setAttributeNS(null, "width", pf(width) + "px");
                  imgEl.setAttributeNS(null, "height", pf(height) + "px");
                  imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                  if (mask) {
                    mask.append(imgEl);
                  } else {
                    this._ensureTransformGroup().append(imgEl);
                  }
                }
                paintImageMaskXObject(img) {
                  const imgData = this.getObject(img.data, img);
                  if (imgData.bitmap) {
                    (0, _util2.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                    return;
                  }
                  const current = this.current;
                  const width = imgData.width;
                  const height = imgData.height;
                  const fillColor = current.fillColor;
                  current.maskId = `mask${maskCount++}`;
                  const mask = this.svgFactory.createElement("svg:mask");
                  mask.setAttributeNS(null, "id", current.maskId);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", pf(width));
                  rect.setAttributeNS(null, "height", pf(height));
                  rect.setAttributeNS(null, "fill", fillColor);
                  rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                  this.defs.append(mask);
                  this._ensureTransformGroup().append(rect);
                  this.paintInlineImageXObject(imgData, mask);
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                  }
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", bbox[0]);
                    cliprect.setAttributeNS(null, "y", bbox[1]);
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                }
                _initialize(viewport) {
                  const svg = this.svgFactory.create(viewport.width, viewport.height);
                  const definitions = this.svgFactory.createElement("svg:defs");
                  svg.append(definitions);
                  this.defs = definitions;
                  const rootGroup = this.svgFactory.createElement("svg:g");
                  rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                  svg.append(rootGroup);
                  this.svg = rootGroup;
                  return svg;
                }
                _ensureClipGroup() {
                  if (!this.current.clipGroup) {
                    const clipGroup = this.svgFactory.createElement("svg:g");
                    clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                    this.svg.append(clipGroup);
                    this.current.clipGroup = clipGroup;
                  }
                  return this.current.clipGroup;
                }
                _ensureTransformGroup() {
                  if (!this.tgrp) {
                    this.tgrp = this.svgFactory.createElement("svg:g");
                    this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    if (this.current.activeClipUrl) {
                      this._ensureClipGroup().append(this.tgrp);
                    } else {
                      this.svg.append(this.tgrp);
                    }
                  }
                  return this.tgrp;
                }
              }
              exports2.SVGGraphics = SVGGraphics;
            },
            /* 25 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaText = void 0;
              class XfaText {
                static textContent(xfa) {
                  const items = [];
                  const output = {
                    items,
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  function walk(node) {
                    var _a3;
                    if (!node) {
                      return;
                    }
                    let str = null;
                    const name = node.name;
                    if (name === "#text") {
                      str = node.value;
                    } else if (!XfaText.shouldBuildText(name)) {
                      return;
                    } else if ((_a3 = node == null ? void 0 : node.attributes) == null ? void 0 : _a3.textContent) {
                      str = node.attributes.textContent;
                    } else if (node.value) {
                      str = node.value;
                    }
                    if (str !== null) {
                      items.push({
                        str
                      });
                    }
                    if (!node.children) {
                      return;
                    }
                    for (const child of node.children) {
                      walk(child);
                    }
                  }
                  walk(xfa);
                  return output;
                }
                static shouldBuildText(name) {
                  return !(name === "textarea" || name === "input" || name === "option" || name === "select");
                }
              }
              exports2.XfaText = XfaText;
            },
            /* 26 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextLayerRenderTask = void 0;
              exports2.renderTextLayer = renderTextLayer;
              exports2.updateTextLayer = updateTextLayer;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              const MAX_TEXT_DIVS_TO_RENDER = 1e5;
              const DEFAULT_FONT_SIZE = 30;
              const DEFAULT_FONT_ASCENT = 0.8;
              const ascentCache = /* @__PURE__ */ new Map();
              function getCtx(size, isOffscreenCanvasSupported) {
                let ctx;
                if (isOffscreenCanvasSupported && _util2.FeatureTest.isOffscreenCanvasSupported) {
                  ctx = new OffscreenCanvas(size, size).getContext("2d", {
                    alpha: false
                  });
                } else {
                  const canvas = document.createElement("canvas");
                  canvas.width = canvas.height = size;
                  ctx = canvas.getContext("2d", {
                    alpha: false
                  });
                }
                return ctx;
              }
              function getAscent(fontFamily, isOffscreenCanvasSupported) {
                const cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);
                ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
                const metrics = ctx.measureText("");
                let ascent = metrics.fontBoundingBoxAscent;
                let descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  ctx.canvas.width = ctx.canvas.height = 0;
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (let i3 = pixels.length - 1 - 3; i3 >= 0; i3 -= 4) {
                  if (pixels[i3] > 0) {
                    descent = Math.ceil(i3 / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (let i3 = 0, ii2 = pixels.length; i3 < ii2; i3 += 4) {
                  if (pixels[i3] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(i3 / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.canvas.width = ctx.canvas.height = 0;
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom, styles) {
                const textDiv = document.createElement("span");
                const textDivProperties = {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  fontSize: 0
                };
                task._textDivs.push(textDiv);
                const tx = _util2.Util.transform(task._transform, geom.transform);
                let angle = Math.atan2(tx[1], tx[0]);
                const style = styles[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                const fontHeight = Math.hypot(tx[2], tx[3]);
                const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);
                let left, top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                const scaleFactorStr = "calc(var(--scale-factor)*";
                const divStyle = textDiv.style;
                if (task._container === task._rootContainer) {
                  divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;
                  divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;
                } else {
                  divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
                  divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
                }
                divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;
                divStyle.fontFamily = style.fontFamily;
                textDivProperties.fontSize = fontHeight;
                textDiv.setAttribute("role", "presentation");
                textDiv.textContent = geom.str;
                textDiv.dir = geom.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                let shouldScaleText = false;
                if (geom.str.length > 1) {
                  shouldScaleText = true;
                } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
                  const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._isReadableStream) {
                  task._layoutText(textDiv);
                }
              }
              function layout(params) {
                const {
                  div,
                  scale,
                  properties,
                  ctx,
                  prevFontSize,
                  prevFontFamily
                } = params;
                const {
                  style
                } = div;
                let transform = "";
                if (properties.canvasWidth !== 0 && properties.hasText) {
                  const {
                    fontFamily
                  } = style;
                  const {
                    canvasWidth,
                    fontSize
                  } = properties;
                  if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {
                    ctx.font = `${fontSize * scale}px ${fontFamily}`;
                    params.prevFontSize = fontSize;
                    params.prevFontFamily = fontFamily;
                  }
                  const {
                    width
                  } = ctx.measureText(div.textContent);
                  if (width > 0) {
                    transform = `scaleX(${canvasWidth * scale / width})`;
                  }
                }
                if (properties.angle !== 0) {
                  transform = `rotate(${properties.angle}deg) ${transform}`;
                }
                if (transform.length > 0) {
                  style.transform = transform;
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                const textDivs = task._textDivs;
                const capability = task._capability;
                const textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  capability.resolve();
                  return;
                }
                if (!task._isReadableStream) {
                  for (const textDiv of textDivs) {
                    task._layoutText(textDiv);
                  }
                }
                capability.resolve();
              }
              class TextLayerRenderTask {
                constructor({
                  textContentSource,
                  container,
                  viewport,
                  textDivs,
                  textDivProperties,
                  textContentItemsStr,
                  isOffscreenCanvasSupported
                }) {
                  var _a3;
                  this._textContentSource = textContentSource;
                  this._isReadableStream = textContentSource instanceof ReadableStream;
                  this._container = this._rootContainer = container;
                  this._textDivs = textDivs || [];
                  this._textContentItemsStr = textContentItemsStr || [];
                  this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;
                  this._fontInspectorEnabled = !!((_a3 = globalThis.FontInspector) == null ? void 0 : _a3.enabled);
                  this._reader = null;
                  this._textDivProperties = textDivProperties || /* @__PURE__ */ new WeakMap();
                  this._canceled = false;
                  this._capability = new _util2.PromiseCapability();
                  this._layoutTextParams = {
                    prevFontSize: null,
                    prevFontFamily: null,
                    div: null,
                    scale: viewport.scale * (globalThis.devicePixelRatio || 1),
                    properties: null,
                    ctx: getCtx(0, isOffscreenCanvasSupported)
                  };
                  const {
                    pageWidth,
                    pageHeight,
                    pageX,
                    pageY
                  } = viewport.rawDims;
                  this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
                  this._pageWidth = pageWidth;
                  this._pageHeight = pageHeight;
                  (0, _display_utils2.setLayerDimensions)(container, viewport);
                  this._capability.promise.finally(() => {
                    this._layoutTextParams = null;
                  }).catch(() => {
                  });
                }
                get promise() {
                  return this._capability.promise;
                }
                cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled.")).catch(() => {
                    });
                    this._reader = null;
                  }
                  this._capability.reject(new _util2.AbortException("TextLayer task cancelled."));
                }
                _processItems(items, styleCache) {
                  for (const item of items) {
                    if (item.str === void 0) {
                      if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
                        const parent = this._container;
                        this._container = document.createElement("span");
                        this._container.classList.add("markedContent");
                        if (item.id !== null) {
                          this._container.setAttribute("id", `${item.id}`);
                        }
                        parent.append(this._container);
                      } else if (item.type === "endMarkedContent") {
                        this._container = this._container.parentNode;
                      }
                      continue;
                    }
                    this._textContentItemsStr.push(item.str);
                    appendText(this, item, styleCache);
                  }
                }
                _layoutText(textDiv) {
                  const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);
                  this._layoutTextParams.div = textDiv;
                  layout(this._layoutTextParams);
                  if (textDivProperties.hasText) {
                    this._container.append(textDiv);
                  }
                  if (textDivProperties.hasEOL) {
                    const br2 = document.createElement("br");
                    br2.setAttribute("role", "presentation");
                    this._container.append(br2);
                  }
                }
                _render() {
                  const capability = new _util2.PromiseCapability();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  if (this._isReadableStream) {
                    const pump = () => {
                      this._reader.read().then(({
                        value,
                        done
                      }) => {
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value.styles);
                        this._processItems(value.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentSource.getReader();
                    pump();
                  } else if (this._textContentSource) {
                    const {
                      items,
                      styles
                    } = this._textContentSource;
                    this._processItems(items, styles);
                    capability.resolve();
                  } else {
                    throw new Error('No "textContentSource" parameter specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    render(this);
                  }, this._capability.reject);
                }
              }
              exports2.TextLayerRenderTask = TextLayerRenderTask;
              function renderTextLayer(params) {
                if (!params.textContentSource && (params.textContent || params.textContentStream)) {
                  (0, _display_utils2.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead.");
                  params.textContentSource = params.textContent || params.textContentStream;
                }
                const {
                  container,
                  viewport
                } = params;
                const style = getComputedStyle(container);
                const visibility = style.getPropertyValue("visibility");
                const scaleFactor = parseFloat(style.getPropertyValue("--scale-factor"));
                if (visibility === "visible" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {
                  console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
                }
                const task = new TextLayerRenderTask(params);
                task._render();
                return task;
              }
              function updateTextLayer({
                container,
                viewport,
                textDivs,
                textDivProperties,
                isOffscreenCanvasSupported,
                mustRotate = true,
                mustRescale = true
              }) {
                if (mustRotate) {
                  (0, _display_utils2.setLayerDimensions)(container, {
                    rotation: viewport.rotation
                  });
                }
                if (mustRescale) {
                  const ctx = getCtx(0, isOffscreenCanvasSupported);
                  const scale = viewport.scale * (globalThis.devicePixelRatio || 1);
                  const params = {
                    prevFontSize: null,
                    prevFontFamily: null,
                    div: null,
                    scale,
                    properties: null,
                    ctx
                  };
                  for (const div of textDivs) {
                    params.properties = textDivProperties.get(div);
                    params.div = div;
                    layout(params);
                  }
                }
              }
            },
            /* 27 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _accessibilityManager, _allowClick, _annotationLayer, _boundPointerup, _boundPointerdown, _editors, _hadPointerDown, _isCleaningUp, _isDisabling, _uiManager, _createNewEditor, createNewEditor_fn, _createAndAddNewEditor, createAndAddNewEditor_fn, _getCenterPoint, getCenterPoint_fn, _cleanup, cleanup_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditorLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(4);
              var _freetext = __w_pdfjs_require__2(28);
              var _ink = __w_pdfjs_require__2(33);
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _stamp = __w_pdfjs_require__2(34);
              const _AnnotationEditorLayer = class _AnnotationEditorLayer {
                constructor({
                  uiManager,
                  pageIndex,
                  div,
                  accessibilityManager,
                  annotationLayer,
                  viewport,
                  l10n
                }) {
                  __privateAdd(this, _createNewEditor);
                  __privateAdd(this, _createAndAddNewEditor);
                  __privateAdd(this, _getCenterPoint);
                  __privateAdd(this, _cleanup);
                  __privateAdd(this, _accessibilityManager, void 0);
                  __privateAdd(this, _allowClick, false);
                  __privateAdd(this, _annotationLayer, null);
                  __privateAdd(this, _boundPointerup, this.pointerup.bind(this));
                  __privateAdd(this, _boundPointerdown, this.pointerdown.bind(this));
                  __privateAdd(this, _editors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _hadPointerDown, false);
                  __privateAdd(this, _isCleaningUp, false);
                  __privateAdd(this, _isDisabling, false);
                  __privateAdd(this, _uiManager, void 0);
                  const editorTypes = [_freetext.FreeTextEditor, _ink.InkEditor, _stamp.StampEditor];
                  if (!_AnnotationEditorLayer._initialized) {
                    _AnnotationEditorLayer._initialized = true;
                    for (const editorType of editorTypes) {
                      editorType.initialize(l10n);
                    }
                  }
                  uiManager.registerEditorTypes(editorTypes);
                  __privateSet(this, _uiManager, uiManager);
                  this.pageIndex = pageIndex;
                  this.div = div;
                  __privateSet(this, _accessibilityManager, accessibilityManager);
                  __privateSet(this, _annotationLayer, annotationLayer);
                  this.viewport = viewport;
                  __privateGet(this, _uiManager).addLayer(this);
                }
                get isEmpty() {
                  return __privateGet(this, _editors).size === 0;
                }
                updateToolbar(mode) {
                  __privateGet(this, _uiManager).updateToolbar(mode);
                }
                updateMode(mode = __privateGet(this, _uiManager).getMode()) {
                  __privateMethod(this, _cleanup, cleanup_fn).call(this);
                  if (mode === _util2.AnnotationEditorType.INK) {
                    this.addInkEditorIfNeeded(false);
                    this.disableClick();
                  } else {
                    this.enableClick();
                  }
                  if (mode !== _util2.AnnotationEditorType.NONE) {
                    this.div.classList.toggle("freeTextEditing", mode === _util2.AnnotationEditorType.FREETEXT);
                    this.div.classList.toggle("inkEditing", mode === _util2.AnnotationEditorType.INK);
                    this.div.classList.toggle("stampEditing", mode === _util2.AnnotationEditorType.STAMP);
                    this.div.hidden = false;
                  }
                }
                addInkEditorIfNeeded(isCommitting) {
                  if (!isCommitting && __privateGet(this, _uiManager).getMode() !== _util2.AnnotationEditorType.INK) {
                    return;
                  }
                  if (!isCommitting) {
                    for (const editor2 of __privateGet(this, _editors).values()) {
                      if (editor2.isEmpty()) {
                        editor2.setInBackground();
                        return;
                      }
                    }
                  }
                  const editor = __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, {
                    offsetX: 0,
                    offsetY: 0
                  }, false);
                  editor.setInBackground();
                }
                setEditingState(isEditing) {
                  __privateGet(this, _uiManager).setEditingState(isEditing);
                }
                addCommands(params) {
                  __privateGet(this, _uiManager).addCommands(params);
                }
                enable() {
                  this.div.style.pointerEvents = "auto";
                  const annotationElementIds = /* @__PURE__ */ new Set();
                  for (const editor of __privateGet(this, _editors).values()) {
                    editor.enableEditing();
                    if (editor.annotationElementId) {
                      annotationElementIds.add(editor.annotationElementId);
                    }
                  }
                  if (!__privateGet(this, _annotationLayer)) {
                    return;
                  }
                  const editables = __privateGet(this, _annotationLayer).getEditableAnnotations();
                  for (const editable of editables) {
                    editable.hide();
                    if (__privateGet(this, _uiManager).isDeletedAnnotationElement(editable.data.id)) {
                      continue;
                    }
                    if (annotationElementIds.has(editable.data.id)) {
                      continue;
                    }
                    const editor = this.deserialize(editable);
                    if (!editor) {
                      continue;
                    }
                    this.addOrRebuild(editor);
                    editor.enableEditing();
                  }
                }
                disable() {
                  var _a3;
                  __privateSet(this, _isDisabling, true);
                  this.div.style.pointerEvents = "none";
                  const hiddenAnnotationIds = /* @__PURE__ */ new Set();
                  for (const editor of __privateGet(this, _editors).values()) {
                    editor.disableEditing();
                    if (!editor.annotationElementId || editor.serialize() !== null) {
                      hiddenAnnotationIds.add(editor.annotationElementId);
                      continue;
                    }
                    (_a3 = this.getEditableAnnotation(editor.annotationElementId)) == null ? void 0 : _a3.show();
                    editor.remove();
                  }
                  if (__privateGet(this, _annotationLayer)) {
                    const editables = __privateGet(this, _annotationLayer).getEditableAnnotations();
                    for (const editable of editables) {
                      const {
                        id
                      } = editable.data;
                      if (hiddenAnnotationIds.has(id) || __privateGet(this, _uiManager).isDeletedAnnotationElement(id)) {
                        continue;
                      }
                      editable.show();
                    }
                  }
                  __privateMethod(this, _cleanup, cleanup_fn).call(this);
                  if (this.isEmpty) {
                    this.div.hidden = true;
                  }
                  __privateSet(this, _isDisabling, false);
                }
                getEditableAnnotation(id) {
                  var _a3;
                  return ((_a3 = __privateGet(this, _annotationLayer)) == null ? void 0 : _a3.getEditableAnnotation(id)) || null;
                }
                setActiveEditor(editor) {
                  const currentActive = __privateGet(this, _uiManager).getActive();
                  if (currentActive === editor) {
                    return;
                  }
                  __privateGet(this, _uiManager).setActiveEditor(editor);
                }
                enableClick() {
                  this.div.addEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.addEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                disableClick() {
                  this.div.removeEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.removeEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                attach(editor) {
                  __privateGet(this, _editors).set(editor.id, editor);
                  const {
                    annotationElementId
                  } = editor;
                  if (annotationElementId && __privateGet(this, _uiManager).isDeletedAnnotationElement(annotationElementId)) {
                    __privateGet(this, _uiManager).removeDeletedAnnotationElement(editor);
                  }
                }
                detach(editor) {
                  var _a3;
                  __privateGet(this, _editors).delete(editor.id);
                  (_a3 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a3.removePointerInTextLayer(editor.contentDiv);
                  if (!__privateGet(this, _isDisabling) && editor.annotationElementId) {
                    __privateGet(this, _uiManager).addDeletedAnnotationElement(editor);
                  }
                }
                remove(editor) {
                  this.detach(editor);
                  __privateGet(this, _uiManager).removeEditor(editor);
                  if (editor.div.contains(document.activeElement)) {
                    setTimeout(() => {
                      __privateGet(this, _uiManager).focusMainContainer();
                    }, 0);
                  }
                  editor.div.remove();
                  editor.isAttachedToDOM = false;
                  if (!__privateGet(this, _isCleaningUp)) {
                    this.addInkEditorIfNeeded(false);
                  }
                }
                changeParent(editor) {
                  var _a3;
                  if (editor.parent === this) {
                    return;
                  }
                  if (editor.annotationElementId) {
                    __privateGet(this, _uiManager).addDeletedAnnotationElement(editor.annotationElementId);
                    _editor.AnnotationEditor.deleteAnnotationElement(editor);
                    editor.annotationElementId = null;
                  }
                  this.attach(editor);
                  (_a3 = editor.parent) == null ? void 0 : _a3.detach(editor);
                  editor.setParent(this);
                  if (editor.div && editor.isAttachedToDOM) {
                    editor.div.remove();
                    this.div.append(editor.div);
                  }
                }
                add(editor) {
                  this.changeParent(editor);
                  __privateGet(this, _uiManager).addEditor(editor);
                  this.attach(editor);
                  if (!editor.isAttachedToDOM) {
                    const div = editor.render();
                    this.div.append(div);
                    editor.isAttachedToDOM = true;
                  }
                  editor.fixAndSetPosition();
                  editor.onceAdded();
                  __privateGet(this, _uiManager).addToAnnotationStorage(editor);
                }
                moveEditorInDOM(editor) {
                  var _a3;
                  if (!editor.isAttachedToDOM) {
                    return;
                  }
                  const {
                    activeElement
                  } = document;
                  if (editor.div.contains(activeElement)) {
                    editor._focusEventsAllowed = false;
                    setTimeout(() => {
                      if (!editor.div.contains(document.activeElement)) {
                        editor.div.addEventListener("focusin", () => {
                          editor._focusEventsAllowed = true;
                        }, {
                          once: true
                        });
                        activeElement.focus();
                      } else {
                        editor._focusEventsAllowed = true;
                      }
                    }, 0);
                  }
                  editor._structTreeParentId = (_a3 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a3.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
                }
                addOrRebuild(editor) {
                  if (editor.needsToBeRebuilt()) {
                    editor.rebuild();
                  } else {
                    this.add(editor);
                  }
                }
                addUndoableEditor(editor) {
                  const cmd = () => editor._uiManager.rebuild(editor);
                  const undo = () => {
                    editor.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: false
                  });
                }
                getNextId() {
                  return __privateGet(this, _uiManager).getId();
                }
                pasteEditor(mode, params) {
                  __privateGet(this, _uiManager).updateToolbar(mode);
                  __privateGet(this, _uiManager).updateMode(mode);
                  const {
                    offsetX,
                    offsetY
                  } = __privateMethod(this, _getCenterPoint, getCenterPoint_fn).call(this);
                  const id = this.getNextId();
                  const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
                    parent: this,
                    id,
                    x: offsetX,
                    y: offsetY,
                    uiManager: __privateGet(this, _uiManager),
                    isCentered: true,
                    ...params
                  });
                  if (editor) {
                    this.add(editor);
                  }
                }
                deserialize(data) {
                  switch (data.annotationType ?? data.annotationEditorType) {
                    case _util2.AnnotationEditorType.FREETEXT:
                      return _freetext.FreeTextEditor.deserialize(data, this, __privateGet(this, _uiManager));
                    case _util2.AnnotationEditorType.INK:
                      return _ink.InkEditor.deserialize(data, this, __privateGet(this, _uiManager));
                    case _util2.AnnotationEditorType.STAMP:
                      return _stamp.StampEditor.deserialize(data, this, __privateGet(this, _uiManager));
                  }
                  return null;
                }
                addNewEditor() {
                  __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, __privateMethod(this, _getCenterPoint, getCenterPoint_fn).call(this), true);
                }
                setSelected(editor) {
                  __privateGet(this, _uiManager).setSelected(editor);
                }
                toggleSelected(editor) {
                  __privateGet(this, _uiManager).toggleSelected(editor);
                }
                isSelected(editor) {
                  return __privateGet(this, _uiManager).isSelected(editor);
                }
                unselect(editor) {
                  __privateGet(this, _uiManager).unselect(editor);
                }
                pointerup(event) {
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  if (!__privateGet(this, _hadPointerDown)) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, false);
                  if (!__privateGet(this, _allowClick)) {
                    __privateSet(this, _allowClick, true);
                    return;
                  }
                  if (__privateGet(this, _uiManager).getMode() === _util2.AnnotationEditorType.STAMP) {
                    __privateGet(this, _uiManager).unselectAll();
                    return;
                  }
                  __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, event, false);
                }
                pointerdown(event) {
                  if (__privateGet(this, _hadPointerDown)) {
                    __privateSet(this, _hadPointerDown, false);
                    return;
                  }
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, true);
                  const editor = __privateGet(this, _uiManager).getActive();
                  __privateSet(this, _allowClick, !editor || editor.isEmpty());
                }
                findNewParent(editor, x3, y3) {
                  const layer = __privateGet(this, _uiManager).findParent(x3, y3);
                  if (layer === null || layer === this) {
                    return false;
                  }
                  layer.changeParent(editor);
                  return true;
                }
                destroy() {
                  var _a3, _b2;
                  if (((_a3 = __privateGet(this, _uiManager).getActive()) == null ? void 0 : _a3.parent) === this) {
                    __privateGet(this, _uiManager).commitOrRemove();
                    __privateGet(this, _uiManager).setActiveEditor(null);
                  }
                  for (const editor of __privateGet(this, _editors).values()) {
                    (_b2 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _b2.removePointerInTextLayer(editor.contentDiv);
                    editor.setParent(null);
                    editor.isAttachedToDOM = false;
                    editor.div.remove();
                  }
                  this.div = null;
                  __privateGet(this, _editors).clear();
                  __privateGet(this, _uiManager).removeLayer(this);
                }
                render({
                  viewport
                }) {
                  this.viewport = viewport;
                  (0, _display_utils2.setLayerDimensions)(this.div, viewport);
                  for (const editor of __privateGet(this, _uiManager).getEditors(this.pageIndex)) {
                    this.add(editor);
                  }
                  this.updateMode();
                }
                update({
                  viewport
                }) {
                  __privateGet(this, _uiManager).commitOrRemove();
                  this.viewport = viewport;
                  (0, _display_utils2.setLayerDimensions)(this.div, {
                    rotation: viewport.rotation
                  });
                  this.updateMode();
                }
                get pageDimensions() {
                  const {
                    pageWidth,
                    pageHeight
                  } = this.viewport.rawDims;
                  return [pageWidth, pageHeight];
                }
              };
              _accessibilityManager = new WeakMap();
              _allowClick = new WeakMap();
              _annotationLayer = new WeakMap();
              _boundPointerup = new WeakMap();
              _boundPointerdown = new WeakMap();
              _editors = new WeakMap();
              _hadPointerDown = new WeakMap();
              _isCleaningUp = new WeakMap();
              _isDisabling = new WeakMap();
              _uiManager = new WeakMap();
              _createNewEditor = new WeakSet();
              createNewEditor_fn = function(params) {
                switch (__privateGet(this, _uiManager).getMode()) {
                  case _util2.AnnotationEditorType.FREETEXT:
                    return new _freetext.FreeTextEditor(params);
                  case _util2.AnnotationEditorType.INK:
                    return new _ink.InkEditor(params);
                  case _util2.AnnotationEditorType.STAMP:
                    return new _stamp.StampEditor(params);
                }
                return null;
              };
              _createAndAddNewEditor = new WeakSet();
              createAndAddNewEditor_fn = function(event, isCentered) {
                const id = this.getNextId();
                const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
                  parent: this,
                  id,
                  x: event.offsetX,
                  y: event.offsetY,
                  uiManager: __privateGet(this, _uiManager),
                  isCentered
                });
                if (editor) {
                  this.add(editor);
                }
                return editor;
              };
              _getCenterPoint = new WeakSet();
              getCenterPoint_fn = function() {
                const {
                  x: x3,
                  y: y3,
                  width,
                  height
                } = this.div.getBoundingClientRect();
                const tlX = Math.max(0, x3);
                const tlY = Math.max(0, y3);
                const brX = Math.min(window.innerWidth, x3 + width);
                const brY = Math.min(window.innerHeight, y3 + height);
                const centerX = (tlX + brX) / 2 - x3;
                const centerY = (tlY + brY) / 2 - y3;
                const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
                return {
                  offsetX,
                  offsetY
                };
              };
              _cleanup = new WeakSet();
              cleanup_fn = function() {
                __privateSet(this, _isCleaningUp, true);
                for (const editor of __privateGet(this, _editors).values()) {
                  if (editor.isEmpty()) {
                    editor.remove();
                  }
                }
                __privateSet(this, _isCleaningUp, false);
              };
              __publicField(_AnnotationEditorLayer, "_initialized", false);
              let AnnotationEditorLayer = _AnnotationEditorLayer;
              exports2.AnnotationEditorLayer = AnnotationEditorLayer;
            },
            /* 28 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundEditorDivBlur, _boundEditorDivFocus, _boundEditorDivInput, _boundEditorDivKeydown, _color, _content, _editorDivId, _fontSize, _initialData, _updateFontSize, updateFontSize_fn, _updateColor, updateColor_fn, _extractText, extractText_fn, _setEditorDimensions, setEditorDimensions_fn, _setContent, setContent_fn, _hasElementChanged, hasElementChanged_fn, _cheatInitialRect, cheatInitialRect_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FreeTextEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _tools = __w_pdfjs_require__2(5);
              var _editor = __w_pdfjs_require__2(4);
              var _annotation_layer = __w_pdfjs_require__2(29);
              const _FreeTextEditor = class _FreeTextEditor extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "freeTextEditor"
                  });
                  __privateAdd(this, _updateFontSize);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _extractText);
                  __privateAdd(this, _setEditorDimensions);
                  __privateAdd(this, _setContent);
                  __privateAdd(this, _hasElementChanged);
                  __privateAdd(this, _cheatInitialRect);
                  __privateAdd(this, _boundEditorDivBlur, this.editorDivBlur.bind(this));
                  __privateAdd(this, _boundEditorDivFocus, this.editorDivFocus.bind(this));
                  __privateAdd(this, _boundEditorDivInput, this.editorDivInput.bind(this));
                  __privateAdd(this, _boundEditorDivKeydown, this.editorDivKeydown.bind(this));
                  __privateAdd(this, _color, void 0);
                  __privateAdd(this, _content, "");
                  __privateAdd(this, _editorDivId, `${this.id}-editor`);
                  __privateAdd(this, _fontSize, void 0);
                  __privateAdd(this, _initialData, null);
                  __privateSet(this, _color, params.color || _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  __privateSet(this, _fontSize, params.fontSize || _FreeTextEditor._defaultFontSize);
                }
                static get _keyboardManager() {
                  const proto = _FreeTextEditor.prototype;
                  const arrowChecker = (self2) => self2.isEmpty();
                  const small = _tools.AnnotationEditorUIManager.TRANSLATE_SMALL;
                  const big = _tools.AnnotationEditorUIManager.TRANSLATE_BIG;
                  return (0, _util2.shadow)(this, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
                    bubbles: true
                  }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
                    args: [-small, 0],
                    checker: arrowChecker
                  }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
                    args: [-big, 0],
                    checker: arrowChecker
                  }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
                    args: [small, 0],
                    checker: arrowChecker
                  }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
                    args: [big, 0],
                    checker: arrowChecker
                  }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
                    args: [0, -small],
                    checker: arrowChecker
                  }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
                    args: [0, -big],
                    checker: arrowChecker
                  }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
                    args: [0, small],
                    checker: arrowChecker
                  }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
                    args: [0, big],
                    checker: arrowChecker
                  }]]));
                }
                static initialize(l10n) {
                  _editor.AnnotationEditor.initialize(l10n, {
                    strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
                  });
                  const style = getComputedStyle(document.documentElement);
                  this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
                }
                static updateDefaultParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      _FreeTextEditor._defaultFontSize = value;
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      _FreeTextEditor._defaultColor = value;
                      break;
                  }
                }
                updateParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      __privateMethod(this, _updateFontSize, updateFontSize_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, __privateGet(this, _fontSize)], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, __privateGet(this, _color)]];
                }
                _translateEmpty(x3, y3) {
                  this._uiManager.translateSelectedEditors(x3, y3, true);
                }
                getInitialTranslation() {
                  const scale = this.parentScale;
                  return [-_FreeTextEditor._internalPadding * scale, -(_FreeTextEditor._internalPadding + __privateGet(this, _fontSize)) * scale];
                }
                rebuild() {
                  if (!this.parent) {
                    return;
                  }
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                  }
                }
                enableEditMode() {
                  if (this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(false);
                  this.parent.updateToolbar(_util2.AnnotationEditorType.FREETEXT);
                  super.enableEditMode();
                  this.overlayDiv.classList.remove("enabled");
                  this.editorDiv.contentEditable = true;
                  this._isDraggable = false;
                  this.div.removeAttribute("aria-activedescendant");
                  this.editorDiv.addEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.addEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.addEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                  this.editorDiv.addEventListener("input", __privateGet(this, _boundEditorDivInput));
                }
                disableEditMode() {
                  if (!this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(true);
                  super.disableEditMode();
                  this.overlayDiv.classList.add("enabled");
                  this.editorDiv.contentEditable = false;
                  this.div.setAttribute("aria-activedescendant", __privateGet(this, _editorDivId));
                  this._isDraggable = true;
                  this.editorDiv.removeEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.removeEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.removeEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                  this.editorDiv.removeEventListener("input", __privateGet(this, _boundEditorDivInput));
                  this.div.focus({
                    preventScroll: true
                  });
                  this.isEditing = false;
                  this.parent.div.classList.add("freeTextEditing");
                }
                focusin(event) {
                  if (!this._focusEventsAllowed) {
                    return;
                  }
                  super.focusin(event);
                  if (event.target !== this.editorDiv) {
                    this.editorDiv.focus();
                  }
                }
                onceAdded() {
                  var _a3;
                  if (this.width) {
                    __privateMethod(this, _cheatInitialRect, cheatInitialRect_fn).call(this);
                    return;
                  }
                  this.enableEditMode();
                  this.editorDiv.focus();
                  if ((_a3 = this._initialOptions) == null ? void 0 : _a3.isCentered) {
                    this.center();
                  }
                  this._initialOptions = null;
                }
                isEmpty() {
                  return !this.editorDiv || this.editorDiv.innerText.trim() === "";
                }
                remove() {
                  this.isEditing = false;
                  if (this.parent) {
                    this.parent.setEditingState(true);
                    this.parent.div.classList.add("freeTextEditing");
                  }
                  super.remove();
                }
                commit() {
                  if (!this.isInEditMode()) {
                    return;
                  }
                  super.commit();
                  this.disableEditMode();
                  const savedText = __privateGet(this, _content);
                  const newText = __privateSet(this, _content, __privateMethod(this, _extractText, extractText_fn).call(this).trimEnd());
                  if (savedText === newText) {
                    return;
                  }
                  const setText = (text) => {
                    __privateSet(this, _content, text);
                    if (!text) {
                      this.remove();
                      return;
                    }
                    __privateMethod(this, _setContent, setContent_fn).call(this);
                    this._uiManager.rebuild(this);
                    __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                  };
                  this.addCommands({
                    cmd: () => {
                      setText(newText);
                    },
                    undo: () => {
                      setText(savedText);
                    },
                    mustExec: false
                  });
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                }
                shouldGetKeyboardEvents() {
                  return this.isInEditMode();
                }
                enterInEditMode() {
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                dblclick(event) {
                  this.enterInEditMode();
                }
                keydown(event) {
                  if (event.target === this.div && event.key === "Enter") {
                    this.enterInEditMode();
                    event.preventDefault();
                  }
                }
                editorDivKeydown(event) {
                  _FreeTextEditor._keyboardManager.exec(this, event);
                }
                editorDivFocus(event) {
                  this.isEditing = true;
                }
                editorDivBlur(event) {
                  this.isEditing = false;
                }
                editorDivInput(event) {
                  this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
                }
                disableEditing() {
                  this.editorDiv.setAttribute("role", "comment");
                  this.editorDiv.removeAttribute("aria-multiline");
                }
                enableEditing() {
                  this.editorDiv.setAttribute("role", "textbox");
                  this.editorDiv.setAttribute("aria-multiline", true);
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  this.editorDiv = document.createElement("div");
                  this.editorDiv.className = "internal";
                  this.editorDiv.setAttribute("id", __privateGet(this, _editorDivId));
                  this.enableEditing();
                  _editor.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((msg) => {
                    var _a3;
                    return (_a3 = this.editorDiv) == null ? void 0 : _a3.setAttribute("aria-label", msg);
                  });
                  _editor.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((msg) => {
                    var _a3;
                    return (_a3 = this.editorDiv) == null ? void 0 : _a3.setAttribute("default-content", msg);
                  });
                  this.editorDiv.contentEditable = true;
                  const {
                    style
                  } = this.editorDiv;
                  style.fontSize = `calc(${__privateGet(this, _fontSize)}px * var(--scale-factor))`;
                  style.color = __privateGet(this, _color);
                  this.div.append(this.editorDiv);
                  this.overlayDiv = document.createElement("div");
                  this.overlayDiv.classList.add("overlay", "enabled");
                  this.div.append(this.overlayDiv);
                  (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parentDimensions;
                    if (this.annotationElementId) {
                      const {
                        position
                      } = __privateGet(this, _initialData);
                      let [tx, ty] = this.getInitialTranslation();
                      [tx, ty] = this.pageTranslationToScreen(tx, ty);
                      const [pageWidth, pageHeight] = this.pageDimensions;
                      const [pageX, pageY] = this.pageTranslation;
                      let posX, posY;
                      switch (this.rotation) {
                        case 0:
                          posX = baseX + (position[0] - pageX) / pageWidth;
                          posY = baseY + this.height - (position[1] - pageY) / pageHeight;
                          break;
                        case 90:
                          posX = baseX + (position[0] - pageX) / pageWidth;
                          posY = baseY - (position[1] - pageY) / pageHeight;
                          [tx, ty] = [ty, -tx];
                          break;
                        case 180:
                          posX = baseX - this.width + (position[0] - pageX) / pageWidth;
                          posY = baseY - (position[1] - pageY) / pageHeight;
                          [tx, ty] = [-tx, -ty];
                          break;
                        case 270:
                          posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
                          posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
                          [tx, ty] = [-ty, tx];
                          break;
                      }
                      this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
                    } else {
                      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    }
                    __privateMethod(this, _setContent, setContent_fn).call(this);
                    this._isDraggable = true;
                    this.editorDiv.contentEditable = false;
                  } else {
                    this._isDraggable = false;
                    this.editorDiv.contentEditable = true;
                  }
                  return this.div;
                }
                get contentDiv() {
                  return this.editorDiv;
                }
                static deserialize(data, parent, uiManager) {
                  let initialData = null;
                  if (data instanceof _annotation_layer.FreeTextAnnotationElement) {
                    const {
                      data: {
                        defaultAppearanceData: {
                          fontSize,
                          fontColor
                        },
                        rect,
                        rotation,
                        id
                      },
                      textContent,
                      textPosition,
                      parent: {
                        page: {
                          pageNumber
                        }
                      }
                    } = data;
                    if (!textContent || textContent.length === 0) {
                      return null;
                    }
                    initialData = data = {
                      annotationType: _util2.AnnotationEditorType.FREETEXT,
                      color: Array.from(fontColor),
                      fontSize,
                      value: textContent.join("\n"),
                      position: textPosition,
                      pageIndex: pageNumber - 1,
                      rect,
                      rotation,
                      id,
                      deleted: false
                    };
                  }
                  const editor = super.deserialize(data, parent, uiManager);
                  __privateSet(editor, _fontSize, data.fontSize);
                  __privateSet(editor, _color, _util2.Util.makeHexColor(...data.color));
                  __privateSet(editor, _content, data.value);
                  editor.annotationElementId = data.id || null;
                  __privateSet(editor, _initialData, initialData);
                  return editor;
                }
                serialize(isForCopying = false) {
                  if (this.isEmpty()) {
                    return null;
                  }
                  if (this.deleted) {
                    return {
                      pageIndex: this.pageIndex,
                      id: this.annotationElementId,
                      deleted: true
                    };
                  }
                  const padding = _FreeTextEditor._internalPadding * this.parentScale;
                  const rect = this.getRect(padding, padding);
                  const color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : __privateGet(this, _color));
                  const serialized = {
                    annotationType: _util2.AnnotationEditorType.FREETEXT,
                    color,
                    fontSize: __privateGet(this, _fontSize),
                    value: __privateGet(this, _content),
                    pageIndex: this.pageIndex,
                    rect,
                    rotation: this.rotation,
                    structTreeParentId: this._structTreeParentId
                  };
                  if (isForCopying) {
                    return serialized;
                  }
                  if (this.annotationElementId && !__privateMethod(this, _hasElementChanged, hasElementChanged_fn).call(this, serialized)) {
                    return null;
                  }
                  serialized.id = this.annotationElementId;
                  return serialized;
                }
              };
              _boundEditorDivBlur = new WeakMap();
              _boundEditorDivFocus = new WeakMap();
              _boundEditorDivInput = new WeakMap();
              _boundEditorDivKeydown = new WeakMap();
              _color = new WeakMap();
              _content = new WeakMap();
              _editorDivId = new WeakMap();
              _fontSize = new WeakMap();
              _initialData = new WeakMap();
              _updateFontSize = new WeakSet();
              updateFontSize_fn = function(fontSize) {
                const setFontsize = (size) => {
                  this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
                  this.translate(0, -(size - __privateGet(this, _fontSize)) * this.parentScale);
                  __privateSet(this, _fontSize, size);
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                };
                const savedFontsize = __privateGet(this, _fontSize);
                this.addCommands({
                  cmd: () => {
                    setFontsize(fontSize);
                  },
                  undo: () => {
                    setFontsize(savedFontsize);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_SIZE,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color) {
                const savedColor = __privateGet(this, _color);
                this.addCommands({
                  cmd: () => {
                    __privateSet(this, _color, this.editorDiv.style.color = color);
                  },
                  undo: () => {
                    __privateSet(this, _color, this.editorDiv.style.color = savedColor);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _extractText = new WeakSet();
              extractText_fn = function() {
                const divs = this.editorDiv.getElementsByTagName("div");
                if (divs.length === 0) {
                  return this.editorDiv.innerText;
                }
                const buffer = [];
                for (const div of divs) {
                  buffer.push(div.innerText.replace(/\r\n?|\n/, ""));
                }
                return buffer.join("\n");
              };
              _setEditorDimensions = new WeakSet();
              setEditorDimensions_fn = function() {
                const [parentWidth, parentHeight] = this.parentDimensions;
                let rect;
                if (this.isAttachedToDOM) {
                  rect = this.div.getBoundingClientRect();
                } else {
                  const {
                    currentLayer,
                    div
                  } = this;
                  const savedDisplay = div.style.display;
                  div.style.display = "hidden";
                  currentLayer.div.append(this.div);
                  rect = div.getBoundingClientRect();
                  div.remove();
                  div.style.display = savedDisplay;
                }
                if (this.rotation % 180 === this.parentRotation % 180) {
                  this.width = rect.width / parentWidth;
                  this.height = rect.height / parentHeight;
                } else {
                  this.width = rect.height / parentWidth;
                  this.height = rect.width / parentHeight;
                }
                this.fixAndSetPosition();
              };
              _setContent = new WeakSet();
              setContent_fn = function() {
                this.editorDiv.replaceChildren();
                if (!__privateGet(this, _content)) {
                  return;
                }
                for (const line of __privateGet(this, _content).split("\n")) {
                  const div = document.createElement("div");
                  div.append(line ? document.createTextNode(line) : document.createElement("br"));
                  this.editorDiv.append(div);
                }
              };
              _hasElementChanged = new WeakSet();
              hasElementChanged_fn = function(serialized) {
                const {
                  value,
                  fontSize,
                  color,
                  rect,
                  pageIndex
                } = __privateGet(this, _initialData);
                return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x3, i3) => Math.abs(x3 - rect[i3]) >= 1) || serialized.color.some((c3, i3) => c3 !== color[i3]) || serialized.pageIndex !== pageIndex;
              };
              _cheatInitialRect = new WeakSet();
              cheatInitialRect_fn = function(delayed = false) {
                if (!this.annotationElementId) {
                  return;
                }
                __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                if (!delayed && (this.width === 0 || this.height === 0)) {
                  setTimeout(() => __privateMethod(this, _cheatInitialRect, cheatInitialRect_fn).call(this, true), 0);
                  return;
                }
                const padding = _FreeTextEditor._internalPadding * this.parentScale;
                __privateGet(this, _initialData).rect = this.getRect(padding, padding);
              };
              __publicField(_FreeTextEditor, "_freeTextDefaultContent", "");
              __publicField(_FreeTextEditor, "_internalPadding", 0);
              __publicField(_FreeTextEditor, "_defaultColor", null);
              __publicField(_FreeTextEditor, "_defaultFontSize", 10);
              __publicField(_FreeTextEditor, "_type", "freetext");
              let FreeTextEditor = _FreeTextEditor;
              exports2.FreeTextEditor = FreeTextEditor;
            },
            /* 29 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _hasBorder, _setInternalLink, setInternalLink_fn, _bindSetOCGState, bindSetOCGState_fn, _dateTimePromise, _boundKeyDown, _boundHide, _boundShow, _boundToggle, _color, _container, _contentsObj, _elements, _parent, _parentRect, _pinned, _popup, _rect, _richText, _titleObj, _wasVisible, _keyDown, keyDown_fn, _toggle, toggle_fn, _show, show_fn, _hide, hide_fn, _line, _square, _circle, _polyline, _polylines, _trigger, _download, download_fn, _accessibilityManager, _annotationCanvasMap, _editableAnnotations, _appendElement, appendElement_fn, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StampAnnotationElement = exports2.InkAnnotationElement = exports2.FreeTextAnnotationElement = exports2.AnnotationLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _annotation_storage2 = __w_pdfjs_require__2(3);
              var _scripting_utils = __w_pdfjs_require__2(30);
              var _displayL10n_utils = __w_pdfjs_require__2(31);
              var _xfa_layer = __w_pdfjs_require__2(32);
              const DEFAULT_TAB_INDEX = 1e3;
              const DEFAULT_FONT_SIZE = 9;
              const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
              function getRectDims(rect) {
                return {
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
              }
              class AnnotationElementFactory {
                static create(parameters) {
                  const subtype = parameters.data.annotationType;
                  switch (subtype) {
                    case _util2.AnnotationType.LINK:
                      return new LinkAnnotationElement(parameters);
                    case _util2.AnnotationType.TEXT:
                      return new TextAnnotationElement(parameters);
                    case _util2.AnnotationType.WIDGET:
                      const fieldType = parameters.data.fieldType;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotationElement(parameters);
                        case "Btn":
                          if (parameters.data.radioButton) {
                            return new RadioButtonWidgetAnnotationElement(parameters);
                          } else if (parameters.data.checkBox) {
                            return new CheckboxWidgetAnnotationElement(parameters);
                          }
                          return new PushButtonWidgetAnnotationElement(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotationElement(parameters);
                        case "Sig":
                          return new SignatureWidgetAnnotationElement(parameters);
                      }
                      return new WidgetAnnotationElement(parameters);
                    case _util2.AnnotationType.POPUP:
                      return new PopupAnnotationElement(parameters);
                    case _util2.AnnotationType.FREETEXT:
                      return new FreeTextAnnotationElement(parameters);
                    case _util2.AnnotationType.LINE:
                      return new LineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUARE:
                      return new SquareAnnotationElement(parameters);
                    case _util2.AnnotationType.CIRCLE:
                      return new CircleAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYLINE:
                      return new PolylineAnnotationElement(parameters);
                    case _util2.AnnotationType.CARET:
                      return new CaretAnnotationElement(parameters);
                    case _util2.AnnotationType.INK:
                      return new InkAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYGON:
                      return new PolygonAnnotationElement(parameters);
                    case _util2.AnnotationType.HIGHLIGHT:
                      return new HighlightAnnotationElement(parameters);
                    case _util2.AnnotationType.UNDERLINE:
                      return new UnderlineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUIGGLY:
                      return new SquigglyAnnotationElement(parameters);
                    case _util2.AnnotationType.STRIKEOUT:
                      return new StrikeOutAnnotationElement(parameters);
                    case _util2.AnnotationType.STAMP:
                      return new StampAnnotationElement(parameters);
                    case _util2.AnnotationType.FILEATTACHMENT:
                      return new FileAttachmentAnnotationElement(parameters);
                    default:
                      return new AnnotationElement(parameters);
                  }
                }
              }
              const _AnnotationElement = class _AnnotationElement {
                constructor(parameters, {
                  isRenderable = false,
                  ignoreBorder = false,
                  createQuadrilaterals = false
                } = {}) {
                  __privateAdd(this, _hasBorder, false);
                  this.isRenderable = isRenderable;
                  this.data = parameters.data;
                  this.layer = parameters.layer;
                  this.linkService = parameters.linkService;
                  this.downloadManager = parameters.downloadManager;
                  this.imageResourcesPath = parameters.imageResourcesPath;
                  this.renderForms = parameters.renderForms;
                  this.svgFactory = parameters.svgFactory;
                  this.annotationStorage = parameters.annotationStorage;
                  this.enableScripting = parameters.enableScripting;
                  this.hasJSActions = parameters.hasJSActions;
                  this._fieldObjects = parameters.fieldObjects;
                  this.parent = parameters.parent;
                  if (isRenderable) {
                    this.container = this._createContainer(ignoreBorder);
                  }
                  if (createQuadrilaterals) {
                    this._createQuadrilaterals();
                  }
                }
                static _hasPopupData({
                  titleObj,
                  contentsObj,
                  richText
                }) {
                  return !!((titleObj == null ? void 0 : titleObj.str) || (contentsObj == null ? void 0 : contentsObj.str) || (richText == null ? void 0 : richText.str));
                }
                get hasPopupData() {
                  return _AnnotationElement._hasPopupData(this.data);
                }
                _createContainer(ignoreBorder) {
                  const {
                    data,
                    parent: {
                      page,
                      viewport
                    }
                  } = this;
                  const container = document.createElement("section");
                  container.setAttribute("data-annotation-id", data.id);
                  if (!(this instanceof WidgetAnnotationElement)) {
                    container.tabIndex = DEFAULT_TAB_INDEX;
                  }
                  container.style.zIndex = this.parent.zIndex++;
                  if (this.data.popupRef) {
                    container.setAttribute("aria-haspopup", "dialog");
                  }
                  if (data.noRotate) {
                    container.classList.add("norotate");
                  }
                  const {
                    pageWidth,
                    pageHeight,
                    pageX,
                    pageY
                  } = viewport.rawDims;
                  if (!data.rect || this instanceof PopupAnnotationElement) {
                    const {
                      rotation: rotation2
                    } = data;
                    if (!data.hasOwnCanvas && rotation2 !== 0) {
                      this.setRotation(rotation2, container);
                    }
                    return container;
                  }
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  if (!ignoreBorder && data.borderStyle.width > 0) {
                    container.style.borderWidth = `${data.borderStyle.width}px`;
                    const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                    const verticalRadius = data.borderStyle.verticalCornerRadius;
                    if (horizontalRadius > 0 || verticalRadius > 0) {
                      const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                      const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    }
                    switch (data.borderStyle.style) {
                      case _util2.AnnotationBorderStyleType.SOLID:
                        container.style.borderStyle = "solid";
                        break;
                      case _util2.AnnotationBorderStyleType.DASHED:
                        container.style.borderStyle = "dashed";
                        break;
                      case _util2.AnnotationBorderStyleType.BEVELED:
                        (0, _util2.warn)("Unimplemented border style: beveled");
                        break;
                      case _util2.AnnotationBorderStyleType.INSET:
                        (0, _util2.warn)("Unimplemented border style: inset");
                        break;
                      case _util2.AnnotationBorderStyleType.UNDERLINE:
                        container.style.borderBottomStyle = "solid";
                        break;
                      default:
                        break;
                    }
                    const borderColor = data.borderColor || null;
                    if (borderColor) {
                      __privateSet(this, _hasBorder, true);
                      container.style.borderColor = _util2.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
                    } else {
                      container.style.borderWidth = 0;
                    }
                  }
                  container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
                  container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
                  const {
                    rotation
                  } = data;
                  if (data.hasOwnCanvas || rotation === 0) {
                    container.style.width = `${100 * width / pageWidth}%`;
                    container.style.height = `${100 * height / pageHeight}%`;
                  } else {
                    this.setRotation(rotation, container);
                  }
                  return container;
                }
                setRotation(angle, container = this.container) {
                  if (!this.data.rect) {
                    return;
                  }
                  const {
                    pageWidth,
                    pageHeight
                  } = this.parent.viewport.rawDims;
                  const {
                    width,
                    height
                  } = getRectDims(this.data.rect);
                  let elementWidth, elementHeight;
                  if (angle % 180 === 0) {
                    elementWidth = 100 * width / pageWidth;
                    elementHeight = 100 * height / pageHeight;
                  } else {
                    elementWidth = 100 * height / pageWidth;
                    elementHeight = 100 * width / pageHeight;
                  }
                  container.style.width = `${elementWidth}%`;
                  container.style.height = `${elementHeight}%`;
                  container.setAttribute("data-main-rotation", (360 - angle) % 360);
                }
                get _commonActions() {
                  const setColor = (jsName, styleName, event) => {
                    const color = event.detail[jsName];
                    const colorType = color[0];
                    const colorArray = color.slice(1);
                    event.target.style[styleName] = _scripting_utils.ColorConverters[`${colorType}_HTML`](colorArray);
                    this.annotationStorage.setValue(this.data.id, {
                      [styleName]: _scripting_utils.ColorConverters[`${colorType}_rgb`](colorArray)
                    });
                  };
                  return (0, _util2.shadow)(this, "_commonActions", {
                    display: (event) => {
                      const {
                        display
                      } = event.detail;
                      const hidden = display % 2 === 1;
                      this.container.style.visibility = hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        noView: hidden,
                        noPrint: display === 1 || display === 2
                      });
                    },
                    print: (event) => {
                      this.annotationStorage.setValue(this.data.id, {
                        noPrint: !event.detail.print
                      });
                    },
                    hidden: (event) => {
                      const {
                        hidden
                      } = event.detail;
                      this.container.style.visibility = hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        noPrint: hidden,
                        noView: hidden
                      });
                    },
                    focus: (event) => {
                      setTimeout(() => event.target.focus({
                        preventScroll: false
                      }), 0);
                    },
                    userName: (event) => {
                      event.target.title = event.detail.userName;
                    },
                    readonly: (event) => {
                      event.target.disabled = event.detail.readonly;
                    },
                    required: (event) => {
                      this._setRequired(event.target, event.detail.required);
                    },
                    bgColor: (event) => {
                      setColor("bgColor", "backgroundColor", event);
                    },
                    fillColor: (event) => {
                      setColor("fillColor", "backgroundColor", event);
                    },
                    fgColor: (event) => {
                      setColor("fgColor", "color", event);
                    },
                    textColor: (event) => {
                      setColor("textColor", "color", event);
                    },
                    borderColor: (event) => {
                      setColor("borderColor", "borderColor", event);
                    },
                    strokeColor: (event) => {
                      setColor("strokeColor", "borderColor", event);
                    },
                    rotation: (event) => {
                      const angle = event.detail.rotation;
                      this.setRotation(angle);
                      this.annotationStorage.setValue(this.data.id, {
                        rotation: angle
                      });
                    }
                  });
                }
                _dispatchEventFromSandbox(actions, jsEvent) {
                  const commonActions = this._commonActions;
                  for (const name of Object.keys(jsEvent.detail)) {
                    const action = actions[name] || commonActions[name];
                    action == null ? void 0 : action(jsEvent);
                  }
                }
                _setDefaultPropertiesFromJS(element) {
                  if (!this.enableScripting) {
                    return;
                  }
                  const storedData = this.annotationStorage.getRawValue(this.data.id);
                  if (!storedData) {
                    return;
                  }
                  const commonActions = this._commonActions;
                  for (const [actionName, detail] of Object.entries(storedData)) {
                    const action = commonActions[actionName];
                    if (action) {
                      const eventProxy = {
                        detail: {
                          [actionName]: detail
                        },
                        target: element
                      };
                      action(eventProxy);
                      delete storedData[actionName];
                    }
                  }
                }
                _createQuadrilaterals() {
                  if (!this.container) {
                    return;
                  }
                  const {
                    quadPoints
                  } = this.data;
                  if (!quadPoints) {
                    return;
                  }
                  const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;
                  if (quadPoints.length === 1) {
                    const [, {
                      x: trX,
                      y: trY
                    }, {
                      x: blX,
                      y: blY
                    }] = quadPoints[0];
                    if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
                      return;
                    }
                  }
                  const {
                    style
                  } = this.container;
                  let svgBuffer;
                  if (__privateGet(this, _hasBorder)) {
                    const {
                      borderColor,
                      borderWidth
                    } = style;
                    style.borderWidth = 0;
                    svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
                    this.container.classList.add("hasBorder");
                  }
                  const width = rectTrX - rectBlX;
                  const height = rectTrY - rectBlY;
                  const {
                    svgFactory
                  } = this;
                  const svg = svgFactory.createElement("svg");
                  svg.classList.add("quadrilateralsContainer");
                  svg.setAttribute("width", 0);
                  svg.setAttribute("height", 0);
                  const defs = svgFactory.createElement("defs");
                  svg.append(defs);
                  const clipPath = svgFactory.createElement("clipPath");
                  const id = `clippath_${this.data.id}`;
                  clipPath.setAttribute("id", id);
                  clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
                  defs.append(clipPath);
                  for (const [, {
                    x: trX,
                    y: trY
                  }, {
                    x: blX,
                    y: blY
                  }] of quadPoints) {
                    const rect = svgFactory.createElement("rect");
                    const x3 = (blX - rectBlX) / width;
                    const y3 = (rectTrY - trY) / height;
                    const rectWidth = (trX - blX) / width;
                    const rectHeight = (trY - blY) / height;
                    rect.setAttribute("x", x3);
                    rect.setAttribute("y", y3);
                    rect.setAttribute("width", rectWidth);
                    rect.setAttribute("height", rectHeight);
                    clipPath.append(rect);
                    svgBuffer == null ? void 0 : svgBuffer.push(`<rect vector-effect="non-scaling-stroke" x="${x3}" y="${y3}" width="${rectWidth}" height="${rectHeight}"/>`);
                  }
                  if (__privateGet(this, _hasBorder)) {
                    svgBuffer.push(`</g></svg>')`);
                    style.backgroundImage = svgBuffer.join("");
                  }
                  this.container.append(svg);
                  this.container.style.clipPath = `url(#${id})`;
                }
                _createPopup() {
                  const {
                    container,
                    data
                  } = this;
                  container.setAttribute("aria-haspopup", "dialog");
                  const popup = new PopupAnnotationElement({
                    data: {
                      color: data.color,
                      titleObj: data.titleObj,
                      modificationDate: data.modificationDate,
                      contentsObj: data.contentsObj,
                      richText: data.richText,
                      parentRect: data.rect,
                      borderStyle: 0,
                      id: `popup_${data.id}`,
                      rotation: data.rotation
                    },
                    parent: this.parent,
                    elements: [this]
                  });
                  this.parent.div.append(popup.render());
                }
                render() {
                  (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                }
                _getElementsByName(name, skipId = null) {
                  const fields = [];
                  if (this._fieldObjects) {
                    const fieldObj = this._fieldObjects[name];
                    if (fieldObj) {
                      for (const {
                        page,
                        id,
                        exportValues
                      } of fieldObj) {
                        if (page === -1) {
                          continue;
                        }
                        if (id === skipId) {
                          continue;
                        }
                        const exportValue = typeof exportValues === "string" ? exportValues : null;
                        const domElement = document.querySelector(`[data-element-id="${id}"]`);
                        if (domElement && !GetElementsByNameSet.has(domElement)) {
                          (0, _util2.warn)(`_getElementsByName - element not allowed: ${id}`);
                          continue;
                        }
                        fields.push({
                          id,
                          exportValue,
                          domElement
                        });
                      }
                    }
                    return fields;
                  }
                  for (const domElement of document.getElementsByName(name)) {
                    const {
                      exportValue
                    } = domElement;
                    const id = domElement.getAttribute("data-element-id");
                    if (id === skipId) {
                      continue;
                    }
                    if (!GetElementsByNameSet.has(domElement)) {
                      continue;
                    }
                    fields.push({
                      id,
                      exportValue,
                      domElement
                    });
                  }
                  return fields;
                }
                show() {
                  var _a3;
                  if (this.container) {
                    this.container.hidden = false;
                  }
                  (_a3 = this.popup) == null ? void 0 : _a3.maybeShow();
                }
                hide() {
                  var _a3;
                  if (this.container) {
                    this.container.hidden = true;
                  }
                  (_a3 = this.popup) == null ? void 0 : _a3.forceHide();
                }
                getElementsToTriggerPopup() {
                  return this.container;
                }
                addHighlightArea() {
                  const triggers = this.getElementsToTriggerPopup();
                  if (Array.isArray(triggers)) {
                    for (const element of triggers) {
                      element.classList.add("highlightArea");
                    }
                  } else {
                    triggers.classList.add("highlightArea");
                  }
                }
                _editOnDoubleClick() {
                  const {
                    annotationEditorType: mode,
                    data: {
                      id: editId
                    }
                  } = this;
                  this.container.addEventListener("dblclick", () => {
                    var _a3;
                    (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("switchannotationeditormode", {
                      source: this,
                      mode,
                      editId
                    });
                  });
                }
              };
              _hasBorder = new WeakMap();
              let AnnotationElement = _AnnotationElement;
              class LinkAnnotationElement extends AnnotationElement {
                constructor(parameters, options = null) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: !!(options == null ? void 0 : options.ignoreBorder),
                    createQuadrilaterals: true
                  });
                  __privateAdd(this, _setInternalLink);
                  __privateAdd(this, _bindSetOCGState);
                  this.isTooltipOnly = parameters.data.isTooltipOnly;
                }
                render() {
                  const {
                    data,
                    linkService
                  } = this;
                  const link = document.createElement("a");
                  link.setAttribute("data-element-id", data.id);
                  let isBound = false;
                  if (data.url) {
                    linkService.addLinkAttributes(link, data.url, data.newWindow);
                    isBound = true;
                  } else if (data.action) {
                    this._bindNamedAction(link, data.action);
                    isBound = true;
                  } else if (data.attachment) {
                    this._bindAttachment(link, data.attachment);
                    isBound = true;
                  } else if (data.setOCGState) {
                    __privateMethod(this, _bindSetOCGState, bindSetOCGState_fn).call(this, link, data.setOCGState);
                    isBound = true;
                  } else if (data.dest) {
                    this._bindLink(link, data.dest);
                    isBound = true;
                  } else {
                    if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                      this._bindJSAction(link, data);
                      isBound = true;
                    }
                    if (data.resetForm) {
                      this._bindResetFormAction(link, data.resetForm);
                      isBound = true;
                    } else if (this.isTooltipOnly && !isBound) {
                      this._bindLink(link, "");
                      isBound = true;
                    }
                  }
                  this.container.classList.add("linkAnnotation");
                  if (isBound) {
                    this.container.append(link);
                  }
                  return this.container;
                }
                _bindLink(link, destination) {
                  link.href = this.linkService.getDestinationHash(destination);
                  link.onclick = () => {
                    if (destination) {
                      this.linkService.goToDestination(destination);
                    }
                    return false;
                  };
                  if (destination || destination === "") {
                    __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                  }
                }
                _bindNamedAction(link, action) {
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = () => {
                    this.linkService.executeNamedAction(action);
                    return false;
                  };
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                }
                _bindAttachment(link, attachment) {
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = () => {
                    var _a3;
                    (_a3 = this.downloadManager) == null ? void 0 : _a3.openOrDownloadData(this.container, attachment.content, attachment.filename);
                    return false;
                  };
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                }
                _bindJSAction(link, data) {
                  link.href = this.linkService.getAnchorUrl("");
                  const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                  for (const name of Object.keys(data.actions)) {
                    const jsName = map.get(name);
                    if (!jsName) {
                      continue;
                    }
                    link[jsName] = () => {
                      var _a3;
                      (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: data.id,
                          name
                        }
                      });
                      return false;
                    };
                  }
                  if (!link.onclick) {
                    link.onclick = () => false;
                  }
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                }
                _bindResetFormAction(link, resetForm) {
                  const otherClickAction = link.onclick;
                  if (!otherClickAction) {
                    link.href = this.linkService.getAnchorUrl("");
                  }
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                  if (!this._fieldObjects) {
                    (0, _util2.warn)(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
                    if (!otherClickAction) {
                      link.onclick = () => false;
                    }
                    return;
                  }
                  link.onclick = () => {
                    var _a3;
                    otherClickAction == null ? void 0 : otherClickAction();
                    const {
                      fields: resetFormFields,
                      refs: resetFormRefs,
                      include
                    } = resetForm;
                    const allFields = [];
                    if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                      const fieldIds = new Set(resetFormRefs);
                      for (const fieldName of resetFormFields) {
                        const fields = this._fieldObjects[fieldName] || [];
                        for (const {
                          id
                        } of fields) {
                          fieldIds.add(id);
                        }
                      }
                      for (const fields of Object.values(this._fieldObjects)) {
                        for (const field of fields) {
                          if (fieldIds.has(field.id) === include) {
                            allFields.push(field);
                          }
                        }
                      }
                    } else {
                      for (const fields of Object.values(this._fieldObjects)) {
                        allFields.push(...fields);
                      }
                    }
                    const storage = this.annotationStorage;
                    const allIds = [];
                    for (const field of allFields) {
                      const {
                        id
                      } = field;
                      allIds.push(id);
                      switch (field.type) {
                        case "text": {
                          const value = field.defaultValue || "";
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        case "checkbox":
                        case "radiobutton": {
                          const value = field.defaultValue === field.exportValues;
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        case "combobox":
                        case "listbox": {
                          const value = field.defaultValue || "";
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        default:
                          continue;
                      }
                      const domElement = document.querySelector(`[data-element-id="${id}"]`);
                      if (!domElement) {
                        continue;
                      } else if (!GetElementsByNameSet.has(domElement)) {
                        (0, _util2.warn)(`_bindResetFormAction - element not allowed: ${id}`);
                        continue;
                      }
                      domElement.dispatchEvent(new Event("resetform"));
                    }
                    if (this.enableScripting) {
                      (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: "app",
                          ids: allIds,
                          name: "ResetForm"
                        }
                      });
                    }
                    return false;
                  };
                }
              }
              _setInternalLink = new WeakSet();
              setInternalLink_fn = function() {
                this.container.setAttribute("data-internal-link", "");
              };
              _bindSetOCGState = new WeakSet();
              bindSetOCGState_fn = function(link, action) {
                link.href = this.linkService.getAnchorUrl("");
                link.onclick = () => {
                  this.linkService.executeSetOCGState(action);
                  return false;
                };
                __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
              };
              class TextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true
                  });
                }
                render() {
                  this.container.classList.add("textAnnotation");
                  const image = document.createElement("img");
                  image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                  image.alt = "[{{type}} Annotation]";
                  image.dataset.l10nId = "text_annotation_type";
                  image.dataset.l10nArgs = JSON.stringify({
                    type: this.data.name
                  });
                  if (!this.data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  this.container.append(image);
                  return this.container;
                }
              }
              class WidgetAnnotationElement extends AnnotationElement {
                render() {
                  if (this.data.alternativeText) {
                    this.container.title = this.data.alternativeText;
                  }
                  return this.container;
                }
                showElementAndHideCanvas(element) {
                  var _a3;
                  if (this.data.hasOwnCanvas) {
                    if (((_a3 = element.previousSibling) == null ? void 0 : _a3.nodeName) === "CANVAS") {
                      element.previousSibling.hidden = true;
                    }
                    element.hidden = false;
                  }
                }
                _getKeyModifier(event) {
                  const {
                    isWin,
                    isMac
                  } = _util2.FeatureTest.platform;
                  return isWin && event.ctrlKey || isMac && event.metaKey;
                }
                _setEventListener(element, elementData, baseName, eventName, valueGetter) {
                  if (baseName.includes("mouse")) {
                    element.addEventListener(baseName, (event) => {
                      var _a3;
                      (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event),
                          shift: event.shiftKey,
                          modifier: this._getKeyModifier(event)
                        }
                      });
                    });
                  } else {
                    element.addEventListener(baseName, (event) => {
                      var _a3;
                      if (baseName === "blur") {
                        if (!elementData.focused || !event.relatedTarget) {
                          return;
                        }
                        elementData.focused = false;
                      } else if (baseName === "focus") {
                        if (elementData.focused) {
                          return;
                        }
                        elementData.focused = true;
                      }
                      if (!valueGetter) {
                        return;
                      }
                      (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event)
                        }
                      });
                    });
                  }
                }
                _setEventListeners(element, elementData, names, getter) {
                  var _a3, _b2, _c2;
                  for (const [baseName, eventName] of names) {
                    if (eventName === "Action" || ((_a3 = this.data.actions) == null ? void 0 : _a3[eventName])) {
                      if (eventName === "Focus" || eventName === "Blur") {
                        elementData || (elementData = {
                          focused: false
                        });
                      }
                      this._setEventListener(element, elementData, baseName, eventName, getter);
                      if (eventName === "Focus" && !((_b2 = this.data.actions) == null ? void 0 : _b2.Blur)) {
                        this._setEventListener(element, elementData, "blur", "Blur", null);
                      } else if (eventName === "Blur" && !((_c2 = this.data.actions) == null ? void 0 : _c2.Focus)) {
                        this._setEventListener(element, elementData, "focus", "Focus", null);
                      }
                    }
                  }
                }
                _setBackgroundColor(element) {
                  const color = this.data.backgroundColor || null;
                  element.style.backgroundColor = color === null ? "transparent" : _util2.Util.makeHexColor(color[0], color[1], color[2]);
                }
                _setTextStyle(element) {
                  const TEXT_ALIGNMENT = ["left", "center", "right"];
                  const {
                    fontColor
                  } = this.data.defaultAppearanceData;
                  const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
                  const style = element.style;
                  let computedFontSize;
                  const BORDER_SIZE = 2;
                  const roundToOneDecimal = (x3) => Math.round(10 * x3) / 10;
                  if (this.data.multiLine) {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
                    const numberOfLines = Math.round(height / (_util2.LINE_FACTOR * fontSize)) || 1;
                    const lineHeight = height / numberOfLines;
                    computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util2.LINE_FACTOR));
                  } else {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
                    computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util2.LINE_FACTOR));
                  }
                  style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
                  style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                  if (this.data.textAlignment !== null) {
                    style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                  }
                }
                _setRequired(element, isRequired2) {
                  if (isRequired2) {
                    element.setAttribute("required", true);
                  } else {
                    element.removeAttribute("required");
                  }
                  element.setAttribute("aria-required", isRequired2);
                }
              }
              class TextWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                  super(parameters, {
                    isRenderable
                  });
                }
                setPropertyOnSiblings(base, key, value, keyInStorage) {
                  const storage = this.annotationStorage;
                  for (const element of this._getElementsByName(base.name, base.id)) {
                    if (element.domElement) {
                      element.domElement[key] = value;
                    }
                    storage.setValue(element.id, {
                      [keyInStorage]: value
                    });
                  }
                }
                render() {
                  var _a3, _b2;
                  const storage = this.annotationStorage;
                  const id = this.data.id;
                  this.container.classList.add("textWidgetAnnotation");
                  let element = null;
                  if (this.renderForms) {
                    const storedData = storage.getValue(id, {
                      value: this.data.fieldValue
                    });
                    let textContent = storedData.value || "";
                    const maxLen = storage.getValue(id, {
                      charLimit: this.data.maxLen
                    }).charLimit;
                    if (maxLen && textContent.length > maxLen) {
                      textContent = textContent.slice(0, maxLen);
                    }
                    let fieldFormattedValues = storedData.formattedValue || ((_a3 = this.data.textContent) == null ? void 0 : _a3.join("\n")) || null;
                    if (fieldFormattedValues && this.data.comb) {
                      fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
                    }
                    const elementData = {
                      userValue: textContent,
                      formattedValue: fieldFormattedValues,
                      lastCommittedValue: null,
                      commitKey: 1,
                      focused: false
                    };
                    if (this.data.multiLine) {
                      element = document.createElement("textarea");
                      element.textContent = fieldFormattedValues ?? textContent;
                      if (this.data.doNotScroll) {
                        element.style.overflowY = "hidden";
                      }
                    } else {
                      element = document.createElement("input");
                      element.type = "text";
                      element.setAttribute("value", fieldFormattedValues ?? textContent);
                      if (this.data.doNotScroll) {
                        element.style.overflowX = "hidden";
                      }
                    }
                    if (this.data.hasOwnCanvas) {
                      element.hidden = true;
                    }
                    GetElementsByNameSet.add(element);
                    element.setAttribute("data-element-id", id);
                    element.disabled = this.data.readOnly;
                    element.name = this.data.fieldName;
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    this._setRequired(element, this.data.required);
                    if (maxLen) {
                      element.maxLength = maxLen;
                    }
                    element.addEventListener("input", (event) => {
                      storage.setValue(id, {
                        value: event.target.value
                      });
                      this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                      elementData.formattedValue = null;
                    });
                    element.addEventListener("resetform", (event) => {
                      const defaultValue = this.data.defaultFieldValue ?? "";
                      element.value = elementData.userValue = defaultValue;
                      elementData.formattedValue = null;
                    });
                    let blurListener = (event) => {
                      const {
                        formattedValue
                      } = elementData;
                      if (formattedValue !== null && formattedValue !== void 0) {
                        event.target.value = formattedValue;
                      }
                      event.target.scrollLeft = 0;
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      element.addEventListener("focus", (event) => {
                        if (elementData.focused) {
                          return;
                        }
                        const {
                          target
                        } = event;
                        if (elementData.userValue) {
                          target.value = elementData.userValue;
                        }
                        elementData.lastCommittedValue = target.value;
                        elementData.commitKey = 1;
                        elementData.focused = true;
                      });
                      element.addEventListener("updatefromsandbox", (jsEvent) => {
                        this.showElementAndHideCanvas(jsEvent.target);
                        const actions = {
                          value(event) {
                            elementData.userValue = event.detail.value ?? "";
                            storage.setValue(id, {
                              value: elementData.userValue.toString()
                            });
                            event.target.value = elementData.userValue;
                          },
                          formattedValue(event) {
                            const {
                              formattedValue
                            } = event.detail;
                            elementData.formattedValue = formattedValue;
                            if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                              event.target.value = formattedValue;
                            }
                            storage.setValue(id, {
                              formattedValue
                            });
                          },
                          selRange(event) {
                            event.target.setSelectionRange(...event.detail.selRange);
                          },
                          charLimit: (event) => {
                            var _a4;
                            const {
                              charLimit
                            } = event.detail;
                            const {
                              target
                            } = event;
                            if (charLimit === 0) {
                              target.removeAttribute("maxLength");
                              return;
                            }
                            target.setAttribute("maxLength", charLimit);
                            let value = elementData.userValue;
                            if (!value || value.length <= charLimit) {
                              return;
                            }
                            value = value.slice(0, charLimit);
                            target.value = elementData.userValue = value;
                            storage.setValue(id, {
                              value
                            });
                            (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                              source: this,
                              detail: {
                                id,
                                name: "Keystroke",
                                value,
                                willCommit: true,
                                commitKey: 1,
                                selStart: target.selectionStart,
                                selEnd: target.selectionEnd
                              }
                            });
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      element.addEventListener("keydown", (event) => {
                        var _a4;
                        elementData.commitKey = 1;
                        let commitKey = -1;
                        if (event.key === "Escape") {
                          commitKey = 0;
                        } else if (event.key === "Enter" && !this.data.multiLine) {
                          commitKey = 2;
                        } else if (event.key === "Tab") {
                          elementData.commitKey = 3;
                        }
                        if (commitKey === -1) {
                          return;
                        }
                        const {
                          value
                        } = event.target;
                        if (elementData.lastCommittedValue === value) {
                          return;
                        }
                        elementData.lastCommittedValue = value;
                        elementData.userValue = value;
                        (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id,
                            name: "Keystroke",
                            value,
                            willCommit: true,
                            commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      });
                      const _blurListener = blurListener;
                      blurListener = null;
                      element.addEventListener("blur", (event) => {
                        var _a4;
                        if (!elementData.focused || !event.relatedTarget) {
                          return;
                        }
                        elementData.focused = false;
                        const {
                          value
                        } = event.target;
                        elementData.userValue = value;
                        if (elementData.lastCommittedValue !== value) {
                          (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              willCommit: true,
                              commitKey: elementData.commitKey,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        }
                        _blurListener(event);
                      });
                      if ((_b2 = this.data.actions) == null ? void 0 : _b2.Keystroke) {
                        element.addEventListener("beforeinput", (event) => {
                          var _a4;
                          elementData.lastCommittedValue = null;
                          const {
                            data,
                            target
                          } = event;
                          const {
                            value,
                            selectionStart,
                            selectionEnd
                          } = target;
                          let selStart = selectionStart, selEnd = selectionEnd;
                          switch (event.inputType) {
                            case "deleteWordBackward": {
                              const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                              if (match) {
                                selStart -= match[0].length;
                              }
                              break;
                            }
                            case "deleteWordForward": {
                              const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                              if (match) {
                                selEnd += match[0].length;
                              }
                              break;
                            }
                            case "deleteContentBackward":
                              if (selectionStart === selectionEnd) {
                                selStart -= 1;
                              }
                              break;
                            case "deleteContentForward":
                              if (selectionStart === selectionEnd) {
                                selEnd += 1;
                              }
                              break;
                          }
                          event.preventDefault();
                          (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              change: data || "",
                              willCommit: false,
                              selStart,
                              selEnd
                            }
                          });
                        });
                      }
                      this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                    }
                    if (blurListener) {
                      element.addEventListener("blur", blurListener);
                    }
                    if (this.data.comb) {
                      const fieldWidth = this.data.rect[2] - this.data.rect[0];
                      const combWidth = fieldWidth / maxLen;
                      element.classList.add("comb");
                      element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
                    }
                  } else {
                    element = document.createElement("div");
                    element.textContent = this.data.fieldValue;
                    element.style.verticalAlign = "middle";
                    element.style.display = "table-cell";
                  }
                  this._setTextStyle(element);
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: !!parameters.data.hasOwnCanvas
                  });
                }
              }
              class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id = data.id;
                  let value = storage.getValue(id, {
                    value: data.exportValue === data.fieldValue
                  }).value;
                  if (typeof value === "string") {
                    value = value !== "Off";
                    storage.setValue(id, {
                      value
                    });
                  }
                  this.container.classList.add("buttonWidgetAnnotation", "checkBox");
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "checkbox";
                  element.name = data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.setAttribute("exportValue", data.exportValue);
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const checkbox of this._getElementsByName(name, id)) {
                      const curChecked = checked && checkbox.exportValue === data.exportValue;
                      if (checkbox.domElement) {
                        checkbox.domElement.checked = curChecked;
                      }
                      storage.setValue(checkbox.id, {
                        value: curChecked
                      });
                    }
                    storage.setValue(id, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue || "Off";
                    event.target.checked = defaultValue === data.exportValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          event.target.checked = event.detail.value !== "Off";
                          storage.setValue(id, {
                            value: event.target.checked
                          });
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.classList.add("buttonWidgetAnnotation", "radioButton");
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id = data.id;
                  let value = storage.getValue(id, {
                    value: data.fieldValue === data.buttonValue
                  }).value;
                  if (typeof value === "string") {
                    value = value !== data.buttonValue;
                    storage.setValue(id, {
                      value
                    });
                  }
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "radio";
                  element.name = data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const radio of this._getElementsByName(name, id)) {
                      storage.setValue(radio.id, {
                        value: false
                      });
                    }
                    storage.setValue(id, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue;
                    event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    const pdfButtonValue = data.buttonValue;
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value: (event) => {
                          const checked = pdfButtonValue === event.detail.value;
                          for (const radio of this._getElementsByName(event.target.name)) {
                            const curChecked = checked && radio.id === id;
                            if (radio.domElement) {
                              radio.domElement.checked = curChecked;
                            }
                            storage.setValue(radio.id, {
                              value: curChecked
                            });
                          }
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    ignoreBorder: parameters.data.hasAppearance
                  });
                }
                render() {
                  const container = super.render();
                  container.classList.add("buttonWidgetAnnotation", "pushButton");
                  if (this.data.alternativeText) {
                    container.title = this.data.alternativeText;
                  }
                  const linkElement = container.lastChild;
                  if (this.enableScripting && this.hasJSActions && linkElement) {
                    this._setDefaultPropertiesFromJS(linkElement);
                    linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      this._dispatchEventFromSandbox({}, jsEvent);
                    });
                  }
                  return container;
                }
              }
              class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.classList.add("choiceWidgetAnnotation");
                  const storage = this.annotationStorage;
                  const id = this.data.id;
                  const storedData = storage.getValue(id, {
                    value: this.data.fieldValue
                  });
                  const selectElement = document.createElement("select");
                  GetElementsByNameSet.add(selectElement);
                  selectElement.setAttribute("data-element-id", id);
                  selectElement.disabled = this.data.readOnly;
                  this._setRequired(selectElement, this.data.required);
                  selectElement.name = this.data.fieldName;
                  selectElement.tabIndex = DEFAULT_TAB_INDEX;
                  let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
                  if (!this.data.combo) {
                    selectElement.size = this.data.options.length;
                    if (this.data.multiSelect) {
                      selectElement.multiple = true;
                    }
                  }
                  selectElement.addEventListener("resetform", (event) => {
                    const defaultValue = this.data.defaultFieldValue;
                    for (const option of selectElement.options) {
                      option.selected = option.value === defaultValue;
                    }
                  });
                  for (const option of this.data.options) {
                    const optionElement = document.createElement("option");
                    optionElement.textContent = option.displayValue;
                    optionElement.value = option.exportValue;
                    if (storedData.value.includes(option.exportValue)) {
                      optionElement.setAttribute("selected", true);
                      addAnEmptyEntry = false;
                    }
                    selectElement.append(optionElement);
                  }
                  let removeEmptyEntry = null;
                  if (addAnEmptyEntry) {
                    const noneOptionElement = document.createElement("option");
                    noneOptionElement.value = " ";
                    noneOptionElement.setAttribute("hidden", true);
                    noneOptionElement.setAttribute("selected", true);
                    selectElement.prepend(noneOptionElement);
                    removeEmptyEntry = () => {
                      noneOptionElement.remove();
                      selectElement.removeEventListener("input", removeEmptyEntry);
                      removeEmptyEntry = null;
                    };
                    selectElement.addEventListener("input", removeEmptyEntry);
                  }
                  const getValue = (isExport) => {
                    const name = isExport ? "value" : "textContent";
                    const {
                      options,
                      multiple
                    } = selectElement;
                    if (!multiple) {
                      return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                    }
                    return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
                  };
                  let selectedValues = getValue(false);
                  const getItems = (event) => {
                    const options = event.target.options;
                    return Array.prototype.map.call(options, (option) => {
                      return {
                        displayValue: option.textContent,
                        exportValue: option.value
                      };
                    });
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          removeEmptyEntry == null ? void 0 : removeEmptyEntry();
                          const value = event.detail.value;
                          const values = new Set(Array.isArray(value) ? value : [value]);
                          for (const option of selectElement.options) {
                            option.selected = values.has(option.value);
                          }
                          storage.setValue(id, {
                            value: getValue(true)
                          });
                          selectedValues = getValue(false);
                        },
                        multipleSelection(event) {
                          selectElement.multiple = true;
                        },
                        remove(event) {
                          const options = selectElement.options;
                          const index = event.detail.remove;
                          options[index].selected = false;
                          selectElement.remove(index);
                          if (options.length > 0) {
                            const i3 = Array.prototype.findIndex.call(options, (option) => option.selected);
                            if (i3 === -1) {
                              options[0].selected = true;
                            }
                          }
                          storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                          });
                          selectedValues = getValue(false);
                        },
                        clear(event) {
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          storage.setValue(id, {
                            value: null,
                            items: []
                          });
                          selectedValues = getValue(false);
                        },
                        insert(event) {
                          const {
                            index,
                            displayValue,
                            exportValue
                          } = event.detail.insert;
                          const selectChild = selectElement.children[index];
                          const optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          if (selectChild) {
                            selectChild.before(optionElement);
                          } else {
                            selectElement.append(optionElement);
                          }
                          storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                          });
                          selectedValues = getValue(false);
                        },
                        items(event) {
                          const {
                            items
                          } = event.detail;
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          for (const item of items) {
                            const {
                              displayValue,
                              exportValue
                            } = item;
                            const optionElement = document.createElement("option");
                            optionElement.textContent = displayValue;
                            optionElement.value = exportValue;
                            selectElement.append(optionElement);
                          }
                          if (selectElement.options.length > 0) {
                            selectElement.options[0].selected = true;
                          }
                          storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                          });
                          selectedValues = getValue(false);
                        },
                        indices(event) {
                          const indices = new Set(event.detail.indices);
                          for (const option of event.target.options) {
                            option.selected = indices.has(option.index);
                          }
                          storage.setValue(id, {
                            value: getValue(true)
                          });
                          selectedValues = getValue(false);
                        },
                        editable(event) {
                          event.target.disabled = !event.detail.editable;
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    selectElement.addEventListener("input", (event) => {
                      var _a3;
                      const exportValue = getValue(true);
                      storage.setValue(id, {
                        value: exportValue
                      });
                      event.preventDefault();
                      (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id,
                          name: "Keystroke",
                          value: selectedValues,
                          changeEx: exportValue,
                          willCommit: false,
                          commitKey: 1,
                          keyDown: false
                        }
                      });
                    });
                    this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
                  } else {
                    selectElement.addEventListener("input", function(event) {
                      storage.setValue(id, {
                        value: getValue(true)
                      });
                    });
                  }
                  if (this.data.combo) {
                    this._setTextStyle(selectElement);
                  } else {
                  }
                  this._setBackgroundColor(selectElement);
                  this._setDefaultPropertiesFromJS(selectElement);
                  this.container.append(selectElement);
                  return this.container;
                }
              }
              class PopupAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const {
                    data,
                    elements
                  } = parameters;
                  super(parameters, {
                    isRenderable: AnnotationElement._hasPopupData(data)
                  });
                  this.elements = elements;
                }
                render() {
                  this.container.classList.add("popupAnnotation");
                  const popup = new PopupElement({
                    container: this.container,
                    color: this.data.color,
                    titleObj: this.data.titleObj,
                    modificationDate: this.data.modificationDate,
                    contentsObj: this.data.contentsObj,
                    richText: this.data.richText,
                    rect: this.data.rect,
                    parentRect: this.data.parentRect || null,
                    parent: this.parent,
                    elements: this.elements,
                    open: this.data.open
                  });
                  const elementIds = [];
                  for (const element of this.elements) {
                    element.popup = popup;
                    elementIds.push(element.data.id);
                    element.addHighlightArea();
                  }
                  this.container.setAttribute("aria-controls", elementIds.map((id) => `${_util2.AnnotationPrefix}${id}`).join(","));
                  return this.container;
                }
              }
              class PopupElement {
                constructor({
                  container,
                  color,
                  elements,
                  titleObj,
                  modificationDate,
                  contentsObj,
                  richText,
                  parent,
                  rect,
                  parentRect,
                  open
                }) {
                  __privateAdd(this, _keyDown);
                  __privateAdd(this, _toggle);
                  __privateAdd(this, _show);
                  __privateAdd(this, _hide);
                  __privateAdd(this, _dateTimePromise, null);
                  __privateAdd(this, _boundKeyDown, __privateMethod(this, _keyDown, keyDown_fn).bind(this));
                  __privateAdd(this, _boundHide, __privateMethod(this, _hide, hide_fn).bind(this));
                  __privateAdd(this, _boundShow, __privateMethod(this, _show, show_fn).bind(this));
                  __privateAdd(this, _boundToggle, __privateMethod(this, _toggle, toggle_fn).bind(this));
                  __privateAdd(this, _color, null);
                  __privateAdd(this, _container, null);
                  __privateAdd(this, _contentsObj, null);
                  __privateAdd(this, _elements, null);
                  __privateAdd(this, _parent, null);
                  __privateAdd(this, _parentRect, null);
                  __privateAdd(this, _pinned, false);
                  __privateAdd(this, _popup, null);
                  __privateAdd(this, _rect, null);
                  __privateAdd(this, _richText, null);
                  __privateAdd(this, _titleObj, null);
                  __privateAdd(this, _wasVisible, false);
                  var _a3;
                  __privateSet(this, _container, container);
                  __privateSet(this, _titleObj, titleObj);
                  __privateSet(this, _contentsObj, contentsObj);
                  __privateSet(this, _richText, richText);
                  __privateSet(this, _parent, parent);
                  __privateSet(this, _color, color);
                  __privateSet(this, _rect, rect);
                  __privateSet(this, _parentRect, parentRect);
                  __privateSet(this, _elements, elements);
                  const dateObject = _display_utils2.PDFDateString.toDateObject(modificationDate);
                  if (dateObject) {
                    __privateSet(this, _dateTimePromise, parent.l10n.get("annotation_date_string", {
                      date: dateObject.toLocaleDateString(),
                      time: dateObject.toLocaleTimeString()
                    }));
                  }
                  this.trigger = elements.flatMap((e3) => e3.getElementsToTriggerPopup());
                  for (const element of this.trigger) {
                    element.addEventListener("click", __privateGet(this, _boundToggle));
                    element.addEventListener("mouseenter", __privateGet(this, _boundShow));
                    element.addEventListener("mouseleave", __privateGet(this, _boundHide));
                    element.classList.add("popupTriggerArea");
                  }
                  for (const element of elements) {
                    (_a3 = element.container) == null ? void 0 : _a3.addEventListener("keydown", __privateGet(this, _boundKeyDown));
                  }
                  __privateGet(this, _container).hidden = true;
                  if (open) {
                    __privateMethod(this, _toggle, toggle_fn).call(this);
                  }
                }
                render() {
                  if (__privateGet(this, _popup)) {
                    return;
                  }
                  const {
                    page: {
                      view
                    },
                    viewport: {
                      rawDims: {
                        pageWidth,
                        pageHeight,
                        pageX,
                        pageY
                      }
                    }
                  } = __privateGet(this, _parent);
                  const popup = __privateSet(this, _popup, document.createElement("div"));
                  popup.className = "popup";
                  if (__privateGet(this, _color)) {
                    const baseColor = popup.style.outlineColor = _util2.Util.makeHexColor(...__privateGet(this, _color));
                    if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) {
                      popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
                    } else {
                      const BACKGROUND_ENLIGHT = 0.7;
                      popup.style.backgroundColor = _util2.Util.makeHexColor(...__privateGet(this, _color).map((c3) => Math.floor(BACKGROUND_ENLIGHT * (255 - c3) + c3)));
                    }
                  }
                  const header = document.createElement("span");
                  header.className = "header";
                  const title = document.createElement("h1");
                  header.append(title);
                  ({
                    dir: title.dir,
                    str: title.textContent
                  } = __privateGet(this, _titleObj));
                  popup.append(header);
                  if (__privateGet(this, _dateTimePromise)) {
                    const modificationDate = document.createElement("span");
                    modificationDate.classList.add("popupDate");
                    __privateGet(this, _dateTimePromise).then((localized) => {
                      modificationDate.textContent = localized;
                    });
                    header.append(modificationDate);
                  }
                  const contentsObj = __privateGet(this, _contentsObj);
                  const richText = __privateGet(this, _richText);
                  if ((richText == null ? void 0 : richText.str) && (!(contentsObj == null ? void 0 : contentsObj.str) || contentsObj.str === richText.str)) {
                    _xfa_layer.XfaLayer.render({
                      xfaHtml: richText.html,
                      intent: "richText",
                      div: popup
                    });
                    popup.lastChild.classList.add("richText", "popupContent");
                  } else {
                    const contents = this._formatContents(contentsObj);
                    popup.append(contents);
                  }
                  let useParentRect = !!__privateGet(this, _parentRect);
                  let rect = useParentRect ? __privateGet(this, _parentRect) : __privateGet(this, _rect);
                  for (const element of __privateGet(this, _elements)) {
                    if (!rect || _util2.Util.intersect(element.data.rect, rect) !== null) {
                      rect = element.data.rect;
                      useParentRect = true;
                      break;
                    }
                  }
                  const normalizedRect = _util2.Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
                  const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
                  const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
                  const popupLeft = normalizedRect[0] + parentWidth;
                  const popupTop = normalizedRect[1];
                  const {
                    style
                  } = __privateGet(this, _container);
                  style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;
                  style.top = `${100 * (popupTop - pageY) / pageHeight}%`;
                  __privateGet(this, _container).append(popup);
                }
                _formatContents({
                  str,
                  dir
                }) {
                  const p2 = document.createElement("p");
                  p2.classList.add("popupContent");
                  p2.dir = dir;
                  const lines = str.split(/(?:\r\n?|\n)/);
                  for (let i3 = 0, ii2 = lines.length; i3 < ii2; ++i3) {
                    const line = lines[i3];
                    p2.append(document.createTextNode(line));
                    if (i3 < ii2 - 1) {
                      p2.append(document.createElement("br"));
                    }
                  }
                  return p2;
                }
                forceHide() {
                  __privateSet(this, _wasVisible, this.isVisible);
                  if (!__privateGet(this, _wasVisible)) {
                    return;
                  }
                  __privateGet(this, _container).hidden = true;
                }
                maybeShow() {
                  if (!__privateGet(this, _wasVisible)) {
                    return;
                  }
                  __privateSet(this, _wasVisible, false);
                  __privateGet(this, _container).hidden = false;
                }
                get isVisible() {
                  return __privateGet(this, _container).hidden === false;
                }
              }
              _dateTimePromise = new WeakMap();
              _boundKeyDown = new WeakMap();
              _boundHide = new WeakMap();
              _boundShow = new WeakMap();
              _boundToggle = new WeakMap();
              _color = new WeakMap();
              _container = new WeakMap();
              _contentsObj = new WeakMap();
              _elements = new WeakMap();
              _parent = new WeakMap();
              _parentRect = new WeakMap();
              _pinned = new WeakMap();
              _popup = new WeakMap();
              _rect = new WeakMap();
              _richText = new WeakMap();
              _titleObj = new WeakMap();
              _wasVisible = new WeakMap();
              _keyDown = new WeakSet();
              keyDown_fn = function(event) {
                if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
                  return;
                }
                if (event.key === "Enter" || event.key === "Escape" && __privateGet(this, _pinned)) {
                  __privateMethod(this, _toggle, toggle_fn).call(this);
                }
              };
              _toggle = new WeakSet();
              toggle_fn = function() {
                __privateSet(this, _pinned, !__privateGet(this, _pinned));
                if (__privateGet(this, _pinned)) {
                  __privateMethod(this, _show, show_fn).call(this);
                  __privateGet(this, _container).addEventListener("click", __privateGet(this, _boundToggle));
                  __privateGet(this, _container).addEventListener("keydown", __privateGet(this, _boundKeyDown));
                } else {
                  __privateMethod(this, _hide, hide_fn).call(this);
                  __privateGet(this, _container).removeEventListener("click", __privateGet(this, _boundToggle));
                  __privateGet(this, _container).removeEventListener("keydown", __privateGet(this, _boundKeyDown));
                }
              };
              _show = new WeakSet();
              show_fn = function() {
                if (!__privateGet(this, _popup)) {
                  this.render();
                }
                if (!this.isVisible) {
                  __privateGet(this, _container).hidden = false;
                  __privateGet(this, _container).style.zIndex = parseInt(__privateGet(this, _container).style.zIndex) + 1e3;
                } else if (__privateGet(this, _pinned)) {
                  __privateGet(this, _container).classList.add("focused");
                }
              };
              _hide = new WeakSet();
              hide_fn = function() {
                __privateGet(this, _container).classList.remove("focused");
                if (__privateGet(this, _pinned) || !this.isVisible) {
                  return;
                }
                __privateGet(this, _container).hidden = true;
                __privateGet(this, _container).style.zIndex = parseInt(__privateGet(this, _container).style.zIndex) - 1e3;
              };
              class FreeTextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true
                  });
                  this.textContent = parameters.data.textContent;
                  this.textPosition = parameters.data.textPosition;
                  this.annotationEditorType = _util2.AnnotationEditorType.FREETEXT;
                }
                render() {
                  this.container.classList.add("freeTextAnnotation");
                  if (this.textContent) {
                    const content = document.createElement("div");
                    content.classList.add("annotationTextContent");
                    content.setAttribute("role", "comment");
                    for (const line of this.textContent) {
                      const lineSpan = document.createElement("span");
                      lineSpan.textContent = line;
                      content.append(lineSpan);
                    }
                    this.container.append(content);
                  }
                  if (!this.data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  this._editOnDoubleClick();
                  return this.container;
                }
              }
              exports2.FreeTextAnnotationElement = FreeTextAnnotationElement;
              class LineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _line, null);
                }
                render() {
                  this.container.classList.add("lineAnnotation");
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const line = __privateSet(this, _line, this.svgFactory.createElement("svg:line"));
                  line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                  line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                  line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                  line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                  line.setAttribute("stroke-width", data.borderStyle.width || 1);
                  line.setAttribute("stroke", "transparent");
                  line.setAttribute("fill", "transparent");
                  svg.append(line);
                  this.container.append(svg);
                  if (!data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _line);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _line = new WeakMap();
              class SquareAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _square, null);
                }
                render() {
                  this.container.classList.add("squareAnnotation");
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const borderWidth = data.borderStyle.width;
                  const square = __privateSet(this, _square, this.svgFactory.createElement("svg:rect"));
                  square.setAttribute("x", borderWidth / 2);
                  square.setAttribute("y", borderWidth / 2);
                  square.setAttribute("width", width - borderWidth);
                  square.setAttribute("height", height - borderWidth);
                  square.setAttribute("stroke-width", borderWidth || 1);
                  square.setAttribute("stroke", "transparent");
                  square.setAttribute("fill", "transparent");
                  svg.append(square);
                  this.container.append(svg);
                  if (!data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _square);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _square = new WeakMap();
              class CircleAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _circle, null);
                }
                render() {
                  this.container.classList.add("circleAnnotation");
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const borderWidth = data.borderStyle.width;
                  const circle = __privateSet(this, _circle, this.svgFactory.createElement("svg:ellipse"));
                  circle.setAttribute("cx", width / 2);
                  circle.setAttribute("cy", height / 2);
                  circle.setAttribute("rx", width / 2 - borderWidth / 2);
                  circle.setAttribute("ry", height / 2 - borderWidth / 2);
                  circle.setAttribute("stroke-width", borderWidth || 1);
                  circle.setAttribute("stroke", "transparent");
                  circle.setAttribute("fill", "transparent");
                  svg.append(circle);
                  this.container.append(svg);
                  if (!data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _circle);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _circle = new WeakMap();
              class PolylineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _polyline, null);
                  this.containerClassName = "polylineAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.classList.add(this.containerClassName);
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  let points = [];
                  for (const coordinate of data.vertices) {
                    const x3 = coordinate.x - data.rect[0];
                    const y3 = data.rect[3] - coordinate.y;
                    points.push(x3 + "," + y3);
                  }
                  points = points.join(" ");
                  const polyline = __privateSet(this, _polyline, this.svgFactory.createElement(this.svgElementName));
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "transparent");
                  svg.append(polyline);
                  this.container.append(svg);
                  if (!data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _polyline);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _polyline = new WeakMap();
              class PolygonAnnotationElement extends PolylineAnnotationElement {
                constructor(parameters) {
                  super(parameters);
                  this.containerClassName = "polygonAnnotation";
                  this.svgElementName = "svg:polygon";
                }
              }
              class CaretAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.classList.add("caretAnnotation");
                  if (!this.data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  return this.container;
                }
              }
              class InkAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _polylines, []);
                  this.containerClassName = "inkAnnotation";
                  this.svgElementName = "svg:polyline";
                  this.annotationEditorType = _util2.AnnotationEditorType.INK;
                }
                render() {
                  this.container.classList.add(this.containerClassName);
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  for (const inkList of data.inkLists) {
                    let points = [];
                    for (const coordinate of inkList) {
                      const x3 = coordinate.x - data.rect[0];
                      const y3 = data.rect[3] - coordinate.y;
                      points.push(`${x3},${y3}`);
                    }
                    points = points.join(" ");
                    const polyline = this.svgFactory.createElement(this.svgElementName);
                    __privateGet(this, _polylines).push(polyline);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "transparent");
                    if (!data.popupRef && this.hasPopupData) {
                      this._createPopup();
                    }
                    svg.append(polyline);
                  }
                  this.container.append(svg);
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _polylines);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _polylines = new WeakMap();
              exports2.InkAnnotationElement = InkAnnotationElement;
              class HighlightAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  this.container.classList.add("highlightAnnotation");
                  return this.container;
                }
              }
              class UnderlineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  this.container.classList.add("underlineAnnotation");
                  return this.container;
                }
              }
              class SquigglyAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  this.container.classList.add("squigglyAnnotation");
                  return this.container;
                }
              }
              class StrikeOutAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  this.container.classList.add("strikeoutAnnotation");
                  return this.container;
                }
              }
              class StampAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.classList.add("stampAnnotation");
                  if (!this.data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  return this.container;
                }
              }
              exports2.StampAnnotationElement = StampAnnotationElement;
              class FileAttachmentAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a3;
                  super(parameters, {
                    isRenderable: true
                  });
                  __privateAdd(this, _download);
                  __privateAdd(this, _trigger, null);
                  const {
                    filename,
                    content
                  } = this.data.file;
                  this.filename = (0, _display_utils2.getFilenameFromUrl)(filename, true);
                  this.content = content;
                  (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("fileattachmentannotation", {
                    source: this,
                    filename,
                    content
                  });
                }
                render() {
                  this.container.classList.add("fileAttachmentAnnotation");
                  const {
                    container,
                    data
                  } = this;
                  let trigger;
                  if (data.hasAppearance || data.fillAlpha === 0) {
                    trigger = document.createElement("div");
                  } else {
                    trigger = document.createElement("img");
                    trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
                    if (data.fillAlpha && data.fillAlpha < 1) {
                      trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
                    }
                  }
                  trigger.addEventListener("dblclick", __privateMethod(this, _download, download_fn).bind(this));
                  __privateSet(this, _trigger, trigger);
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  container.addEventListener("keydown", (evt) => {
                    if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
                      __privateMethod(this, _download, download_fn).call(this);
                    }
                  });
                  if (!data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  } else {
                    trigger.classList.add("popupTriggerArea");
                  }
                  container.append(trigger);
                  return container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _trigger);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _trigger = new WeakMap();
              _download = new WeakSet();
              download_fn = function() {
                var _a3;
                (_a3 = this.downloadManager) == null ? void 0 : _a3.openOrDownloadData(this.container, this.content, this.filename);
              };
              class AnnotationLayer {
                constructor({
                  div,
                  accessibilityManager,
                  annotationCanvasMap,
                  l10n,
                  page,
                  viewport
                }) {
                  __privateAdd(this, _appendElement);
                  __privateAdd(this, _setAnnotationCanvasMap);
                  __privateAdd(this, _accessibilityManager, null);
                  __privateAdd(this, _annotationCanvasMap, null);
                  __privateAdd(this, _editableAnnotations, /* @__PURE__ */ new Map());
                  this.div = div;
                  __privateSet(this, _accessibilityManager, accessibilityManager);
                  __privateSet(this, _annotationCanvasMap, annotationCanvasMap);
                  this.l10n = l10n;
                  this.page = page;
                  this.viewport = viewport;
                  this.zIndex = 0;
                  this.l10n || (this.l10n = _displayL10n_utils.NullL10n);
                }
                async render(params) {
                  const {
                    annotations
                  } = params;
                  const layer = this.div;
                  (0, _display_utils2.setLayerDimensions)(layer, this.viewport);
                  const popupToElements = /* @__PURE__ */ new Map();
                  const elementParams = {
                    data: null,
                    layer,
                    linkService: params.linkService,
                    downloadManager: params.downloadManager,
                    imageResourcesPath: params.imageResourcesPath || "",
                    renderForms: params.renderForms !== false,
                    svgFactory: new _display_utils2.DOMSVGFactory(),
                    annotationStorage: params.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                    enableScripting: params.enableScripting === true,
                    hasJSActions: params.hasJSActions,
                    fieldObjects: params.fieldObjects,
                    parent: this,
                    elements: null
                  };
                  for (const data of annotations) {
                    if (data.noHTML) {
                      continue;
                    }
                    const isPopupAnnotation = data.annotationType === _util2.AnnotationType.POPUP;
                    if (!isPopupAnnotation) {
                      const {
                        width,
                        height
                      } = getRectDims(data.rect);
                      if (width <= 0 || height <= 0) {
                        continue;
                      }
                    } else {
                      const elements = popupToElements.get(data.id);
                      if (!elements) {
                        continue;
                      }
                      elementParams.elements = elements;
                    }
                    elementParams.data = data;
                    const element = AnnotationElementFactory.create(elementParams);
                    if (!element.isRenderable) {
                      continue;
                    }
                    if (!isPopupAnnotation && data.popupRef) {
                      const elements = popupToElements.get(data.popupRef);
                      if (!elements) {
                        popupToElements.set(data.popupRef, [element]);
                      } else {
                        elements.push(element);
                      }
                    }
                    if (element.annotationEditorType > 0) {
                      __privateGet(this, _editableAnnotations).set(element.data.id, element);
                    }
                    const rendered = element.render();
                    if (data.hidden) {
                      rendered.style.visibility = "hidden";
                    }
                    __privateMethod(this, _appendElement, appendElement_fn).call(this, rendered, data.id);
                  }
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
                  await this.l10n.translate(layer);
                }
                update({
                  viewport
                }) {
                  const layer = this.div;
                  this.viewport = viewport;
                  (0, _display_utils2.setLayerDimensions)(layer, {
                    rotation: viewport.rotation
                  });
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
                  layer.hidden = false;
                }
                getEditableAnnotations() {
                  return Array.from(__privateGet(this, _editableAnnotations).values());
                }
                getEditableAnnotation(id) {
                  return __privateGet(this, _editableAnnotations).get(id);
                }
              }
              _accessibilityManager = new WeakMap();
              _annotationCanvasMap = new WeakMap();
              _editableAnnotations = new WeakMap();
              _appendElement = new WeakSet();
              appendElement_fn = function(element, id) {
                var _a3;
                const contentElement = element.firstChild || element;
                contentElement.id = `${_util2.AnnotationPrefix}${id}`;
                this.div.append(element);
                (_a3 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a3.moveElementInDOM(this.div, element, contentElement, false);
              };
              _setAnnotationCanvasMap = new WeakSet();
              setAnnotationCanvasMap_fn = function() {
                if (!__privateGet(this, _annotationCanvasMap)) {
                  return;
                }
                const layer = this.div;
                for (const [id, canvas] of __privateGet(this, _annotationCanvasMap)) {
                  const element = layer.querySelector(`[data-annotation-id="${id}"]`);
                  if (!element) {
                    continue;
                  }
                  const {
                    firstChild
                  } = element;
                  if (!firstChild) {
                    element.append(canvas);
                  } else if (firstChild.nodeName === "CANVAS") {
                    firstChild.replaceWith(canvas);
                  } else {
                    firstChild.before(canvas);
                  }
                }
                __privateGet(this, _annotationCanvasMap).clear();
              };
              exports2.AnnotationLayer = AnnotationLayer;
            },
            /* 30 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorConverters = void 0;
              function makeColorComp(n3) {
                return Math.floor(Math.max(0, Math.min(1, n3)) * 255).toString(16).padStart(2, "0");
              }
              function scaleAndClamp(x3) {
                return Math.max(0, Math.min(255, 255 * x3));
              }
              class ColorConverters {
                static CMYK_G([c3, y3, m3, k3]) {
                  return ["G", 1 - Math.min(1, 0.3 * c3 + 0.59 * m3 + 0.11 * y3 + k3)];
                }
                static G_CMYK([g3]) {
                  return ["CMYK", 0, 0, 0, 1 - g3];
                }
                static G_RGB([g3]) {
                  return ["RGB", g3, g3, g3];
                }
                static G_rgb([g3]) {
                  g3 = scaleAndClamp(g3);
                  return [g3, g3, g3];
                }
                static G_HTML([g3]) {
                  const G3 = makeColorComp(g3);
                  return `#${G3}${G3}${G3}`;
                }
                static RGB_G([r3, g3, b3]) {
                  return ["G", 0.3 * r3 + 0.59 * g3 + 0.11 * b3];
                }
                static RGB_rgb(color) {
                  return color.map(scaleAndClamp);
                }
                static RGB_HTML(color) {
                  return `#${color.map(makeColorComp).join("")}`;
                }
                static T_HTML() {
                  return "#00000000";
                }
                static T_rgb() {
                  return [null];
                }
                static CMYK_RGB([c3, y3, m3, k3]) {
                  return ["RGB", 1 - Math.min(1, c3 + k3), 1 - Math.min(1, m3 + k3), 1 - Math.min(1, y3 + k3)];
                }
                static CMYK_rgb([c3, y3, m3, k3]) {
                  return [scaleAndClamp(1 - Math.min(1, c3 + k3)), scaleAndClamp(1 - Math.min(1, m3 + k3)), scaleAndClamp(1 - Math.min(1, y3 + k3))];
                }
                static CMYK_HTML(components) {
                  const rgb = this.CMYK_RGB(components).slice(1);
                  return this.RGB_HTML(rgb);
                }
                static RGB_CMYK([r3, g3, b3]) {
                  const c3 = 1 - r3;
                  const m3 = 1 - g3;
                  const y3 = 1 - b3;
                  const k3 = Math.min(c3, m3, y3);
                  return ["CMYK", c3, m3, y3, k3];
                }
              }
              exports2.ColorConverters = ColorConverters;
            },
            /* 31 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NullL10n = void 0;
              exports2.getL10nFallback = getL10nFallback;
              const DEFAULT_L10N_STRINGS = {
                of_pages: "of {{pagesCount}}",
                page_of_pages: "({{pageNumber}} of {{pagesCount}})",
                document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
                document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
                document_properties_date_string: "{{date}}, {{time}}",
                document_properties_page_size_unit_inches: "in",
                document_properties_page_size_unit_millimeters: "mm",
                document_properties_page_size_orientation_portrait: "portrait",
                document_properties_page_size_orientation_landscape: "landscape",
                document_properties_page_size_name_a3: "A3",
                document_properties_page_size_name_a4: "A4",
                document_properties_page_size_name_letter: "Letter",
                document_properties_page_size_name_legal: "Legal",
                document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
                document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
                document_properties_linearized_yes: "Yes",
                document_properties_linearized_no: "No",
                additional_layers: "Additional Layers",
                page_landmark: "Page {{page}}",
                thumb_page_title: "Page {{page}}",
                thumb_page_canvas: "Thumbnail of Page {{page}}",
                find_reached_top: "Reached top of document, continued from bottom",
                find_reached_bottom: "Reached end of document, continued from top",
                "find_match_count[one]": "{{current}} of {{total}} match",
                "find_match_count[other]": "{{current}} of {{total}} matches",
                "find_match_count_limit[one]": "More than {{limit}} match",
                "find_match_count_limit[other]": "More than {{limit}} matches",
                find_not_found: "Phrase not found",
                page_scale_width: "Page Width",
                page_scale_fit: "Page Fit",
                page_scale_auto: "Automatic Zoom",
                page_scale_actual: "Actual Size",
                page_scale_percent: "{{scale}}%",
                loading_error: "An error occurred while loading the PDF.",
                invalid_file_error: "Invalid or corrupted PDF file.",
                missing_file_error: "Missing PDF file.",
                unexpected_response_error: "Unexpected server response.",
                rendering_error: "An error occurred while rendering the page.",
                annotation_date_string: "{{date}}, {{time}}",
                printing_not_supported: "Warning: Printing is not fully supported by this browser.",
                printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
                web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
                free_text2_default_content: "Start typing…",
                editor_free_text2_aria_label: "Text Editor",
                editor_ink2_aria_label: "Draw Editor",
                editor_ink_canvas_aria_label: "User-created image",
                editor_alt_text_button_label: "Alt text",
                editor_alt_text_edit_button_label: "Edit alt text",
                editor_alt_text_decorative_tooltip: "Marked as decorative"
              };
              {
                DEFAULT_L10N_STRINGS.print_progress_percent = "{{progress}}%";
              }
              function getL10nFallback(key, args) {
                switch (key) {
                  case "find_match_count":
                    key = `find_match_count[${args.total === 1 ? "one" : "other"}]`;
                    break;
                  case "find_match_count_limit":
                    key = `find_match_count_limit[${args.limit === 1 ? "one" : "other"}]`;
                    break;
                }
                return DEFAULT_L10N_STRINGS[key] || "";
              }
              function formatL10nValue(text, args) {
                if (!args) {
                  return text;
                }
                return text.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
                  return name in args ? args[name] : "{{" + name + "}}";
                });
              }
              const NullL10n = {
                async getLanguage() {
                  return "en-us";
                },
                async getDirection() {
                  return "ltr";
                },
                async get(key, args = null, fallback = getL10nFallback(key, args)) {
                  return formatL10nValue(fallback, args);
                },
                async translate(element) {
                }
              };
              exports2.NullL10n = NullL10n;
            },
            /* 32 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaLayer = void 0;
              var _xfa_text2 = __w_pdfjs_require__2(25);
              class XfaLayer {
                static setupStorage(html, id, element, storage, intent) {
                  const storedData = storage.getValue(id, {
                    value: null
                  });
                  switch (element.name) {
                    case "textarea":
                      if (storedData.value !== null) {
                        html.textContent = storedData.value;
                      }
                      if (intent === "print") {
                        break;
                      }
                      html.addEventListener("input", (event) => {
                        storage.setValue(id, {
                          value: event.target.value
                        });
                      });
                      break;
                    case "input":
                      if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                        if (storedData.value === element.attributes.xfaOn) {
                          html.setAttribute("checked", true);
                        } else if (storedData.value === element.attributes.xfaOff) {
                          html.removeAttribute("checked");
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("change", (event) => {
                          storage.setValue(id, {
                            value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                          });
                        });
                      } else {
                        if (storedData.value !== null) {
                          html.setAttribute("value", storedData.value);
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("input", (event) => {
                          storage.setValue(id, {
                            value: event.target.value
                          });
                        });
                      }
                      break;
                    case "select":
                      if (storedData.value !== null) {
                        html.setAttribute("value", storedData.value);
                        for (const option of element.children) {
                          if (option.attributes.value === storedData.value) {
                            option.attributes.selected = true;
                          } else if (option.attributes.hasOwnProperty("selected")) {
                            delete option.attributes.selected;
                          }
                        }
                      }
                      html.addEventListener("input", (event) => {
                        const options = event.target.options;
                        const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                        storage.setValue(id, {
                          value
                        });
                      });
                      break;
                  }
                }
                static setAttributes({
                  html,
                  element,
                  storage = null,
                  intent,
                  linkService
                }) {
                  const {
                    attributes
                  } = element;
                  const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                  if (attributes.type === "radio") {
                    attributes.name = `${attributes.name}-${intent}`;
                  }
                  for (const [key, value] of Object.entries(attributes)) {
                    if (value === null || value === void 0) {
                      continue;
                    }
                    switch (key) {
                      case "class":
                        if (value.length) {
                          html.setAttribute(key, value.join(" "));
                        }
                        break;
                      case "dataId":
                        break;
                      case "id":
                        html.setAttribute("data-element-id", value);
                        break;
                      case "style":
                        Object.assign(html.style, value);
                        break;
                      case "textContent":
                        html.textContent = value;
                        break;
                      default:
                        if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                          html.setAttribute(key, value);
                        }
                    }
                  }
                  if (isHTMLAnchorElement) {
                    linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                  }
                  if (storage && attributes.dataId) {
                    this.setupStorage(html, attributes.dataId, element, storage);
                  }
                }
                static render(parameters) {
                  var _a3;
                  const storage = parameters.annotationStorage;
                  const linkService = parameters.linkService;
                  const root = parameters.xfaHtml;
                  const intent = parameters.intent || "display";
                  const rootHtml = document.createElement(root.name);
                  if (root.attributes) {
                    this.setAttributes({
                      html: rootHtml,
                      element: root,
                      intent,
                      linkService
                    });
                  }
                  const stack = [[root, -1, rootHtml]];
                  const rootDiv = parameters.div;
                  rootDiv.append(rootHtml);
                  if (parameters.viewport) {
                    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                    rootDiv.style.transform = transform;
                  }
                  if (intent !== "richText") {
                    rootDiv.setAttribute("class", "xfaLayer xfaFont");
                  }
                  const textDivs = [];
                  while (stack.length > 0) {
                    const [parent, i3, html] = stack.at(-1);
                    if (i3 + 1 === parent.children.length) {
                      stack.pop();
                      continue;
                    }
                    const child = parent.children[++stack.at(-1)[1]];
                    if (child === null) {
                      continue;
                    }
                    const {
                      name
                    } = child;
                    if (name === "#text") {
                      const node = document.createTextNode(child.value);
                      textDivs.push(node);
                      html.append(node);
                      continue;
                    }
                    const childHtml = ((_a3 = child == null ? void 0 : child.attributes) == null ? void 0 : _a3.xmlns) ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
                    html.append(childHtml);
                    if (child.attributes) {
                      this.setAttributes({
                        html: childHtml,
                        element: child,
                        storage,
                        intent,
                        linkService
                      });
                    }
                    if (child.children && child.children.length > 0) {
                      stack.push([child, -1, childHtml]);
                    } else if (child.value) {
                      const node = document.createTextNode(child.value);
                      if (_xfa_text2.XfaText.shouldBuildText(name)) {
                        textDivs.push(node);
                      }
                      childHtml.append(node);
                    }
                  }
                  for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
                    el.setAttribute("readOnly", true);
                  }
                  return {
                    textDivs
                  };
                }
                static update(parameters) {
                  const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                  parameters.div.style.transform = transform;
                  parameters.div.hidden = false;
                }
              }
              exports2.XfaLayer = XfaLayer;
            },
            /* 33 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _baseHeight, _baseWidth, _boundCanvasPointermove, _boundCanvasPointerleave, _boundCanvasPointerup, _boundCanvasPointerdown, _currentPath2D, _disableEditing, _hasSomethingToDraw, _isCanvasInitialized, _observer, _realWidth, _realHeight, _requestFrameCallback, _updateThickness, updateThickness_fn, _updateColor, updateColor_fn, _updateOpacity, updateOpacity_fn, _getInitialBBox, getInitialBBox_fn, _setStroke, setStroke_fn, _startDrawing, startDrawing_fn, _draw, draw_fn, _endPath, endPath_fn, _stopDrawing, stopDrawing_fn, _drawPoints, drawPoints_fn, _makeBezierCurve, makeBezierCurve_fn, _generateBezierPoints, generateBezierPoints_fn, _redraw, redraw_fn, _endDrawing, endDrawing_fn, _createCanvas, createCanvas_fn, _createObserver, createObserver_fn, _setCanvasDims, setCanvasDims_fn, _setScaleFactor, setScaleFactor_fn, _updateTransform, updateTransform_fn, _buildPath2D, buildPath2D_fn, _toPDFCoordinates, toPDFCoordinates_fn, _fromPDFCoordinates, fromPDFCoordinates_fn, _serializePaths, serializePaths_fn, _getBbox, getBbox_fn, _getPadding, getPadding_fn, _fitToContent, fitToContent_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InkEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(4);
              var _annotation_layer = __w_pdfjs_require__2(29);
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _tools = __w_pdfjs_require__2(5);
              const _InkEditor = class _InkEditor extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "inkEditor"
                  });
                  __privateAdd(this, _updateThickness);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _updateOpacity);
                  __privateAdd(this, _getInitialBBox);
                  __privateAdd(this, _setStroke);
                  __privateAdd(this, _startDrawing);
                  __privateAdd(this, _draw);
                  __privateAdd(this, _endPath);
                  __privateAdd(this, _stopDrawing);
                  __privateAdd(this, _drawPoints);
                  __privateAdd(this, _makeBezierCurve);
                  __privateAdd(this, _generateBezierPoints);
                  __privateAdd(this, _redraw);
                  __privateAdd(this, _endDrawing);
                  __privateAdd(this, _createCanvas);
                  __privateAdd(this, _createObserver);
                  __privateAdd(this, _setCanvasDims);
                  __privateAdd(this, _setScaleFactor);
                  __privateAdd(this, _updateTransform);
                  __privateAdd(this, _serializePaths);
                  __privateAdd(this, _getBbox);
                  __privateAdd(this, _getPadding);
                  __privateAdd(this, _fitToContent);
                  __privateAdd(this, _baseHeight, 0);
                  __privateAdd(this, _baseWidth, 0);
                  __privateAdd(this, _boundCanvasPointermove, this.canvasPointermove.bind(this));
                  __privateAdd(this, _boundCanvasPointerleave, this.canvasPointerleave.bind(this));
                  __privateAdd(this, _boundCanvasPointerup, this.canvasPointerup.bind(this));
                  __privateAdd(this, _boundCanvasPointerdown, this.canvasPointerdown.bind(this));
                  __privateAdd(this, _currentPath2D, new Path2D());
                  __privateAdd(this, _disableEditing, false);
                  __privateAdd(this, _hasSomethingToDraw, false);
                  __privateAdd(this, _isCanvasInitialized, false);
                  __privateAdd(this, _observer, null);
                  __privateAdd(this, _realWidth, 0);
                  __privateAdd(this, _realHeight, 0);
                  __privateAdd(this, _requestFrameCallback, null);
                  this.color = params.color || null;
                  this.thickness = params.thickness || null;
                  this.opacity = params.opacity || null;
                  this.paths = [];
                  this.bezierPath2D = [];
                  this.allRawPaths = [];
                  this.currentPath = [];
                  this.scaleFactor = 1;
                  this.translationX = this.translationY = 0;
                  this.x = 0;
                  this.y = 0;
                  this._willKeepAspectRatio = true;
                }
                static initialize(l10n) {
                  _editor.AnnotationEditor.initialize(l10n, {
                    strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
                  });
                }
                static updateDefaultParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      _InkEditor._defaultThickness = value;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      _InkEditor._defaultColor = value;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      _InkEditor._defaultOpacity = value / 100;
                      break;
                  }
                }
                updateParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      __privateMethod(this, _updateThickness, updateThickness_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      __privateMethod(this, _updateOpacity, updateOpacity_fn).call(this, value);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(_InkEditor._defaultOpacity * 100)]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, this.color || _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? _InkEditor._defaultOpacity))]];
                }
                rebuild() {
                  if (!this.parent) {
                    return;
                  }
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.canvas) {
                    __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                    __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  }
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                }
                remove() {
                  if (this.canvas === null) {
                    return;
                  }
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.canvas.width = this.canvas.height = 0;
                  this.canvas.remove();
                  this.canvas = null;
                  __privateGet(this, _observer).disconnect();
                  __privateSet(this, _observer, null);
                  super.remove();
                }
                setParent(parent) {
                  if (!this.parent && parent) {
                    this._uiManager.removeShouldRescale(this);
                  } else if (this.parent && parent === null) {
                    this._uiManager.addShouldRescale(this);
                  }
                  super.setParent(parent);
                }
                onScaleChanging() {
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  const width = this.width * parentWidth;
                  const height = this.height * parentHeight;
                  this.setDimensions(width, height);
                }
                enableEditMode() {
                  if (__privateGet(this, _disableEditing) || this.canvas === null) {
                    return;
                  }
                  super.enableEditMode();
                  this._isDraggable = false;
                  this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                }
                disableEditMode() {
                  if (!this.isInEditMode() || this.canvas === null) {
                    return;
                  }
                  super.disableEditMode();
                  this._isDraggable = !this.isEmpty();
                  this.div.classList.remove("editing");
                  this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                }
                onceAdded() {
                  this._isDraggable = !this.isEmpty();
                }
                isEmpty() {
                  return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
                }
                commit() {
                  if (__privateGet(this, _disableEditing)) {
                    return;
                  }
                  super.commit();
                  this.isEditing = false;
                  this.disableEditMode();
                  this.setInForeground();
                  __privateSet(this, _disableEditing, true);
                  this.div.classList.add("disabled");
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this, true);
                  this.makeResizable();
                  this.parent.addInkEditorIfNeeded(true);
                  this.moveInDOM();
                  this.div.focus({
                    preventScroll: true
                  });
                }
                focusin(event) {
                  if (!this._focusEventsAllowed) {
                    return;
                  }
                  super.focusin(event);
                  this.enableEditMode();
                }
                canvasPointerdown(event) {
                  if (event.button !== 0 || !this.isInEditMode() || __privateGet(this, _disableEditing)) {
                    return;
                  }
                  this.setInForeground();
                  event.preventDefault();
                  if (event.type !== "mouse") {
                    this.div.focus();
                  }
                  __privateMethod(this, _startDrawing, startDrawing_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointermove(event) {
                  event.preventDefault();
                  __privateMethod(this, _draw, draw_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointerup(event) {
                  event.preventDefault();
                  __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                }
                canvasPointerleave(event) {
                  __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                }
                get isResizable() {
                  return !this.isEmpty() && __privateGet(this, _disableEditing);
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  _editor.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((msg) => {
                    var _a3;
                    return (_a3 = this.div) == null ? void 0 : _a3.setAttribute("aria-label", msg);
                  });
                  const [x3, y3, w3, h2] = __privateMethod(this, _getInitialBBox, getInitialBBox_fn).call(this);
                  this.setAt(x3, y3, 0, 0);
                  this.setDims(w3, h2);
                  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parentDimensions;
                    this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    __privateSet(this, _isCanvasInitialized, true);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                    this.setDims(this.width * parentWidth, this.height * parentHeight);
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                    this.div.classList.add("disabled");
                  } else {
                    this.div.classList.add("editing");
                    this.enableEditMode();
                  }
                  __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  return this.div;
                }
                setDimensions(width, height) {
                  const roundedWidth = Math.round(width);
                  const roundedHeight = Math.round(height);
                  if (__privateGet(this, _realWidth) === roundedWidth && __privateGet(this, _realHeight) === roundedHeight) {
                    return;
                  }
                  __privateSet(this, _realWidth, roundedWidth);
                  __privateSet(this, _realHeight, roundedHeight);
                  this.canvas.style.visibility = "hidden";
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  this.width = width / parentWidth;
                  this.height = height / parentHeight;
                  this.fixAndSetPosition();
                  if (__privateGet(this, _disableEditing)) {
                    __privateMethod(this, _setScaleFactor, setScaleFactor_fn).call(this, width, height);
                  }
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  this.canvas.style.visibility = "visible";
                  this.fixDims();
                }
                static deserialize(data, parent, uiManager) {
                  var _a3, _b2, _c2;
                  if (data instanceof _annotation_layer.InkAnnotationElement) {
                    return null;
                  }
                  const editor = super.deserialize(data, parent, uiManager);
                  editor.thickness = data.thickness;
                  editor.color = _util2.Util.makeHexColor(...data.color);
                  editor.opacity = data.opacity;
                  const [pageWidth, pageHeight] = editor.pageDimensions;
                  const width = editor.width * pageWidth;
                  const height = editor.height * pageHeight;
                  const scaleFactor = editor.parentScale;
                  const padding = data.thickness / 2;
                  __privateSet(editor, _disableEditing, true);
                  __privateSet(editor, _realWidth, Math.round(width));
                  __privateSet(editor, _realHeight, Math.round(height));
                  const {
                    paths,
                    rect,
                    rotation
                  } = data;
                  for (let {
                    bezier
                  } of paths) {
                    bezier = __privateMethod(_a3 = _InkEditor, _fromPDFCoordinates, fromPDFCoordinates_fn).call(_a3, bezier, rect, rotation);
                    const path = [];
                    editor.paths.push(path);
                    let p0 = scaleFactor * (bezier[0] - padding);
                    let p1 = scaleFactor * (bezier[1] - padding);
                    for (let i3 = 2, ii2 = bezier.length; i3 < ii2; i3 += 6) {
                      const p10 = scaleFactor * (bezier[i3] - padding);
                      const p11 = scaleFactor * (bezier[i3 + 1] - padding);
                      const p20 = scaleFactor * (bezier[i3 + 2] - padding);
                      const p21 = scaleFactor * (bezier[i3 + 3] - padding);
                      const p30 = scaleFactor * (bezier[i3 + 4] - padding);
                      const p31 = scaleFactor * (bezier[i3 + 5] - padding);
                      path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
                      p0 = p30;
                      p1 = p31;
                    }
                    const path2D = __privateMethod(this, _buildPath2D, buildPath2D_fn).call(this, path);
                    editor.bezierPath2D.push(path2D);
                  }
                  const bbox = __privateMethod(_b2 = editor, _getBbox, getBbox_fn).call(_b2);
                  __privateSet(editor, _baseWidth, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]));
                  __privateSet(editor, _baseHeight, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]));
                  __privateMethod(_c2 = editor, _setScaleFactor, setScaleFactor_fn).call(_c2, width, height);
                  return editor;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const rect = this.getRect(0, 0);
                  const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                  return {
                    annotationType: _util2.AnnotationEditorType.INK,
                    color,
                    thickness: this.thickness,
                    opacity: this.opacity,
                    paths: __privateMethod(this, _serializePaths, serializePaths_fn).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),
                    pageIndex: this.pageIndex,
                    rect,
                    rotation: this.rotation,
                    structTreeParentId: this._structTreeParentId
                  };
                }
              };
              _baseHeight = new WeakMap();
              _baseWidth = new WeakMap();
              _boundCanvasPointermove = new WeakMap();
              _boundCanvasPointerleave = new WeakMap();
              _boundCanvasPointerup = new WeakMap();
              _boundCanvasPointerdown = new WeakMap();
              _currentPath2D = new WeakMap();
              _disableEditing = new WeakMap();
              _hasSomethingToDraw = new WeakMap();
              _isCanvasInitialized = new WeakMap();
              _observer = new WeakMap();
              _realWidth = new WeakMap();
              _realHeight = new WeakMap();
              _requestFrameCallback = new WeakMap();
              _updateThickness = new WeakSet();
              updateThickness_fn = function(thickness) {
                const savedThickness = this.thickness;
                this.addCommands({
                  cmd: () => {
                    this.thickness = thickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  undo: () => {
                    this.thickness = savedThickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_THICKNESS,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color) {
                const savedColor = this.color;
                this.addCommands({
                  cmd: () => {
                    this.color = color;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.color = savedColor;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateOpacity = new WeakSet();
              updateOpacity_fn = function(opacity) {
                opacity /= 100;
                const savedOpacity = this.opacity;
                this.addCommands({
                  cmd: () => {
                    this.opacity = opacity;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.opacity = savedOpacity;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_OPACITY,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _getInitialBBox = new WeakSet();
              getInitialBBox_fn = function() {
                const {
                  parentRotation,
                  parentDimensions: [width, height]
                } = this;
                switch (parentRotation) {
                  case 90:
                    return [0, height, height, width];
                  case 180:
                    return [width, height, width, height];
                  case 270:
                    return [width, 0, height, width];
                  default:
                    return [0, 0, width, height];
                }
              };
              _setStroke = new WeakSet();
              setStroke_fn = function() {
                const {
                  ctx,
                  color,
                  opacity,
                  thickness,
                  parentScale,
                  scaleFactor
                } = this;
                ctx.lineWidth = thickness * parentScale / scaleFactor;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.miterLimit = 10;
                ctx.strokeStyle = `${color}${(0, _tools.opacityToHex)(opacity)}`;
              };
              _startDrawing = new WeakSet();
              startDrawing_fn = function(x3, y3) {
                this.canvas.addEventListener("contextmenu", _display_utils2.noContextMenu);
                this.canvas.addEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                this.canvas.addEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                this.canvas.addEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                this.isEditing = true;
                if (!__privateGet(this, _isCanvasInitialized)) {
                  __privateSet(this, _isCanvasInitialized, true);
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  this.thickness || (this.thickness = _InkEditor._defaultThickness);
                  this.color || (this.color = _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  this.opacity ?? (this.opacity = _InkEditor._defaultOpacity);
                }
                this.currentPath.push([x3, y3]);
                __privateSet(this, _hasSomethingToDraw, false);
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                __privateSet(this, _requestFrameCallback, () => {
                  __privateMethod(this, _drawPoints, drawPoints_fn).call(this);
                  if (__privateGet(this, _requestFrameCallback)) {
                    window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
                  }
                });
                window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
              };
              _draw = new WeakSet();
              draw_fn = function(x3, y3) {
                const [lastX, lastY] = this.currentPath.at(-1);
                if (this.currentPath.length > 1 && x3 === lastX && y3 === lastY) {
                  return;
                }
                const currentPath = this.currentPath;
                let path2D = __privateGet(this, _currentPath2D);
                currentPath.push([x3, y3]);
                __privateSet(this, _hasSomethingToDraw, true);
                if (currentPath.length <= 2) {
                  path2D.moveTo(...currentPath[0]);
                  path2D.lineTo(x3, y3);
                  return;
                }
                if (currentPath.length === 3) {
                  __privateSet(this, _currentPath2D, path2D = new Path2D());
                  path2D.moveTo(...currentPath[0]);
                }
                __privateMethod(this, _makeBezierCurve, makeBezierCurve_fn).call(this, path2D, ...currentPath.at(-3), ...currentPath.at(-2), x3, y3);
              };
              _endPath = new WeakSet();
              endPath_fn = function() {
                if (this.currentPath.length === 0) {
                  return;
                }
                const lastPoint = this.currentPath.at(-1);
                __privateGet(this, _currentPath2D).lineTo(...lastPoint);
              };
              _stopDrawing = new WeakSet();
              stopDrawing_fn = function(x3, y3) {
                __privateSet(this, _requestFrameCallback, null);
                x3 = Math.min(Math.max(x3, 0), this.canvas.width);
                y3 = Math.min(Math.max(y3, 0), this.canvas.height);
                __privateMethod(this, _draw, draw_fn).call(this, x3, y3);
                __privateMethod(this, _endPath, endPath_fn).call(this);
                let bezier;
                if (this.currentPath.length !== 1) {
                  bezier = __privateMethod(this, _generateBezierPoints, generateBezierPoints_fn).call(this);
                } else {
                  const xy = [x3, y3];
                  bezier = [[xy, xy.slice(), xy.slice(), xy]];
                }
                const path2D = __privateGet(this, _currentPath2D);
                const currentPath = this.currentPath;
                this.currentPath = [];
                __privateSet(this, _currentPath2D, new Path2D());
                const cmd = () => {
                  this.allRawPaths.push(currentPath);
                  this.paths.push(bezier);
                  this.bezierPath2D.push(path2D);
                  this.rebuild();
                };
                const undo = () => {
                  this.allRawPaths.pop();
                  this.paths.pop();
                  this.bezierPath2D.pop();
                  if (this.paths.length === 0) {
                    this.remove();
                  } else {
                    if (!this.canvas) {
                      __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                      __privateMethod(this, _createObserver, createObserver_fn).call(this);
                    }
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  }
                };
                this.addCommands({
                  cmd,
                  undo,
                  mustExec: true
                });
              };
              _drawPoints = new WeakSet();
              drawPoints_fn = function() {
                if (!__privateGet(this, _hasSomethingToDraw)) {
                  return;
                }
                __privateSet(this, _hasSomethingToDraw, false);
                const thickness = Math.ceil(this.thickness * this.parentScale);
                const lastPoints = this.currentPath.slice(-3);
                const x3 = lastPoints.map((xy) => xy[0]);
                const y3 = lastPoints.map((xy) => xy[1]);
                const xMin = Math.min(...x3) - thickness;
                const xMax = Math.max(...x3) + thickness;
                const yMin = Math.min(...y3) - thickness;
                const yMax = Math.max(...y3) + thickness;
                const {
                  ctx
                } = this;
                ctx.save();
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                for (const path of this.bezierPath2D) {
                  ctx.stroke(path);
                }
                ctx.stroke(__privateGet(this, _currentPath2D));
                ctx.restore();
              };
              _makeBezierCurve = new WeakSet();
              makeBezierCurve_fn = function(path2D, x0, y0, x1, y1, x22, y22) {
                const prevX = (x0 + x1) / 2;
                const prevY = (y0 + y1) / 2;
                const x3 = (x1 + x22) / 2;
                const y3 = (y1 + y22) / 2;
                path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);
              };
              _generateBezierPoints = new WeakSet();
              generateBezierPoints_fn = function() {
                const path = this.currentPath;
                if (path.length <= 2) {
                  return [[path[0], path[0], path.at(-1), path.at(-1)]];
                }
                const bezierPoints = [];
                let i3;
                let [x0, y0] = path[0];
                for (i3 = 1; i3 < path.length - 2; i3++) {
                  const [x12, y12] = path[i3];
                  const [x23, y23] = path[i3 + 1];
                  const x3 = (x12 + x23) / 2;
                  const y3 = (y12 + y23) / 2;
                  const control12 = [x0 + 2 * (x12 - x0) / 3, y0 + 2 * (y12 - y0) / 3];
                  const control22 = [x3 + 2 * (x12 - x3) / 3, y3 + 2 * (y12 - y3) / 3];
                  bezierPoints.push([[x0, y0], control12, control22, [x3, y3]]);
                  [x0, y0] = [x3, y3];
                }
                const [x1, y1] = path[i3];
                const [x22, y22] = path[i3 + 1];
                const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
                const control2 = [x22 + 2 * (x1 - x22) / 3, y22 + 2 * (y1 - y22) / 3];
                bezierPoints.push([[x0, y0], control1, control2, [x22, y22]]);
                return bezierPoints;
              };
              _redraw = new WeakSet();
              redraw_fn = function() {
                if (this.isEmpty()) {
                  __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                  return;
                }
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                const {
                  canvas,
                  ctx
                } = this;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                for (const path of this.bezierPath2D) {
                  ctx.stroke(path);
                }
              };
              _endDrawing = new WeakSet();
              endDrawing_fn = function(event) {
                this.canvas.removeEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                this.canvas.removeEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                this.canvas.removeEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                setTimeout(() => {
                  this.canvas.removeEventListener("contextmenu", _display_utils2.noContextMenu);
                }, 10);
                __privateMethod(this, _stopDrawing, stopDrawing_fn).call(this, event.offsetX, event.offsetY);
                this.addToAnnotationStorage();
                this.setInBackground();
              };
              _createCanvas = new WeakSet();
              createCanvas_fn = function() {
                this.canvas = document.createElement("canvas");
                this.canvas.width = this.canvas.height = 0;
                this.canvas.className = "inkEditorCanvas";
                _editor.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((msg) => {
                  var _a3;
                  return (_a3 = this.canvas) == null ? void 0 : _a3.setAttribute("aria-label", msg);
                });
                this.div.append(this.canvas);
                this.ctx = this.canvas.getContext("2d");
              };
              _createObserver = new WeakSet();
              createObserver_fn = function() {
                __privateSet(this, _observer, new ResizeObserver((entries) => {
                  const rect = entries[0].contentRect;
                  if (rect.width && rect.height) {
                    this.setDimensions(rect.width, rect.height);
                  }
                }));
                __privateGet(this, _observer).observe(this.div);
              };
              _setCanvasDims = new WeakSet();
              setCanvasDims_fn = function() {
                if (!__privateGet(this, _isCanvasInitialized)) {
                  return;
                }
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.canvas.width = Math.ceil(this.width * parentWidth);
                this.canvas.height = Math.ceil(this.height * parentHeight);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
              };
              _setScaleFactor = new WeakSet();
              setScaleFactor_fn = function(width, height) {
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                const scaleFactorW = (width - padding) / __privateGet(this, _baseWidth);
                const scaleFactorH = (height - padding) / __privateGet(this, _baseHeight);
                this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
              };
              _updateTransform = new WeakSet();
              updateTransform_fn = function() {
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this) / 2;
                this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
              };
              _buildPath2D = new WeakSet();
              buildPath2D_fn = function(bezier) {
                const path2D = new Path2D();
                for (let i3 = 0, ii2 = bezier.length; i3 < ii2; i3++) {
                  const [first, control1, control2, second] = bezier[i3];
                  if (i3 === 0) {
                    path2D.moveTo(...first);
                  }
                  path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
                }
                return path2D;
              };
              _toPDFCoordinates = new WeakSet();
              toPDFCoordinates_fn = function(points, rect, rotation) {
                const [blX, blY, trX, trY] = rect;
                switch (rotation) {
                  case 0:
                    for (let i3 = 0, ii2 = points.length; i3 < ii2; i3 += 2) {
                      points[i3] += blX;
                      points[i3 + 1] = trY - points[i3 + 1];
                    }
                    break;
                  case 90:
                    for (let i3 = 0, ii2 = points.length; i3 < ii2; i3 += 2) {
                      const x3 = points[i3];
                      points[i3] = points[i3 + 1] + blX;
                      points[i3 + 1] = x3 + blY;
                    }
                    break;
                  case 180:
                    for (let i3 = 0, ii2 = points.length; i3 < ii2; i3 += 2) {
                      points[i3] = trX - points[i3];
                      points[i3 + 1] += blY;
                    }
                    break;
                  case 270:
                    for (let i3 = 0, ii2 = points.length; i3 < ii2; i3 += 2) {
                      const x3 = points[i3];
                      points[i3] = trX - points[i3 + 1];
                      points[i3 + 1] = trY - x3;
                    }
                    break;
                  default:
                    throw new Error("Invalid rotation");
                }
                return points;
              };
              _fromPDFCoordinates = new WeakSet();
              fromPDFCoordinates_fn = function(points, rect, rotation) {
                const [blX, blY, trX, trY] = rect;
                switch (rotation) {
                  case 0:
                    for (let i3 = 0, ii2 = points.length; i3 < ii2; i3 += 2) {
                      points[i3] -= blX;
                      points[i3 + 1] = trY - points[i3 + 1];
                    }
                    break;
                  case 90:
                    for (let i3 = 0, ii2 = points.length; i3 < ii2; i3 += 2) {
                      const x3 = points[i3];
                      points[i3] = points[i3 + 1] - blY;
                      points[i3 + 1] = x3 - blX;
                    }
                    break;
                  case 180:
                    for (let i3 = 0, ii2 = points.length; i3 < ii2; i3 += 2) {
                      points[i3] = trX - points[i3];
                      points[i3 + 1] -= blY;
                    }
                    break;
                  case 270:
                    for (let i3 = 0, ii2 = points.length; i3 < ii2; i3 += 2) {
                      const x3 = points[i3];
                      points[i3] = trY - points[i3 + 1];
                      points[i3 + 1] = trX - x3;
                    }
                    break;
                  default:
                    throw new Error("Invalid rotation");
                }
                return points;
              };
              _serializePaths = new WeakSet();
              serializePaths_fn = function(s3, tx, ty, rect) {
                var _a3, _b2;
                const paths = [];
                const padding = this.thickness / 2;
                const shiftX = s3 * tx + padding;
                const shiftY = s3 * ty + padding;
                for (const bezier of this.paths) {
                  const buffer = [];
                  const points = [];
                  for (let j3 = 0, jj = bezier.length; j3 < jj; j3++) {
                    const [first, control1, control2, second] = bezier[j3];
                    const p10 = s3 * first[0] + shiftX;
                    const p11 = s3 * first[1] + shiftY;
                    const p20 = s3 * control1[0] + shiftX;
                    const p21 = s3 * control1[1] + shiftY;
                    const p30 = s3 * control2[0] + shiftX;
                    const p31 = s3 * control2[1] + shiftY;
                    const p40 = s3 * second[0] + shiftX;
                    const p41 = s3 * second[1] + shiftY;
                    if (j3 === 0) {
                      buffer.push(p10, p11);
                      points.push(p10, p11);
                    }
                    buffer.push(p20, p21, p30, p31, p40, p41);
                    points.push(p20, p21);
                    if (j3 === jj - 1) {
                      points.push(p40, p41);
                    }
                  }
                  paths.push({
                    bezier: __privateMethod(_a3 = _InkEditor, _toPDFCoordinates, toPDFCoordinates_fn).call(_a3, buffer, rect, this.rotation),
                    points: __privateMethod(_b2 = _InkEditor, _toPDFCoordinates, toPDFCoordinates_fn).call(_b2, points, rect, this.rotation)
                  });
                }
                return paths;
              };
              _getBbox = new WeakSet();
              getBbox_fn = function() {
                let xMin = Infinity;
                let xMax = -Infinity;
                let yMin = Infinity;
                let yMax = -Infinity;
                for (const path of this.paths) {
                  for (const [first, control1, control2, second] of path) {
                    const bbox = _util2.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
                    xMin = Math.min(xMin, bbox[0]);
                    yMin = Math.min(yMin, bbox[1]);
                    xMax = Math.max(xMax, bbox[2]);
                    yMax = Math.max(yMax, bbox[3]);
                  }
                }
                return [xMin, yMin, xMax, yMax];
              };
              _getPadding = new WeakSet();
              getPadding_fn = function() {
                return __privateGet(this, _disableEditing) ? Math.ceil(this.thickness * this.parentScale) : 0;
              };
              _fitToContent = new WeakSet();
              fitToContent_fn = function(firstTime = false) {
                if (this.isEmpty()) {
                  return;
                }
                if (!__privateGet(this, _disableEditing)) {
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  return;
                }
                const bbox = __privateMethod(this, _getBbox, getBbox_fn).call(this);
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                __privateSet(this, _baseWidth, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]));
                __privateSet(this, _baseHeight, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]));
                const width = Math.ceil(padding + __privateGet(this, _baseWidth) * this.scaleFactor);
                const height = Math.ceil(padding + __privateGet(this, _baseHeight) * this.scaleFactor);
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.width = width / parentWidth;
                this.height = height / parentHeight;
                this.setAspectRatio(width, height);
                const prevTranslationX = this.translationX;
                const prevTranslationY = this.translationY;
                this.translationX = -bbox[0];
                this.translationY = -bbox[1];
                __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                __privateMethod(this, _redraw, redraw_fn).call(this);
                __privateSet(this, _realWidth, width);
                __privateSet(this, _realHeight, height);
                this.setDims(width, height);
                const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
                this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
              };
              __privateAdd(_InkEditor, _buildPath2D);
              __privateAdd(_InkEditor, _toPDFCoordinates);
              __privateAdd(_InkEditor, _fromPDFCoordinates);
              __publicField(_InkEditor, "_defaultColor", null);
              __publicField(_InkEditor, "_defaultOpacity", 1);
              __publicField(_InkEditor, "_defaultThickness", 1);
              __publicField(_InkEditor, "_type", "ink");
              let InkEditor = _InkEditor;
              exports2.InkEditor = InkEditor;
            },
            /* 34 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _bitmap, _bitmapId, _bitmapPromise, _bitmapUrl, _bitmapFile, _canvas2, _observer, _resizeTimeoutId, _isSvg, _hasBeenAddedInUndoStack, _getBitmapFetched, getBitmapFetched_fn, _getBitmapDone, getBitmapDone_fn, _getBitmap, getBitmap_fn, _createCanvas, createCanvas_fn, _setDimensions, setDimensions_fn, _scaleBitmap, scaleBitmap_fn, _drawBitmap, drawBitmap_fn, _serializeBitmap, serializeBitmap_fn, _createObserver, createObserver_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StampEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(4);
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _annotation_layer = __w_pdfjs_require__2(29);
              const _StampEditor = class _StampEditor extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "stampEditor"
                  });
                  __privateAdd(this, _getBitmapFetched);
                  __privateAdd(this, _getBitmapDone);
                  __privateAdd(this, _getBitmap);
                  __privateAdd(this, _createCanvas);
                  __privateAdd(this, _setDimensions);
                  __privateAdd(this, _scaleBitmap);
                  __privateAdd(this, _drawBitmap);
                  __privateAdd(this, _serializeBitmap);
                  __privateAdd(this, _createObserver);
                  __privateAdd(this, _bitmap, null);
                  __privateAdd(this, _bitmapId, null);
                  __privateAdd(this, _bitmapPromise, null);
                  __privateAdd(this, _bitmapUrl, null);
                  __privateAdd(this, _bitmapFile, null);
                  __privateAdd(this, _canvas2, null);
                  __privateAdd(this, _observer, null);
                  __privateAdd(this, _resizeTimeoutId, null);
                  __privateAdd(this, _isSvg, false);
                  __privateAdd(this, _hasBeenAddedInUndoStack, false);
                  __privateSet(this, _bitmapUrl, params.bitmapUrl);
                  __privateSet(this, _bitmapFile, params.bitmapFile);
                }
                static initialize(l10n) {
                  _editor.AnnotationEditor.initialize(l10n);
                }
                static get supportedTypes() {
                  const types = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
                  return (0, _util2.shadow)(this, "supportedTypes", types.map((type) => `image/${type}`));
                }
                static get supportedTypesStr() {
                  return (0, _util2.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
                }
                static isHandlingMimeForPasting(mime) {
                  return this.supportedTypes.includes(mime);
                }
                static paste(item, parent) {
                  parent.pasteEditor(_util2.AnnotationEditorType.STAMP, {
                    bitmapFile: item.getAsFile()
                  });
                }
                remove() {
                  var _a3, _b2;
                  if (__privateGet(this, _bitmapId)) {
                    __privateSet(this, _bitmap, null);
                    this._uiManager.imageManager.deleteId(__privateGet(this, _bitmapId));
                    (_a3 = __privateGet(this, _canvas2)) == null ? void 0 : _a3.remove();
                    __privateSet(this, _canvas2, null);
                    (_b2 = __privateGet(this, _observer)) == null ? void 0 : _b2.disconnect();
                    __privateSet(this, _observer, null);
                  }
                  super.remove();
                }
                rebuild() {
                  if (!this.parent) {
                    if (__privateGet(this, _bitmapId)) {
                      __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
                    }
                    return;
                  }
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (__privateGet(this, _bitmapId)) {
                    __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                  }
                }
                onceAdded() {
                  this._isDraggable = true;
                  this.div.focus();
                }
                isEmpty() {
                  return !(__privateGet(this, _bitmapPromise) || __privateGet(this, _bitmap) || __privateGet(this, _bitmapUrl) || __privateGet(this, _bitmapFile));
                }
                get isResizable() {
                  return true;
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  this.div.hidden = true;
                  if (__privateGet(this, _bitmap)) {
                    __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                  } else {
                    __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
                  }
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parentDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                  }
                  return this.div;
                }
                static deserialize(data, parent, uiManager) {
                  if (data instanceof _annotation_layer.StampAnnotationElement) {
                    return null;
                  }
                  const editor = super.deserialize(data, parent, uiManager);
                  const {
                    rect,
                    bitmapUrl,
                    bitmapId,
                    isSvg,
                    accessibilityData
                  } = data;
                  if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
                    __privateSet(editor, _bitmapId, bitmapId);
                  } else {
                    __privateSet(editor, _bitmapUrl, bitmapUrl);
                  }
                  __privateSet(editor, _isSvg, isSvg);
                  const [parentWidth, parentHeight] = editor.pageDimensions;
                  editor.width = (rect[2] - rect[0]) / parentWidth;
                  editor.height = (rect[3] - rect[1]) / parentHeight;
                  if (accessibilityData) {
                    editor.altTextData = accessibilityData;
                  }
                  return editor;
                }
                serialize(isForCopying = false, context = null) {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const serialized = {
                    annotationType: _util2.AnnotationEditorType.STAMP,
                    bitmapId: __privateGet(this, _bitmapId),
                    pageIndex: this.pageIndex,
                    rect: this.getRect(0, 0),
                    rotation: this.rotation,
                    isSvg: __privateGet(this, _isSvg),
                    structTreeParentId: this._structTreeParentId
                  };
                  if (isForCopying) {
                    serialized.bitmapUrl = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, true);
                    serialized.accessibilityData = this.altTextData;
                    return serialized;
                  }
                  const {
                    decorative,
                    altText
                  } = this.altTextData;
                  if (!decorative && altText) {
                    serialized.accessibilityData = {
                      type: "Figure",
                      alt: altText
                    };
                  }
                  if (context === null) {
                    return serialized;
                  }
                  context.stamps || (context.stamps = /* @__PURE__ */ new Map());
                  const area = __privateGet(this, _isSvg) ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
                  if (!context.stamps.has(__privateGet(this, _bitmapId))) {
                    context.stamps.set(__privateGet(this, _bitmapId), {
                      area,
                      serialized
                    });
                    serialized.bitmap = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, false);
                  } else if (__privateGet(this, _isSvg)) {
                    const prevData = context.stamps.get(__privateGet(this, _bitmapId));
                    if (area > prevData.area) {
                      prevData.area = area;
                      prevData.serialized.bitmap.close();
                      prevData.serialized.bitmap = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, false);
                    }
                  }
                  return serialized;
                }
              };
              _bitmap = new WeakMap();
              _bitmapId = new WeakMap();
              _bitmapPromise = new WeakMap();
              _bitmapUrl = new WeakMap();
              _bitmapFile = new WeakMap();
              _canvas2 = new WeakMap();
              _observer = new WeakMap();
              _resizeTimeoutId = new WeakMap();
              _isSvg = new WeakMap();
              _hasBeenAddedInUndoStack = new WeakMap();
              _getBitmapFetched = new WeakSet();
              getBitmapFetched_fn = function(data, fromId = false) {
                if (!data) {
                  this.remove();
                  return;
                }
                __privateSet(this, _bitmap, data.bitmap);
                if (!fromId) {
                  __privateSet(this, _bitmapId, data.id);
                  __privateSet(this, _isSvg, data.isSvg);
                }
                __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
              };
              _getBitmapDone = new WeakSet();
              getBitmapDone_fn = function() {
                __privateSet(this, _bitmapPromise, null);
                this._uiManager.enableWaiting(false);
                if (__privateGet(this, _canvas2)) {
                  this.div.focus();
                }
              };
              _getBitmap = new WeakSet();
              getBitmap_fn = function() {
                if (__privateGet(this, _bitmapId)) {
                  this._uiManager.enableWaiting(true);
                  this._uiManager.imageManager.getFromId(__privateGet(this, _bitmapId)).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data, true)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this));
                  return;
                }
                if (__privateGet(this, _bitmapUrl)) {
                  const url = __privateGet(this, _bitmapUrl);
                  __privateSet(this, _bitmapUrl, null);
                  this._uiManager.enableWaiting(true);
                  __privateSet(this, _bitmapPromise, this._uiManager.imageManager.getFromUrl(url).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
                  return;
                }
                if (__privateGet(this, _bitmapFile)) {
                  const file = __privateGet(this, _bitmapFile);
                  __privateSet(this, _bitmapFile, null);
                  this._uiManager.enableWaiting(true);
                  __privateSet(this, _bitmapPromise, this._uiManager.imageManager.getFromFile(file).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
                  return;
                }
                const input = document.createElement("input");
                input.type = "file";
                input.accept = _StampEditor.supportedTypesStr;
                __privateSet(this, _bitmapPromise, new Promise((resolve) => {
                  input.addEventListener("change", async () => {
                    if (!input.files || input.files.length === 0) {
                      this.remove();
                    } else {
                      this._uiManager.enableWaiting(true);
                      const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
                      __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data);
                    }
                    resolve();
                  });
                  input.addEventListener("cancel", () => {
                    this.remove();
                    resolve();
                  });
                }).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
                input.click();
              };
              _createCanvas = new WeakSet();
              createCanvas_fn = function() {
                const {
                  div
                } = this;
                let {
                  width,
                  height
                } = __privateGet(this, _bitmap);
                const [pageWidth, pageHeight] = this.pageDimensions;
                const MAX_RATIO = 0.75;
                if (this.width) {
                  width = this.width * pageWidth;
                  height = this.height * pageHeight;
                } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
                  const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
                  width *= factor;
                  height *= factor;
                }
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
                this._uiManager.enableWaiting(false);
                const canvas = __privateSet(this, _canvas2, document.createElement("canvas"));
                div.append(canvas);
                div.hidden = false;
                __privateMethod(this, _drawBitmap, drawBitmap_fn).call(this, width, height);
                __privateMethod(this, _createObserver, createObserver_fn).call(this);
                if (!__privateGet(this, _hasBeenAddedInUndoStack)) {
                  this.parent.addUndoableEditor(this);
                  __privateSet(this, _hasBeenAddedInUndoStack, true);
                }
                this._uiManager._eventBus.dispatch("reporttelemetry", {
                  source: this,
                  details: {
                    type: "editing",
                    subtype: this.editorType,
                    data: {
                      action: "inserted_image"
                    }
                  }
                });
                this.addAltTextButton();
              };
              _setDimensions = new WeakSet();
              setDimensions_fn = function(width, height) {
                var _a3;
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.width = width / parentWidth;
                this.height = height / parentHeight;
                this.setDims(width, height);
                if ((_a3 = this._initialOptions) == null ? void 0 : _a3.isCentered) {
                  this.center();
                } else {
                  this.fixAndSetPosition();
                }
                this._initialOptions = null;
                if (__privateGet(this, _resizeTimeoutId) !== null) {
                  clearTimeout(__privateGet(this, _resizeTimeoutId));
                }
                const TIME_TO_WAIT = 200;
                __privateSet(this, _resizeTimeoutId, setTimeout(() => {
                  __privateSet(this, _resizeTimeoutId, null);
                  __privateMethod(this, _drawBitmap, drawBitmap_fn).call(this, width, height);
                }, TIME_TO_WAIT));
              };
              _scaleBitmap = new WeakSet();
              scaleBitmap_fn = function(width, height) {
                const {
                  width: bitmapWidth,
                  height: bitmapHeight
                } = __privateGet(this, _bitmap);
                let newWidth = bitmapWidth;
                let newHeight = bitmapHeight;
                let bitmap = __privateGet(this, _bitmap);
                while (newWidth > 2 * width || newHeight > 2 * height) {
                  const prevWidth = newWidth;
                  const prevHeight = newHeight;
                  if (newWidth > 2 * width) {
                    newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
                  }
                  if (newHeight > 2 * height) {
                    newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
                  }
                  const offscreen = new OffscreenCanvas(newWidth, newHeight);
                  const ctx = offscreen.getContext("2d");
                  ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
                  bitmap = offscreen.transferToImageBitmap();
                }
                return bitmap;
              };
              _drawBitmap = new WeakSet();
              drawBitmap_fn = function(width, height) {
                width = Math.ceil(width);
                height = Math.ceil(height);
                const canvas = __privateGet(this, _canvas2);
                if (!canvas || canvas.width === width && canvas.height === height) {
                  return;
                }
                canvas.width = width;
                canvas.height = height;
                const bitmap = __privateGet(this, _isSvg) ? __privateGet(this, _bitmap) : __privateMethod(this, _scaleBitmap, scaleBitmap_fn).call(this, width, height);
                const ctx = canvas.getContext("2d");
                ctx.filter = this._uiManager.hcmFilter;
                ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);
              };
              _serializeBitmap = new WeakSet();
              serializeBitmap_fn = function(toUrl) {
                if (toUrl) {
                  if (__privateGet(this, _isSvg)) {
                    const url = this._uiManager.imageManager.getSvgUrl(__privateGet(this, _bitmapId));
                    if (url) {
                      return url;
                    }
                  }
                  const canvas = document.createElement("canvas");
                  ({
                    width: canvas.width,
                    height: canvas.height
                  } = __privateGet(this, _bitmap));
                  const ctx = canvas.getContext("2d");
                  ctx.drawImage(__privateGet(this, _bitmap), 0, 0);
                  return canvas.toDataURL();
                }
                if (__privateGet(this, _isSvg)) {
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  const width = Math.round(this.width * pageWidth * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                  const height = Math.round(this.height * pageHeight * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                  const offscreen = new OffscreenCanvas(width, height);
                  const ctx = offscreen.getContext("2d");
                  ctx.drawImage(__privateGet(this, _bitmap), 0, 0, __privateGet(this, _bitmap).width, __privateGet(this, _bitmap).height, 0, 0, width, height);
                  return offscreen.transferToImageBitmap();
                }
                return structuredClone(__privateGet(this, _bitmap));
              };
              _createObserver = new WeakSet();
              createObserver_fn = function() {
                __privateSet(this, _observer, new ResizeObserver((entries) => {
                  const rect = entries[0].contentRect;
                  if (rect.width && rect.height) {
                    __privateMethod(this, _setDimensions, setDimensions_fn).call(this, rect.width, rect.height);
                  }
                }));
                __privateGet(this, _observer).observe(this.div);
              };
              __publicField(_StampEditor, "_type", "stamp");
              let StampEditor = _StampEditor;
              exports2.StampEditor = StampEditor;
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          var __webpack_exports__ = {};
          (() => {
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "AbortException", {
              enumerable: true,
              get: function() {
                return _util2.AbortException;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorLayer", {
              enumerable: true,
              get: function() {
                return _annotation_editor_layer.AnnotationEditorLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorParamsType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorParamsType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorUIManager", {
              enumerable: true,
              get: function() {
                return _tools.AnnotationEditorUIManager;
              }
            });
            Object.defineProperty(exports2, "AnnotationLayer", {
              enumerable: true,
              get: function() {
                return _annotation_layer.AnnotationLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationMode", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationMode;
              }
            });
            Object.defineProperty(exports2, "CMapCompressionType", {
              enumerable: true,
              get: function() {
                return _util2.CMapCompressionType;
              }
            });
            Object.defineProperty(exports2, "DOMSVGFactory", {
              enumerable: true,
              get: function() {
                return _display_utils2.DOMSVGFactory;
              }
            });
            Object.defineProperty(exports2, "FeatureTest", {
              enumerable: true,
              get: function() {
                return _util2.FeatureTest;
              }
            });
            Object.defineProperty(exports2, "GlobalWorkerOptions", {
              enumerable: true,
              get: function() {
                return _worker_options2.GlobalWorkerOptions;
              }
            });
            Object.defineProperty(exports2, "ImageKind", {
              enumerable: true,
              get: function() {
                return _util2.ImageKind;
              }
            });
            Object.defineProperty(exports2, "InvalidPDFException", {
              enumerable: true,
              get: function() {
                return _util2.InvalidPDFException;
              }
            });
            Object.defineProperty(exports2, "MissingPDFException", {
              enumerable: true,
              get: function() {
                return _util2.MissingPDFException;
              }
            });
            Object.defineProperty(exports2, "OPS", {
              enumerable: true,
              get: function() {
                return _util2.OPS;
              }
            });
            Object.defineProperty(exports2, "PDFDataRangeTransport", {
              enumerable: true,
              get: function() {
                return _api.PDFDataRangeTransport;
              }
            });
            Object.defineProperty(exports2, "PDFDateString", {
              enumerable: true,
              get: function() {
                return _display_utils2.PDFDateString;
              }
            });
            Object.defineProperty(exports2, "PDFWorker", {
              enumerable: true,
              get: function() {
                return _api.PDFWorker;
              }
            });
            Object.defineProperty(exports2, "PasswordResponses", {
              enumerable: true,
              get: function() {
                return _util2.PasswordResponses;
              }
            });
            Object.defineProperty(exports2, "PermissionFlag", {
              enumerable: true,
              get: function() {
                return _util2.PermissionFlag;
              }
            });
            Object.defineProperty(exports2, "PixelsPerInch", {
              enumerable: true,
              get: function() {
                return _display_utils2.PixelsPerInch;
              }
            });
            Object.defineProperty(exports2, "PromiseCapability", {
              enumerable: true,
              get: function() {
                return _util2.PromiseCapability;
              }
            });
            Object.defineProperty(exports2, "RenderingCancelledException", {
              enumerable: true,
              get: function() {
                return _display_utils2.RenderingCancelledException;
              }
            });
            Object.defineProperty(exports2, "SVGGraphics", {
              enumerable: true,
              get: function() {
                return _api.SVGGraphics;
              }
            });
            Object.defineProperty(exports2, "UnexpectedResponseException", {
              enumerable: true,
              get: function() {
                return _util2.UnexpectedResponseException;
              }
            });
            Object.defineProperty(exports2, "Util", {
              enumerable: true,
              get: function() {
                return _util2.Util;
              }
            });
            Object.defineProperty(exports2, "VerbosityLevel", {
              enumerable: true,
              get: function() {
                return _util2.VerbosityLevel;
              }
            });
            Object.defineProperty(exports2, "XfaLayer", {
              enumerable: true,
              get: function() {
                return _xfa_layer.XfaLayer;
              }
            });
            Object.defineProperty(exports2, "build", {
              enumerable: true,
              get: function() {
                return _api.build;
              }
            });
            Object.defineProperty(exports2, "createValidAbsoluteUrl", {
              enumerable: true,
              get: function() {
                return _util2.createValidAbsoluteUrl;
              }
            });
            Object.defineProperty(exports2, "getDocument", {
              enumerable: true,
              get: function() {
                return _api.getDocument;
              }
            });
            Object.defineProperty(exports2, "getFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getPdfFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getXfaPageViewport", {
              enumerable: true,
              get: function() {
                return _display_utils2.getXfaPageViewport;
              }
            });
            Object.defineProperty(exports2, "isDataScheme", {
              enumerable: true,
              get: function() {
                return _display_utils2.isDataScheme;
              }
            });
            Object.defineProperty(exports2, "isPdfFile", {
              enumerable: true,
              get: function() {
                return _display_utils2.isPdfFile;
              }
            });
            Object.defineProperty(exports2, "loadScript", {
              enumerable: true,
              get: function() {
                return _display_utils2.loadScript;
              }
            });
            Object.defineProperty(exports2, "noContextMenu", {
              enumerable: true,
              get: function() {
                return _display_utils2.noContextMenu;
              }
            });
            Object.defineProperty(exports2, "normalizeUnicode", {
              enumerable: true,
              get: function() {
                return _util2.normalizeUnicode;
              }
            });
            Object.defineProperty(exports2, "renderTextLayer", {
              enumerable: true,
              get: function() {
                return _text_layer.renderTextLayer;
              }
            });
            Object.defineProperty(exports2, "setLayerDimensions", {
              enumerable: true,
              get: function() {
                return _display_utils2.setLayerDimensions;
              }
            });
            Object.defineProperty(exports2, "shadow", {
              enumerable: true,
              get: function() {
                return _util2.shadow;
              }
            });
            Object.defineProperty(exports2, "updateTextLayer", {
              enumerable: true,
              get: function() {
                return _text_layer.updateTextLayer;
              }
            });
            Object.defineProperty(exports2, "version", {
              enumerable: true,
              get: function() {
                return _api.version;
              }
            });
            var _util2 = __w_pdfjs_require__(1);
            var _api = __w_pdfjs_require__(2);
            var _display_utils2 = __w_pdfjs_require__(6);
            var _text_layer = __w_pdfjs_require__(26);
            var _annotation_editor_layer = __w_pdfjs_require__(27);
            var _tools = __w_pdfjs_require__(5);
            var _annotation_layer = __w_pdfjs_require__(29);
            var _worker_options2 = __w_pdfjs_require__(14);
            var _xfa_layer = __w_pdfjs_require__(32);
            const pdfjsVersion = "3.11.174";
            const pdfjsBuild = "ce8716743";
          })();
          return __webpack_exports__;
        })()
      );
    });
  }
});

// node_modules/react-pdf/dist/cjs/pdfjs.js
var require_pdfjs = __commonJS({
  "node_modules/react-pdf/dist/cjs/pdfjs.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m3, k3);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k3];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var pdfjsModule = __importStar(require_pdf());
    var pdfjs = "default" in pdfjsModule ? pdfjsModule["default"] : pdfjsModule;
    exports2.default = pdfjs;
  }
});

// node_modules/make-event-props/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/make-event-props/dist/cjs/index.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i3 = 0, l3 = from.length, ar2; i3 < l3; i3++) {
          if (ar2 || !(i3 in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i3);
            ar2[i3] = from[i3];
          }
        }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.allEvents = exports2.changeEvents = exports2.otherEvents = exports2.transitionEvents = exports2.animationEvents = exports2.wheelEvents = exports2.uiEvents = exports2.pointerEvents = exports2.touchEvents = exports2.selectionEvents = exports2.dragEvents = exports2.mouseEvents = exports2.mediaEvents = exports2.keyboardEvents = exports2.imageEvents = exports2.formEvents = exports2.focusEvents = exports2.compositionEvents = exports2.clipboardEvents = void 0;
    exports2.clipboardEvents = ["onCopy", "onCut", "onPaste"];
    exports2.compositionEvents = [
      "onCompositionEnd",
      "onCompositionStart",
      "onCompositionUpdate"
    ];
    exports2.focusEvents = ["onFocus", "onBlur"];
    exports2.formEvents = ["onInput", "onInvalid", "onReset", "onSubmit"];
    exports2.imageEvents = ["onLoad", "onError"];
    exports2.keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"];
    exports2.mediaEvents = [
      "onAbort",
      "onCanPlay",
      "onCanPlayThrough",
      "onDurationChange",
      "onEmptied",
      "onEncrypted",
      "onEnded",
      "onError",
      "onLoadedData",
      "onLoadedMetadata",
      "onLoadStart",
      "onPause",
      "onPlay",
      "onPlaying",
      "onProgress",
      "onRateChange",
      "onSeeked",
      "onSeeking",
      "onStalled",
      "onSuspend",
      "onTimeUpdate",
      "onVolumeChange",
      "onWaiting"
    ];
    exports2.mouseEvents = [
      "onClick",
      "onContextMenu",
      "onDoubleClick",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOut",
      "onMouseOver",
      "onMouseUp"
    ];
    exports2.dragEvents = [
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onDragOver",
      "onDragStart",
      "onDrop"
    ];
    exports2.selectionEvents = ["onSelect"];
    exports2.touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"];
    exports2.pointerEvents = [
      "onPointerDown",
      "onPointerMove",
      "onPointerUp",
      "onPointerCancel",
      "onGotPointerCapture",
      "onLostPointerCapture",
      "onPointerEnter",
      "onPointerLeave",
      "onPointerOver",
      "onPointerOut"
    ];
    exports2.uiEvents = ["onScroll"];
    exports2.wheelEvents = ["onWheel"];
    exports2.animationEvents = [
      "onAnimationStart",
      "onAnimationEnd",
      "onAnimationIteration"
    ];
    exports2.transitionEvents = ["onTransitionEnd"];
    exports2.otherEvents = ["onToggle"];
    exports2.changeEvents = ["onChange"];
    exports2.allEvents = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], exports2.clipboardEvents, true), exports2.compositionEvents, true), exports2.focusEvents, true), exports2.formEvents, true), exports2.imageEvents, true), exports2.keyboardEvents, true), exports2.mediaEvents, true), exports2.mouseEvents, true), exports2.dragEvents, true), exports2.selectionEvents, true), exports2.touchEvents, true), exports2.pointerEvents, true), exports2.uiEvents, true), exports2.wheelEvents, true), exports2.animationEvents, true), exports2.transitionEvents, true), exports2.changeEvents, true), exports2.otherEvents, true);
    function makeEventProps(props, getArgs) {
      var eventProps = {};
      exports2.allEvents.forEach(function(eventName) {
        var eventHandler = props[eventName];
        if (!eventHandler) {
          return;
        }
        if (getArgs) {
          eventProps[eventName] = function(event) {
            return eventHandler(event, getArgs(eventName));
          };
        } else {
          eventProps[eventName] = eventHandler;
        }
      });
      return eventProps;
    }
    exports2.default = makeEventProps;
  }
});

// node_modules/make-cancellable-promise/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/make-cancellable-promise/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeCancellablePromise(promise) {
      var isCancelled = false;
      var wrappedPromise = new Promise(function(resolve, reject) {
        promise.then(function(value) {
          return !isCancelled && resolve(value);
        }).catch(function(error) {
          return !isCancelled && reject(error);
        });
      });
      return {
        promise: wrappedPromise,
        cancel: function() {
          isCancelled = true;
        }
      };
    }
    exports2.default = makeCancellablePromise;
  }
});

// node_modules/clsx/dist/clsx.js
var require_clsx = __commonJS({
  "node_modules/clsx/dist/clsx.js"(exports2, module2) {
    function e3(r4) {
      var o3, t3, f2 = "";
      if ("string" == typeof r4 || "number" == typeof r4)
        f2 += r4;
      else if ("object" == typeof r4)
        if (Array.isArray(r4))
          for (o3 = 0; o3 < r4.length; o3++)
            r4[o3] && (t3 = e3(r4[o3])) && (f2 && (f2 += " "), f2 += t3);
        else
          for (o3 in r4)
            r4[o3] && (f2 && (f2 += " "), f2 += o3);
      return f2;
    }
    function r3() {
      for (var r4, o3, t3 = 0, f2 = ""; t3 < arguments.length; )
        (r4 = arguments[t3++]) && (o3 = e3(r4)) && (f2 && (f2 += " "), f2 += o3);
      return f2;
    }
    module2.exports = r3, module2.exports.clsx = r3;
  }
});

// node_modules/tiny-invariant/dist/tiny-invariant.cjs.js
var require_tiny_invariant_cjs = __commonJS({
  "node_modules/tiny-invariant/dist/tiny-invariant.cjs.js"(exports2, module2) {
    "use strict";
    var isProduction = false;
    var prefix = "Invariant failed";
    function invariant(condition, message) {
      if (condition) {
        return;
      }
      if (isProduction) {
        throw new Error(prefix);
      }
      var provided = typeof message === "function" ? message() : message;
      var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value);
    }
    module2.exports = invariant;
  }
});

// node_modules/warning/warning.js
var require_warning = __commonJS({
  "node_modules/warning/warning.js"(exports2, module2) {
    "use strict";
    var __DEV__ = true;
    var warning = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
      warning = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      };
    }
    var printWarning;
    module2.exports = warning;
  }
});

// node_modules/dequal/dist/index.js
var require_dist = __commonJS({
  "node_modules/dequal/dist/index.js"(exports2) {
    var has = Object.prototype.hasOwnProperty;
    function find2(iter, tar, key) {
      for (key of iter.keys()) {
        if (dequal(key, tar))
          return key;
      }
    }
    function dequal(foo, bar) {
      var ctor, len, tmp;
      if (foo === bar)
        return true;
      if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
        if (ctor === Date)
          return foo.getTime() === bar.getTime();
        if (ctor === RegExp)
          return foo.toString() === bar.toString();
        if (ctor === Array) {
          if ((len = foo.length) === bar.length) {
            while (len-- && dequal(foo[len], bar[len]))
              ;
          }
          return len === -1;
        }
        if (ctor === Set) {
          if (foo.size !== bar.size) {
            return false;
          }
          for (len of foo) {
            tmp = len;
            if (tmp && typeof tmp === "object") {
              tmp = find2(bar, tmp);
              if (!tmp)
                return false;
            }
            if (!bar.has(tmp))
              return false;
          }
          return true;
        }
        if (ctor === Map) {
          if (foo.size !== bar.size) {
            return false;
          }
          for (len of foo) {
            tmp = len[0];
            if (tmp && typeof tmp === "object") {
              tmp = find2(bar, tmp);
              if (!tmp)
                return false;
            }
            if (!dequal(len[1], bar.get(tmp))) {
              return false;
            }
          }
          return true;
        }
        if (ctor === ArrayBuffer) {
          foo = new Uint8Array(foo);
          bar = new Uint8Array(bar);
        } else if (ctor === DataView) {
          if ((len = foo.byteLength) === bar.byteLength) {
            while (len-- && foo.getInt8(len) === bar.getInt8(len))
              ;
          }
          return len === -1;
        }
        if (ArrayBuffer.isView(foo)) {
          if ((len = foo.byteLength) === bar.byteLength) {
            while (len-- && foo[len] === bar[len])
              ;
          }
          return len === -1;
        }
        if (!ctor || typeof foo === "object") {
          len = 0;
          for (ctor in foo) {
            if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
              return false;
            if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
              return false;
          }
          return Object.keys(bar).length === len;
        }
      }
      return foo !== foo && bar !== bar;
    }
    exports2.dequal = dequal;
  }
});

// node_modules/react-pdf/dist/cjs/DocumentContext.js
var require_DocumentContext = __commonJS({
  "node_modules/react-pdf/dist/cjs/DocumentContext.js"(exports2) {
    "use strict";
    "use client";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = require_react();
    exports2.default = (0, react_1.createContext)(null);
  }
});

// node_modules/react-pdf/dist/cjs/Message.js
var require_Message = __commonJS({
  "node_modules/react-pdf/dist/cjs/Message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    function Message2({ children, type }) {
      return (0, jsx_runtime_1.jsx)("div", { className: `react-pdf__message react-pdf__message--${type}`, children });
    }
    exports2.default = Message2;
  }
});

// node_modules/react-pdf/dist/cjs/LinkService.js
var require_LinkService = __commonJS({
  "node_modules/react-pdf/dist/cjs/LinkService.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
    var LinkService = class {
      constructor() {
        this.externalLinkEnabled = true;
        this.externalLinkRel = void 0;
        this.externalLinkTarget = void 0;
        this.isInPresentationMode = false;
        this.pdfDocument = void 0;
        this.pdfViewer = void 0;
      }
      setDocument(pdfDocument) {
        this.pdfDocument = pdfDocument;
      }
      setViewer(pdfViewer) {
        this.pdfViewer = pdfViewer;
      }
      setExternalLinkRel(externalLinkRel) {
        this.externalLinkRel = externalLinkRel;
      }
      setExternalLinkTarget(externalLinkTarget) {
        this.externalLinkTarget = externalLinkTarget;
      }
      setHistory() {
      }
      get pagesCount() {
        return this.pdfDocument ? this.pdfDocument.numPages : 0;
      }
      get page() {
        (0, tiny_invariant_1.default)(this.pdfViewer, "PDF viewer is not initialized.");
        return this.pdfViewer.currentPageNumber || 0;
      }
      set page(value) {
        (0, tiny_invariant_1.default)(this.pdfViewer, "PDF viewer is not initialized.");
        this.pdfViewer.currentPageNumber = value;
      }
      // eslint-disable-next-line @typescript-eslint/class-literal-property-style
      get rotation() {
        return 0;
      }
      set rotation(value) {
      }
      goToDestination(dest) {
        return new Promise((resolve) => {
          (0, tiny_invariant_1.default)(this.pdfDocument, "PDF document not loaded.");
          (0, tiny_invariant_1.default)(dest, "Destination is not specified.");
          if (typeof dest === "string") {
            this.pdfDocument.getDestination(dest).then(resolve);
          } else if (Array.isArray(dest)) {
            resolve(dest);
          } else {
            dest.then(resolve);
          }
        }).then((explicitDest) => {
          (0, tiny_invariant_1.default)(Array.isArray(explicitDest), `"${explicitDest}" is not a valid destination array.`);
          const destRef = explicitDest[0];
          new Promise((resolve) => {
            (0, tiny_invariant_1.default)(this.pdfDocument, "PDF document not loaded.");
            if (destRef instanceof Object) {
              this.pdfDocument.getPageIndex(destRef).then((pageIndex) => {
                resolve(pageIndex);
              }).catch(() => {
                (0, tiny_invariant_1.default)(false, `"${destRef}" is not a valid page reference.`);
              });
            } else if (typeof destRef === "number") {
              resolve(destRef);
            } else {
              (0, tiny_invariant_1.default)(false, `"${destRef}" is not a valid destination reference.`);
            }
          }).then((pageIndex) => {
            const pageNumber = pageIndex + 1;
            (0, tiny_invariant_1.default)(this.pdfViewer, "PDF viewer is not initialized.");
            (0, tiny_invariant_1.default)(pageNumber >= 1 && pageNumber <= this.pagesCount, `"${pageNumber}" is not a valid page number.`);
            this.pdfViewer.scrollPageIntoView({
              dest: explicitDest,
              pageIndex,
              pageNumber
            });
          });
        });
      }
      navigateTo(dest) {
        this.goToDestination(dest);
      }
      goToPage(pageNumber) {
        const pageIndex = pageNumber - 1;
        (0, tiny_invariant_1.default)(this.pdfViewer, "PDF viewer is not initialized.");
        (0, tiny_invariant_1.default)(pageNumber >= 1 && pageNumber <= this.pagesCount, `"${pageNumber}" is not a valid page number.`);
        this.pdfViewer.scrollPageIntoView({
          pageIndex,
          pageNumber
        });
      }
      addLinkAttributes(link, url, newWindow) {
        link.href = url;
        link.rel = this.externalLinkRel || DEFAULT_LINK_REL;
        link.target = newWindow ? "_blank" : this.externalLinkTarget || "";
      }
      getDestinationHash() {
        return "#";
      }
      getAnchorUrl() {
        return "#";
      }
      setHash() {
      }
      executeNamedAction() {
      }
      cachePageRef() {
      }
      isPageVisible() {
        return true;
      }
      isPageCached() {
        return true;
      }
      executeSetOCGState() {
      }
    };
    exports2.default = LinkService;
  }
});

// node_modules/react-pdf/dist/cjs/PasswordResponses.js
var require_PasswordResponses = __commonJS({
  "node_modules/react-pdf/dist/cjs/PasswordResponses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PasswordResponses = {
      NEED_PASSWORD: 1,
      INCORRECT_PASSWORD: 2
    };
    exports2.default = PasswordResponses;
  }
});

// node_modules/react-pdf/dist/cjs/shared/utils.js
var require_utils = __commonJS({
  "node_modules/react-pdf/dist/cjs/shared/utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadFromFile = exports2.isCancelException = exports2.makePageCallback = exports2.cancelRunningTask = exports2.displayWorkerWarning = exports2.displayCORSWarning = exports2.getDevicePixelRatio = exports2.dataURItoByteString = exports2.isDataURI = exports2.isBlob = exports2.isArrayBuffer = exports2.isString = exports2.isProvided = exports2.isDefined = exports2.isLocalFileSystem = exports2.isBrowser = void 0;
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    exports2.isBrowser = typeof document !== "undefined";
    exports2.isLocalFileSystem = exports2.isBrowser && window.location.protocol === "file:";
    function isDefined(variable) {
      return typeof variable !== "undefined";
    }
    exports2.isDefined = isDefined;
    function isProvided(variable) {
      return isDefined(variable) && variable !== null;
    }
    exports2.isProvided = isProvided;
    function isString(variable) {
      return typeof variable === "string";
    }
    exports2.isString = isString;
    function isArrayBuffer(variable) {
      return variable instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isBlob(variable) {
      (0, tiny_invariant_1.default)(exports2.isBrowser, "isBlob can only be used in a browser environment");
      return variable instanceof Blob;
    }
    exports2.isBlob = isBlob;
    function isDataURI(variable) {
      return isString(variable) && /^data:/.test(variable);
    }
    exports2.isDataURI = isDataURI;
    function dataURItoByteString(dataURI) {
      (0, tiny_invariant_1.default)(isDataURI(dataURI), "Invalid data URI.");
      const [headersString = "", dataString = ""] = dataURI.split(",");
      const headers = headersString.split(";");
      if (headers.indexOf("base64") !== -1) {
        return atob(dataString);
      }
      return unescape(dataString);
    }
    exports2.dataURItoByteString = dataURItoByteString;
    function getDevicePixelRatio() {
      return exports2.isBrowser && window.devicePixelRatio || 1;
    }
    exports2.getDevicePixelRatio = getDevicePixelRatio;
    var allowFileAccessFromFilesTip = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
    function displayCORSWarning() {
      (0, warning_1.default)(!exports2.isLocalFileSystem, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);
    }
    exports2.displayCORSWarning = displayCORSWarning;
    function displayWorkerWarning() {
      (0, warning_1.default)(!exports2.isLocalFileSystem, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);
    }
    exports2.displayWorkerWarning = displayWorkerWarning;
    function cancelRunningTask(runningTask) {
      if (runningTask && runningTask.cancel)
        runningTask.cancel();
    }
    exports2.cancelRunningTask = cancelRunningTask;
    function makePageCallback(page, scale) {
      Object.defineProperty(page, "width", {
        get() {
          return this.view[2] * scale;
        },
        configurable: true
      });
      Object.defineProperty(page, "height", {
        get() {
          return this.view[3] * scale;
        },
        configurable: true
      });
      Object.defineProperty(page, "originalWidth", {
        get() {
          return this.view[2];
        },
        configurable: true
      });
      Object.defineProperty(page, "originalHeight", {
        get() {
          return this.view[3];
        },
        configurable: true
      });
      return page;
    }
    exports2.makePageCallback = makePageCallback;
    function isCancelException(error) {
      return error.name === "RenderingCancelledException";
    }
    exports2.isCancelException = isCancelException;
    function loadFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          if (!reader.result) {
            return reject(new Error("Error while reading a file."));
          }
          resolve(reader.result);
        };
        reader.onerror = (event) => {
          if (!event.target) {
            return reject(new Error("Error while reading a file."));
          }
          const { error } = event.target;
          if (!error) {
            return reject(new Error("Error while reading a file."));
          }
          switch (error.code) {
            case error.NOT_FOUND_ERR:
              return reject(new Error("Error while reading a file: File not found."));
            case error.SECURITY_ERR:
              return reject(new Error("Error while reading a file: Security error."));
            case error.ABORT_ERR:
              return reject(new Error("Error while reading a file: Aborted."));
            default:
              return reject(new Error("Error while reading a file."));
          }
        };
        reader.readAsArrayBuffer(file);
      });
    }
    exports2.loadFromFile = loadFromFile;
  }
});

// node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js
var require_useResolver = __commonJS({
  "node_modules/react-pdf/dist/cjs/shared/hooks/useResolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = require_react();
    function reducer(state, action) {
      switch (action.type) {
        case "RESOLVE":
          return { value: action.value, error: void 0 };
        case "REJECT":
          return { value: false, error: action.error };
        case "RESET":
          return { value: void 0, error: void 0 };
        default:
          return state;
      }
    }
    function useResolver() {
      return (0, react_1.useReducer)(reducer, { value: void 0, error: void 0 });
    }
    exports2.default = useResolver;
  }
});

// node_modules/react-pdf/dist/cjs/Document.js
var require_Document = __commonJS({
  "node_modules/react-pdf/dist/cjs/Document.js"(exports2) {
    "use strict";
    "use client";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest = exports2 && exports2.__rest || function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
          if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
            t3[p2[i3]] = s3[p2[i3]];
        }
      return t3;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var make_event_props_1 = __importDefault(require_cjs());
    var make_cancellable_promise_1 = __importDefault(require_cjs2());
    var clsx_1 = __importDefault(require_clsx());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    var dequal_1 = require_dist();
    var pdfjs_js_1 = __importDefault(require_pdfjs());
    var DocumentContext_js_1 = __importDefault(require_DocumentContext());
    var Message_js_1 = __importDefault(require_Message());
    var LinkService_js_1 = __importDefault(require_LinkService());
    var PasswordResponses_js_1 = __importDefault(require_PasswordResponses());
    var utils_js_1 = require_utils();
    var useResolver_js_1 = __importDefault(require_useResolver());
    var { PDFDataRangeTransport: PDFDataRangeTransport2 } = pdfjs_js_1.default;
    var defaultOnPassword = (callback, reason) => {
      switch (reason) {
        case PasswordResponses_js_1.default.NEED_PASSWORD: {
          const password = prompt("Enter the password to open this PDF file.");
          callback(password);
          break;
        }
        case PasswordResponses_js_1.default.INCORRECT_PASSWORD: {
          const password = prompt("Invalid password. Please try again.");
          callback(password);
          break;
        }
        default:
      }
    };
    function isParameterObject(file) {
      return typeof file === "object" && file !== null && ("data" in file || "range" in file || "url" in file);
    }
    var Document = (0, react_1.forwardRef)(function Document2(_a3, ref) {
      var { children, className, error = "Failed to load PDF file.", externalLinkRel, externalLinkTarget, file, inputRef, imageResourcesPath, loading = "Loading PDF…", noData = "No PDF file specified.", onItemClick, onLoadError: onLoadErrorProps, onLoadProgress, onLoadSuccess: onLoadSuccessProps, onPassword = defaultOnPassword, onSourceError: onSourceErrorProps, onSourceSuccess: onSourceSuccessProps, options, renderMode, rotate } = _a3, otherProps = __rest(_a3, ["children", "className", "error", "externalLinkRel", "externalLinkTarget", "file", "inputRef", "imageResourcesPath", "loading", "noData", "onItemClick", "onLoadError", "onLoadProgress", "onLoadSuccess", "onPassword", "onSourceError", "onSourceSuccess", "options", "renderMode", "rotate"]);
      const [sourceState, sourceDispatch] = (0, useResolver_js_1.default)();
      const { value: source, error: sourceError } = sourceState;
      const [pdfState, pdfDispatch] = (0, useResolver_js_1.default)();
      const { value: pdf, error: pdfError } = pdfState;
      const linkService = (0, react_1.useRef)(new LinkService_js_1.default());
      const pages = (0, react_1.useRef)([]);
      const prevFile = (0, react_1.useRef)(void 0);
      const prevOptions = (0, react_1.useRef)(void 0);
      if (file && file !== prevFile.current && isParameterObject(file)) {
        (0, warning_1.default)(!(0, dequal_1.dequal)(file, prevFile.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.`);
        prevFile.current = file;
      }
      if (options && options !== prevOptions.current) {
        (0, warning_1.default)(!(0, dequal_1.dequal)(options, prevOptions.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.`);
        prevOptions.current = options;
      }
      const viewer = (0, react_1.useRef)({
        // Handling jumping to internal links target
        scrollPageIntoView: (args) => {
          const { dest, pageNumber, pageIndex = pageNumber - 1 } = args;
          if (onItemClick) {
            onItemClick({ dest, pageIndex, pageNumber });
            return;
          }
          const page = pages.current[pageIndex];
          if (page) {
            page.scrollIntoView();
            return;
          }
          (0, warning_1.default)(false, `An internal link leading to page ${pageNumber} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);
        }
      });
      (0, react_1.useImperativeHandle)(ref, () => ({
        linkService,
        pages,
        viewer
      }), []);
      function onSourceSuccess() {
        if (onSourceSuccessProps) {
          onSourceSuccessProps();
        }
      }
      function onSourceError() {
        if (!sourceError) {
          return;
        }
        (0, warning_1.default)(false, sourceError.toString());
        if (onSourceErrorProps) {
          onSourceErrorProps(sourceError);
        }
      }
      function resetSource() {
        sourceDispatch({ type: "RESET" });
      }
      (0, react_1.useEffect)(resetSource, [file, sourceDispatch]);
      const findDocumentSource = (0, react_1.useCallback)(() => __awaiter(this, void 0, void 0, function* () {
        if (!file) {
          return null;
        }
        if (typeof file === "string") {
          if ((0, utils_js_1.isDataURI)(file)) {
            const fileByteString = (0, utils_js_1.dataURItoByteString)(file);
            return { data: fileByteString };
          }
          (0, utils_js_1.displayCORSWarning)();
          return { url: file };
        }
        if (file instanceof PDFDataRangeTransport2) {
          return { range: file };
        }
        if ((0, utils_js_1.isArrayBuffer)(file)) {
          return { data: file };
        }
        if (utils_js_1.isBrowser) {
          if ((0, utils_js_1.isBlob)(file)) {
            const data = yield (0, utils_js_1.loadFromFile)(file);
            return { data };
          }
        }
        (0, tiny_invariant_1.default)(typeof file === "object", "Invalid parameter in file, need either Uint8Array, string or a parameter object");
        (0, tiny_invariant_1.default)(isParameterObject(file), "Invalid parameter object: need either .data, .range or .url");
        if ("url" in file && typeof file.url === "string") {
          if ((0, utils_js_1.isDataURI)(file.url)) {
            const { url } = file, otherParams = __rest(file, ["url"]);
            const fileByteString = (0, utils_js_1.dataURItoByteString)(url);
            return Object.assign({ data: fileByteString }, otherParams);
          }
          (0, utils_js_1.displayCORSWarning)();
        }
        return file;
      }), [file]);
      (0, react_1.useEffect)(() => {
        const cancellable = (0, make_cancellable_promise_1.default)(findDocumentSource());
        cancellable.promise.then((nextSource) => {
          sourceDispatch({ type: "RESOLVE", value: nextSource });
        }).catch((error2) => {
          sourceDispatch({ type: "REJECT", error: error2 });
        });
        return () => {
          (0, utils_js_1.cancelRunningTask)(cancellable);
        };
      }, [findDocumentSource, sourceDispatch]);
      (0, react_1.useEffect)(
        () => {
          if (typeof source === "undefined") {
            return;
          }
          if (source === false) {
            onSourceError();
            return;
          }
          onSourceSuccess();
        },
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [source]
      );
      function onLoadSuccess() {
        if (!pdf) {
          return;
        }
        if (onLoadSuccessProps) {
          onLoadSuccessProps(pdf);
        }
        pages.current = new Array(pdf.numPages);
        linkService.current.setDocument(pdf);
      }
      function onLoadError() {
        if (!pdfError) {
          return;
        }
        (0, warning_1.default)(false, pdfError.toString());
        if (onLoadErrorProps) {
          onLoadErrorProps(pdfError);
        }
      }
      function resetDocument() {
        pdfDispatch({ type: "RESET" });
      }
      (0, react_1.useEffect)(resetDocument, [pdfDispatch, source]);
      function loadDocument() {
        if (!source) {
          return;
        }
        const optionsWithModifiedIsEvalSupported = Object.assign(Object.assign({}, options), { isEvalSupported: false });
        const documentInitParams = Object.assign(Object.assign({}, source), optionsWithModifiedIsEvalSupported);
        const destroyable = pdfjs_js_1.default.getDocument(documentInitParams);
        if (onLoadProgress) {
          destroyable.onProgress = onLoadProgress;
        }
        if (onPassword) {
          destroyable.onPassword = onPassword;
        }
        const loadingTask = destroyable;
        loadingTask.promise.then((nextPdf) => {
          pdfDispatch({ type: "RESOLVE", value: nextPdf });
        }).catch((error2) => {
          if (loadingTask.destroyed) {
            return;
          }
          pdfDispatch({ type: "REJECT", error: error2 });
        });
        return () => {
          loadingTask.destroy();
        };
      }
      (0, react_1.useEffect)(
        loadDocument,
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [options, pdfDispatch, source]
      );
      (0, react_1.useEffect)(
        () => {
          if (typeof pdf === "undefined") {
            return;
          }
          if (pdf === false) {
            onLoadError();
            return;
          }
          onLoadSuccess();
        },
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [pdf]
      );
      function setupLinkService() {
        linkService.current.setViewer(viewer.current);
        linkService.current.setExternalLinkRel(externalLinkRel);
        linkService.current.setExternalLinkTarget(externalLinkTarget);
      }
      (0, react_1.useEffect)(setupLinkService, [externalLinkRel, externalLinkTarget]);
      function registerPage(pageIndex, ref2) {
        pages.current[pageIndex] = ref2;
      }
      function unregisterPage(pageIndex) {
        delete pages.current[pageIndex];
      }
      const childContext = (0, react_1.useMemo)(() => ({
        imageResourcesPath,
        linkService: linkService.current,
        onItemClick,
        pdf,
        registerPage,
        renderMode,
        rotate,
        unregisterPage
      }), [imageResourcesPath, onItemClick, pdf, renderMode, rotate]);
      const eventProps = (0, react_1.useMemo)(() => (0, make_event_props_1.default)(otherProps, () => pdf), [otherProps, pdf]);
      function renderChildren() {
        return (0, jsx_runtime_1.jsx)(DocumentContext_js_1.default.Provider, { value: childContext, children });
      }
      function renderContent() {
        if (!file) {
          return (0, jsx_runtime_1.jsx)(Message_js_1.default, { type: "no-data", children: typeof noData === "function" ? noData() : noData });
        }
        if (pdf === void 0 || pdf === null) {
          return (0, jsx_runtime_1.jsx)(Message_js_1.default, { type: "loading", children: typeof loading === "function" ? loading() : loading });
        }
        if (pdf === false) {
          return (0, jsx_runtime_1.jsx)(Message_js_1.default, { type: "error", children: typeof error === "function" ? error() : error });
        }
        return renderChildren();
      }
      return (0, jsx_runtime_1.jsx)("div", Object.assign({ className: (0, clsx_1.default)("react-pdf__Document", className), ref: inputRef, style: {
        ["--scale-factor"]: "1"
      } }, eventProps, { children: renderContent() }));
    });
    exports2.default = Document;
  }
});

// node_modules/react-pdf/dist/cjs/OutlineContext.js
var require_OutlineContext = __commonJS({
  "node_modules/react-pdf/dist/cjs/OutlineContext.js"(exports2) {
    "use strict";
    "use client";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = require_react();
    exports2.default = (0, react_1.createContext)(null);
  }
});

// node_modules/react-pdf/dist/cjs/Ref.js
var require_Ref = __commonJS({
  "node_modules/react-pdf/dist/cjs/Ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Ref2 = class {
      constructor({ num, gen }) {
        this.num = num;
        this.gen = gen;
      }
      toString() {
        let str = `${this.num}R`;
        if (this.gen !== 0) {
          str += this.gen;
        }
        return str;
      }
    };
    exports2.default = Ref2;
  }
});

// node_modules/react-pdf/dist/cjs/shared/hooks/useCachedValue.js
var require_useCachedValue = __commonJS({
  "node_modules/react-pdf/dist/cjs/shared/hooks/useCachedValue.js"(exports2) {
    "use strict";
    "use client";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = require_react();
    var utils_js_1 = require_utils();
    function useCachedValue(getter) {
      const ref = (0, react_1.useRef)(void 0);
      const currentValue = ref.current;
      if ((0, utils_js_1.isDefined)(currentValue)) {
        return () => currentValue;
      }
      return () => {
        const value = getter();
        ref.current = value;
        return value;
      };
    }
    exports2.default = useCachedValue;
  }
});

// node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js
var require_useDocumentContext = __commonJS({
  "node_modules/react-pdf/dist/cjs/shared/hooks/useDocumentContext.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = require_react();
    var DocumentContext_js_1 = __importDefault(require_DocumentContext());
    function useDocumentContext() {
      return (0, react_1.useContext)(DocumentContext_js_1.default);
    }
    exports2.default = useDocumentContext;
  }
});

// node_modules/react-pdf/dist/cjs/shared/hooks/useOutlineContext.js
var require_useOutlineContext = __commonJS({
  "node_modules/react-pdf/dist/cjs/shared/hooks/useOutlineContext.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = require_react();
    var OutlineContext_js_1 = __importDefault(require_OutlineContext());
    function useOutlineContext() {
      return (0, react_1.useContext)(OutlineContext_js_1.default);
    }
    exports2.default = useOutlineContext;
  }
});

// node_modules/react-pdf/dist/cjs/OutlineItem.js
var require_OutlineItem = __commonJS({
  "node_modules/react-pdf/dist/cjs/OutlineItem.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest = exports2 && exports2.__rest || function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
          if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
            t3[p2[i3]] = s3[p2[i3]];
        }
      return t3;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var Ref_js_1 = __importDefault(require_Ref());
    var useCachedValue_js_1 = __importDefault(require_useCachedValue());
    var useDocumentContext_js_1 = __importDefault(require_useDocumentContext());
    var useOutlineContext_js_1 = __importDefault(require_useOutlineContext());
    function OutlineItem(props) {
      const documentContext = (0, useDocumentContext_js_1.default)();
      const outlineContext = (0, useOutlineContext_js_1.default)();
      (0, tiny_invariant_1.default)(outlineContext, "Unable to find Outline context.");
      const mergedProps = Object.assign(Object.assign(Object.assign({}, documentContext), outlineContext), props);
      const { item, linkService, onItemClick, pdf } = mergedProps, otherProps = __rest(mergedProps, ["item", "linkService", "onItemClick", "pdf"]);
      (0, tiny_invariant_1.default)(pdf, "Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.");
      const getDestination = (0, useCachedValue_js_1.default)(() => {
        if (typeof item.dest === "string") {
          return pdf.getDestination(item.dest);
        }
        return item.dest;
      });
      const getPageIndex = (0, useCachedValue_js_1.default)(() => __awaiter(this, void 0, void 0, function* () {
        const destination = yield getDestination();
        if (!destination) {
          throw new Error("Destination not found.");
        }
        const [ref] = destination;
        return pdf.getPageIndex(new Ref_js_1.default(ref));
      }));
      const getPageNumber = (0, useCachedValue_js_1.default)(() => __awaiter(this, void 0, void 0, function* () {
        const pageIndex = yield getPageIndex();
        return pageIndex + 1;
      }));
      function onClick(event) {
        event.preventDefault();
        (0, tiny_invariant_1.default)(onItemClick || linkService, "Either onItemClick callback or linkService must be defined in order to navigate to an outline item.");
        if (onItemClick) {
          Promise.all([getDestination(), getPageIndex(), getPageNumber()]).then(([dest, pageIndex, pageNumber]) => {
            onItemClick({
              dest,
              pageIndex,
              pageNumber
            });
          });
        } else if (linkService) {
          linkService.goToDestination(item.dest);
        }
      }
      function renderSubitems() {
        if (!item.items || !item.items.length) {
          return null;
        }
        const { items: subitems } = item;
        return (0, jsx_runtime_1.jsx)("ul", { children: subitems.map((subitem, subitemIndex) => (0, jsx_runtime_1.jsx)(OutlineItem, Object.assign({ item: subitem, pdf }, otherProps), typeof subitem.dest === "string" ? subitem.dest : subitemIndex)) });
      }
      return (0, jsx_runtime_1.jsxs)("li", { children: [(0, jsx_runtime_1.jsx)("a", { href: "#", onClick, children: item.title }), renderSubitems()] });
    }
    exports2.default = OutlineItem;
  }
});

// node_modules/react-pdf/dist/cjs/Outline.js
var require_Outline = __commonJS({
  "node_modules/react-pdf/dist/cjs/Outline.js"(exports2) {
    "use strict";
    "use client";
    var __rest = exports2 && exports2.__rest || function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
          if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
            t3[p2[i3]] = s3[p2[i3]];
        }
      return t3;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var make_cancellable_promise_1 = __importDefault(require_cjs2());
    var make_event_props_1 = __importDefault(require_cjs());
    var clsx_1 = __importDefault(require_clsx());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    var OutlineContext_js_1 = __importDefault(require_OutlineContext());
    var OutlineItem_js_1 = __importDefault(require_OutlineItem());
    var utils_js_1 = require_utils();
    var useDocumentContext_js_1 = __importDefault(require_useDocumentContext());
    var useResolver_js_1 = __importDefault(require_useResolver());
    function Outline(props) {
      const documentContext = (0, useDocumentContext_js_1.default)();
      const mergedProps = Object.assign(Object.assign({}, documentContext), props);
      const { className, inputRef, onItemClick, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, pdf } = mergedProps, otherProps = __rest(mergedProps, ["className", "inputRef", "onItemClick", "onLoadError", "onLoadSuccess", "pdf"]);
      (0, tiny_invariant_1.default)(pdf, "Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.");
      const [outlineState, outlineDispatch] = (0, useResolver_js_1.default)();
      const { value: outline, error: outlineError } = outlineState;
      function onLoadSuccess() {
        if (typeof outline === "undefined" || outline === false) {
          return;
        }
        if (onLoadSuccessProps) {
          onLoadSuccessProps(outline);
        }
      }
      function onLoadError() {
        if (!outlineError) {
          return;
        }
        (0, warning_1.default)(false, outlineError.toString());
        if (onLoadErrorProps) {
          onLoadErrorProps(outlineError);
        }
      }
      function resetOutline() {
        outlineDispatch({ type: "RESET" });
      }
      (0, react_1.useEffect)(resetOutline, [outlineDispatch, pdf]);
      function loadOutline() {
        if (!pdf) {
          return;
        }
        const cancellable = (0, make_cancellable_promise_1.default)(pdf.getOutline());
        const runningTask = cancellable;
        cancellable.promise.then((nextOutline) => {
          outlineDispatch({ type: "RESOLVE", value: nextOutline });
        }).catch((error) => {
          outlineDispatch({ type: "REJECT", error });
        });
        return () => (0, utils_js_1.cancelRunningTask)(runningTask);
      }
      (0, react_1.useEffect)(loadOutline, [outlineDispatch, pdf]);
      (0, react_1.useEffect)(
        () => {
          if (outline === void 0) {
            return;
          }
          if (outline === false) {
            onLoadError();
            return;
          }
          onLoadSuccess();
        },
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [outline]
      );
      const childContext = (0, react_1.useMemo)(() => ({
        onItemClick
      }), [onItemClick]);
      const eventProps = (0, react_1.useMemo)(() => (0, make_event_props_1.default)(otherProps, () => outline), [otherProps, outline]);
      if (!outline) {
        return null;
      }
      function renderOutline() {
        if (!outline) {
          return null;
        }
        return (0, jsx_runtime_1.jsx)("ul", { children: outline.map((item, itemIndex) => (0, jsx_runtime_1.jsx)(OutlineItem_js_1.default, { item, pdf }, typeof item.dest === "string" ? item.dest : itemIndex)) });
      }
      return (0, jsx_runtime_1.jsx)("div", Object.assign({ className: (0, clsx_1.default)("react-pdf__Outline", className), ref: inputRef }, eventProps, { children: (0, jsx_runtime_1.jsx)(OutlineContext_js_1.default.Provider, { value: childContext, children: renderOutline() }) }));
    }
    exports2.default = Outline;
  }
});

// node_modules/merge-refs/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/merge-refs/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function mergeRefs() {
      var inputRefs = [];
      for (var _i3 = 0; _i3 < arguments.length; _i3++) {
        inputRefs[_i3] = arguments[_i3];
      }
      var filteredInputRefs = inputRefs.filter(Boolean);
      if (filteredInputRefs.length <= 1) {
        var firstRef = filteredInputRefs[0];
        return firstRef || null;
      }
      return function mergedRefs(ref) {
        filteredInputRefs.forEach(function(inputRef) {
          if (typeof inputRef === "function") {
            inputRef(ref);
          } else if (inputRef) {
            inputRef.current = ref;
          }
        });
      };
    }
    exports2.default = mergeRefs;
  }
});

// node_modules/react-pdf/dist/cjs/PageContext.js
var require_PageContext = __commonJS({
  "node_modules/react-pdf/dist/cjs/PageContext.js"(exports2) {
    "use strict";
    "use client";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = require_react();
    exports2.default = (0, react_1.createContext)(null);
  }
});

// node_modules/react-pdf/dist/cjs/shared/constants.js
var require_constants = __commonJS({
  "node_modules/react-pdf/dist/cjs/shared/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HEADING_PATTERN = exports2.PDF_ROLE_TO_HTML_ROLE = void 0;
    exports2.PDF_ROLE_TO_HTML_ROLE = {
      // Document level structure types
      Document: null,
      // There's a "document" role, but it doesn't make sense here.
      DocumentFragment: null,
      // Grouping level structure types
      Part: "group",
      Sect: "group",
      // XXX: There's a "section" role, but it's abstract.
      Div: "group",
      Aside: "note",
      NonStruct: "none",
      // Block level structure types
      P: null,
      // H<n>,
      H: "heading",
      Title: null,
      FENote: "note",
      // Sub-block level structure type
      Sub: "group",
      // General inline level structure types
      Lbl: null,
      Span: null,
      Em: null,
      Strong: null,
      Link: "link",
      Annot: "note",
      Form: "form",
      // Ruby and Warichu structure types
      Ruby: null,
      RB: null,
      RT: null,
      RP: null,
      Warichu: null,
      WT: null,
      WP: null,
      // List standard structure types
      L: "list",
      LI: "listitem",
      LBody: null,
      // Table standard structure types
      Table: "table",
      TR: "row",
      TH: "columnheader",
      TD: "cell",
      THead: "columnheader",
      TBody: null,
      TFoot: null,
      // Standard structure type Caption
      Caption: null,
      // Standard structure type Figure
      Figure: "figure",
      // Standard structure type Formula
      Formula: null,
      // standard structure type Artifact
      Artifact: null
    };
    exports2.HEADING_PATTERN = /^H(\d+)$/;
  }
});

// node_modules/react-pdf/dist/cjs/shared/structTreeUtils.js
var require_structTreeUtils = __commonJS({
  "node_modules/react-pdf/dist/cjs/shared/structTreeUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAttributes = exports2.getBaseAttributes = exports2.getRoleAttributes = exports2.isStructTreeNodeWithOnlyContentChild = exports2.isStructTreeNode = exports2.isPdfRole = void 0;
    var constants_js_1 = require_constants();
    function isPdfRole(role) {
      return role in constants_js_1.PDF_ROLE_TO_HTML_ROLE;
    }
    exports2.isPdfRole = isPdfRole;
    function isStructTreeNode(node) {
      return "children" in node;
    }
    exports2.isStructTreeNode = isStructTreeNode;
    function isStructTreeNodeWithOnlyContentChild(node) {
      if (!isStructTreeNode(node)) {
        return false;
      }
      return node.children.length === 1 && 0 in node.children && "id" in node.children[0];
    }
    exports2.isStructTreeNodeWithOnlyContentChild = isStructTreeNodeWithOnlyContentChild;
    function getRoleAttributes(node) {
      const attributes = {};
      if (isStructTreeNode(node)) {
        const { role } = node;
        const matches = role.match(constants_js_1.HEADING_PATTERN);
        if (matches) {
          attributes.role = "heading";
          attributes["aria-level"] = Number(matches[1]);
        } else if (isPdfRole(role)) {
          const htmlRole = constants_js_1.PDF_ROLE_TO_HTML_ROLE[role];
          if (htmlRole) {
            attributes.role = htmlRole;
          }
        }
      }
      return attributes;
    }
    exports2.getRoleAttributes = getRoleAttributes;
    function getBaseAttributes(node) {
      const attributes = {};
      if (isStructTreeNode(node)) {
        if (node.alt !== void 0) {
          attributes["aria-label"] = node.alt;
        }
        if (node.lang !== void 0) {
          attributes.lang = node.lang;
        }
        if (isStructTreeNodeWithOnlyContentChild(node)) {
          const [child] = node.children;
          if (child) {
            const childAttributes = getBaseAttributes(child);
            return Object.assign(Object.assign({}, attributes), childAttributes);
          }
        }
      } else {
        if ("id" in node) {
          attributes["aria-owns"] = node.id;
        }
      }
      return attributes;
    }
    exports2.getBaseAttributes = getBaseAttributes;
    function getAttributes(node) {
      if (!node) {
        return null;
      }
      return Object.assign(Object.assign({}, getRoleAttributes(node)), getBaseAttributes(node));
    }
    exports2.getAttributes = getAttributes;
  }
});

// node_modules/react-pdf/dist/cjs/StructTreeItem.js
var require_StructTreeItem = __commonJS({
  "node_modules/react-pdf/dist/cjs/StructTreeItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var structTreeUtils_js_1 = require_structTreeUtils();
    function StructTreeItem({ className, node }) {
      const attributes = (0, react_1.useMemo)(() => (0, structTreeUtils_js_1.getAttributes)(node), [node]);
      const children = (0, react_1.useMemo)(() => {
        if (!(0, structTreeUtils_js_1.isStructTreeNode)(node)) {
          return null;
        }
        if ((0, structTreeUtils_js_1.isStructTreeNodeWithOnlyContentChild)(node)) {
          return null;
        }
        return node.children.map((child, index) => {
          return (
            // eslint-disable-next-line react/no-array-index-key
            (0, jsx_runtime_1.jsx)(StructTreeItem, { node: child }, index)
          );
        });
      }, [node]);
      return (0, jsx_runtime_1.jsx)("span", Object.assign({ className }, attributes, { children }));
    }
    exports2.default = StructTreeItem;
  }
});

// node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js
var require_usePageContext = __commonJS({
  "node_modules/react-pdf/dist/cjs/shared/hooks/usePageContext.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = require_react();
    var PageContext_js_1 = __importDefault(require_PageContext());
    function usePageContext() {
      return (0, react_1.useContext)(PageContext_js_1.default);
    }
    exports2.default = usePageContext;
  }
});

// node_modules/react-pdf/dist/cjs/StructTree.js
var require_StructTree = __commonJS({
  "node_modules/react-pdf/dist/cjs/StructTree.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var make_cancellable_promise_1 = __importDefault(require_cjs2());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    var StructTreeItem_js_1 = __importDefault(require_StructTreeItem());
    var usePageContext_js_1 = __importDefault(require_usePageContext());
    var useResolver_js_1 = __importDefault(require_useResolver());
    var utils_js_1 = require_utils();
    function StructTree() {
      const pageContext = (0, usePageContext_js_1.default)();
      (0, tiny_invariant_1.default)(pageContext, "Unable to find Page context.");
      const { onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps } = pageContext;
      const [structTreeState, structTreeDispatch] = (0, useResolver_js_1.default)();
      const { value: structTree, error: structTreeError } = structTreeState;
      const { customTextRenderer, page } = pageContext;
      function onLoadSuccess() {
        if (!structTree) {
          return;
        }
        if (onGetStructTreeSuccessProps) {
          onGetStructTreeSuccessProps(structTree);
        }
      }
      function onLoadError() {
        if (!structTreeError) {
          return;
        }
        (0, warning_1.default)(false, structTreeError.toString());
        if (onGetStructTreeErrorProps) {
          onGetStructTreeErrorProps(structTreeError);
        }
      }
      function resetAnnotations() {
        structTreeDispatch({ type: "RESET" });
      }
      (0, react_1.useEffect)(resetAnnotations, [structTreeDispatch, page]);
      function loadStructTree() {
        if (customTextRenderer) {
          return;
        }
        if (!page) {
          return;
        }
        const cancellable = (0, make_cancellable_promise_1.default)(page.getStructTree());
        const runningTask = cancellable;
        cancellable.promise.then((nextStructTree) => {
          structTreeDispatch({ type: "RESOLVE", value: nextStructTree });
        }).catch((error) => {
          structTreeDispatch({ type: "REJECT", error });
        });
        return () => (0, utils_js_1.cancelRunningTask)(runningTask);
      }
      (0, react_1.useEffect)(loadStructTree, [customTextRenderer, page, structTreeDispatch]);
      (0, react_1.useEffect)(
        () => {
          if (structTree === void 0) {
            return;
          }
          if (structTree === false) {
            onLoadError();
            return;
          }
          onLoadSuccess();
        },
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [structTree]
      );
      if (!structTree) {
        return null;
      }
      return (0, jsx_runtime_1.jsx)(StructTreeItem_js_1.default, { className: "react-pdf__Page__structTree structTree", node: structTree });
    }
    exports2.default = StructTree;
  }
});

// node_modules/react-pdf/dist/cjs/Page/PageCanvas.js
var require_PageCanvas = __commonJS({
  "node_modules/react-pdf/dist/cjs/Page/PageCanvas.js"(exports2) {
    "use strict";
    "use client";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var merge_refs_1 = __importDefault(require_cjs3());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    var pdfjs_js_1 = __importDefault(require_pdfjs());
    var StructTree_js_1 = __importDefault(require_StructTree());
    var usePageContext_js_1 = __importDefault(require_usePageContext());
    var utils_js_1 = require_utils();
    var ANNOTATION_MODE = pdfjs_js_1.default.AnnotationMode;
    function PageCanvas(props) {
      const pageContext = (0, usePageContext_js_1.default)();
      (0, tiny_invariant_1.default)(pageContext, "Unable to find Page context.");
      const mergedProps = Object.assign(Object.assign({}, pageContext), props);
      const { _className, canvasBackground, devicePixelRatio = (0, utils_js_1.getDevicePixelRatio)(), onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, page, renderForms, renderTextLayer, rotate, scale } = mergedProps;
      const { canvasRef } = props;
      (0, tiny_invariant_1.default)(page, "Attempted to render page canvas, but no page was specified.");
      const canvasElement = (0, react_1.useRef)(null);
      function onRenderSuccess() {
        if (!page) {
          return;
        }
        if (onRenderSuccessProps) {
          onRenderSuccessProps((0, utils_js_1.makePageCallback)(page, scale));
        }
      }
      function onRenderError(error) {
        if ((0, utils_js_1.isCancelException)(error)) {
          return;
        }
        (0, warning_1.default)(false, error.toString());
        if (onRenderErrorProps) {
          onRenderErrorProps(error);
        }
      }
      const renderViewport = (0, react_1.useMemo)(() => page.getViewport({ scale: scale * devicePixelRatio, rotation: rotate }), [devicePixelRatio, page, rotate, scale]);
      const viewport = (0, react_1.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
      function drawPageOnCanvas() {
        if (!page) {
          return;
        }
        page.cleanup();
        const { current: canvas } = canvasElement;
        if (!canvas) {
          return;
        }
        canvas.width = renderViewport.width;
        canvas.height = renderViewport.height;
        canvas.style.width = `${Math.floor(viewport.width)}px`;
        canvas.style.height = `${Math.floor(viewport.height)}px`;
        canvas.style.visibility = "hidden";
        const renderContext = {
          annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,
          canvasContext: canvas.getContext("2d", { alpha: false }),
          viewport: renderViewport
        };
        if (canvasBackground) {
          renderContext.background = canvasBackground;
        }
        const cancellable = page.render(renderContext);
        const runningTask = cancellable;
        cancellable.promise.then(() => {
          canvas.style.visibility = "";
          onRenderSuccess();
        }).catch(onRenderError);
        return () => (0, utils_js_1.cancelRunningTask)(runningTask);
      }
      (0, react_1.useEffect)(
        drawPageOnCanvas,
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [
          canvasBackground,
          canvasElement,
          devicePixelRatio,
          page,
          renderForms,
          renderViewport,
          viewport
        ]
      );
      const cleanup = (0, react_1.useCallback)(() => {
        const { current: canvas } = canvasElement;
        if (canvas) {
          canvas.width = 0;
          canvas.height = 0;
        }
      }, [canvasElement]);
      (0, react_1.useEffect)(() => cleanup, [cleanup]);
      return (0, jsx_runtime_1.jsx)("canvas", { className: `${_className}__canvas`, dir: "ltr", ref: (0, merge_refs_1.default)(canvasRef, canvasElement), style: {
        display: "block",
        userSelect: "none"
      }, children: renderTextLayer ? (0, jsx_runtime_1.jsx)(StructTree_js_1.default, {}) : null });
    }
    exports2.default = PageCanvas;
  }
});

// node_modules/react-pdf/dist/cjs/Page/PageSVG.js
var require_PageSVG = __commonJS({
  "node_modules/react-pdf/dist/cjs/Page/PageSVG.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var make_cancellable_promise_1 = __importDefault(require_cjs2());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    var pdfjs_js_1 = __importDefault(require_pdfjs());
    var usePageContext_js_1 = __importDefault(require_usePageContext());
    var useResolver_js_1 = __importDefault(require_useResolver());
    var utils_js_1 = require_utils();
    function PageSVG() {
      const pageContext = (0, usePageContext_js_1.default)();
      (0, tiny_invariant_1.default)(pageContext, "Unable to find Page context.");
      const { _className, onRenderSuccess: onRenderSuccessProps, onRenderError: onRenderErrorProps, page, rotate, scale } = pageContext;
      (0, tiny_invariant_1.default)(page, "Attempted to render page SVG, but no page was specified.");
      const [svgState, svgDispatch] = (0, useResolver_js_1.default)();
      const { value: svg, error: svgError } = svgState;
      function onRenderSuccess() {
        if (!page) {
          return;
        }
        if (onRenderSuccessProps) {
          onRenderSuccessProps((0, utils_js_1.makePageCallback)(page, scale));
        }
      }
      function onRenderError() {
        if (!svgError) {
          return;
        }
        if ((0, utils_js_1.isCancelException)(svgError)) {
          return;
        }
        (0, warning_1.default)(false, svgError.toString());
        if (onRenderErrorProps) {
          onRenderErrorProps(svgError);
        }
      }
      const viewport = (0, react_1.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
      function resetSVG() {
        svgDispatch({ type: "RESET" });
      }
      (0, react_1.useEffect)(resetSVG, [page, svgDispatch, viewport]);
      function renderSVG() {
        if (!page) {
          return;
        }
        const cancellable = (0, make_cancellable_promise_1.default)(page.getOperatorList());
        cancellable.promise.then((operatorList) => {
          const svgGfx = new pdfjs_js_1.default.SVGGraphics(page.commonObjs, page.objs);
          svgGfx.getSVG(operatorList, viewport).then((nextSvg) => {
            if (!(nextSvg instanceof SVGElement)) {
              throw new Error("getSVG returned unexpected result.");
            }
            svgDispatch({ type: "RESOLVE", value: nextSvg });
          }).catch((error) => {
            svgDispatch({ type: "REJECT", error });
          });
        }).catch((error) => {
          svgDispatch({ type: "REJECT", error });
        });
        return () => (0, utils_js_1.cancelRunningTask)(cancellable);
      }
      (0, react_1.useEffect)(renderSVG, [page, svgDispatch, viewport]);
      (0, react_1.useEffect)(
        () => {
          if (svg === void 0) {
            return;
          }
          if (svg === false) {
            onRenderError();
            return;
          }
          onRenderSuccess();
        },
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [svg]
      );
      function drawPageOnContainer(element) {
        if (!element || !svg) {
          return;
        }
        if (!element.firstElementChild) {
          element.appendChild(svg);
        }
        const { width: width2, height: height2 } = viewport;
        svg.setAttribute("width", `${width2}`);
        svg.setAttribute("height", `${height2}`);
      }
      const { width, height } = viewport;
      return (0, jsx_runtime_1.jsx)("div", {
        className: `${_className}__svg`,
        // Note: This cannot be shortened, as we need this function to be called with each render.
        ref: (ref) => drawPageOnContainer(ref),
        style: {
          display: "block",
          backgroundColor: "white",
          overflow: "hidden",
          width,
          height,
          userSelect: "none"
        }
      });
    }
    exports2.default = PageSVG;
  }
});

// node_modules/react-pdf/dist/cjs/Page/TextLayer.js
var require_TextLayer = __commonJS({
  "node_modules/react-pdf/dist/cjs/Page/TextLayer.js"(exports2) {
    "use strict";
    "use client";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var make_cancellable_promise_1 = __importDefault(require_cjs2());
    var clsx_1 = __importDefault(require_clsx());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    var pdfjs_js_1 = __importDefault(require_pdfjs());
    var usePageContext_js_1 = __importDefault(require_usePageContext());
    var useResolver_js_1 = __importDefault(require_useResolver());
    var utils_js_1 = require_utils();
    function isTextItem(item) {
      return "str" in item;
    }
    function TextLayer() {
      const pageContext = (0, usePageContext_js_1.default)();
      (0, tiny_invariant_1.default)(pageContext, "Unable to find Page context.");
      const { customTextRenderer, onGetTextError, onGetTextSuccess, onRenderTextLayerError, onRenderTextLayerSuccess, page, pageIndex, pageNumber, rotate, scale } = pageContext;
      (0, tiny_invariant_1.default)(page, "Attempted to load page text content, but no page was specified.");
      const [textContentState, textContentDispatch] = (0, useResolver_js_1.default)();
      const { value: textContent, error: textContentError } = textContentState;
      const layerElement = (0, react_1.useRef)(null);
      const endElement = (0, react_1.useRef)(void 0);
      (0, warning_1.default)(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer");
      function onLoadSuccess() {
        if (!textContent) {
          return;
        }
        if (onGetTextSuccess) {
          onGetTextSuccess(textContent);
        }
      }
      function onLoadError() {
        if (!textContentError) {
          return;
        }
        (0, warning_1.default)(false, textContentError.toString());
        if (onGetTextError) {
          onGetTextError(textContentError);
        }
      }
      function resetTextContent() {
        textContentDispatch({ type: "RESET" });
      }
      (0, react_1.useEffect)(resetTextContent, [page, textContentDispatch]);
      function loadTextContent() {
        if (!page) {
          return;
        }
        const cancellable = (0, make_cancellable_promise_1.default)(page.getTextContent());
        const runningTask = cancellable;
        cancellable.promise.then((nextTextContent) => {
          textContentDispatch({ type: "RESOLVE", value: nextTextContent });
        }).catch((error) => {
          textContentDispatch({ type: "REJECT", error });
        });
        return () => (0, utils_js_1.cancelRunningTask)(runningTask);
      }
      (0, react_1.useEffect)(loadTextContent, [page, textContentDispatch]);
      (0, react_1.useEffect)(
        () => {
          if (textContent === void 0) {
            return;
          }
          if (textContent === false) {
            onLoadError();
            return;
          }
          onLoadSuccess();
        },
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [textContent]
      );
      const onRenderSuccess = (0, react_1.useCallback)(() => {
        if (onRenderTextLayerSuccess) {
          onRenderTextLayerSuccess();
        }
      }, [onRenderTextLayerSuccess]);
      const onRenderError = (0, react_1.useCallback)((error) => {
        (0, warning_1.default)(false, error.toString());
        if (onRenderTextLayerError) {
          onRenderTextLayerError(error);
        }
      }, [onRenderTextLayerError]);
      function onMouseDown() {
        const end = endElement.current;
        if (!end) {
          return;
        }
        end.classList.add("active");
      }
      function onMouseUp() {
        const end = endElement.current;
        if (!end) {
          return;
        }
        end.classList.remove("active");
      }
      const viewport = (0, react_1.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
      function renderTextLayer() {
        if (!page || !textContent) {
          return;
        }
        const { current: layer } = layerElement;
        if (!layer) {
          return;
        }
        layer.innerHTML = "";
        const textContentSource = page.streamTextContent({ includeMarkedContent: true });
        const parameters = {
          container: layer,
          textContentSource,
          viewport
        };
        const cancellable = pdfjs_js_1.default.renderTextLayer(parameters);
        const runningTask = cancellable;
        cancellable.promise.then(() => {
          const end = document.createElement("div");
          end.className = "endOfContent";
          layer.append(end);
          endElement.current = end;
          const layerChildren = layer.querySelectorAll('[role="presentation"]');
          if (customTextRenderer) {
            let index = 0;
            textContent.items.forEach((item, itemIndex) => {
              if (!isTextItem(item)) {
                return;
              }
              const child = layerChildren[index];
              if (!child) {
                return;
              }
              const content = customTextRenderer(Object.assign({
                pageIndex,
                pageNumber,
                itemIndex
              }, item));
              child.innerHTML = content;
              index += item.str && item.hasEOL ? 2 : 1;
            });
          }
          onRenderSuccess();
        }).catch(onRenderError);
        return () => (0, utils_js_1.cancelRunningTask)(runningTask);
      }
      (0, react_1.useLayoutEffect)(renderTextLayer, [
        customTextRenderer,
        onRenderError,
        onRenderSuccess,
        page,
        pageIndex,
        pageNumber,
        textContent,
        viewport
      ]);
      return (
        // eslint-disable-next-line jsx-a11y/no-static-element-interactions
        (0, jsx_runtime_1.jsx)("div", { className: (0, clsx_1.default)("react-pdf__Page__textContent", "textLayer"), onMouseUp, onMouseDown, ref: layerElement })
      );
    }
    exports2.default = TextLayer;
  }
});

// node_modules/react-pdf/dist/cjs/Page/AnnotationLayer.js
var require_AnnotationLayer = __commonJS({
  "node_modules/react-pdf/dist/cjs/Page/AnnotationLayer.js"(exports2) {
    "use strict";
    "use client";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var make_cancellable_promise_1 = __importDefault(require_cjs2());
    var clsx_1 = __importDefault(require_clsx());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    var pdfjs_js_1 = __importDefault(require_pdfjs());
    var useDocumentContext_js_1 = __importDefault(require_useDocumentContext());
    var usePageContext_js_1 = __importDefault(require_usePageContext());
    var useResolver_js_1 = __importDefault(require_useResolver());
    var utils_js_1 = require_utils();
    function AnnotationLayer() {
      const documentContext = (0, useDocumentContext_js_1.default)();
      const pageContext = (0, usePageContext_js_1.default)();
      (0, tiny_invariant_1.default)(pageContext, "Unable to find Page context.");
      const mergedProps = Object.assign(Object.assign({}, documentContext), pageContext);
      const { imageResourcesPath, linkService, onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, page, pdf, renderForms, rotate, scale = 1 } = mergedProps;
      (0, tiny_invariant_1.default)(pdf, "Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
      (0, tiny_invariant_1.default)(page, "Attempted to load page annotations, but no page was specified.");
      (0, tiny_invariant_1.default)(linkService, "Attempted to load page annotations, but no linkService was specified.");
      const [annotationsState, annotationsDispatch] = (0, useResolver_js_1.default)();
      const { value: annotations, error: annotationsError } = annotationsState;
      const layerElement = (0, react_1.useRef)(null);
      (0, warning_1.default)(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations");
      function onLoadSuccess() {
        if (!annotations) {
          return;
        }
        if (onGetAnnotationsSuccessProps) {
          onGetAnnotationsSuccessProps(annotations);
        }
      }
      function onLoadError() {
        if (!annotationsError) {
          return;
        }
        (0, warning_1.default)(false, annotationsError.toString());
        if (onGetAnnotationsErrorProps) {
          onGetAnnotationsErrorProps(annotationsError);
        }
      }
      function resetAnnotations() {
        annotationsDispatch({ type: "RESET" });
      }
      (0, react_1.useEffect)(resetAnnotations, [annotationsDispatch, page]);
      function loadAnnotations() {
        if (!page) {
          return;
        }
        const cancellable = (0, make_cancellable_promise_1.default)(page.getAnnotations());
        const runningTask = cancellable;
        cancellable.promise.then((nextAnnotations) => {
          annotationsDispatch({ type: "RESOLVE", value: nextAnnotations });
        }).catch((error) => {
          annotationsDispatch({ type: "REJECT", error });
        });
        return () => {
          (0, utils_js_1.cancelRunningTask)(runningTask);
        };
      }
      (0, react_1.useEffect)(loadAnnotations, [annotationsDispatch, page, renderForms]);
      (0, react_1.useEffect)(
        () => {
          if (annotations === void 0) {
            return;
          }
          if (annotations === false) {
            onLoadError();
            return;
          }
          onLoadSuccess();
        },
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [annotations]
      );
      function onRenderSuccess() {
        if (onRenderAnnotationLayerSuccessProps) {
          onRenderAnnotationLayerSuccessProps();
        }
      }
      function onRenderError(error) {
        (0, warning_1.default)(false, `${error}`);
        if (onRenderAnnotationLayerErrorProps) {
          onRenderAnnotationLayerErrorProps(error);
        }
      }
      const viewport = (0, react_1.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
      function renderAnnotationLayer() {
        if (!pdf || !page || !linkService || !annotations) {
          return;
        }
        const { current: layer } = layerElement;
        if (!layer) {
          return;
        }
        const clonedViewport = viewport.clone({ dontFlip: true });
        const annotationLayerParameters = {
          accessibilityManager: null,
          // TODO: Implement this
          annotationCanvasMap: null,
          // TODO: Implement this
          div: layer,
          l10n: null,
          // TODO: Implement this
          page,
          viewport: clonedViewport
        };
        const renderParameters = {
          annotations,
          annotationStorage: pdf.annotationStorage,
          div: layer,
          // See https://github.com/mozilla/pdf.js/issues/17029
          downloadManager: null,
          imageResourcesPath,
          linkService,
          page,
          renderForms,
          viewport: clonedViewport
        };
        layer.innerHTML = "";
        try {
          new pdfjs_js_1.default.AnnotationLayer(annotationLayerParameters).render(renderParameters);
          onRenderSuccess();
        } catch (error) {
          onRenderError(error);
        }
        return () => {
        };
      }
      (0, react_1.useEffect)(
        renderAnnotationLayer,
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [annotations, imageResourcesPath, linkService, page, renderForms, viewport]
      );
      return (0, jsx_runtime_1.jsx)("div", { className: (0, clsx_1.default)("react-pdf__Page__annotations", "annotationLayer"), ref: layerElement });
    }
    exports2.default = AnnotationLayer;
  }
});

// node_modules/react-pdf/dist/cjs/Page.js
var require_Page = __commonJS({
  "node_modules/react-pdf/dist/cjs/Page.js"(exports2) {
    "use strict";
    "use client";
    var __rest = exports2 && exports2.__rest || function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
          if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
            t3[p2[i3]] = s3[p2[i3]];
        }
      return t3;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var make_cancellable_promise_1 = __importDefault(require_cjs2());
    var make_event_props_1 = __importDefault(require_cjs());
    var clsx_1 = __importDefault(require_clsx());
    var merge_refs_1 = __importDefault(require_cjs3());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var warning_1 = __importDefault(require_warning());
    var PageContext_js_1 = __importDefault(require_PageContext());
    var Message_js_1 = __importDefault(require_Message());
    var PageCanvas_js_1 = __importDefault(require_PageCanvas());
    var PageSVG_js_1 = __importDefault(require_PageSVG());
    var TextLayer_js_1 = __importDefault(require_TextLayer());
    var AnnotationLayer_js_1 = __importDefault(require_AnnotationLayer());
    var utils_js_1 = require_utils();
    var useDocumentContext_js_1 = __importDefault(require_useDocumentContext());
    var useResolver_js_1 = __importDefault(require_useResolver());
    var defaultScale = 1;
    function Page2(props) {
      const documentContext = (0, useDocumentContext_js_1.default)();
      const mergedProps = Object.assign(Object.assign({}, documentContext), props);
      const { _className = "react-pdf__Page", _enableRegisterUnregisterPage = true, canvasBackground, canvasRef, children, className, customRenderer: CustomRenderer, customTextRenderer, devicePixelRatio, error = "Failed to load the page.", height, inputRef, loading = "Loading page…", noData = "No page specified.", onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps, onGetTextError: onGetTextErrorProps, onGetTextSuccess: onGetTextSuccessProps, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, onRenderTextLayerError: onRenderTextLayerErrorProps, onRenderTextLayerSuccess: onRenderTextLayerSuccessProps, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf, registerPage, renderAnnotationLayer: renderAnnotationLayerProps = true, renderForms = false, renderMode = "canvas", renderTextLayer: renderTextLayerProps = true, rotate: rotateProps, scale: scaleProps = defaultScale, unregisterPage, width } = mergedProps, otherProps = __rest(mergedProps, ["_className", "_enableRegisterUnregisterPage", "canvasBackground", "canvasRef", "children", "className", "customRenderer", "customTextRenderer", "devicePixelRatio", "error", "height", "inputRef", "loading", "noData", "onGetAnnotationsError", "onGetAnnotationsSuccess", "onGetStructTreeError", "onGetStructTreeSuccess", "onGetTextError", "onGetTextSuccess", "onLoadError", "onLoadSuccess", "onRenderAnnotationLayerError", "onRenderAnnotationLayerSuccess", "onRenderError", "onRenderSuccess", "onRenderTextLayerError", "onRenderTextLayerSuccess", "pageIndex", "pageNumber", "pdf", "registerPage", "renderAnnotationLayer", "renderForms", "renderMode", "renderTextLayer", "rotate", "scale", "unregisterPage", "width"]);
      const [pageState, pageDispatch] = (0, useResolver_js_1.default)();
      const { value: page, error: pageError } = pageState;
      const pageElement = (0, react_1.useRef)(null);
      (0, tiny_invariant_1.default)(pdf, "Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
      const pageIndex = (0, utils_js_1.isProvided)(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;
      const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : (0, utils_js_1.isProvided)(pageIndexProps) ? pageIndexProps + 1 : null;
      const rotate = rotateProps !== null && rotateProps !== void 0 ? rotateProps : page ? page.rotate : null;
      const scale = (0, react_1.useMemo)(() => {
        if (!page) {
          return null;
        }
        let pageScale = 1;
        const scaleWithDefault = scaleProps !== null && scaleProps !== void 0 ? scaleProps : defaultScale;
        if (width || height) {
          const viewport = page.getViewport({ scale: 1, rotation: rotate });
          if (width) {
            pageScale = width / viewport.width;
          } else if (height) {
            pageScale = height / viewport.height;
          }
        }
        return scaleWithDefault * pageScale;
      }, [height, page, rotate, scaleProps, width]);
      function hook() {
        return () => {
          if (!(0, utils_js_1.isProvided)(pageIndex)) {
            return;
          }
          if (_enableRegisterUnregisterPage && unregisterPage) {
            unregisterPage(pageIndex);
          }
        };
      }
      (0, react_1.useEffect)(hook, [_enableRegisterUnregisterPage, pdf, pageIndex, unregisterPage]);
      function onLoadSuccess() {
        if (onLoadSuccessProps) {
          if (!page || !scale) {
            return;
          }
          onLoadSuccessProps((0, utils_js_1.makePageCallback)(page, scale));
        }
        if (_enableRegisterUnregisterPage && registerPage) {
          if (!(0, utils_js_1.isProvided)(pageIndex) || !pageElement.current) {
            return;
          }
          registerPage(pageIndex, pageElement.current);
        }
      }
      function onLoadError() {
        if (!pageError) {
          return;
        }
        (0, warning_1.default)(false, pageError.toString());
        if (onLoadErrorProps) {
          onLoadErrorProps(pageError);
        }
      }
      function resetPage() {
        pageDispatch({ type: "RESET" });
      }
      (0, react_1.useEffect)(resetPage, [pageDispatch, pdf, pageIndex]);
      function loadPage() {
        if (!pdf || !pageNumber) {
          return;
        }
        const cancellable = (0, make_cancellable_promise_1.default)(pdf.getPage(pageNumber));
        const runningTask = cancellable;
        cancellable.promise.then((nextPage) => {
          pageDispatch({ type: "RESOLVE", value: nextPage });
        }).catch((error2) => {
          pageDispatch({ type: "REJECT", error: error2 });
        });
        return () => (0, utils_js_1.cancelRunningTask)(runningTask);
      }
      (0, react_1.useEffect)(loadPage, [pageDispatch, pdf, pageIndex, pageNumber, registerPage]);
      (0, react_1.useEffect)(
        () => {
          if (page === void 0) {
            return;
          }
          if (page === false) {
            onLoadError();
            return;
          }
          onLoadSuccess();
        },
        // Ommitted callbacks so they are not called every time they change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [page, scale]
      );
      const childContext = (0, react_1.useMemo)(() => (
        // Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that
        page && (0, utils_js_1.isProvided)(pageIndex) && pageNumber && (0, utils_js_1.isProvided)(rotate) && (0, utils_js_1.isProvided)(scale) ? {
          _className,
          canvasBackground,
          customTextRenderer,
          devicePixelRatio,
          onGetAnnotationsError: onGetAnnotationsErrorProps,
          onGetAnnotationsSuccess: onGetAnnotationsSuccessProps,
          onGetStructTreeError: onGetStructTreeErrorProps,
          onGetStructTreeSuccess: onGetStructTreeSuccessProps,
          onGetTextError: onGetTextErrorProps,
          onGetTextSuccess: onGetTextSuccessProps,
          onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps,
          onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps,
          onRenderError: onRenderErrorProps,
          onRenderSuccess: onRenderSuccessProps,
          onRenderTextLayerError: onRenderTextLayerErrorProps,
          onRenderTextLayerSuccess: onRenderTextLayerSuccessProps,
          page,
          pageIndex,
          pageNumber,
          renderForms,
          renderTextLayer: renderTextLayerProps,
          rotate,
          scale
        } : null
      ), [
        _className,
        canvasBackground,
        customTextRenderer,
        devicePixelRatio,
        onGetAnnotationsErrorProps,
        onGetAnnotationsSuccessProps,
        onGetStructTreeErrorProps,
        onGetStructTreeSuccessProps,
        onGetTextErrorProps,
        onGetTextSuccessProps,
        onRenderAnnotationLayerErrorProps,
        onRenderAnnotationLayerSuccessProps,
        onRenderErrorProps,
        onRenderSuccessProps,
        onRenderTextLayerErrorProps,
        onRenderTextLayerSuccessProps,
        page,
        pageIndex,
        pageNumber,
        renderForms,
        renderTextLayerProps,
        rotate,
        scale
      ]);
      const eventProps = (0, react_1.useMemo)(() => (0, make_event_props_1.default)(otherProps, () => page ? scale ? (0, utils_js_1.makePageCallback)(page, scale) : void 0 : page), [otherProps, page, scale]);
      const pageKey = `${pageIndex}@${scale}/${rotate}`;
      const pageKeyNoScale = `${pageIndex}/${rotate}`;
      function renderMainLayer() {
        switch (renderMode) {
          case "custom": {
            (0, tiny_invariant_1.default)(CustomRenderer, `renderMode was set to "custom", but no customRenderer was passed.`);
            return (0, jsx_runtime_1.jsx)(CustomRenderer, {}, `${pageKey}_custom`);
          }
          case "none":
            return null;
          case "svg":
            return (0, jsx_runtime_1.jsx)(PageSVG_js_1.default, {}, `${pageKeyNoScale}_svg`);
          case "canvas":
          default:
            return (0, jsx_runtime_1.jsx)(PageCanvas_js_1.default, { canvasRef }, `${pageKey}_canvas`);
        }
      }
      function renderTextLayer() {
        if (!renderTextLayerProps) {
          return null;
        }
        return (0, jsx_runtime_1.jsx)(TextLayer_js_1.default, {}, `${pageKey}_text`);
      }
      function renderAnnotationLayer() {
        if (!renderAnnotationLayerProps) {
          return null;
        }
        return (0, jsx_runtime_1.jsx)(AnnotationLayer_js_1.default, {}, `${pageKey}_annotations`);
      }
      function renderChildren() {
        return (0, jsx_runtime_1.jsxs)(PageContext_js_1.default.Provider, { value: childContext, children: [renderMainLayer(), renderTextLayer(), renderAnnotationLayer(), children] });
      }
      function renderContent() {
        if (!pageNumber) {
          return (0, jsx_runtime_1.jsx)(Message_js_1.default, { type: "no-data", children: typeof noData === "function" ? noData() : noData });
        }
        if (pdf === null || page === void 0 || page === null) {
          return (0, jsx_runtime_1.jsx)(Message_js_1.default, { type: "loading", children: typeof loading === "function" ? loading() : loading });
        }
        if (pdf === false || page === false) {
          return (0, jsx_runtime_1.jsx)(Message_js_1.default, { type: "error", children: typeof error === "function" ? error() : error });
        }
        return renderChildren();
      }
      return (0, jsx_runtime_1.jsx)("div", Object.assign({ className: (0, clsx_1.default)(_className, className), "data-page-number": pageNumber, ref: (0, merge_refs_1.default)(inputRef, pageElement), style: {
        ["--scale-factor"]: `${scale}`,
        backgroundColor: canvasBackground || "white",
        position: "relative",
        minWidth: "min-content",
        minHeight: "min-content"
      } }, eventProps, { children: renderContent() }));
    }
    exports2.default = Page2;
  }
});

// node_modules/react-pdf/dist/cjs/Thumbnail.js
var require_Thumbnail = __commonJS({
  "node_modules/react-pdf/dist/cjs/Thumbnail.js"(exports2) {
    "use strict";
    "use client";
    var __rest = exports2 && exports2.__rest || function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s3); i3 < p2.length; i3++) {
          if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i3]))
            t3[p2[i3]] = s3[p2[i3]];
        }
      return t3;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var clsx_1 = __importDefault(require_clsx());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var Page_js_1 = __importDefault(require_Page());
    var utils_js_1 = require_utils();
    var useDocumentContext_js_1 = __importDefault(require_useDocumentContext());
    function Thumbnail(props) {
      const documentContext = (0, useDocumentContext_js_1.default)();
      const mergedProps = Object.assign(Object.assign({}, documentContext), props);
      const { className, linkService, onItemClick, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf } = mergedProps;
      (0, tiny_invariant_1.default)(pdf, "Attempted to load a thumbnail, but no document was specified. Wrap <Thumbnail /> in a <Document /> or pass explicit `pdf` prop.");
      const pageIndex = (0, utils_js_1.isProvided)(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;
      const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : (0, utils_js_1.isProvided)(pageIndexProps) ? pageIndexProps + 1 : null;
      function onClick(event) {
        event.preventDefault();
        if (!(0, utils_js_1.isProvided)(pageIndex) || !pageNumber) {
          return;
        }
        (0, tiny_invariant_1.default)(onItemClick || linkService, "Either onItemClick callback or linkService must be defined in order to navigate to an outline item.");
        if (onItemClick) {
          onItemClick({
            pageIndex,
            pageNumber
          });
        } else if (linkService) {
          linkService.goToPage(pageNumber);
        }
      }
      const { className: classNameProps, onItemClick: onItemClickProps } = props, pageProps = __rest(props, ["className", "onItemClick"]);
      return (
        /* eslint-disable-next-line jsx-a11y/anchor-is-valid */
        (0, jsx_runtime_1.jsx)("a", { className: (0, clsx_1.default)("react-pdf__Thumbnail", className), href: pageNumber ? "#" : void 0, onClick, children: (0, jsx_runtime_1.jsx)(Page_js_1.default, Object.assign({}, pageProps, { _className: "react-pdf__Thumbnail__page", _enableRegisterUnregisterPage: false, renderAnnotationLayer: false, renderTextLayer: false })) })
      );
    }
    exports2.default = Thumbnail;
  }
});

// node_modules/react-pdf/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/react-pdf/dist/cjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PasswordResponses = exports2.usePageContext = exports2.useOutlineContext = exports2.useDocumentContext = exports2.Thumbnail = exports2.Page = exports2.Outline = exports2.Document = exports2.pdfjs = void 0;
    var pdfjs_js_1 = __importDefault(require_pdfjs());
    exports2.pdfjs = pdfjs_js_1.default;
    var Document_js_1 = __importDefault(require_Document());
    exports2.Document = Document_js_1.default;
    var Outline_js_1 = __importDefault(require_Outline());
    exports2.Outline = Outline_js_1.default;
    var Page_js_1 = __importDefault(require_Page());
    exports2.Page = Page_js_1.default;
    var Thumbnail_js_1 = __importDefault(require_Thumbnail());
    exports2.Thumbnail = Thumbnail_js_1.default;
    var useDocumentContext_js_1 = __importDefault(require_useDocumentContext());
    exports2.useDocumentContext = useDocumentContext_js_1.default;
    var useOutlineContext_js_1 = __importDefault(require_useOutlineContext());
    exports2.useOutlineContext = useOutlineContext_js_1.default;
    var usePageContext_js_1 = __importDefault(require_usePageContext());
    exports2.usePageContext = usePageContext_js_1.default;
    var PasswordResponses_js_1 = __importDefault(require_PasswordResponses());
    exports2.PasswordResponses = PasswordResponses_js_1.default;
    var utils_js_1 = require_utils();
    (0, utils_js_1.displayWorkerWarning)();
    pdfjs_js_1.default.GlobalWorkerOptions.workerSrc = "pdf.worker.js";
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/state/actions.js
var require_actions2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/state/actions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setCurrentPage = exports2.SET_CURRENT_PAGE = exports2.setNumPages = exports2.SET_NUM_PAGES = exports2.setPDFPaginated = exports2.SET_PDF_PAGINATED = exports2.setZoomLevel = exports2.SET_ZOOM_LEVEL = void 0;
    exports2.SET_ZOOM_LEVEL = "SET_ZOOM_LEVEL";
    exports2.setZoomLevel = function(value) {
      return {
        type: exports2.SET_ZOOM_LEVEL,
        value
      };
    };
    exports2.SET_PDF_PAGINATED = "SET_PDF_PAGINATED";
    exports2.setPDFPaginated = function(value) {
      return {
        type: exports2.SET_PDF_PAGINATED,
        value
      };
    };
    exports2.SET_NUM_PAGES = "SET_NUM_PAGES";
    exports2.setNumPages = function(value) {
      return {
        type: exports2.SET_NUM_PAGES,
        value
      };
    };
    exports2.SET_CURRENT_PAGE = "SET_CURRENT_PAGE";
    exports2.setCurrentPage = function(value) {
      return {
        type: exports2.SET_CURRENT_PAGE,
        value
      };
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/state/reducer.js
var require_reducer2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/state/reducer.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reducer = exports2.initialPDFState = void 0;
    var actions_1 = require_actions2();
    exports2.initialPDFState = {
      zoomLevel: 1,
      paginated: true,
      numPages: 0,
      currentPage: 1
    };
    exports2.reducer = function(state, action) {
      if (state === void 0) {
        state = exports2.initialPDFState;
      }
      switch (action.type) {
        case actions_1.SET_ZOOM_LEVEL: {
          var value = action.value;
          return __assign(__assign({}, state), { zoomLevel: value });
        }
        case actions_1.SET_PDF_PAGINATED: {
          var value = action.value;
          return __assign(__assign({}, state), { paginated: value });
        }
        case actions_1.SET_NUM_PAGES: {
          var value = action.value;
          return __assign(__assign({}, state), { numPages: value });
        }
        case actions_1.SET_CURRENT_PAGE: {
          var value = action.value;
          return __assign(__assign({}, state), { currentPage: value });
        }
        default:
          return state;
      }
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/state/index.js
var require_state2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/state/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PDFProvider = exports2.PDFContext = void 0;
    var react_1 = __importStar(require_react());
    var reducer_1 = require_reducer2();
    var PDFContext = react_1.createContext({ state: reducer_1.initialPDFState, dispatch: function() {
      return null;
    } });
    exports2.PDFContext = PDFContext;
    var PDFProvider = function(_a3) {
      var children = _a3.children, mainState = _a3.mainState;
      var _b2 = react_1.useReducer(reducer_1.reducer, __assign(__assign({}, reducer_1.initialPDFState), { mainState })), state = _b2[0], dispatch = _b2[1];
      return react_1.default.createElement(PDFContext.Provider, { value: { state, dispatch } }, children);
    };
    exports2.PDFProvider = PDFProvider;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFSinglePage.js
var require_PDFSinglePage = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFSinglePage.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var react_pdf_1 = require_cjs4();
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state2();
    var PDFSinglePage = function(props) {
      var pageNum = props.pageNum;
      var _a3 = react_1.useContext(state_1.PDFContext).state, mainState = _a3.mainState, paginated = _a3.paginated, zoomLevel = _a3.zoomLevel, numPages = _a3.numPages, currentPage = _a3.currentPage;
      var rendererRect = (mainState === null || mainState === void 0 ? void 0 : mainState.rendererRect) || null;
      var _pageNum = pageNum || currentPage;
      return react_1.default.createElement(
        PageWrapper,
        { id: "pdf-page-wrapper", last: _pageNum >= numPages },
        !paginated && react_1.default.createElement(
          PageTag,
          { id: "pdf-page-info" },
          "Page ",
          _pageNum,
          "/",
          numPages
        ),
        react_1.default.createElement(react_pdf_1.Page, { pageNumber: _pageNum || currentPage, scale: zoomLevel, height: ((rendererRect === null || rendererRect === void 0 ? void 0 : rendererRect.height) || 100) - 100, width: ((rendererRect === null || rendererRect === void 0 ? void 0 : rendererRect.width) || 100) - 100 })
      );
    };
    exports2.default = PDFSinglePage;
    var PageWrapper = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  margin: 20px 0;\n"], ["\n  margin: 20px 0;\n"])));
    var PageTag = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  padding: 0 0 10px 10px;\n  color: ", ";\n  font-size: 14px;\n  text-align: left;\n\n  @media (max-width: 768px) {\n    font-size: 10px;\n  }\n"], ["\n  padding: 0 0 10px 10px;\n  color: ", ";\n  font-size: 14px;\n  text-align: left;\n\n  @media (max-width: 768px) {\n    font-size: 10px;\n  }\n"])), function(props) {
      return props.theme.text_tertiary;
    });
    var templateObject_1;
    var templateObject_2;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFAllPages.js
var require_PDFAllPages = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFAllPages.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PDFAllPages = void 0;
    var react_1 = __importStar(require_react());
    var state_1 = require_state2();
    var PDFSinglePage_1 = __importDefault(require_PDFSinglePage());
    exports2.PDFAllPages = function(props) {
      var numPages = react_1.useContext(state_1.PDFContext).state.numPages;
      var PagesArray = [];
      for (var i3 = 0; i3 < numPages; i3++) {
        PagesArray.push(react_1.default.createElement(PDFSinglePage_1.default, { key: i3 + 1, pageNum: i3 + 1 }));
      }
      return react_1.default.createElement(react_1.default.Fragment, null, PagesArray);
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFPages.js
var require_PDFPages = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/pages/PDFPages.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var react_pdf_1 = require_cjs4();
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var state_1 = require_state2();
    var actions_1 = require_actions2();
    var reducer_1 = require_reducer2();
    var PDFAllPages_1 = require_PDFAllPages();
    var PDFSinglePage_1 = __importDefault(require_PDFSinglePage());
    var PDFPages = function() {
      var _a3 = react_1.useContext(state_1.PDFContext), _b2 = _a3.state, mainState = _b2.mainState, paginated = _b2.paginated, dispatch = _a3.dispatch;
      var currentDocument = (mainState === null || mainState === void 0 ? void 0 : mainState.currentDocument) || null;
      react_1.useEffect(function() {
        dispatch(actions_1.setNumPages(reducer_1.initialPDFState.numPages));
      }, [currentDocument]);
      if (!currentDocument || currentDocument.fileData === void 0)
        return null;
      return react_1.default.createElement(DocumentPDF, { file: currentDocument.fileData, onLoadSuccess: function(_a4) {
        var numPages = _a4.numPages;
        return dispatch(actions_1.setNumPages(numPages));
      }, loading: react_1.default.createElement("span", null, "Loading...") }, paginated ? react_1.default.createElement(PDFSinglePage_1.default, null) : react_1.default.createElement(PDFAllPages_1.PDFAllPages, null));
    };
    var DocumentPDF = styled_components_1.default(react_pdf_1.Document)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  margin: 0 auto;\n"], ["\n  display: flex;\n  flex-direction: column;\n  margin: 0 auto;\n"])));
    exports2.default = PDFPages;
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/icons/index.js
var require_icons2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/icons/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TogglePaginationPDFIcon = exports2.ResetZoomPDFIcon = exports2.ZoomOutPDFIcon = exports2.ZoomInPDFIcon = exports2.DownloadPDFIcon = exports2.NextPDFNavIcon = exports2.PrevPDFNavIcon = void 0;
    var react_1 = __importDefault(require_react());
    exports2.PrevPDFNavIcon = function(props) {
      return react_1.default.createElement(PDFNavArrow, __assign({}, props, { reverse: true }));
    };
    exports2.NextPDFNavIcon = function(props) {
      return react_1.default.createElement(PDFNavArrow, __assign({}, props));
    };
    var PDFNavArrow = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", style: { transform: reverse ? "rotate(180deg)" : "" }, viewBox: "0 0 12 12", version: "1.1" },
        react_1.default.createElement(
          "g",
          { id: "Icons", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" },
          react_1.default.createElement(
            "g",
            { id: "Rounded", transform: "translate(-548.000000, -1000.000000)" },
            react_1.default.createElement(
              "g",
              { id: "AV", transform: "translate(100.000000, 852.000000)" },
              react_1.default.createElement(
                "g",
                { id: "-Round-/-AV-/-skip_next", transform: "translate(442.000000, 142.000000)" },
                react_1.default.createElement(
                  "g",
                  null,
                  react_1.default.createElement("rect", { id: "Rectangle-Copy-52", x: "0", y: "0", width: "24", height: "24" }),
                  react_1.default.createElement("path", { d: "M7.58,16.89 L13.35,12.82 C13.91,12.42 13.91,11.58 13.35,11.19 L7.58,7.11 C6.91,6.65 6,7.12 6,7.93 L6,16.07 C6,16.88 6.91,17.35 7.58,16.89 Z M16,7 L16,17 C16,17.55 16.45,18 17,18 C17.55,18 18,17.55 18,17 L18,7 C18,6.45 17.55,6 17,6 C16.45,6 16,6.45 16,7 Z", id: "icon_color", fill: color || "#aaa" })
                )
              )
            )
          )
        )
      );
    };
    exports2.DownloadPDFIcon = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", style: { transform: reverse ? "rotate(180deg)" : "" }, id: "Layer_1", viewBox: "0 0 24 24" },
        react_1.default.createElement("path", { d: "M20.57,9.43A8,8,0,0,0,5.26,10,5,5,0,1,0,5,20h5V18H5a3,3,0,0,1,0-6,3.1,3.1,0,0,1,.79.12l1.12.31.14-1.15a6,6,0,0,1,11.74-.82l.15.54.54.16A3.46,3.46,0,0,1,22,14.5,3.5,3.5,0,0,1,18.5,18H16v2h2.5A5.48,5.48,0,0,0,20.57,9.43Z", fill: color || "#aaa" }),
        react_1.default.createElement("polygon", { points: "12 11 12 15.59 10.71 14.29 9.29 15.71 13 19.41 16.71 15.71 15.29 14.29 14 15.59 14 11 12 11", fill: color || "#aaa" })
      );
    };
    exports2.ZoomInPDFIcon = function(props) {
      return react_1.default.createElement(ZoomPDFIcon, __assign({}, props));
    };
    exports2.ZoomOutPDFIcon = function(props) {
      return react_1.default.createElement(ZoomPDFIcon, __assign({}, props, { reverse: true }));
    };
    var ZoomPDFIcon = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", viewBox: "0 0 32 32", version: "1.1" },
        react_1.default.createElement(
          "g",
          { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" },
          react_1.default.createElement(
            "g",
            { id: "search-plus-icon", fill: color || "#aaa" },
            react_1.default.createElement("path", { id: "search-plus", d: reverse ? "M 13 13 L 16 13 L 19 13 L 19 16 L 16 16 L 13 16 L 10 16 L 10 13 Z M 19.4271 21.4271 C 18.0372 22.4175 16.3367 23 14.5 23 C 9.8056 23 6 19.1944 6 14.5 C 6 9.8056 9.8056 6 14.5 6 C 19.1944 6 23 9.8056 23 14.5 C 23 16.3367 22.4175 18.0372 21.4271 19.4271 L 27.0119 25.0119 C 27.5621 25.5621 27.5575 26.4425 27.0117 26.9883 L 26.9883 27.0117 C 26.4439 27.5561 25.5576 27.5576 25.0119 27.0119 L 19.4271 21.4271 L 19.4271 21.4271 L 19.4271 21.4271 Z M 14.5 21 C 18.0899 21 21 18.0899 21 14.5 C 21 10.9101 18.0899 8 14.5 8 C 10.9101 8 8 10.9101 8 14.5 C 8 18.0899 10.9101 21 14.5 21 L 14.5 21 Z" : "M 13 13 L 13 10 L 16 10 L 16 13 L 19 13 L 19 16 L 16 16 L 16 19 L 13 19 L 13 16 L 10 16 L 10 13 Z M 19.4271 21.4271 C 18.0372 22.4175 16.3367 23 14.5 23 C 9.8056 23 6 19.1944 6 14.5 C 6 9.8056 9.8056 6 14.5 6 C 19.1944 6 23 9.8056 23 14.5 C 23 16.3367 22.4175 18.0372 21.4271 19.4271 L 27.0119 25.0119 C 27.5621 25.5621 27.5575 26.4425 27.0117 26.9883 L 26.9883 27.0117 C 26.4439 27.5561 25.5576 27.5576 25.0119 27.0119 L 19.4271 21.4271 L 19.4271 21.4271 L 19.4271 21.4271 Z M 14.5 21 C 18.0899 21 21 18.0899 21 14.5 C 21 10.9101 18.0899 8 14.5 8 C 10.9101 8 8 10.9101 8 14.5 C 8 18.0899 10.9101 21 14.5 21 L 14.5 21 Z" })
          )
        )
      );
    };
    exports2.ResetZoomPDFIcon = function(props) {
      var color = props.color, size = props.size;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", viewBox: "0 0 24 24" },
        react_1.default.createElement("path", { fill: color || "#aaa", d: "M9.29,13.29,4,18.59V17a1,1,0,0,0-2,0v4a1,1,0,0,0,.08.38,1,1,0,0,0,.54.54A1,1,0,0,0,3,22H7a1,1,0,0,0,0-2H5.41l5.3-5.29a1,1,0,0,0-1.42-1.42ZM5.41,4H7A1,1,0,0,0,7,2H3a1,1,0,0,0-.38.08,1,1,0,0,0-.54.54A1,1,0,0,0,2,3V7A1,1,0,0,0,4,7V5.41l5.29,5.3a1,1,0,0,0,1.42,0,1,1,0,0,0,0-1.42ZM21,16a1,1,0,0,0-1,1v1.59l-5.29-5.3a1,1,0,0,0-1.42,1.42L18.59,20H17a1,1,0,0,0,0,2h4a1,1,0,0,0,.38-.08,1,1,0,0,0,.54-.54A1,1,0,0,0,22,21V17A1,1,0,0,0,21,16Zm.92-13.38a1,1,0,0,0-.54-.54A1,1,0,0,0,21,2H17a1,1,0,0,0,0,2h1.59l-5.3,5.29a1,1,0,0,0,0,1.42,1,1,0,0,0,1.42,0L20,5.41V7a1,1,0,0,0,2,0V3A1,1,0,0,0,21.92,2.62Z" })
      );
    };
    exports2.TogglePaginationPDFIcon = function(props) {
      var color = props.color, size = props.size, reverse = props.reverse;
      return react_1.default.createElement(
        "svg",
        { width: size || "100%", height: size || "100%", style: { transform: reverse ? "rotate(90deg)" : "" }, version: "1.1", id: "Scroll_1", viewBox: "0 0 297 297", xmlSpace: "preserve" },
        react_1.default.createElement("path", { fill: color || "#aaa", d: "M206.004,200.723h-31.231V96.277h31.231c0.005,0,0.014,0,0.019,0c5.289,0,9.575-4.287,9.575-9.574\n  c0-2.342-0.841-4.488-2.236-6.151L156.168,3.851C154.36,1.428,151.515,0,148.492,0c-3.023,0-5.868,1.428-7.675,3.851L83.302,80.98\n  c-2.166,2.902-2.507,6.779-0.883,10.017c1.624,3.236,4.936,5.28,8.559,5.28h31.231v104.445H90.978c-3.623,0-6.934,2.044-8.559,5.28\n  c-1.624,3.237-1.283,7.114,0.883,10.017l57.513,77.129c1.808,2.424,4.652,3.852,7.675,3.852c3.023,0,5.868-1.428,7.676-3.852\n  l57.514-77.129c2.164-2.902,2.507-6.779,0.883-10.017C212.938,202.767,209.627,200.723,206.004,200.723z" })
      );
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/PDFPagination.js
var require_PDFPagination = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/PDFPagination.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var common_1 = require_common();
    var state_1 = require_state2();
    var actions_1 = require_actions2();
    var icons_1 = require_icons2();
    var PDFPagination = function() {
      var _a3 = react_1.useContext(state_1.PDFContext), _b2 = _a3.state, currentPage = _b2.currentPage, numPages = _b2.numPages, dispatch = _a3.dispatch;
      return react_1.default.createElement(
        Container,
        { id: "pdf-pagination" },
        react_1.default.createElement(
          PageNavButtonLeft,
          { id: "pdf-pagination-prev", onClick: function() {
            return dispatch(actions_1.setCurrentPage(currentPage - 1));
          }, disabled: currentPage === 1 },
          react_1.default.createElement(icons_1.PrevPDFNavIcon, { color: "#000", size: "50%" })
        ),
        react_1.default.createElement(
          PageTag,
          { id: "pdf-pagination-info" },
          "Page ",
          currentPage,
          "/",
          numPages
        ),
        react_1.default.createElement(
          PageNavButtonRight,
          { id: "pdf-pagination-next", onClick: function() {
            return dispatch(actions_1.setCurrentPage(currentPage + 1));
          }, disabled: currentPage >= numPages },
          react_1.default.createElement(icons_1.NextPDFNavIcon, { color: "#000", size: "50%" })
        )
      );
    };
    exports2.default = PDFPagination;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n"], ["\n  display: flex;\n  align-items: center;\n"])));
    var PageNavButtonLeft = styled_components_1.default(common_1.Button)(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  margin: 0 5px;\n\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"], ["\n  width: 30px;\n  height: 30px;\n  margin: 0 5px;\n\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"])));
    var PageNavButtonRight = styled_components_1.default(PageNavButtonLeft)(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  margin: 0 20px 0 5px;\n"], ["\n  margin: 0 20px 0 5px;\n"])));
    var PageTag = styled_components_1.default.div(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  color: ", ";\n  font-size: 14px;\n  text-align: left;\n\n  @media (max-width: 768px) {\n    font-size: 10px;\n  }\n"], ["\n  color: ", ";\n  font-size: 14px;\n  text-align: left;\n\n  @media (max-width: 768px) {\n    font-size: 10px;\n  }\n"])), function(props) {
      return props.theme.text_primary;
    });
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/components/PDFControls.js
var require_PDFControls = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/components/PDFControls.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var common_1 = require_common();
    var state_1 = require_state2();
    var actions_1 = require_actions2();
    var reducer_1 = require_reducer2();
    var icons_1 = require_icons2();
    var PDFPagination_1 = __importDefault(require_PDFPagination());
    var PDFControls = function() {
      var _a3 = react_1.useContext(state_1.PDFContext), _b2 = _a3.state, mainState = _b2.mainState, paginated = _b2.paginated, zoomLevel = _b2.zoomLevel, numPages = _b2.numPages, dispatch = _a3.dispatch;
      var currentDocument = (mainState === null || mainState === void 0 ? void 0 : mainState.currentDocument) || null;
      return react_1.default.createElement(
        Container,
        { id: "pdf-controls" },
        paginated && numPages > 1 && react_1.default.createElement(PDFPagination_1.default, null),
        (currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData) && react_1.default.createElement(
          DownloadButton,
          { id: "pdf-download", href: currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData, download: currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.uri },
          react_1.default.createElement(icons_1.DownloadPDFIcon, { color: "#000", size: "75%" })
        ),
        react_1.default.createElement(
          ControlButton,
          { id: "pdf-zoom-out", onMouseDown: function() {
            return dispatch(actions_1.setZoomLevel(zoomLevel - 0.1));
          } },
          react_1.default.createElement(icons_1.ZoomOutPDFIcon, { color: "#000", size: "80%" })
        ),
        react_1.default.createElement(
          ControlButton,
          { id: "pdf-zoom-in", onMouseDown: function() {
            return dispatch(actions_1.setZoomLevel(zoomLevel + 0.1));
          } },
          react_1.default.createElement(icons_1.ZoomInPDFIcon, { color: "#000", size: "80%" })
        ),
        react_1.default.createElement(
          ControlButton,
          { id: "pdf-zoom-reset", onMouseDown: function() {
            return dispatch(actions_1.setZoomLevel(reducer_1.initialPDFState.zoomLevel));
          }, disabled: zoomLevel === reducer_1.initialPDFState.zoomLevel },
          react_1.default.createElement(icons_1.ResetZoomPDFIcon, { color: "#000", size: "70%" })
        ),
        numPages > 1 && react_1.default.createElement(
          ControlButton,
          { id: "pdf-toggle-pagination", onMouseDown: function() {
            return dispatch(actions_1.setPDFPaginated(!paginated));
          } },
          react_1.default.createElement(icons_1.TogglePaginationPDFIcon, { color: "#000", size: "70%", reverse: paginated })
        )
      );
    };
    exports2.default = PDFControls;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  position: sticky;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  justify-content: flex-end;\n  padding: 8px;\n  background-color: ", ";\n  box-shadow: 0px 2px 3px #00000033;\n\n  @media (max-width: 768px) {\n    padding: 6px;\n  }\n"], ["\n  display: flex;\n  position: sticky;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  justify-content: flex-end;\n  padding: 8px;\n  background-color: ", ";\n  box-shadow: 0px 2px 3px #00000033;\n\n  @media (max-width: 768px) {\n    padding: 6px;\n  }\n"])), function(props) {
      return props.theme.tertiary;
    });
    var ControlButton = styled_components_1.default(common_1.Button)(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"], ["\n  width: 30px;\n  height: 30px;\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"])));
    var DownloadButton = styled_components_1.default(common_1.LinkButton)(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"], ["\n  width: 30px;\n  height: 30px;\n  @media (max-width: 768px) {\n    width: 25px;\n    height: 25px;\n  }\n"])));
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
  }
});

// node_modules/react-doc-viewer/build/plugins/pdf/index.js
var require_pdf2 = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/pdf/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var pdfjsWorker = __importStar((init_pdf_worker_min(), __toCommonJS(pdf_worker_min_exports)));
    var react_1 = __importDefault(require_react());
    var react_pdf_1 = require_cjs4();
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var PDFPages_1 = __importDefault(require_PDFPages());
    var PDFControls_1 = __importDefault(require_PDFControls());
    var state_1 = require_state2();
    react_pdf_1.pdfjs.GlobalWorkerOptions.workerSrc = pdfjsWorker;
    var PDFRenderer = function(_a3) {
      var mainState = _a3.mainState;
      return react_1.default.createElement(
        state_1.PDFProvider,
        { mainState },
        react_1.default.createElement(
          Container,
          { id: "pdf-renderer", "data-testid": "pdf-renderer" },
          react_1.default.createElement(PDFControls_1.default, null),
          react_1.default.createElement(PDFPages_1.default, null)
        )
      );
    };
    exports2.default = PDFRenderer;
    PDFRenderer.fileTypes = ["pdf", "application/pdf"];
    PDFRenderer.weight = 0;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  overflow-y: auto;\n\n  /* width */\n  &::-webkit-scrollbar {\n    ", ";\n  }\n  /* Track */\n  &::-webkit-scrollbar-track {\n    /* background: ", "; */\n  }\n  /* Handle */\n  &::-webkit-scrollbar-thumb {\n    background: ", ";\n  }\n  /* Handle on hover */\n  &::-webkit-scrollbar-thumb:hover {\n    background: ", ";\n  }\n"], [
      "\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  overflow-y: auto;\n\n  /* width */\n  &::-webkit-scrollbar {\n    ",
      ";\n  }\n  /* Track */\n  &::-webkit-scrollbar-track {\n    /* background: ",
      "; */\n  }\n  /* Handle */\n  &::-webkit-scrollbar-thumb {\n    background: ",
      ";\n  }\n  /* Handle on hover */\n  &::-webkit-scrollbar-thumb:hover {\n    background: ",
      ";\n  }\n"
    ])), function(props) {
      return props.theme.disableThemeScrollbar ? "" : "width: 10px";
    }, function(props) {
      return props.theme.secondary;
    }, function(props) {
      return props.theme.tertiary;
    }, function(props) {
      return props.theme.primary;
    });
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/plugins/png/index.js
var require_png = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/png/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var image_1 = __importDefault(require_image());
    var StyledImageRenderer = styled_components_1.default(image_1.default)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  background-color: white;\n  background-image: linear-gradient(45deg, #e0e0e0 25%, transparent 25%),\n    linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),\n    linear-gradient(45deg, transparent 75%, #e0e0e0 75%),\n    linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);\n  background-size: 20px 20px;\n  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;\n"], ["\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  background-color: white;\n  background-image: linear-gradient(45deg, #e0e0e0 25%, transparent 25%),\n    linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),\n    linear-gradient(45deg, transparent 75%, #e0e0e0 75%),\n    linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);\n  background-size: 20px 20px;\n  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;\n"])));
    var PNGRenderer = function(props) {
      return react_1.default.createElement(StyledImageRenderer, __assign({}, props));
    };
    PNGRenderer.fileTypes = ["png", "image/png"];
    PNGRenderer.weight = 0;
    exports2.default = PNGRenderer;
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/plugins/tiff/tiffToCanvas.js
var require_tiffToCanvas = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/tiff/tiffToCanvas.js"(exports2) {
    "use strict";
    var _this = exports2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseTIFF = void 0;
    var tiffDataView = void 0;
    var littleEndian = void 0;
    var fileDirectories = [];
    var isLittleEndian = function() {
      var BOM = getBytes(2, 0);
      if (BOM === 18761) {
        littleEndian = true;
      } else if (BOM === 19789) {
        littleEndian = false;
      } else {
        throw TypeError("Invalid byte order value.");
      }
      return littleEndian;
    };
    var hasTowel = function() {
      if (getBytes(2, 2) !== 42) {
        throw RangeError("You forgot your towel!");
        return false;
      }
      return true;
    };
    var getFieldTagName = function(fieldTag) {
      var fieldTagNames = {
        // TIFF Baseline
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        // TIFF Extended
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        // EXIF
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        // IPTC
        33723: "IPTC",
        // ICC
        34675: "ICC Profile",
        // XMP
        700: "XMP",
        // GDAL
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        // Photoshop
        34377: "Photoshop"
      };
      var fieldTagName;
      if (fieldTag in fieldTagNames) {
        fieldTagName = fieldTagNames[fieldTag];
      } else {
        fieldTagName = "Tag" + fieldTag;
      }
      return fieldTagName;
    };
    var getFieldTypeName = function(fieldType) {
      var fieldTypeNames = {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
      };
      var fieldTypeName;
      if (fieldType in fieldTypeNames) {
        fieldTypeName = fieldTypeNames[fieldType];
      }
      return fieldTypeName;
    };
    var getFieldTypeLength = function(fieldTypeName) {
      var fieldTypeLength;
      if (["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(fieldTypeName) !== -1) {
        fieldTypeLength = 1;
      } else if (["SHORT", "SSHORT"].indexOf(fieldTypeName) !== -1) {
        fieldTypeLength = 2;
      } else if (["LONG", "SLONG", "FLOAT"].indexOf(fieldTypeName) !== -1) {
        fieldTypeLength = 4;
      } else if (["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(fieldTypeName) !== -1) {
        fieldTypeLength = 8;
      }
      return fieldTypeLength;
    };
    var getBits = function(numBits, byteOffset, bitOffset) {
      bitOffset = bitOffset || 0;
      var extraBytes = Math.floor(bitOffset / 8);
      var newByteOffset = byteOffset + extraBytes;
      var totalBits = bitOffset + numBits;
      var shiftRight = 32 - numBits;
      if (totalBits <= 0) {
        throw RangeError("No bits requested");
      } else if (totalBits <= 8) {
        var shiftLeft = 24 + bitOffset;
        var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);
      } else if (totalBits <= 16) {
        var shiftLeft = 16 + bitOffset;
        var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);
      } else if (totalBits <= 32) {
        var shiftLeft = bitOffset;
        var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);
      } else {
        throw RangeError("Too many bits requested");
      }
      var chunkInfo = {
        bits: rawBits << shiftLeft >>> shiftRight,
        byteOffset: newByteOffset + Math.floor(totalBits / 8),
        bitOffset: totalBits % 8
      };
      return chunkInfo;
    };
    var getBytes = function(numBytes, offset) {
      if (numBytes <= 0) {
        throw RangeError("No bytes requested");
      } else if (numBytes <= 1) {
        return tiffDataView.getUint8(offset, littleEndian);
      } else if (numBytes <= 2) {
        return tiffDataView.getUint16(offset, littleEndian);
      } else if (numBytes <= 3) {
        return tiffDataView.getUint32(offset, littleEndian) >>> 8;
      } else if (numBytes <= 4) {
        return tiffDataView.getUint32(offset, littleEndian);
      } else {
        throw RangeError("Too many bytes requested");
      }
    };
    var getFieldValues = function(fieldTagName, fieldTypeName, typeCount, valueOffset) {
      var fieldValues = [];
      var fieldTypeLength = getFieldTypeLength(fieldTypeName);
      var fieldValueSize = fieldTypeLength * typeCount;
      if (fieldValueSize <= 4) {
        if (littleEndian === false) {
          var value = valueOffset >>> (4 - fieldTypeLength) * 8;
        } else {
          var value = valueOffset;
        }
        fieldValues.push(value);
      } else {
        for (var i3 = 0; i3 < typeCount; i3++) {
          var indexOffset = fieldTypeLength * i3;
          if (fieldTypeLength >= 8) {
            if (["RATIONAL", "SRATIONAL"].indexOf(fieldTypeName) !== -1) {
              fieldValues.push(getBytes(4, valueOffset + indexOffset));
              fieldValues.push(getBytes(4, valueOffset + indexOffset + 4));
            } else {
              throw TypeError("Can't handle this field type or size");
            }
          } else {
            fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));
          }
        }
      }
      if (fieldTypeName === "ASCII") {
        fieldValues.forEach(function(e3, i4, a3) {
          a3[i4] = String.fromCharCode(e3);
        });
      }
      return fieldValues;
    };
    var clampColorSample = function(colorSample, bitsPerSample) {
      var multiplier = Math.pow(2, 8 - bitsPerSample);
      return Math.floor(colorSample * multiplier + (multiplier - 1));
    };
    var makeRGBAFillValue = function(r3, g3, b3, a3) {
      if (typeof a3 === "undefined") {
        a3 = 1;
      }
      return "rgba(" + r3 + ", " + g3 + ", " + b3 + ", " + a3 + ")";
    };
    var parseFileDirectory = function(byteOffset) {
      var numDirEntries = getBytes(2, byteOffset);
      var tiffFields = [];
      for (var i3 = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i3 += 12, entryCount++) {
        var fieldTag = getBytes(2, i3);
        var fieldType = getBytes(2, i3 + 2);
        var typeCount = getBytes(4, i3 + 4);
        var valueOffset = getBytes(4, i3 + 8);
        var fieldTagName = getFieldTagName(fieldTag);
        var fieldTypeName = getFieldTypeName(fieldType);
        var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
        tiffFields[fieldTagName] = { type: fieldTypeName, values: fieldValues };
      }
      fileDirectories.push(tiffFields);
      var nextIFDByteOffset = getBytes(4, i3);
      if (nextIFDByteOffset === 0) {
        return fileDirectories;
      } else {
        return parseFileDirectory(nextIFDByteOffset);
      }
    };
    exports2.parseTIFF = function(tiffArrayBuffer, _canvas2) {
      var canvas = _canvas2 || document.createElement("canvas");
      if (!tiffArrayBuffer)
        return;
      tiffDataView = new DataView(tiffArrayBuffer);
      littleEndian = isLittleEndian(tiffDataView);
      if (!hasTowel(tiffDataView, littleEndian))
        return;
      var firstIFDByteOffset = getBytes(4, 4);
      fileDirectories = parseFileDirectory(firstIFDByteOffset);
      var fileDirectory = fileDirectories[0];
      var imageWidth = fileDirectory.ImageWidth.values[0];
      var imageLength = fileDirectory.ImageLength.values[0];
      canvas.width = imageWidth;
      canvas.height = imageLength;
      var strips = [];
      var compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;
      var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];
      var sampleProperties = [];
      var bitsPerPixel = 0;
      var hasBytesPerPixel = false;
      fileDirectory.BitsPerSample.values.forEach(function(bitsPerSample, i4, bitsPerSampleValues) {
        sampleProperties[i4] = {
          bitsPerSample,
          hasBytesPerSample: false,
          bytesPerSample: void 0
        };
        if (bitsPerSample % 8 === 0) {
          sampleProperties[i4].hasBytesPerSample = true;
          sampleProperties[i4].bytesPerSample = bitsPerSample / 8;
        }
        bitsPerPixel += bitsPerSample;
      }, _this);
      if (bitsPerPixel % 8 === 0) {
        hasBytesPerPixel = true;
        var bytesPerPixel = bitsPerPixel / 8;
      }
      var stripOffsetValues = fileDirectory.StripOffsets.values;
      var numStripOffsetValues = stripOffsetValues.length;
      if (fileDirectory.StripByteCounts) {
        var stripByteCountValues = fileDirectory.StripByteCounts.values;
      } else {
        if (numStripOffsetValues === 1) {
          var stripByteCountValues = [
            Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)
          ];
        } else {
          throw Error("Cannot recover from missing StripByteCounts");
        }
      }
      for (var i3 = 0; i3 < numStripOffsetValues; i3++) {
        var stripOffset = stripOffsetValues[i3];
        strips[i3] = [];
        var stripByteCount = stripByteCountValues[i3];
        for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {
          switch (compression) {
            case 1:
              for (var m3 = 0, pixel = []; m3 < samplesPerPixel; m3++) {
                if (sampleProperties[m3].hasBytesPerSample) {
                  var sampleOffset = sampleProperties[m3].bytesPerSample * m3;
                  pixel.push(getBytes(sampleProperties[m3].bytesPerSample, stripOffset + byteOffset + sampleOffset));
                } else {
                  var sampleInfo = getBits(sampleProperties[m3].bitsPerSample, stripOffset + byteOffset, bitOffset);
                  pixel.push(sampleInfo.bits);
                  byteOffset = sampleInfo.byteOffset - stripOffset;
                  bitOffset = sampleInfo.bitOffset;
                  throw RangeError("Cannot handle sub-byte bits per sample");
                }
              }
              strips[i3].push(pixel);
              if (hasBytesPerPixel) {
                jIncrement = bytesPerPixel;
              } else {
                jIncrement = 0;
                throw RangeError("Cannot handle sub-byte bits per pixel");
              }
              break;
            case 2:
              break;
            case 3:
              break;
            case 4:
              break;
            case 5:
              break;
            case 6:
              break;
            case 7:
              break;
            case 32773:
              if (getHeader) {
                getHeader = false;
                var blockLength = 1;
                var iterations = 1;
                var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);
                if (header >= 0 && header <= 127) {
                  blockLength = header + 1;
                } else if (header >= -127 && header <= -1) {
                  iterations = -header + 1;
                } else {
                  getHeader = true;
                }
              } else {
                var currentByte = getBytes(1, stripOffset + byteOffset);
                for (var m3 = 0; m3 < iterations; m3++) {
                  if (sampleProperties[sample].hasBytesPerSample) {
                    currentSample = currentSample << 8 * numBytes | currentByte;
                    numBytes++;
                    if (numBytes === sampleProperties[sample].bytesPerSample) {
                      pixel.push(currentSample);
                      currentSample = numBytes = 0;
                      sample++;
                    }
                  } else {
                    throw RangeError("Cannot handle sub-byte bits per sample");
                  }
                  if (sample === samplesPerPixel) {
                    strips[i3].push(pixel);
                    pixel = [];
                    sample = 0;
                  }
                }
                blockLength--;
                if (blockLength === 0) {
                  getHeader = true;
                }
              }
              jIncrement = 1;
              break;
            default:
              break;
          }
        }
      }
      if (canvas.getContext) {
        var ctx = canvas.getContext("2d");
        ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0);
        if (fileDirectory.RowsPerStrip) {
          var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];
        } else {
          var rowsPerStrip = imageLength;
        }
        var numStrips = strips.length;
        var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
        var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;
        var numRowsInStrip = rowsPerStrip;
        var numRowsInPreviousStrip = 0;
        var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];
        var extraSamplesValues = [];
        var numExtraSamples = 0;
        if (fileDirectory.ExtraSamples) {
          extraSamplesValues = fileDirectory.ExtraSamples.values;
          numExtraSamples = extraSamplesValues.length;
        }
        if (fileDirectory.ColorMap) {
          var colorMapValues = fileDirectory.ColorMap.values;
          var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
        }
        for (var i3 = 0; i3 < numStrips; i3++) {
          if (i3 + 1 === numStrips) {
            numRowsInStrip = rowsInLastStrip;
          }
          var numPixels = strips[i3].length;
          var yPadding = numRowsInPreviousStrip * i3;
          for (var y3 = 0, j3 = 0; y3 < numRowsInStrip, j3 < numPixels; y3++) {
            for (var x3 = 0; x3 < imageWidth; x3++, j3++) {
              var pixelSamples = strips[i3][j3];
              var red = 0;
              var green = 0;
              var blue = 0;
              var opacity = 1;
              if (numExtraSamples > 0) {
                for (var k3 = 0; k3 < numExtraSamples; k3++) {
                  if (extraSamplesValues[k3] === 1 || extraSamplesValues[k3] === 2) {
                    opacity = pixelSamples[3 + k3] / 256;
                    break;
                  }
                }
              }
              switch (photometricInterpretation) {
                case 0:
                  if (sampleProperties[0].hasBytesPerSample) {
                    var invertValue = Math.pow(16, sampleProperties[0].bytesPerSample * 2);
                  }
                  pixelSamples.forEach(function(sample2, index, samples) {
                    samples[index] = invertValue - sample2;
                  });
                case 1:
                  red = green = blue = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                  break;
                case 2:
                  red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                  green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                  blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                  break;
                case 3:
                  if (colorMapValues === void 0) {
                    throw Error("Palette image missing color map");
                  }
                  var colorMapIndex = pixelSamples[0];
                  red = clampColorSample(colorMapValues[colorMapIndex], 16);
                  green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                  blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                  break;
                case 4:
                  throw RangeError("Not Yet Implemented: Transparency mask");
                  break;
                case 5:
                  throw RangeError("Not Yet Implemented: CMYK");
                  break;
                case 6:
                  throw RangeError("Not Yet Implemented: YCbCr");
                  break;
                case 8:
                  throw RangeError("Not Yet Implemented: CIELab");
                  break;
                default:
                  throw RangeError("Unknown Photometric Interpretation:", photometricInterpretation);
                  break;
              }
              ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);
              ctx.fillRect(x3, yPadding + y3, 1, 1);
            }
          }
          numRowsInPreviousStrip = numRowsInStrip;
        }
      }
      return canvas;
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/tiff/index.js
var require_tiff = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/tiff/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importStar(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var fileLoaders_1 = require_fileLoaders();
    var image_1 = __importDefault(require_image());
    var tiffToCanvas_1 = require_tiffToCanvas();
    var TIFFRenderer = function(props) {
      var currentDocument = props.mainState.currentDocument;
      var _a3 = react_1.useState(false), loadedCanvas = _a3[0], setLoadedCanvas = _a3[1];
      var _b2 = react_1.useState(false), corruptedFile = _b2[0], setCorruptedFile = _b2[1];
      react_1.useEffect(function() {
        if (!currentDocument || loadedCanvas)
          return;
        var canvas = document.getElementById("tiff-img");
        try {
          canvas && tiffToCanvas_1.parseTIFF(currentDocument.fileData, canvas);
          setLoadedCanvas(true);
        } catch (error) {
          setCorruptedFile(true);
        }
      }, []);
      if (corruptedFile) {
        return react_1.default.createElement(
          image_1.default,
          __assign({}, props),
          react_1.default.createElement("div", null, "Your file is corrupted. Please check it on your machine.")
        );
      }
      return react_1.default.createElement(
        image_1.default,
        __assign({}, props),
        react_1.default.createElement(Canvas, { id: "tiff-img" })
      );
    };
    TIFFRenderer.fileTypes = ["tif", "tiff", "image/tif", "image/tiff"];
    TIFFRenderer.weight = 0;
    TIFFRenderer.fileLoader = fileLoaders_1.arrayBufferFileLoader;
    exports2.default = TIFFRenderer;
    var Canvas = styled_components_1.default.canvas(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  max-width: 95%;\n  max-height: 95%;\n"], ["\n  max-width: 95%;\n  max-height: 95%;\n"])));
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/plugins/txt/index.js
var require_txt = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/txt/index.js"(exports2) {
    "use strict";
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var fileLoaders_1 = require_fileLoaders();
    var TXTRenderer = function(_a3) {
      var currentDocument = _a3.mainState.currentDocument;
      return react_1.default.createElement(Container, { id: "txt-renderer" }, currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.fileData);
    };
    exports2.default = TXTRenderer;
    TXTRenderer.fileTypes = ["txt", "text/plain"];
    TXTRenderer.weight = 0;
    TXTRenderer.fileLoader = fileLoaders_1.textFileLoader;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 30px;\n"], ["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  padding: 30px;\n"])));
    var templateObject_1;
  }
});

// node_modules/react-doc-viewer/build/theme/index.js
var require_theme = __commonJS({
  "node_modules/react-doc-viewer/build/theme/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultTheme = void 0;
    exports2.defaultTheme = {
      primary: "#fff",
      secondary: "#000",
      tertiary: "#ffffff99",
      text_primary: "#000",
      text_secondary: "#fff",
      text_tertiary: "#00000044",
      disableThemeScrollbar: false
    };
  }
});

// node_modules/react-doc-viewer/build/plugins/index.js
var require_plugins = __commonJS({
  "node_modules/react-doc-viewer/build/plugins/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocViewerRenderers = void 0;
    var bmp_1 = __importDefault(require_bmp());
    var html_1 = __importDefault(require_html());
    var jpg_1 = __importDefault(require_jpg());
    var msdoc_1 = __importDefault(require_msdoc());
    var msg_1 = __importDefault(require_msg());
    var pdf_1 = __importDefault(require_pdf2());
    var png_1 = __importDefault(require_png());
    var tiff_1 = __importDefault(require_tiff());
    var txt_1 = __importDefault(require_txt());
    exports2.DocViewerRenderers = [
      bmp_1.default,
      html_1.default,
      jpg_1.default,
      msdoc_1.default,
      msg_1.default,
      pdf_1.default,
      png_1.default,
      tiff_1.default,
      txt_1.default
    ];
  }
});

// node_modules/react-doc-viewer/build/types/index.js
var require_types = __commonJS({
  "node_modules/react-doc-viewer/build/types/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/react-doc-viewer/build/index.js
var require_build = __commonJS({
  "node_modules/react-doc-viewer/build/index.js"(exports2) {
    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s3 = arguments[i3];
          for (var p2 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p2))
              t3[p2] = s3[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3)
        if (p2 !== "default" && !exports3.hasOwnProperty(p2))
          __createBinding(exports3, m3, p2);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TXTRenderer = exports2.TIFFRenderer = exports2.PNGRenderer = exports2.PDFRenderer = exports2.MSGRenderer = exports2.MSDocRenderer = exports2.JPGRenderer = exports2.ImageProxyRenderer = exports2.HTMLRenderer = exports2.BMPRenderer = void 0;
    var react_1 = __importDefault(require_react());
    var styled_components_1 = __importStar((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var HeaderBar_1 = require_HeaderBar();
    var ProxyRenderer_1 = require_ProxyRenderer();
    var bmp_1 = __importDefault(require_bmp());
    exports2.BMPRenderer = bmp_1.default;
    var html_1 = __importDefault(require_html());
    exports2.HTMLRenderer = html_1.default;
    var image_1 = __importDefault(require_image());
    exports2.ImageProxyRenderer = image_1.default;
    var jpg_1 = __importDefault(require_jpg());
    exports2.JPGRenderer = jpg_1.default;
    var msdoc_1 = __importDefault(require_msdoc());
    exports2.MSDocRenderer = msdoc_1.default;
    var msg_1 = __importDefault(require_msg());
    exports2.MSGRenderer = msg_1.default;
    var pdf_1 = __importDefault(require_pdf2());
    exports2.PDFRenderer = pdf_1.default;
    var png_1 = __importDefault(require_png());
    exports2.PNGRenderer = png_1.default;
    var tiff_1 = __importDefault(require_tiff());
    exports2.TIFFRenderer = tiff_1.default;
    var txt_1 = __importDefault(require_txt());
    exports2.TXTRenderer = txt_1.default;
    var state_1 = require_state();
    var theme_1 = require_theme();
    var DocViewer = function(props) {
      var documents = props.documents, theme = props.theme;
      if (!documents || documents === void 0) {
        throw new Error("Please provide an array of documents to DocViewer.\ne.g. <DocViewer documents={[ { uri: 'https://mypdf.pdf' } ]} />");
      }
      return react_1.default.createElement(
        state_1.AppProvider,
        __assign({}, props),
        react_1.default.createElement(
          styled_components_1.ThemeProvider,
          { theme: theme ? __assign(__assign({}, theme_1.defaultTheme), theme) : theme_1.defaultTheme },
          react_1.default.createElement(
            Container,
            __assign({ id: "react-doc-viewer", "data-testid": "react-doc-viewer" }, props),
            react_1.default.createElement(HeaderBar_1.HeaderBar, null),
            react_1.default.createElement(ProxyRenderer_1.ProxyRenderer, null)
          )
        )
      );
    };
    exports2.default = DocViewer;
    var Container = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  background: #eee;\n"], ["\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  background: #eee;\n"])));
    var plugins_1 = require_plugins();
    Object.defineProperty(exports2, "DocViewerRenderers", { enumerable: true, get: function() {
      return plugins_1.DocViewerRenderers;
    } });
    __exportStar(require_types(), exports2);
    __exportStar(require_fileLoaders(), exports2);
    var templateObject_1;
  }
});
export default require_build();
//# sourceMappingURL=react-doc-viewer.js.map
