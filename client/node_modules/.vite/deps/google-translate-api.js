import {
  require_object_assign
} from "./chunk-CO6E7LRM.js";
import {
  __commonJS
} from "./chunk-GFT2G5UO.js";

// browser-external:querystring
var require_querystring = __commonJS({
  "browser-external:querystring"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "querystring" has been externalized for browser compatibility. Cannot access "querystring.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/duplexer3/index.js
var require_duplexer3 = __commonJS({
  "node_modules/duplexer3/index.js"(exports2, module2) {
    "use strict";
    var stream = require_stream();
    function DuplexWrapper(options, writable, readable) {
      if (typeof readable === "undefined") {
        readable = writable;
        writable = options;
        options = null;
      }
      stream.Duplex.call(this, options);
      if (typeof readable.read !== "function") {
        readable = new stream.Readable(options).wrap(readable);
      }
      this._writable = writable;
      this._readable = readable;
      this._waiting = false;
      var self = this;
      writable.once("finish", function() {
        self.end();
      });
      this.once("finish", function() {
        writable.end();
      });
      readable.on("readable", function() {
        if (self._waiting) {
          self._waiting = false;
          self._read();
        }
      });
      readable.once("end", function() {
        self.push(null);
      });
      if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
        writable.on("error", function(err) {
          self.emit("error", err);
        });
        readable.on("error", function(err) {
          self.emit("error", err);
        });
      }
    }
    DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, { constructor: { value: DuplexWrapper } });
    DuplexWrapper.prototype._write = function _write(input, encoding, done) {
      this._writable.write(input, encoding, done);
    };
    DuplexWrapper.prototype._read = function _read() {
      var buf;
      var reads = 0;
      while ((buf = this._readable.read()) !== null) {
        this.push(buf);
        reads++;
      }
      if (reads === 0) {
        this._waiting = true;
      }
    };
    module2.exports = function duplex2(options, writable, readable) {
      return new DuplexWrapper(options, writable, readable);
    };
    module2.exports.DuplexWrapper = DuplexWrapper;
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = module2.exports = function(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    };
    isStream.writable = function(stream) {
      return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    };
    isStream.readable = function(stream) {
      return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    };
    isStream.duplex = function(stream) {
      return isStream.writable(stream) && isStream.readable(stream);
    };
    isStream.transform = function(stream) {
      return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    };
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var PassThrough = require_stream().PassThrough;
    module2.exports = (opts) => {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream = new PassThrough({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      stream.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream.getBufferedLength = () => len;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var bufferStream = require_buffer_stream();
    function getStream(inputStream, opts) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      opts = Object.assign({ maxBuffer: Infinity }, opts);
      const maxBuffer = opts.maxBuffer;
      let stream;
      let clean;
      const p = new Promise((resolve2, reject2) => {
        const error = (err) => {
          if (err) {
            err.bufferedData = stream.getBufferedValue();
          }
          reject2(err);
        };
        stream = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream);
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            reject2(new Error("maxBuffer exceeded"));
          }
        });
        stream.once("error", error);
        stream.on("end", resolve2);
        clean = () => {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream);
          }
        };
      });
      p.then(clean, clean);
      return p.then(() => stream.getBufferedValue());
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, { encoding: "buffer" }));
    module2.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, { array: true }));
  }
});

// node_modules/timed-out/index.js
var require_timed_out = __commonJS({
  "node_modules/timed-out/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(req, time) {
      if (req.timeoutTimer) {
        return req;
      }
      var delays = isNaN(time) ? time : { socket: time, connect: time };
      var host = req._headers ? " to " + req._headers.host : "";
      if (delays.connect !== void 0) {
        req.timeoutTimer = setTimeout(function timeoutHandler() {
          req.abort();
          var e = new Error("Connection timed out on request" + host);
          e.code = "ETIMEDOUT";
          req.emit("error", e);
        }, delays.connect);
      }
      req.on("socket", function assign(socket) {
        if (!(socket.connecting || socket._connecting)) {
          connect();
          return;
        }
        socket.once("connect", connect);
      });
      function clear() {
        if (req.timeoutTimer) {
          clearTimeout(req.timeoutTimer);
          req.timeoutTimer = null;
        }
      }
      function connect() {
        clear();
        if (delays.socket !== void 0) {
          req.setTimeout(delays.socket, function socketTimeoutHandler() {
            req.abort();
            var e = new Error("Socket timed out on request" + host);
            e.code = "ESOCKETTIMEDOUT";
            req.emit("error", e);
          });
        }
      }
      return req.on("error", clear);
    };
  }
});

// node_modules/prepend-http/index.js
var require_prepend_http = __commonJS({
  "node_modules/prepend-http/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(url) {
      if (typeof url !== "string") {
        throw new TypeError("Expected a string, got " + typeof url);
      }
      url = url.trim();
      if (/^\.*\/|^(?!localhost)\w+:/.test(url)) {
        return url;
      }
      return url.replace(/^(?!(?:\w+:)?\/\/)/, "http://");
    };
  }
});

// node_modules/url-parse-lax/index.js
var require_url_parse_lax = __commonJS({
  "node_modules/url-parse-lax/index.js"(exports2, module2) {
    "use strict";
    var url = require_url();
    var prependHttp = require_prepend_http();
    module2.exports = function(x) {
      var withProtocol = prependHttp(x);
      var parsed = url.parse(withProtocol);
      if (withProtocol !== x) {
        parsed.protocol = null;
      }
      return parsed;
    };
  }
});

// node_modules/lowercase-keys/index.js
var require_lowercase_keys = __commonJS({
  "node_modules/lowercase-keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      var ret = {};
      var keys = Object.keys(Object(obj));
      for (var i = 0; i < keys.length; i++) {
        ret[keys[i].toLowerCase()] = obj[keys[i]];
      }
      return ret;
    };
  }
});

// node_modules/is-redirect/index.js
var require_is_redirect = __commonJS({
  "node_modules/is-redirect/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(x) {
      if (typeof x !== "number") {
        throw new TypeError("Expected a number");
      }
      return x === 300 || x === 301 || x === 302 || x === 303 || x === 305 || x === 307 || x === 308;
    };
  }
});

// browser-external:unzip-response
var require_unzip_response = __commonJS({
  "browser-external:unzip-response"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "unzip-response" has been externalized for browser compatibility. Cannot access "unzip-response.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/capture-stack-trace/index.js
var require_capture_stack_trace = __commonJS({
  "node_modules/capture-stack-trace/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error.captureStackTrace || function(error) {
      var container = new Error();
      Object.defineProperty(error, "stack", {
        configurable: true,
        get: function getStack() {
          var stack = container.stack;
          Object.defineProperty(this, "stack", {
            value: stack
          });
          return stack;
        }
      });
    };
  }
});

// node_modules/create-error-class/index.js
var require_create_error_class = __commonJS({
  "node_modules/create-error-class/index.js"(exports2, module2) {
    "use strict";
    var captureStackTrace = require_capture_stack_trace();
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
    module2.exports = function createErrorClass(className, setup) {
      if (typeof className !== "string") {
        throw new TypeError("Expected className to be a string");
      }
      if (/[^0-9a-zA-Z_$]/.test(className)) {
        throw new Error("className contains invalid characters");
      }
      setup = setup || function(message) {
        this.message = message;
      };
      var ErrorClass = function() {
        Object.defineProperty(this, "name", {
          configurable: true,
          value: className,
          writable: true
        });
        captureStackTrace(this, this.constructor);
        setup.apply(this, arguments);
      };
      inherits(ErrorClass, Error);
      return ErrorClass;
    };
  }
});

// node_modules/is-retry-allowed/index.js
var require_is_retry_allowed = __commonJS({
  "node_modules/is-retry-allowed/index.js"(exports2, module2) {
    "use strict";
    var WHITELIST = [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "EPIPE",
      "EHOSTUNREACH",
      "EAI_AGAIN"
    ];
    var BLACKLIST = [
      "ENOTFOUND",
      "ENETUNREACH",
      // SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950
      "UNABLE_TO_GET_ISSUER_CERT",
      "UNABLE_TO_GET_CRL",
      "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
      "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
      "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
      "CERT_SIGNATURE_FAILURE",
      "CRL_SIGNATURE_FAILURE",
      "CERT_NOT_YET_VALID",
      "CERT_HAS_EXPIRED",
      "CRL_NOT_YET_VALID",
      "CRL_HAS_EXPIRED",
      "ERROR_IN_CERT_NOT_BEFORE_FIELD",
      "ERROR_IN_CERT_NOT_AFTER_FIELD",
      "ERROR_IN_CRL_LAST_UPDATE_FIELD",
      "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
      "OUT_OF_MEM",
      "DEPTH_ZERO_SELF_SIGNED_CERT",
      "SELF_SIGNED_CERT_IN_CHAIN",
      "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
      "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
      "CERT_CHAIN_TOO_LONG",
      "CERT_REVOKED",
      "INVALID_CA",
      "PATH_LENGTH_EXCEEDED",
      "INVALID_PURPOSE",
      "CERT_UNTRUSTED",
      "CERT_REJECTED"
    ];
    module2.exports = function(err) {
      if (!err || !err.code) {
        return true;
      }
      if (WHITELIST.indexOf(err.code) !== -1) {
        return true;
      }
      if (BLACKLIST.indexOf(err.code) !== -1) {
        return false;
      }
      return true;
    };
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/got/package.json
var require_package = __commonJS({
  "node_modules/got/package.json"(exports2, module2) {
    module2.exports = {
      name: "got",
      version: "6.7.1",
      description: "Simplified HTTP requests",
      license: "MIT",
      repository: "sindresorhus/got",
      maintainers: [
        {
          name: "Sindre Sorhus",
          email: "sindresorhus@gmail.com",
          url: "sindresorhus.com"
        },
        {
          name: "Vsevolod Strukchinsky",
          email: "floatdrop@gmail.com",
          url: "github.com/floatdrop"
        }
      ],
      engines: {
        node: ">=4"
      },
      browser: {
        "unzip-response": false
      },
      scripts: {
        test: "xo && nyc ava",
        coveralls: "nyc report --reporter=text-lcov | coveralls"
      },
      files: [
        "index.js"
      ],
      keywords: [
        "http",
        "https",
        "get",
        "got",
        "url",
        "uri",
        "request",
        "util",
        "utility",
        "simple",
        "curl",
        "wget",
        "fetch"
      ],
      dependencies: {
        "create-error-class": "^3.0.0",
        duplexer3: "^0.1.4",
        "get-stream": "^3.0.0",
        "is-redirect": "^1.0.0",
        "is-retry-allowed": "^1.0.0",
        "is-stream": "^1.0.0",
        "lowercase-keys": "^1.0.0",
        "safe-buffer": "^5.0.1",
        "timed-out": "^4.0.0",
        "unzip-response": "^2.0.1",
        "url-parse-lax": "^1.0.0"
      },
      devDependencies: {
        ava: "^0.17.0",
        coveralls: "^2.11.4",
        "form-data": "^2.1.1",
        "get-port": "^2.0.0",
        "into-stream": "^3.0.0",
        nyc: "^10.0.0",
        pem: "^1.4.4",
        pify: "^2.3.0",
        tempfile: "^1.1.1",
        xo: "*"
      },
      xo: {
        esnext: true
      },
      ava: {
        concurrency: 4
      }
    };
  }
});

// node_modules/got/index.js
var require_got = __commonJS({
  "node_modules/got/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events();
    var http = require_http();
    var https = require_https();
    var PassThrough = require_stream().PassThrough;
    var urlLib = require_url();
    var querystring = require_querystring();
    var duplexer3 = require_duplexer3();
    var isStream = require_is_stream();
    var getStream = require_get_stream();
    var timedOut = require_timed_out();
    var urlParseLax = require_url_parse_lax();
    var lowercaseKeys = require_lowercase_keys();
    var isRedirect = require_is_redirect();
    var unzipResponse = require_unzip_response();
    var createErrorClass = require_create_error_class();
    var isRetryAllowed = require_is_retry_allowed();
    var Buffer2 = require_safe_buffer().Buffer;
    var pkg = require_package();
    function requestAsEventEmitter(opts) {
      opts = opts || {};
      const ee = new EventEmitter();
      const requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);
      let redirectCount = 0;
      let retryCount = 0;
      let redirectUrl;
      const get2 = (opts2) => {
        const fn = opts2.protocol === "https:" ? https : http;
        const req = fn.request(opts2, (res2) => {
          const statusCode = res2.statusCode;
          if (isRedirect(statusCode) && opts2.followRedirect && "location" in res2.headers && (opts2.method === "GET" || opts2.method === "HEAD")) {
            res2.resume();
            if (++redirectCount > 10) {
              ee.emit("error", new got2.MaxRedirectsError(statusCode, opts2), null, res2);
              return;
            }
            const bufferString = Buffer2.from(res2.headers.location, "binary").toString();
            redirectUrl = urlLib.resolve(urlLib.format(opts2), bufferString);
            const redirectOpts = Object.assign({}, opts2, urlLib.parse(redirectUrl));
            ee.emit("redirect", res2, redirectOpts);
            get2(redirectOpts);
            return;
          }
          setImmediate(() => {
            const response = typeof unzipResponse === "function" && req.method !== "HEAD" ? unzipResponse(res2) : res2;
            response.url = redirectUrl || requestUrl;
            response.requestUrl = requestUrl;
            ee.emit("response", response);
          });
        });
        req.once("error", (err) => {
          const backoff = opts2.retries(++retryCount, err);
          if (backoff) {
            setTimeout(get2, backoff, opts2);
            return;
          }
          ee.emit("error", new got2.RequestError(err, opts2));
        });
        if (opts2.gotTimeout) {
          timedOut(req, opts2.gotTimeout);
        }
        setImmediate(() => {
          ee.emit("request", req);
        });
      };
      get2(opts);
      return ee;
    }
    function asPromise(opts) {
      return new Promise((resolve2, reject2) => {
        const ee = requestAsEventEmitter(opts);
        ee.on("request", (req) => {
          if (isStream(opts.body)) {
            opts.body.pipe(req);
            opts.body = void 0;
            return;
          }
          req.end(opts.body);
        });
        ee.on("response", (res2) => {
          const stream = opts.encoding === null ? getStream.buffer(res2) : getStream(res2, opts);
          stream.catch((err) => reject2(new got2.ReadError(err, opts))).then((data) => {
            const statusCode = res2.statusCode;
            const limitStatusCode = opts.followRedirect ? 299 : 399;
            res2.body = data;
            if (opts.json && res2.body) {
              try {
                res2.body = JSON.parse(res2.body);
              } catch (e) {
                throw new got2.ParseError(e, statusCode, opts, data);
              }
            }
            if (statusCode < 200 || statusCode > limitStatusCode) {
              throw new got2.HTTPError(statusCode, opts);
            }
            resolve2(res2);
          }).catch((err) => {
            Object.defineProperty(err, "response", { value: res2 });
            reject2(err);
          });
        });
        ee.on("error", reject2);
      });
    }
    function asStream(opts) {
      const input = new PassThrough();
      const output = new PassThrough();
      const proxy = duplexer3(input, output);
      if (opts.json) {
        throw new Error("got can not be used as stream when options.json is used");
      }
      if (opts.body) {
        proxy.write = () => {
          throw new Error("got's stream is not writable when options.body is used");
        };
      }
      const ee = requestAsEventEmitter(opts);
      ee.on("request", (req) => {
        proxy.emit("request", req);
        if (isStream(opts.body)) {
          opts.body.pipe(req);
          return;
        }
        if (opts.body) {
          req.end(opts.body);
          return;
        }
        if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
          input.pipe(req);
          return;
        }
        req.end();
      });
      ee.on("response", (res2) => {
        const statusCode = res2.statusCode;
        res2.pipe(output);
        if (statusCode < 200 || statusCode > 299) {
          proxy.emit("error", new got2.HTTPError(statusCode, opts), null, res2);
          return;
        }
        proxy.emit("response", res2);
      });
      ee.on("redirect", proxy.emit.bind(proxy, "redirect"));
      ee.on("error", proxy.emit.bind(proxy, "error"));
      return proxy;
    }
    function normalizeArguments(url, opts) {
      if (typeof url !== "string" && typeof url !== "object") {
        throw new Error(`Parameter \`url\` must be a string or object, not ${typeof url}`);
      }
      if (typeof url === "string") {
        url = url.replace(/^unix:/, "http://$&");
        url = urlParseLax(url);
        if (url.auth) {
          throw new Error("Basic authentication must be done with auth option");
        }
      }
      opts = Object.assign(
        {
          protocol: "http:",
          path: "",
          retries: 5
        },
        url,
        opts
      );
      opts.headers = Object.assign({
        "user-agent": `${pkg.name}/${pkg.version} (https://github.com/sindresorhus/got)`,
        "accept-encoding": "gzip,deflate"
      }, lowercaseKeys(opts.headers));
      const query = opts.query;
      if (query) {
        if (typeof query !== "string") {
          opts.query = querystring.stringify(query);
        }
        opts.path = `${opts.path.split("?")[0]}?${opts.query}`;
        delete opts.query;
      }
      if (opts.json && opts.headers.accept === void 0) {
        opts.headers.accept = "application/json";
      }
      let body = opts.body;
      if (body) {
        if (typeof body !== "string" && !(body !== null && typeof body === "object")) {
          throw new Error("options.body must be a ReadableStream, string, Buffer or plain Object");
        }
        opts.method = opts.method || "POST";
        if (isStream(body) && typeof body.getBoundary === "function") {
          opts.headers["content-type"] = opts.headers["content-type"] || `multipart/form-data; boundary=${body.getBoundary()}`;
        } else if (body !== null && typeof body === "object" && !Buffer2.isBuffer(body) && !isStream(body)) {
          opts.headers["content-type"] = opts.headers["content-type"] || "application/x-www-form-urlencoded";
          body = opts.body = querystring.stringify(body);
        }
        if (opts.headers["content-length"] === void 0 && opts.headers["transfer-encoding"] === void 0 && !isStream(body)) {
          const length = typeof body === "string" ? Buffer2.byteLength(body) : body.length;
          opts.headers["content-length"] = length;
        }
      }
      opts.method = (opts.method || "GET").toUpperCase();
      if (opts.hostname === "unix") {
        const matches = /(.+):(.+)/.exec(opts.path);
        if (matches) {
          opts.socketPath = matches[1];
          opts.path = matches[2];
          opts.host = null;
        }
      }
      if (typeof opts.retries !== "function") {
        const retries = opts.retries;
        opts.retries = (iter, err) => {
          if (iter > retries || !isRetryAllowed(err)) {
            return 0;
          }
          const noise = Math.random() * 100;
          return (1 << iter) * 1e3 + noise;
        };
      }
      if (opts.followRedirect === void 0) {
        opts.followRedirect = true;
      }
      if (opts.timeout) {
        opts.gotTimeout = opts.timeout;
        delete opts.timeout;
      }
      return opts;
    }
    function got2(url, opts) {
      try {
        return asPromise(normalizeArguments(url, opts));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    var helpers = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    helpers.forEach((el) => {
      got2[el] = (url, opts) => got2(url, Object.assign({}, opts, { method: el }));
    });
    got2.stream = (url, opts) => asStream(normalizeArguments(url, opts));
    for (const el of helpers) {
      got2.stream[el] = (url, opts) => got2.stream(url, Object.assign({}, opts, { method: el }));
    }
    function stdError(error, opts) {
      if (error.code !== void 0) {
        this.code = error.code;
      }
      Object.assign(this, {
        message: error.message,
        host: opts.host,
        hostname: opts.hostname,
        method: opts.method,
        path: opts.path
      });
    }
    got2.RequestError = createErrorClass("RequestError", stdError);
    got2.ReadError = createErrorClass("ReadError", stdError);
    got2.ParseError = createErrorClass("ParseError", function(e, statusCode, opts, data) {
      stdError.call(this, e, opts);
      this.statusCode = statusCode;
      this.statusMessage = http.STATUS_CODES[this.statusCode];
      this.message = `${e.message} in "${urlLib.format(opts)}": 
${data.slice(0, 77)}...`;
    });
    got2.HTTPError = createErrorClass("HTTPError", function(statusCode, opts) {
      stdError.call(this, {}, opts);
      this.statusCode = statusCode;
      this.statusMessage = http.STATUS_CODES[this.statusCode];
      this.message = `Response code ${this.statusCode} (${this.statusMessage})`;
    });
    got2.MaxRedirectsError = createErrorClass("MaxRedirectsError", function(statusCode, opts) {
      stdError.call(this, {}, opts);
      this.statusCode = statusCode;
      this.statusMessage = http.STATUS_CODES[this.statusCode];
      this.message = "Redirected 10 times. Aborting.";
    });
    module2.exports = got2;
  }
});

// browser-external:vm
var require_vm = __commonJS({
  "browser-external:vm"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "vm" has been externalized for browser compatibility. Cannot access "vm.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/safe-eval/index.js
var require_safe_eval = __commonJS({
  "node_modules/safe-eval/index.js"(exports2, module2) {
    var vm = require_vm();
    module2.exports = function safeEval(code2, context, opts) {
      var sandbox = {};
      var resultKey = "SAFE_EVAL_" + Math.floor(Math.random() * 1e6);
      sandbox[resultKey] = {};
      code2 = resultKey + "=" + code2;
      if (context) {
        Object.keys(context).forEach(function(key) {
          sandbox[key] = context[key];
        });
      }
      vm.runInNewContext(code2, sandbox, opts);
      return sandbox[resultKey];
    };
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:constants
var require_constants = __commonJS({
  "browser-external:constants"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "constants" has been externalized for browser compatibility. Cannot access "constants.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require_constants();
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs2.fchmod(fd, mode, function(err2) {
                fs2.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require_stream().Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs = require_fs();
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require_util();
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require_assert().equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now2 = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now2;
          fs[gracefulQueue][i][4] = now2;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/os-tmpdir/index.js
var require_os_tmpdir = __commonJS({
  "node_modules/os-tmpdir/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
    module2.exports = function() {
      var path;
      if (isWindows) {
        path = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp";
      } else {
        path = process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp";
      }
      if (trailingSlashRe.test(path)) {
        path = path.slice(0, -1);
      }
      return path;
    };
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/os-homedir/index.js
var require_os_homedir = __commonJS({
  "node_modules/os-homedir/index.js"(exports2, module2) {
    "use strict";
    var os = require_os();
    function homedir() {
      var env = process.env;
      var home = env.HOME;
      var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
      if (process.platform === "win32") {
        return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    }
    module2.exports = typeof os.homedir === "function" ? os.homedir : homedir;
  }
});

// node_modules/osenv/osenv.js
var require_osenv = __commonJS({
  "node_modules/osenv/osenv.js"(exports2) {
    var isWindows = process.platform === "win32";
    var path = require_path();
    var exec = require_child_process().exec;
    var osTmpdir = require_os_tmpdir();
    var osHomedir = require_os_homedir();
    function memo(key, lookup, fallback) {
      var fell = false;
      var falling = false;
      exports2[key] = function(cb) {
        var val = lookup();
        if (!val && !fell && !falling && fallback) {
          fell = true;
          falling = true;
          exec(fallback, function(er, output, stderr) {
            falling = false;
            if (er)
              return;
            val = output.trim();
          });
        }
        exports2[key] = function(cb2) {
          if (cb2)
            process.nextTick(cb2.bind(null, null, val));
          return val;
        };
        if (cb && !falling)
          process.nextTick(cb.bind(null, null, val));
        return val;
      };
    }
    memo("user", function() {
      return isWindows ? process.env.USERDOMAIN + "\\" + process.env.USERNAME : process.env.USER;
    }, "whoami");
    memo("prompt", function() {
      return isWindows ? process.env.PROMPT : process.env.PS1;
    });
    memo("hostname", function() {
      return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME;
    }, "hostname");
    memo("tmpdir", function() {
      return osTmpdir();
    });
    memo("home", function() {
      return osHomedir();
    });
    memo("path", function() {
      return (process.env.PATH || process.env.Path || process.env.path).split(isWindows ? ";" : ":");
    });
    memo("editor", function() {
      return process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi");
    });
    memo("shell", function() {
      return isWindows ? process.env.ComSpec || "cmd" : process.env.SHELL || "bash";
    });
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports2, module2) {
    var path = require_path();
    var fs = require_fs();
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || /* istanbul ignore next */
      function() {
      };
      p = path.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path.dirname(p) === p)
              return cb(er);
            mkdirP(path.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/uuid/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/uuid/rng-browser.js"(exports2, module2) {
    var rng;
    var crypto = global.crypto || global.msCrypto;
    if (crypto && crypto.getRandomValues) {
      _rnds8 = new Uint8Array(16);
      rng = function whatwgRNG() {
        crypto.getRandomValues(_rnds8);
        return _rnds8;
      };
    }
    var _rnds8;
    if (!rng) {
      _rnds = new Array(16);
      rng = function() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0)
            r = Math.random() * 4294967296;
          _rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return _rnds;
      };
    }
    var _rnds;
    module2.exports = rng;
  }
});

// node_modules/uuid/uuid.js
var require_uuid = __commonJS({
  "node_modules/uuid/uuid.js"(exports2, module2) {
    var _rng = require_rng_browser();
    var _byteToHex = [];
    var _hexToByte = {};
    for (i = 0; i < 256; i++) {
      _byteToHex[i] = (i + 256).toString(16).substr(1);
      _hexToByte[_byteToHex[i]] = i;
    }
    var i;
    function parse(s, buf, offset) {
      var i2 = buf && offset || 0, ii = 0;
      buf = buf || [];
      s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
        if (ii < 16) {
          buf[i2 + ii++] = _hexToByte[oct];
        }
      });
      while (ii < 16) {
        buf[i2 + ii++] = 0;
      }
      return buf;
    }
    function unparse(buf, offset) {
      var i2 = offset || 0, bth = _byteToHex;
      return bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]];
    }
    var _seedBytes = _rng();
    var _nodeId = [
      _seedBytes[0] | 1,
      _seedBytes[1],
      _seedBytes[2],
      _seedBytes[3],
      _seedBytes[4],
      _seedBytes[5]
    ];
    var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 16383;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i2 = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i2++] = tl >>> 24 & 255;
      b[i2++] = tl >>> 16 & 255;
      b[i2++] = tl >>> 8 & 255;
      b[i2++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i2++] = tmh >>> 8 & 255;
      b[i2++] = tmh & 255;
      b[i2++] = tmh >>> 24 & 15 | 16;
      b[i2++] = tmh >>> 16 & 255;
      b[i2++] = clockseq >>> 8 | 128;
      b[i2++] = clockseq & 255;
      var node = options.node || _nodeId;
      for (var n = 0; n < 6; n++) {
        b[i2 + n] = node[n];
      }
      return buf ? buf : unparse(b);
    }
    function v4(options, buf, offset) {
      var i2 = buf && offset || 0;
      if (typeof options == "string") {
        buf = options == "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || _rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ii++) {
          buf[i2 + ii] = rnds[ii];
        }
      }
      return buf || unparse(rnds);
    }
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    uuid.parse = parse;
    uuid.unparse = unparse;
    module2.exports = uuid;
  }
});

// node_modules/xdg-basedir/index.js
var require_xdg_basedir = __commonJS({
  "node_modules/xdg-basedir/index.js"(exports2) {
    "use strict";
    var path = require_path();
    var osHomedir = require_os_homedir();
    var home = osHomedir();
    var env = process.env;
    exports2.data = env.XDG_DATA_HOME || (home ? path.join(home, ".local", "share") : null);
    exports2.config = env.XDG_CONFIG_HOME || (home ? path.join(home, ".config") : null);
    exports2.cache = env.XDG_CACHE_HOME || (home ? path.join(home, ".cache") : null);
    exports2.runtime = env.XDG_RUNTIME_DIR || null;
    exports2.dataDirs = (env.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":");
    if (exports2.data) {
      exports2.dataDirs.unshift(exports2.data);
    }
    exports2.configDirs = (env.XDG_CONFIG_DIRS || "/etc/xdg").split(":");
    if (exports2.config) {
      exports2.configDirs.unshift(exports2.config);
    }
  }
});

// node_modules/slide/lib/async-map.js
var require_async_map = __commonJS({
  "node_modules/slide/lib/async-map.js"(exports2, module2) {
    module2.exports = asyncMap;
    function asyncMap() {
      var steps = Array.prototype.slice.call(arguments), list = steps.shift() || [], cb_ = steps.pop();
      if (typeof cb_ !== "function")
        throw new Error(
          "No callback provided to asyncMap"
        );
      if (!list)
        return cb_(null, []);
      if (!Array.isArray(list))
        list = [list];
      var n = steps.length, data = [], errState = null, l = list.length, a = l * n;
      if (!a)
        return cb_(null, []);
      function cb(er) {
        if (er && !errState)
          errState = er;
        var argLen = arguments.length;
        for (var i = 1; i < argLen; i++)
          if (arguments[i] !== void 0) {
            data[i - 1] = (data[i - 1] || []).concat(arguments[i]);
          }
        if (list.length > l) {
          var newList = list.slice(l);
          a += (list.length - l) * n;
          l = list.length;
          process.nextTick(function() {
            newList.forEach(function(ar) {
              steps.forEach(function(fn) {
                fn(ar, cb);
              });
            });
          });
        }
        if (--a === 0)
          cb_.apply(null, [errState].concat(data));
      }
      list.forEach(function(ar) {
        steps.forEach(function(fn) {
          fn(ar, cb);
        });
      });
    }
  }
});

// node_modules/slide/lib/bind-actor.js
var require_bind_actor = __commonJS({
  "node_modules/slide/lib/bind-actor.js"(exports2, module2) {
    module2.exports = bindActor;
    function bindActor() {
      var args = Array.prototype.slice.call(arguments), obj = null, fn;
      if (typeof args[0] === "object") {
        obj = args.shift();
        fn = args.shift();
        if (typeof fn === "string")
          fn = obj[fn];
      } else
        fn = args.shift();
      return function(cb) {
        fn.apply(obj, args.concat(cb));
      };
    }
  }
});

// node_modules/slide/lib/chain.js
var require_chain = __commonJS({
  "node_modules/slide/lib/chain.js"(exports2, module2) {
    module2.exports = chain;
    var bindActor = require_bind_actor();
    chain.first = {};
    chain.last = {};
    function chain(things, cb) {
      var res2 = [];
      (function LOOP(i, len) {
        if (i >= len)
          return cb(null, res2);
        if (Array.isArray(things[i]))
          things[i] = bindActor.apply(
            null,
            things[i].map(function(i2) {
              return i2 === chain.first ? res2[0] : i2 === chain.last ? res2[res2.length - 1] : i2;
            })
          );
        if (!things[i])
          return LOOP(i + 1, len);
        things[i](function(er, data) {
          if (er)
            return cb(er, res2);
          if (data !== void 0)
            res2 = res2.concat(data);
          LOOP(i + 1, len);
        });
      })(0, things.length);
    }
  }
});

// node_modules/slide/lib/slide.js
var require_slide = __commonJS({
  "node_modules/slide/lib/slide.js"(exports2) {
    exports2.asyncMap = require_async_map();
    exports2.bindActor = require_bind_actor();
    exports2.chain = require_chain();
  }
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "node_modules/imurmurhash/imurmurhash.js"(exports2, module2) {
    (function() {
      var cache;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache = new MurmurHash3();
      if (typeof module2 != "undefined") {
        module2.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// node_modules/write-file-atomic/index.js
var require_write_file_atomic = __commonJS({
  "node_modules/write-file-atomic/index.js"(exports2, module2) {
    "use strict";
    module2.exports = writeFile;
    module2.exports.sync = writeFileSync;
    module2.exports._getTmpname = getTmpname;
    var fs = require_graceful_fs();
    var chain = require_slide().chain;
    var MurmurHash3 = require_imurmurhash();
    var extend = Object.assign || require_util()._extend;
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(++invocations)).result();
    }
    function writeFile(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = null;
      }
      if (!options)
        options = {};
      fs.realpath(filename, function(_, realname) {
        _writeFile(realname || filename, data, options, callback);
      });
    }
    function _writeFile(filename, data, options, callback) {
      var tmpfile = getTmpname(filename);
      if (options.mode && options.chown) {
        return thenWriteFile();
      } else {
        return fs.stat(filename, function(err, stats) {
          if (err || !stats)
            return thenWriteFile();
          options = extend({}, options);
          if (!options.mode) {
            options.mode = stats.mode;
          }
          if (!options.chown && process.getuid) {
            options.chown = { uid: stats.uid, gid: stats.gid };
          }
          return thenWriteFile();
        });
      }
      function thenWriteFile() {
        chain([
          [writeFileAsync, tmpfile, data, options.mode, options.encoding || "utf8"],
          options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid],
          options.mode && [fs, fs.chmod, tmpfile, options.mode],
          [fs, fs.rename, tmpfile, filename]
        ], function(err) {
          err ? fs.unlink(tmpfile, function() {
            callback(err);
          }) : callback();
        });
      }
      function writeFileAsync(file, data2, mode, encoding, cb) {
        fs.open(file, "w", options.mode, function(err, fd) {
          if (err)
            return cb(err);
          if (Buffer.isBuffer(data2)) {
            return fs.write(fd, data2, 0, data2.length, 0, syncAndClose);
          } else if (data2 != null) {
            return fs.write(fd, String(data2), 0, String(encoding), syncAndClose);
          } else {
            return syncAndClose();
          }
          function syncAndClose(err2) {
            if (err2)
              return cb(err2);
            fs.fsync(fd, function(err3) {
              if (err3)
                return cb(err3);
              fs.close(fd, cb);
            });
          }
        });
      }
    }
    function writeFileSync(filename, data, options) {
      if (!options)
        options = {};
      try {
        filename = fs.realpathSync(filename);
      } catch (ex) {
      }
      var tmpfile = getTmpname(filename);
      try {
        if (!options.mode || !options.chown) {
          try {
            var stats = fs.statSync(filename);
            options = extend({}, options);
            if (!options.mode) {
              options.mode = stats.mode;
            }
            if (!options.chown && process.getuid) {
              options.chown = { uid: stats.uid, gid: stats.gid };
            }
          } catch (ex) {
          }
        }
        var fd = fs.openSync(tmpfile, "w", options.mode);
        if (Buffer.isBuffer(data)) {
          fs.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
          fs.writeSync(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        fs.fsyncSync(fd);
        fs.closeSync(fd);
        if (options.chown)
          fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
        if (options.mode)
          fs.chmodSync(tmpfile, options.mode);
        fs.renameSync(tmpfile, filename);
      } catch (err) {
        try {
          fs.unlinkSync(tmpfile);
        } catch (e) {
        }
        throw err;
      }
    }
  }
});

// node_modules/is-obj/index.js
var require_is_obj = __commonJS({
  "node_modules/is-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(x) {
      var type = typeof x;
      return x !== null && (type === "object" || type === "function");
    };
  }
});

// node_modules/dot-prop/index.js
var require_dot_prop = __commonJS({
  "node_modules/dot-prop/index.js"(exports2, module2) {
    "use strict";
    var isObj = require_is_obj();
    module2.exports.get = function(obj, path) {
      if (!isObj(obj) || typeof path !== "string") {
        return obj;
      }
      var pathArr = getPathSegments(path);
      for (var i = 0; i < pathArr.length; i++) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, pathArr[i]) || Object.getOwnPropertyDescriptor(Object.prototype, pathArr[i]);
        if (descriptor && !descriptor.enumerable) {
          return;
        }
        obj = obj[pathArr[i]];
        if (obj === void 0 || obj === null) {
          if (i !== pathArr.length - 1) {
            return void 0;
          }
          break;
        }
      }
      return obj;
    };
    module2.exports.set = function(obj, path, value) {
      if (!isObj(obj) || typeof path !== "string") {
        return;
      }
      var pathArr = getPathSegments(path);
      for (var i = 0; i < pathArr.length; i++) {
        var p = pathArr[i];
        if (!isObj(obj[p])) {
          obj[p] = {};
        }
        if (i === pathArr.length - 1) {
          obj[p] = value;
        }
        obj = obj[p];
      }
    };
    module2.exports.delete = function(obj, path) {
      if (!isObj(obj) || typeof path !== "string") {
        return;
      }
      var pathArr = getPathSegments(path);
      for (var i = 0; i < pathArr.length; i++) {
        var p = pathArr[i];
        if (i === pathArr.length - 1) {
          delete obj[p];
          return;
        }
        obj = obj[p];
      }
    };
    module2.exports.has = function(obj, path) {
      if (!isObj(obj) || typeof path !== "string") {
        return false;
      }
      var pathArr = getPathSegments(path);
      for (var i = 0; i < pathArr.length; i++) {
        obj = obj[pathArr[i]];
        if (obj === void 0) {
          return false;
        }
      }
      return true;
    };
    function getPathSegments(path) {
      var pathArr = path.split(".");
      var parts = [];
      for (var i = 0; i < pathArr.length; i++) {
        var p = pathArr[i];
        while (p[p.length - 1] === "\\" && pathArr[i + 1] !== void 0) {
          p = p.slice(0, -1) + ".";
          p += pathArr[++i];
        }
        parts.push(p);
      }
      return parts;
    }
  }
});

// node_modules/configstore/index.js
var require_configstore = __commonJS({
  "node_modules/configstore/index.js"(exports2, module2) {
    "use strict";
    var path = require_path();
    var fs = require_graceful_fs();
    var osenv = require_osenv();
    var assign = require_object_assign();
    var mkdirp = require_mkdirp();
    var uuid = require_uuid();
    var xdgBasedir = require_xdg_basedir();
    var osTmpdir = require_os_tmpdir();
    var writeFileAtomic = require_write_file_atomic();
    var dotProp = require_dot_prop();
    var user = (osenv.user() || uuid.v4()).replace(/\\/g, "");
    var configDir = xdgBasedir.config || path.join(osTmpdir(), user, ".config");
    var permissionError = "You don't have access to this file.";
    var defaultPathMode = parseInt("0700", 8);
    var writeFileOptions = { mode: parseInt("0600", 8) };
    function Configstore2(id, defaults, opts) {
      opts = opts || {};
      var pathPrefix = opts.globalConfigPath ? path.join(id, "config.json") : path.join("configstore", id + ".json");
      this.path = path.join(configDir, pathPrefix);
      this.all = assign({}, defaults || {}, this.all || {});
    }
    Configstore2.prototype = Object.create(Object.prototype, {
      all: {
        get: function() {
          try {
            return JSON.parse(fs.readFileSync(this.path, "utf8"));
          } catch (err) {
            if (err.code === "ENOENT") {
              mkdirp.sync(path.dirname(this.path), defaultPathMode);
              return {};
            }
            if (err.code === "EACCES") {
              err.message = err.message + "\n" + permissionError + "\n";
            }
            if (err.name === "SyntaxError") {
              writeFileAtomic.sync(this.path, "", writeFileOptions);
              return {};
            }
            throw err;
          }
        },
        set: function(val) {
          try {
            mkdirp.sync(path.dirname(this.path), defaultPathMode);
            writeFileAtomic.sync(this.path, JSON.stringify(val, null, "	"), writeFileOptions);
          } catch (err) {
            if (err.code === "EACCES") {
              err.message = err.message + "\n" + permissionError + "\n";
            }
            throw err;
          }
        }
      },
      size: {
        get: function() {
          return Object.keys(this.all || {}).length;
        }
      }
    });
    Configstore2.prototype.get = function(key) {
      return dotProp.get(this.all, key);
    };
    Configstore2.prototype.set = function(key, val) {
      var config2 = this.all;
      if (arguments.length === 1) {
        Object.keys(key).forEach(function(k) {
          dotProp.set(config2, k, key[k]);
        });
      } else {
        dotProp.set(config2, key, val);
      }
      this.all = config2;
    };
    Configstore2.prototype.has = function(key) {
      return dotProp.has(this.all, key);
    };
    Configstore2.prototype.delete = Configstore2.prototype.del = function(key) {
      var config2 = this.all;
      dotProp.delete(config2, key);
      this.all = config2;
    };
    Configstore2.prototype.clear = function() {
      this.all = {};
    };
    module2.exports = Configstore2;
  }
});

// node_modules/google-translate-token/index.js
var require_google_translate_token = __commonJS({
  "node_modules/google-translate-token/index.js"(exports, module) {
    var got = require_got();
    var Configstore = require_configstore();
    function sM(a) {
      var b;
      if (null !== yr)
        b = yr;
      else {
        b = wr(String.fromCharCode(84));
        var c = wr(String.fromCharCode(75));
        b = [b(), b()];
        b[1] = c();
        b = (yr = window[b.join(c())] || "") || "";
      }
      var d = wr(String.fromCharCode(116)), c = wr(String.fromCharCode(107)), d = [d(), d()];
      d[1] = c();
      c = "&" + d.join("") + "=";
      d = b.split(".");
      b = Number(d[0]) || 0;
      for (var e = [], f = 0, g = 0; g < a.length; g++) {
        var l = a.charCodeAt(g);
        128 > l ? e[f++] = l : (2048 > l ? e[f++] = l >> 6 | 192 : (55296 == (l & 64512) && g + 1 < a.length && 56320 == (a.charCodeAt(g + 1) & 64512) ? (l = 65536 + ((l & 1023) << 10) + (a.charCodeAt(++g) & 1023), e[f++] = l >> 18 | 240, e[f++] = l >> 12 & 63 | 128) : e[f++] = l >> 12 | 224, e[f++] = l >> 6 & 63 | 128), e[f++] = l & 63 | 128);
      }
      a = b;
      for (f = 0; f < e.length; f++)
        a += e[f], a = xr(a, "+-a^+6");
      a = xr(a, "+-3^+b+-f");
      a ^= Number(d[1]) || 0;
      0 > a && (a = (a & 2147483647) + 2147483648);
      a %= 1e6;
      return c + (a.toString() + "." + (a ^ b));
    }
    var yr = null;
    var wr = function(a) {
      return function() {
        return a;
      };
    };
    var xr = function(a, b) {
      for (var c = 0; c < b.length - 2; c += 3) {
        var d = b.charAt(c + 2), d = "a" <= d ? d.charCodeAt(0) - 87 : Number(d), d = "+" == b.charAt(c + 1) ? a >>> d : a << d;
        a = "+" == b.charAt(c) ? a + d & 4294967295 : a ^ d;
      }
      return a;
    };
    var config = new Configstore("google-translate-api");
    var window = {
      TKK: config.get("TKK") || "0"
    };
    function updateTKK() {
      return new Promise(function(resolve, reject) {
        var now = Math.floor(Date.now() / 36e5);
        if (Number(window.TKK.split(".")[0]) === now) {
          resolve();
        } else {
          got("https://translate.google.com").then(function(res) {
            var code = res.body.match(/TKK=(.*?)\(\)\)'\);/g);
            if (code) {
              eval(code[0]);
              if (typeof TKK !== "undefined") {
                window.TKK = TKK;
                config.set("TKK", TKK);
              }
            }
            resolve();
          }).catch(function(err) {
            var e = new Error();
            e.code = "BAD_NETWORK";
            e.message = err.message;
            reject(e);
          });
        }
      });
    }
    function get(text) {
      return updateTKK().then(function() {
        var tk = sM(text);
        tk = tk.replace("&tk=", "");
        return { name: "tk", value: tk };
      }).catch(function(err) {
        throw err;
      });
    }
    module.exports.get = get;
  }
});

// node_modules/google-translate-api/languages.js
var require_languages = __commonJS({
  "node_modules/google-translate-api/languages.js"(exports2, module2) {
    var langs = {
      "auto": "Automatic",
      "af": "Afrikaans",
      "sq": "Albanian",
      "am": "Amharic",
      "ar": "Arabic",
      "hy": "Armenian",
      "az": "Azerbaijani",
      "eu": "Basque",
      "be": "Belarusian",
      "bn": "Bengali",
      "bs": "Bosnian",
      "bg": "Bulgarian",
      "ca": "Catalan",
      "ceb": "Cebuano",
      "ny": "Chichewa",
      "zh-cn": "Chinese Simplified",
      "zh-tw": "Chinese Traditional",
      "co": "Corsican",
      "hr": "Croatian",
      "cs": "Czech",
      "da": "Danish",
      "nl": "Dutch",
      "en": "English",
      "eo": "Esperanto",
      "et": "Estonian",
      "tl": "Filipino",
      "fi": "Finnish",
      "fr": "French",
      "fy": "Frisian",
      "gl": "Galician",
      "ka": "Georgian",
      "de": "German",
      "el": "Greek",
      "gu": "Gujarati",
      "ht": "Haitian Creole",
      "ha": "Hausa",
      "haw": "Hawaiian",
      "iw": "Hebrew",
      "hi": "Hindi",
      "hmn": "Hmong",
      "hu": "Hungarian",
      "is": "Icelandic",
      "ig": "Igbo",
      "id": "Indonesian",
      "ga": "Irish",
      "it": "Italian",
      "ja": "Japanese",
      "jw": "Javanese",
      "kn": "Kannada",
      "kk": "Kazakh",
      "km": "Khmer",
      "ko": "Korean",
      "ku": "Kurdish (Kurmanji)",
      "ky": "Kyrgyz",
      "lo": "Lao",
      "la": "Latin",
      "lv": "Latvian",
      "lt": "Lithuanian",
      "lb": "Luxembourgish",
      "mk": "Macedonian",
      "mg": "Malagasy",
      "ms": "Malay",
      "ml": "Malayalam",
      "mt": "Maltese",
      "mi": "Maori",
      "mr": "Marathi",
      "mn": "Mongolian",
      "my": "Myanmar (Burmese)",
      "ne": "Nepali",
      "no": "Norwegian",
      "ps": "Pashto",
      "fa": "Persian",
      "pl": "Polish",
      "pt": "Portuguese",
      "ma": "Punjabi",
      "ro": "Romanian",
      "ru": "Russian",
      "sm": "Samoan",
      "gd": "Scots Gaelic",
      "sr": "Serbian",
      "st": "Sesotho",
      "sn": "Shona",
      "sd": "Sindhi",
      "si": "Sinhala",
      "sk": "Slovak",
      "sl": "Slovenian",
      "so": "Somali",
      "es": "Spanish",
      "su": "Sundanese",
      "sw": "Swahili",
      "sv": "Swedish",
      "tg": "Tajik",
      "ta": "Tamil",
      "te": "Telugu",
      "th": "Thai",
      "tr": "Turkish",
      "uk": "Ukrainian",
      "ur": "Urdu",
      "uz": "Uzbek",
      "vi": "Vietnamese",
      "cy": "Welsh",
      "xh": "Xhosa",
      "yi": "Yiddish",
      "yo": "Yoruba",
      "zu": "Zulu"
    };
    function getCode(desiredLang) {
      if (!desiredLang) {
        return false;
      }
      desiredLang = desiredLang.toLowerCase();
      if (langs[desiredLang]) {
        return desiredLang;
      }
      var keys = Object.keys(langs).filter(function(key) {
        if (typeof langs[key] !== "string") {
          return false;
        }
        return langs[key].toLowerCase() === desiredLang;
      });
      return keys[0] || false;
    }
    function isSupported(desiredLang) {
      return Boolean(getCode(desiredLang));
    }
    module2.exports = langs;
    module2.exports.isSupported = isSupported;
    module2.exports.getCode = getCode;
  }
});

// node_modules/google-translate-api/index.js
var require_google_translate_api = __commonJS({
  "node_modules/google-translate-api/index.js"(exports2, module2) {
    var querystring = require_querystring();
    var got2 = require_got();
    var safeEval = require_safe_eval();
    var token = require_google_translate_token();
    var languages = require_languages();
    function translate(text, opts) {
      opts = opts || {};
      var e;
      [opts.from, opts.to].forEach(function(lang) {
        if (lang && !languages.isSupported(lang)) {
          e = new Error();
          e.code = 400;
          e.message = "The language '" + lang + "' is not supported";
        }
      });
      if (e) {
        return new Promise(function(resolve2, reject2) {
          reject2(e);
        });
      }
      opts.from = opts.from || "auto";
      opts.to = opts.to || "en";
      opts.from = languages.getCode(opts.from);
      opts.to = languages.getCode(opts.to);
      return token.get(text).then(function(token2) {
        var url = "https://translate.google.com/translate_a/single";
        var data = {
          client: "t",
          sl: opts.from,
          tl: opts.to,
          hl: opts.to,
          dt: ["at", "bd", "ex", "ld", "md", "qca", "rw", "rm", "ss", "t"],
          ie: "UTF-8",
          oe: "UTF-8",
          otf: 1,
          ssel: 0,
          tsel: 0,
          kc: 7,
          q: text
        };
        data[token2.name] = token2.value;
        return url + "?" + querystring.stringify(data);
      }).then(function(url) {
        return got2(url).then(function(res2) {
          var result = {
            text: "",
            from: {
              language: {
                didYouMean: false,
                iso: ""
              },
              text: {
                autoCorrected: false,
                value: "",
                didYouMean: false
              }
            },
            raw: ""
          };
          if (opts.raw) {
            result.raw = res2.body;
          }
          var body = safeEval(res2.body);
          body[0].forEach(function(obj) {
            if (obj[0]) {
              result.text += obj[0];
            }
          });
          if (body[2] === body[8][0][0]) {
            result.from.language.iso = body[2];
          } else {
            result.from.language.didYouMean = true;
            result.from.language.iso = body[8][0][0];
          }
          if (body[7] && body[7][0]) {
            var str = body[7][0];
            str = str.replace(/<b><i>/g, "[");
            str = str.replace(/<\/i><\/b>/g, "]");
            result.from.text.value = str;
            if (body[7][5] === true) {
              result.from.text.autoCorrected = true;
            } else {
              result.from.text.didYouMean = true;
            }
          }
          return result;
        }).catch(function(err) {
          var e2;
          e2 = new Error();
          if (err.statusCode !== void 0 && err.statusCode !== 200) {
            e2.code = "BAD_REQUEST";
          } else {
            e2.code = "BAD_NETWORK";
          }
          throw e2;
        });
      });
    }
    module2.exports = translate;
    module2.exports.languages = languages;
  }
});
export default require_google_translate_api();
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)
*/
//# sourceMappingURL=google-translate-api.js.map
